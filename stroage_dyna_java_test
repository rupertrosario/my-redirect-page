import { execution } from "@dynatrace-sdk/automation-utils";

export default async function ({ execution_id }) {
  const ex     = await execution(execution_id);
  const result = await ex.result(execute_dql_query_1);  // keep your existing DQL step ID

  // DQL rows
  const rows = result.records ?? [];

  const BYTES_PER_TB = 1_000_000_000_000;

  function safeNum(x) {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  }

  function badge(p) {
    const n = Number(p);
    if (!Number.isFinite(n)) return "âšª";
    if (n < 70) return "ðŸŸ¢";
    if (n < 85) return "ðŸŸ¡";
    return "ðŸ”´";
  }

  // Normalize rows â†’ clusters
  const clusters = rows
    .map((r) => {
      const clusterName = r.clusterName ?? "Unknown";

      // Overall TB and %
      const usedTB  = safeNum(r.used_TB);
      const totalTB = safeNum(r.total_TB);

      const usedPctRaw =
        r.used_pct_rounded != null
          ? safeNum(r.used_pct_rounded)
          : (totalTB > 0 ? (usedTB / totalTB) * 100 : 0);

      const usedPctLabel =
        typeof r.used_pct_label === "string"
          ? r.used_pct_label
          : `${usedPctRaw.toFixed(1)} %`;

      // HDD / SSD TB
      const usedHddTB  = safeNum(r.used_hdd_bytes)  / BYTES_PER_TB;
      const totalHddTB = safeNum(r.total_hdd_bytes) / BYTES_PER_TB;
      const usedSddTB  = safeNum(r.used_sdd_bytes)  / BYTES_PER_TB;
      const totalSddTB = safeNum(r.total_sdd_bytes) / BYTES_PER_TB;

      const usedHddPct =
        totalHddTB > 0 ? (usedHddTB / totalHddTB) * 100 : 0;
      const usedSddPct =
        totalSddTB > 0 ? (usedSddTB / totalSddTB) * 100 : 0;

      const statusEmoji = badge(usedPctRaw);

      return {
        clusterName,

        usedTB:  usedTB.toFixed(1),
        totalTB: totalTB.toFixed(1),
        usedPct: usedPctRaw.toFixed(1),
        usedPctLabel,

        usedHddTB:  usedHddTB.toFixed(1),
        totalHddTB: totalHddTB.toFixed(1),
        usedHddPct: usedHddPct.toFixed(1),

        usedSddTB:  usedSddTB.toFixed(1),
        totalSddTB: totalSddTB.toFixed(1),
        usedSddPct: usedSddPct.toFixed(1),

        status: statusEmoji
      };
    })
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  // Build markdown table for email body
  const header = [
    "ðŸ“Š **Isilon Cluster Capacity Report**",
    "",
    "| Cluster | Used (TB) | Total (TB) | Used % | HDD Used (TB) | HDD Total (TB) | HDD % | SSD Used (TB) | SSD Total (TB) | SSD % | Status |",
    "|---------|-----------:|-----------:|-------:|--------------:|---------------:|------:|--------------:|---------------:|------:|:--------|"
  ].join("\n");

  const body = clusters
    .map((c) =>
      `| ${c.clusterName}` +
      ` | ${c.usedTB}` +
      ` | ${c.totalTB}` +
      ` | ${c.usedPct} %` +
      ` | ${c.usedHddTB}` +
      ` | ${c.totalHddTB}` +
      ` | ${c.usedHddPct} %` +
      ` | ${c.usedSddTB}` +
      ` | ${c.totalSddTB}` +
      ` | ${c.usedSddPct} %` +
      ` | ${c.status} |`
    )
    .join("\n");

  const footer = [
    "",
    `Total clusters in report: ${clusters.length}`,
    "",
    "Legend (overall Used %):",
    "- ðŸŸ¢ < 70%",
    "- ðŸŸ¡ 70â€“84.9%",
    "- ðŸ”´ â‰¥ 85%"
  ].join("\n");

  const report = [header, body, footer].join("\n\n");

  // What this JS step outputs
  return {
    clusters,
    report
  };
}
