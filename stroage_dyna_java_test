// Isilon â€“ Cluster Capacity Report with HDD + SSD Breakdown
// Handles mixed units: overall "bytes" might already be TB, HDD/SSD are bytes.

export default async function (input) {
  const rows = input.rows || [];

  const BYTES_PER_TB = 1_000_000_000_000; // decimal TB

  function safeNum(x) {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  }

  // If value is tiny (< 10_000), assume it's already TB. Otherwise assume bytes.
  function toTBMaybe(value) {
    const n = safeNum(value);
    if (n === 0) return 0;
    if (Math.abs(n) < 10_000) {
      // Likely already TB
      return n;
    }
    // Likely bytes
    return n / BYTES_PER_TB;
  }

  function badge(p) {
    if (p == null || isNaN(p)) return "âšª N/A";
    if (p < 70) return "ðŸŸ¢ Healthy";
    if (p < 85) return "ðŸŸ¡ Warning";
    return "ðŸ”´ Critical";
  }

  const clusters = rows.map((row) => {
    const clusterName = row.clusterName ?? row.name ?? "Unknown";

    const usedBytes      = safeNum(row.used_bytes);
    const totalBytes     = safeNum(row.total_bytes);
    const usedHddBytes   = safeNum(row.used_hdd_bytes);
    const totalHddBytes  = safeNum(row.total_hdd_bytes);
    const usedSddBytes   = safeNum(row.used_sdd_bytes);
    const totalSddBytes  = safeNum(row.total_sdd_bytes);

    // Overall
    const usedTB     = toTBMaybe(usedBytes);
    const totalTB    = toTBMaybe(totalBytes);

    // Tiers
    const usedHddTB  = toTBMaybe(usedHddBytes);
    const totalHddTB = toTBMaybe(totalHddBytes);
    const usedSddTB  = toTBMaybe(usedSddBytes);
    const totalSddTB = toTBMaybe(totalSddBytes);

    const usedPct     = totalTB    > 0 ? (usedTB    / totalTB)    * 100 : 0;
    const usedHddPct  = totalHddTB > 0 ? (usedHddTB / totalHddTB) * 100 : 0;
    const usedSddPct  = totalSddTB > 0 ? (usedSddTB / totalSddTB) * 100 : 0;

    return {
      clusterName,
      usedTB:     usedTB.toFixed(1),
      totalTB:    totalTB.toFixed(1),
      usedPct:    usedPct.toFixed(1),

      usedHddTB:  usedHddTB.toFixed(1),
      totalHddTB: totalHddTB.toFixed(1),
      usedHddPct: usedHddPct.toFixed(1),

      usedSddTB:  usedSddTB.toFixed(1),
      totalSddTB: totalSddTB.toFixed(1),
      usedSddPct: usedSddPct.toFixed(1),

      status: badge(usedPct)
    };
  }).sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  const header = [
    "ðŸ“Š **Isilon Cluster Capacity Report**",
    "",
    "_Source: Dynatrace Isilon extension (last 30 minutes window)_",
    "",
    "| Cluster | Used (TB) | Total (TB) | Used % | HDD Used (TB) | HDD Total (TB) | HDD % | SSD Used (TB) | SSD Total (TB) | SSD % | Status |",
    "|---------|-----------:|-----------:|-------:|--------------:|---------------:|------:|--------------:|---------------:|------:|:--------|"
  ].join("\n");

  const body = clusters.map(c =>
    `| ${c.clusterName}` +
    ` | ${c.usedTB}` +
    ` | ${c.totalTB}` +
    ` | ${c.usedPct} %` +
    ` | ${c.usedHddTB}` +
    ` | ${c.totalHddTB}` +
    ` | ${c.usedHddPct} %` +
    ` | ${c.usedSddTB}` +
    ` | ${c.totalSddTB}` +
    ` | ${c.usedSddPct} %` +
    ` | ${c.status} |`
  ).join("\n");

  const footer = [
    "",
    `**Total clusters in report: ${clusters.length}**`,
    "",
    "Legend (overall Used % â€“ HDD+SSD):",
    "- ðŸŸ¢ Healthy: **< 70%** used",
    "- ðŸŸ¡ Warning: **70â€“84.9%** used",
    "- ðŸ”´ Critical: **â‰¥ 85%** used"
  ].join("\n");

  const report = [header, body, "", footer].join("\n");

  return {
    clusters,
    report
  };
}
