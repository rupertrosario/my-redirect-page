import { result } from "@dynatrace-sdk/automation-utils";

/**
 * cohesity_backup_failures_p2
 * READ-ONLY (GET-only)
 *
 * Reads Part 1 output via result("cohesity_backup_failures_p1")
 * Output -> Part 3 reads via result("cohesity_backup_failures_p2")
 */
export default async function () {
  const PART1_TASK = "cohesity_backup_failures_p1";

  const p1 = await result(PART1_TASK);
  if (!p1?.apiKey || !Array.isArray(p1.pgIndex)) {
    throw new Error(`Part 2: missing Part 1 output. Check task name: ${PART1_TASK}`);
  }

  const baseUrl = p1.baseUrl || "https://helios.cohesity.com";
  const apiKey = String(p1.apiKey).trim();
  const commonHeaders = { accept: "application/json", ...(p1.commonHeaders || {}), apiKey };

  const daysToKeepMin = Number(p1.daysToKeepMin ?? 35);
  const numRuns = Number(p1.numRuns ?? 5);
  const pgIndex = p1.pgIndex;

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // group by cluster (policy cache per cluster)
  const byCluster = new Map();
  for (const it of pgIndex) {
    const cid = String(it?.clusterId || "");
    if (!cid) continue;
    if (!byCluster.has(cid)) byCluster.set(cid, { clusterName: it?.clusterName || `Unknown-${cid}`, items: [] });
    byCluster.get(cid).items.push(it);
  }

  const pgWorkItems = [];

  for (const [clusterId, group] of byCluster.entries()) {
    const headers = { ...commonHeaders, Accept: "application/json", accessClusterId: String(clusterId) };

    const policyCache = new Map(); // policyId -> { daysToKeep, name }

    async function getPolicy(policyId) {
      if (!policyId) return null;
      const pid = String(policyId);
      if (policyCache.has(pid)) return policyCache.get(pid);

      const url = `${baseUrl}/irisservices/api/v1/public/protectionPolicies/${encodeURIComponent(pid)}`;
      try {
        const p = await getJson(url, headers);
        const obj = { daysToKeep: p?.daysToKeep ?? null, name: p?.name ?? "" };
        policyCache.set(pid, obj);
        return obj;
      } catch (_) {
        const obj = { daysToKeep: null, name: "PolicyLookupFailed" };
        policyCache.set(pid, obj);
        return obj;
      }
    }

    for (const it of group.items) {
      const pol = await getPolicy(it.policyId);
      const days = pol?.daysToKeep;

      if (days !== null && Number(days) >= daysToKeepMin) {
        pgWorkItems.push({
          clusterId: String(it.clusterId),
          clusterName: it.clusterName || group.clusterName,
          pgId: String(it.pgId),
          pgName: it.pgName || "",
          pgEnv: it.pgEnv || "UnknownEnv",
          policyId: String(it.policyId),
          policyName: pol?.name || "",
          daysToKeep: Number(days),
        });
      }
    }
  }

  return {
    authMode: p1.authMode || "vault",
    baseUrl,
    apiKey,
    commonHeaders,
    daysToKeepMin,
    numRuns,
    pgWorkItems,
  };
}
