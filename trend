/**
 * Build a DB x Date heatmap as Markdown table.
 *
 * @param {Array} protectedObjects - array of:
 *   {
 *     name: string,
 *     parentSourceName: string,
 *     trends: [
 *       {
 *         trendName: string,
 *         total: number,
 *         successful: number,
 *         failed: number,
 *         running: number,
 *         cancelled: number
 *       },
 *       ...
 *     ]
 *   }
 * @param {number} maxBlocks - max emoji blocks per cell (default 6)
 * @returns {string} markdown
 */
function buildDbTrendHeatmapMarkdown(protectedObjects, maxBlocks = 6) {
  if (!Array.isArray(protectedObjects) || protectedObjects.length === 0) {
    return "_No data returned for protected objects._";
  }

  // 1) Collect all distinct dates (trendName)
  const dateSet = new Set();
  for (const obj of protectedObjects) {
    if (!obj.trends) continue;
    for (const t of obj.trends) {
      if (t && t.trendName) dateSet.add(t.trendName);
    }
  }
  const dates = Array.from(dateSet).sort();

  if (dates.length === 0) {
    return "_No trend data for selected range._";
  }

  // 2) Sort DBs by name, then parentSourceName
  const dbs = [...protectedObjects].sort((a, b) => {
    const na = (a.name || "").toLowerCase();
    const nb = (b.name || "").toLowerCase();
    if (na < nb) return -1;
    if (na > nb) return 1;

    const sa = (a.parentSourceName || "").toLowerCase();
    const sb = (b.parentSourceName || "").toLowerCase();
    if (sa < sb) return -1;
    if (sa > sb) return 1;
    return 0;
  });

  // 3) Helper: find trend for a specific date
  function findTrendForDate(db, date) {
    if (!db.trends) return null;
    return db.trends.find(t => t.trendName === date) || null;
  }

  // 4) Helper: build colored emoji bar
  function buildEmojiBar(trend) {
    const succ    = Number(trend.successful || 0);
    const fail    = Number(trend.failed || 0);
    const running = Number(trend.running || 0);
    const cancel  = Number(trend.cancelled || 0);

    let remaining = maxBlocks;
    let bar = "";

    // ðŸŸ© successes
    const succBlocks = Math.min(succ, remaining);
    bar += "ðŸŸ©".repeat(succBlocks);
    remaining -= succBlocks;

    // ðŸŸ¥ failures
    if (remaining > 0) {
      const failBlocks = Math.min(fail, remaining);
      bar += "ðŸŸ¥".repeat(failBlocks);
      remaining -= failBlocks;
    }

    // ðŸŸ¨ running
    if (remaining > 0) {
      const runBlocks = Math.min(running, remaining);
      bar += "ðŸŸ¨".repeat(runBlocks);
      remaining -= runBlocks;
    }

    // â¬› cancelled
    if (remaining > 0) {
      const canBlocks = Math.min(cancel, remaining);
      bar += "â¬›".repeat(canBlocks);
      remaining -= canBlocks;
    }

    return bar;
  }

  // 5) Build header row + separator row
  let md = "";

  // Optional legend
  md += "**Legend:** ðŸŸ© success, ðŸŸ¥ failed, ðŸŸ¨ running, â¬› cancelled\n\n";

  // Header
  md += "| DB (Server) |";
  for (const d of dates) {
    md += " " + d + " |";
  }
  md += "\n";

  // Separator
  md += "|-------------|";
  for (let i = 0; i < dates.length; i++) {
    md += "-----------|";
  }
  md += "\n";

  // 6) Data rows
  for (const db of dbs) {
    const dbLabel = `${db.name || "?"} (${db.parentSourceName || "?"})`;
    md += `| ${dbLabel} |`;

    for (const d of dates) {
      const trend = findTrendForDate(db, d);

      if (!trend) {
        md += " - |";
        continue;
      }

      const succ  = Number(trend.successful || 0);
      const total = Number(trend.total || 0);

      if (total === 0) {
        md += " 0/0 - |";
        continue;
      }

      const bar = buildEmojiBar(trend);
      const cellText = `${succ}/${total} ${bar}`;

      md += " " + cellText + " |";
    }

    md += "\n";
  }

  return md;
}
