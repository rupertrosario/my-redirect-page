<#
Cohesity Helios – Cluster Interface Health (Full Script)
-------------------------------------------------------
- Loads API key from your file path (as provided).
- Fetches all clusters (name + id) from /v2/mcm/cluster-mgmt/info.
- For each cluster, calls /irisservices/api/v1/public/interface with accessClusterId.
- Emits the SAME object layout you had in your screenshot (Cluster, NodeID, NodeIP, ChassisSerial,
  BondSlaves, SlaveInterfaceStatus, SlaveSpeed, SlotType) – kept AS-IS.
- Optional: At the end, prints a per-cluster summary (everything up vs list of down slave names).

Note: The 'AS-IS Core Block' is kept verbatim to your structure; summary is appended after.
#>

# =========================
# 0) API Key from your path
# =========================
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$ApiKey = (Get-Content -Path $apikeypath -Raw).Trim()
$commonHeaders = @{ "apiKey" = $ApiKey }

# =========================================================
# 1) Get Clusters (ClusterName + ClusterId) – your 2nd image
# =========================================================
$url = "https://helios.cohesity.com/v2/mcm/cluster-mgmt/info"
$response  = Invoke-WebRequest -Method Get -Uri $url -Headers $commonHeaders
$json_clu  = $response.Content | ConvertFrom-Json
$json_clus = $json_clu.cohesityClusters

# Will collect all rows so the table shows every node from every cluster
$AllRows = @()

foreach ($clus in $json_clus) {
    $cluster_name = $clus.ClusterName
    $cluster_id   = $clus.ClusterId

    Write-Host "`n▶ Processing cluster: $cluster_name ($cluster_id)" -ForegroundColor Cyan

    # ==============================================
    # 2) Interfaces – your 1st image (used as-is)
    # ==============================================
    $url = "https://helios.cohesity.com/irisservices/api/v1/public/interface"
    $headers = @{ "apiKey" = $ApiKey; "accessClusterId" = $cluster_id }
    $body = @{
        bondInterfaceOnly        = "true"
        ifaceGroupAssignedOnly   = "true"
        includeUplinkSwitchInfo  = "true"
        includeBondSlavesDetails = "true"
        includeStats             = "true"
    }

    $response = Invoke-WebRequest -Method Get -Uri $url -Headers $headers -Body $body
    $json = $response.Content | ConvertFrom-Json
    #$json2 = $json.interfaces.bondSlavesDetails
    #$json2

    foreach ($node in $json) {
        # =====================
        # AS-IS CORE BLOCK
        # =====================
        $results = [PSCustomObject]@{
            Cluster              = $cluster_name
            NodeID               = $node.nodeId
            NodeIP               = $node.nodeIp
            ChassisSerial        = $node.chassisSerial
            #InterfaceGroup      = $node.interfaces.group
            #BondName            = $name
            #BondLinkSpeed       = $node.interfaces.speed
            BondSlaves           = $node.interfaces.bondSlaves
            SlaveInterfaceStatus = $node.interfaces.bondSlavesDetails.linkState
            SlaveSpeed           = $node.interfaces.bondSlavesDetails.speed
            SlotType             = $node.interfaces.bondSlavesSlotTypes
            #UplinkSwitchInfo    = $node.interfaces.bondSlavesDetails.uplinkSwitchInfo.sysName
            #SwitchPortId        = $node.interfaces.bondSlavesDetails.uplinkSwitchInfo.portId
        }
        # Keep the original object shape, but also accumulate to show every row after the loop
        $AllRows += $results
    }
}

# ==============================
# 3) Print Table (as your script)
# ==============================
$AllRows | Format-Table -AutoSize

<#
# Your original CSV export block (kept available if you want it later)
if ($AllRows.Count -gt 0) {
    Write-Host "Objects with Errors:" -ForegroundColor Yellow
    $AllRows | Export-Csv -Path "H:\Cohesity_API\Logs\objects_errors.csv" -NoTypeInformation -Encoding UTF8
} else {
    Write-Host " All Objects are healthy. No errors to display."
}
#>

# ==========================================================
# 4) OPTIONAL: Per-cluster summary (everything up vs down)
#    - Uses the fields already present in the AS-IS block.
#    - If there is nothing down, prints: "Everything is up" with counts.
#    - If any down, prints only the down interface names.
# ==========================================================
if ($AllRows.Count -gt 0) {
    Write-Host "`nSummary:" -ForegroundColor Green

    # Attempt to count interfaces via the BondSlaves array length per node
    $byCluster = $AllRows | Group-Object Cluster

    foreach ($grp in $byCluster) {
        $cName = $grp.Name

        # Flatten potential arrays of slave names & their statuses
        $slaveNames = @()
        $slaveStates = @()
        foreach ($r in $grp.Group) {
            if ($null -ne $r.BondSlaves) { $slaveNames += $r.BondSlaves }
            if ($null -ne $r.SlaveInterfaceStatus) { $slaveStates += $r.SlaveInterfaceStatus }
        }

        # Build pairs if lengths match; otherwise best-effort: treat non-"up" as down where possible
        $downList = @()
        if ($slaveNames.Count -eq $slaveStates.Count -and $slaveNames.Count -gt 0) {
            for ($i=0; $i -lt $slaveNames.Count; $i++) {
                $n = [string]$slaveNames[$i]
                $s = [string]$slaveStates[$i]
                if ($s -match 'down|error|disabled|unknown') { $downList += $n }
            }
        } else {
            # Fallback: if status array exists, collect indices that look down
            foreach ($s in $slaveStates) { if ($s -match 'down|error|disabled|unknown') { $downList += '(unknown-iface)' } }
        }

        $ifaceCount = [int]($slaveNames | Where-Object { $_ } | Measure-Object).Count
        if ($downList.Count -eq 0) {
            Write-Host "• $cName: $ifaceCount interfaces — Everything is up"
        } else {
            Write-Host "• $cName: $ifaceCount interfaces — down: $([string]::Join(', ', ($downList | Select-Object -Unique)))"
        }
    }
}
