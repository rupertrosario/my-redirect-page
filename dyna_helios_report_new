import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alert Tiles (LOW OUTPUT SIZE)
 * - Endpoint: GET https://helios.cohesity.com/v2/alerts   (as you pasted)
 * - Per-cluster accuracy: sends header accessClusterId for every call
 * - GET-only
 * - ONLY clusters that have Active (kOpen) alerts in each section are shown
 * - No startTimeUsecs/endTimeUsecs (keeps result small + avoids API param issues)
 * - Uses maxAlerts to cap payload size
 * - Symbols: ✅ healthy, else ⛔<n> ⚠️<n> ℹ️<n> ❓<n>
 *
 * Returns ONLY:
 *  - note
 *  - markdownHardware
 *  - markdownMaintenance
 *  - markdownDataService
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // AUTH (vault id)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // OUTPUT SAFETY (reduce size)
  // ==============================
  const MAX_ALERTS = 500; // cap per cluster per bucket (keeps response small)

  // ==============================
  // CATEGORY COLUMNS (EXACT ENUMS)
  // ==============================
  const HW_Cats = [
    "kCPU","kChassis","kCluster","kDisk","kFan","kFirmware","kMemory","kNIC",
    "kNode","kNodeHealth","kOperatingSystem","kPowerSupply","kStorageDevice",
    "kStoragePool","kTemperature"
  ].sort();

  const MAINT_Cats = [
    "kAuditLog","kClusterManagement","kConfiguration","kFaultTolerance",
    "kGeneralSoftwareFailure","kHelios","kLicense","kNetworking","kSecurity",
    "kStorageUsage","kSystemService","kUpgrade"
  ].sort();

  const DS_Cats = [
    "kAgent","kAppMarketPlace","kArchivalRestore","kBackupRestore","kCDP",
    "kDataPath","kDataSourceConnector","kDisasterRecovery","kIndexing","kMetadata",
    "kNetBackup","kQuota","kRemoteReplication","kViewFailover"
  ].sort();

  // ==============================
  // SYMBOLS
  // ==============================
  const SYM_OK = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";
  const SYM_U = "❓";

  function sevBucket(sev) {
    switch (sev) {
      case "kCritical": return "C";
      case "kWarning":  return "W";
      case "kInfo":     return "I";
      default:          return "U";
    }
  }

  function normalizeAlerts(resp) {
    if (Array.isArray(resp)) return resp;
    if (Array.isArray(resp?.alerts)) return resp.alerts;
    if (Array.isArray(resp?.items)) return resp.items;
    return [];
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // ==============================
  // CLUSTERS
  // ==============================
  const clu = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { ...commonHeaders, Accept: "application/json" });
  const clusters = Array.isArray(clu?.cohesityClusters) ? clu.cohesityClusters : [];
  if (!clusters.length) throw new Error("No clusters returned from /v2/mcm/cluster-mgmt/info");

  // ==============================
  // ALERTS (your pasted endpoint style)
  // ==============================
  async function getAlertsForClusterBucket(clusterId, bucketEnum) {
    const qs = new URLSearchParams({
      alertStateList: "kOpen",
      alertTypeBucketList: bucketEnum,
      maxAlerts: String(MAX_ALERTS)
    });

    const url = `${baseUrl}/v2/alerts?${qs.toString()}`;
    const headers = {
      ...commonHeaders,
      Accept: "application/json",
      accessClusterId: String(clusterId)
    };

    // fail-open per cluster
    try {
      const data = await getJson(url, headers);
      return normalizeAlerts(data);
    } catch (_) {
      return [];
    }
  }

  function cell(C, W, I, U) {
    if (C === 0 && W === 0 && I === 0 && U === 0) return SYM_OK;
    return `${SYM_C}${C} ${SYM_W}${W} ${SYM_I}${I} ${SYM_U}${U}`;
  }

  function mdTable(rows, cats) {
    if (!rows.length) return "No Active alerts (no clusters to display).";
    const header = ["ClusterName", ...cats];
    const sep = header.map(() => "---");
    const out = [`| ${header.join(" | ")} |`, `| ${sep.join(" | ")} |`];
    for (const r of rows) {
      out.push(`| ${[r.ClusterName, ...cats.map((c) => r[c] ?? SYM_OK)].join(" | ")} |`);
    }
    return out.join("\n");
  }

  async function buildSection(bucketEnum, cats) {
    const counts = new Map();          // key cluster||cat -> {C,W,I,U}
    const clustersWithAny = new Set(); // only clusters with any active alerts in this bucket

    for (const cl of clusters) {
      const clusterId = cl?.clusterId;
      const clusterName = String(cl?.clusterName || "").trim();
      if (!clusterId || !clusterName) continue;

      const alerts = await getAlertsForClusterBucket(clusterId, bucketEnum);

      for (const a of alerts) {
        const cat = String(a?.alertCategory ?? "").trim();
        if (!cat || !cats.includes(cat)) continue;

        const sev = sevBucket(String(a?.severity ?? ""));
        const key = `${clusterName}||${cat}`;

        if (!counts.has(key)) counts.set(key, { C: 0, W: 0, I: 0, U: 0 });
        counts.get(key)[sev] += 1;
        clustersWithAny.add(clusterName);
      }
    }

    const list = Array.from(clustersWithAny).sort((a, b) => a.localeCompare(b));
    const rows = list.map((cn) => {
      const row = { ClusterName: cn };
      for (const cat of cats) {
        const k = `${cn}||${cat}`;
        if (!counts.has(k)) row[cat] = SYM_OK;
        else {
          const { C, W, I, U } = counts.get(k);
          row[cat] = cell(C, W, I, U);
        }
      }
      return row;
    });

    return mdTable(rows, cats);
  }

  const note =
    `**NOTE:** This mimics the **System → Health → Components** page of the cluster.\n` +
    `- Shows ONLY clusters that currently have Active (kOpen) alerts for the selected section.\n` +
    `- Clusters not displayed have no Active alerts for that section (healthy for these tiles).\n` +
    `- Cells show "${SYM_OK}" or "${SYM_C}<n> ${SYM_W}<n> ${SYM_I}<n> ${SYM_U}<n>".\n` +
    `- Data source: per-cluster pull using accessClusterId (no dedupe).`;

  const hw = await buildSection("kHardware", HW_Cats);
  const m  = await buildSection("kMaintenance", MAINT_Cats);
  const ds = await buildSection("kDataService", DS_Cats);

  return {
    note,
    markdownHardware: `**Hardware**\n${hw}`,
    markdownMaintenance: `**Maintenance**\n${m}`,
    markdownDataService: `**Data Service**\n${ds}`
  };
}
