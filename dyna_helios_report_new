import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alert Tiles (FAST: alerts-summary per cluster)
 * - Endpoints:
 *   - GET https://helios.cohesity.com/v2/mcm/cluster-mgmt/info
 *   - GET https://helios.cohesity.com/v2/alerts-summary   (with accessClusterId per cluster)
 * - GET-only
 * - 1 call per cluster (not 3)
 * - Tables are cluster-wise; ClusterId is NOT shown in table
 * - Symbols: ✅ healthy, else ⛔<n> ⚠️<n> ℹ️<n> ❓<n>
 * - Unknown ❓ is computed as: totalCount - (criticalCount + warningCount + infoCount) if positive
 *
 * Returns ONLY:
 *  - note
 *  - markdownHardware
 *  - markdownMaintenance
 *  - markdownDataService
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // AUTH (vault id; same pattern that works for you)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // PERF
  // ==============================
  const CONCURRENCY = 8; // raise/lower based on tenant limits

  // ==============================
  // CATEGORY LISTS (as you confirmed)
  // ==============================
  const HW_Cats = [
    "kDisk","kNode","kCluster","kChassis","kPowerSupply","kCPU","kMemory","kTemperature",
    "kFan","kNIC","kFirmware","kNodeHealth","kOperatingSystem","kStorageDevice","kStoragePool"
  ].sort();

  const MAINT_Cats = [
    "kHelios","kAppMarketPlace","kSystemService","kLicense","kSecurity","kUpgrade",
    "kClusterManagement","kAuditLog","kNetworking","kConfiguration","kStorageUsage",
    "kFaultTolerance","kGeneralSoftwareFailure"
  ].sort();

  const DS_Cats = [
    "kDataPath","kDataSourceConnector","kMetadata","kIndexing","kBackupRestore","kArchivalRestore",
    "kRemoteReplication","kQuota","kCDP","kViewFailover","kDisasterRecovery","kAgent","kNetBackup"
  ].sort();

  // ==============================
  // SYMBOLS
  // ==============================
  const SYM_OK = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";
  const SYM_U = "❓";

  // ==============================
  // HELPERS
  // ==============================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const safeCell = (v) => (v === null || v === undefined ? "" : String(v).replace(/\|/g, " "));

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const e = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      e.status = resp.status;
      e.body = txt;
      throw e;
    }
    return resp.json();
  }

  function mdTable(headers, rows) {
    if (!rows.length) return "No Active alerts (no clusters to display).";
    const head = `| ${headers.join(" | ")} |`;
    const sep = `| ${headers.map(() => "---").join(" | ")} |`;
    const body = rows.map((r) => `| ${headers.map((h) => safeCell(r[h] ?? SYM_OK)).join(" | ")} |`);
    return [head, sep, ...body].join("\n");
  }

  function cellFromCounts(criticalCount, warningCount, infoCount, totalCount) {
    const c = Number(criticalCount || 0);
    const w = Number(warningCount || 0);
    const i = Number(infoCount || 0);
    const t = Number(totalCount || 0);
    const u = Math.max(0, t - (c + w + i)); // unknown bucket
    if (t === 0 || (c === 0 && w === 0 && i === 0 && u === 0)) return SYM_OK;
    return `${SYM_C}${c} ${SYM_W}${w} ${SYM_I}${i} ${SYM_U}${u}`;
  }

  function normalizeAlertsSummaryPayload(payload) {
    // Your PowerShell shows: $json.alertsSummary
    // Handle common variants safely.
    if (Array.isArray(payload?.alertsSummary)) return payload.alertsSummary;
    if (Array.isArray(payload?.summary)) return payload.summary;
    if (Array.isArray(payload)) return payload;
    return [];
  }

  // ==============================
  // 1) CLUSTERS (name + id)
  // ==============================
  const clu = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { ...commonHeaders, Accept: "application/json" });
  const clusters = toArray(clu?.cohesityClusters)
    .map((c) => ({ clusterName: norm(c?.clusterName), clusterId: norm(c?.clusterId) }))
    .filter((c) => c.clusterName && c.clusterId)
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  if (!clusters.length) throw new Error("No clusters returned from /v2/mcm/cluster-mgmt/info");

  // ==============================
  // 2) PER-CLUSTER alerts-summary (1 call/cluster)
  // ==============================
  async function fetchAlertsSummaryForCluster(clusterId) {
    const headers = { ...commonHeaders, Accept: "application/json", accessClusterId: String(clusterId) };

    // Keep it minimal; your screenshot shows no query params required.
    // If your tenant needs them, add here:
    // const url = `${baseUrl}/v2/alerts-summary?types=Regular&includeStats=true&excludedLinkedPolicies=true`;
    const url = `${baseUrl}/v2/alerts-summary`;

    const data = await getJson(url, headers);
    return normalizeAlertsSummaryPayload(data);
  }

  async function poolMap(items, worker, concurrency) {
    const results = new Array(items.length);
    let idx = 0;
    const runners = new Array(Math.min(concurrency, items.length)).fill(0).map(async () => {
      while (idx < items.length) {
        const cur = idx++;
        results[cur] = await worker(items[cur], cur);
      }
    });
    await Promise.all(runners);
    return results;
  }

  // Build per-cluster maps: type -> category -> counts
  const perCluster = await poolMap(
    clusters,
    async (cl) => {
      try {
        const rows = await fetchAlertsSummaryForCluster(cl.clusterId);

        // index by type/category
        const byType = {
          kHardware: new Map(),
          kMaintenance: new Map(),
          kDataService: new Map()
        };

        for (const r of rows) {
          const type = norm(r?.type);
          const category = norm(r?.category);
          if (!type || !category) continue;
          if (!byType[type]) continue;

          byType[type].set(category, {
            criticalCount: Number(r?.criticalCount || 0),
            warningCount: Number(r?.warningCount || 0),
            infoCount: Number(r?.infoCount || 0),
            totalCount: Number(r?.totalCount || 0)
          });
        }

        return { ok: true, clusterName: cl.clusterName, byType };
      } catch (_) {
        // fail-open: treat as no alerts for that cluster in this run
        return { ok: false, clusterName: cl.clusterName, byType: { kHardware: new Map(), kMaintenance: new Map(), kDataService: new Map() } };
      }
    },
    CONCURRENCY
  );

  // ==============================
  // 3) Build section tables (ONLY clusters with any active alerts in that section)
  // ==============================
  function buildSection(typeKey, cats) {
    const rows = [];

    for (const c of perCluster) {
      const m = c.byType?.[typeKey];
      if (!m) continue;

      // Determine if cluster has ANY active alerts in this section
      let hasAny = false;
      for (const [_, v] of m.entries()) {
        if (Number(v?.totalCount || 0) > 0) { hasAny = true; break; }
      }
      if (!hasAny) continue;

      const row = { ClusterName: c.clusterName };
      for (const cat of cats) {
        const v = m.get(cat) || { criticalCount: 0, warningCount: 0, infoCount: 0, totalCount: 0 };
        row[cat] = cellFromCounts(v.criticalCount, v.warningCount, v.infoCount, v.totalCount);
      }
      rows.push(row);
    }

    rows.sort((a, b) => String(a.ClusterName).localeCompare(String(b.ClusterName)));
    return mdTable(["ClusterName", ...cats], rows);
  }

  const note =
    `**NOTE:** This mimics the **System → Health → Components** page of the cluster.\n` +
    `- Source: **/v2/alerts-summary** per cluster (header **accessClusterId**).\n` +
    `- Shows ONLY clusters that have non-zero counts in each section.\n` +
    `- Cell format: "${SYM_OK}" or "${SYM_C}<n> ${SYM_W}<n> ${SYM_I}<n> ${SYM_U}<n>" (❓ is computed from totalCount).`;

  const markdownHardware = `**Hardware**\n${buildSection("kHardware", HW_Cats)}`;
  const markdownMaintenance = `**Maintenance**\n${buildSection("kMaintenance", MAINT_Cats)}`;
  const markdownDataService = `**Data Service**\n${buildSection("kDataService", DS_Cats)}`;

  return {
    note,
    markdownHardware,
    markdownMaintenance,
    markdownDataService
  };
}
