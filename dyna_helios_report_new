import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Helios Active Alert Tiles (GET-only)
 * - Per-cluster accuracy: uses accessClusterId header for every call
 * - 7-day window via startTimeUsecs/endTimeUsecs (epoch microseconds)
 * - Symbols: ✅ healthy, else ⛔ ⚠️ ℹ️ ❓
 * - Returns section markdown separately so you can pick which to email
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ===== Auth (vault id only) =====
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  // ===== Time window: last 7 days (rolling) in usecs =====
  const LOOKBACK_DAYS = 7;
  const endTimeUsecs = String(Date.now() * 1000);
  const startTimeUsecs = String((Date.now() - LOOKBACK_DAYS * 24 * 60 * 60 * 1000) * 1000);

  // ===== Categories (exact enums) =====
  const HW_Cats = [
    "kCPU","kChassis","kCluster","kDisk","kFan","kFirmware","kMemory","kNIC",
    "kNode","kNodeHealth","kOperatingSystem","kPowerSupply","kStorageDevice",
    "kStoragePool","kTemperature"
  ].sort();

  const MAINT_Cats = [
    "kAuditLog","kClusterManagement","kConfiguration","kFaultTolerance",
    "kGeneralSoftwareFailure","kHelios","kLicense","kNetworking","kSecurity",
    "kStorageUsage","kSystemService","kUpgrade"
  ].sort();

  const DS_Cats = [
    "kAgent","kAppMarketPlace","kArchivalRestore","kBackupRestore","kCDP",
    "kDataPath","kDataSourceConnector","kDisasterRecovery","kIndexing","kMetadata",
    "kNetBackup","kQuota","kRemoteReplication","kViewFailover"
  ].sort();

  // ===== Symbols =====
  const SYM_OK = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";
  const SYM_U = "❓";

  function sevBucket(sev) {
    switch (sev) {
      case "kCritical": return "C";
      case "kWarning": return "W";
      case "kInfo": return "I";
      default: return "U";
    }
  }

  function normalizeAlerts(resp) {
    if (Array.isArray(resp)) return resp;
    if (Array.isArray(resp?.alerts)) return resp.alerts;
    if (Array.isArray(resp?.items)) return resp.items;
    return [];
  }

  async function getJson(url, headers) {
    const r = await fetch(url, { method: "GET", headers });
    if (!r.ok) {
      const txt = await r.text().catch(() => "");
      const e = new Error(`GET ${url} -> HTTP ${r.status} ${txt}`);
      e.status = r.status;
      e.body = txt;
      throw e;
    }
    return r.json();
  }

  async function tryAlertsEndpoint(paths, qs, headers) {
    let lastErr = null;
    for (const p of paths) {
      const url = `${baseUrl}${p}?${qs.toString()}`;
      try {
        const data = await getJson(url, headers);
        return { ok: true, data, urlUsed: url };
      } catch (e) {
        lastErr = e;
      }
    }
    return { ok: false, data: null, err: lastErr };
  }

  // ===== Clusters =====
  const clu = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { ...commonHeaders, Accept: "application/json" });
  const clusters = Array.isArray(clu?.cohesityClusters) ? clu.cohesityClusters : [];
  if (!clusters.length) throw new Error("No clusters returned from /v2/mcm/cluster-mgmt/info");

  // ===== Query builder (shared) =====
  function qsFor(bucketEnum) {
    return new URLSearchParams({
      alertStateList: "kOpen",
      alertTypeBucketList: bucketEnum,
      startTimeUsecs,
      endTimeUsecs
    });
  }

  const ALERT_PATHS = ["/v2/alerts", "/v2/mcm/alerts"]; // try /v2/alerts first, fallback to documented Helios route

  async function getClusterBucketAlerts(clusterId, bucketEnum) {
    const headers = { ...commonHeaders, Accept: "application/json", accessClusterId: String(clusterId) };
    const qs = qsFor(bucketEnum);
    const res = await tryAlertsEndpoint(ALERT_PATHS, qs, headers);
    if (!res.ok) return { ok: false, alerts: [], urlUsed: "", err: res.err };
    return { ok: true, alerts: normalizeAlerts(res.data), urlUsed: res.urlUsed, err: null };
  }

  function cell(C, W, I, U) {
    if (C === 0 && W === 0 && I === 0 && U === 0) return SYM_OK;
    return `${SYM_C}${C} ${SYM_W}${W} ${SYM_I}${I} ${SYM_U}${U}`;
  }

  function mdTable(rows, cats) {
    if (!rows.length) return "No Active alerts (no clusters to display).";
    const header = ["ClusterName", ...cats];
    const sep = header.map(() => "---");
    const lines = [`| ${header.join(" | ")} |`, `| ${sep.join(" | ")} |`];
    for (const r of rows) {
      lines.push(`| ${[r.ClusterName, ...cats.map((c) => r[c] ?? SYM_OK)].join(" | ")} |`);
    }
    return lines.join("\n");
  }

  async function buildSection(bucketEnum, cats) {
    const counts = new Map();          // key cluster||cat -> {C,W,I,U}
    const clustersWithAny = new Set(); // only clusters with any active alerts in this bucket

    for (const cl of clusters) {
      const clusterId = cl?.clusterId;
      const clusterName = String(cl?.clusterName || "").trim();
      if (!clusterId || !clusterName) continue;

      const res = await getClusterBucketAlerts(clusterId, bucketEnum);
      const alerts = res.alerts || [];

      for (const a of alerts) {
        const cat = String(a?.alertCategory ?? "").trim();
        if (!cat || !cats.includes(cat)) continue;

        const sev = sevBucket(String(a?.severity ?? ""));
        const key = `${clusterName}||${cat}`;
        if (!counts.has(key)) counts.set(key, { C: 0, W: 0, I: 0, U: 0 });
        counts.get(key)[sev] += 1;

        clustersWithAny.add(clusterName);
      }
    }

    const list = Array.from(clustersWithAny).sort((a, b) => a.localeCompare(b));
    const rows = list.map((cn) => {
      const row = { ClusterName: cn };
      for (const cat of cats) {
        const key = `${cn}||${cat}`;
        if (!counts.has(key)) row[cat] = SYM_OK;
        else {
          const { C, W, I, U } = counts.get(key);
          row[cat] = cell(C, W, I, U);
        }
      }
      return row;
    });

    return mdTable(rows, cats);
  }

  const note =
    `**NOTE:** This mimics the **System → Health → Components** page of the cluster.\n` +
    `- Shows ONLY clusters that have Active (kOpen) alerts in each section.\n` +
    `- Filter: last ${LOOKBACK_DAYS} days (startTimeUsecs/endTimeUsecs).\n` +
    `- Data is pulled per-cluster using accessClusterId (no dedupe).`;

  const markdownHardware = `**Hardware**\n${await buildSection("kHardware", HW_Cats)}`;
  const markdownMaintenance = `**Maintenance**\n${await buildSection("kMaintenance", MAINT_Cats)}`;
  const markdownDataService = `**Data Service**\n${await buildSection("kDataService", DS_Cats)}`;

  return {
    startTimeUsecs,
    endTimeUsecs,
    note,
    markdownHardware,
    markdownMaintenance,
    markdownDataService
  };
}
