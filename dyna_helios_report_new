import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alert Tiles (Cluster-scoped via accessClusterId)
 * - GET-only
 * - ONLY clusters that currently have Active (kOpen) alerts are shown (short output)
 * - Sections: Hardware / Maintenance / Data Service
 * - Columns: EXACT alertCategory enums (alphabetical)
 * - Cell:
 *     - ✅ if no active alerts for that category on that cluster
 *     - else ⛔<n> ⚠️<n> ℹ️<n> ❓<n>  (❓ = unknown severity)
 * - NO dedupe (raw per-cluster counts)
 *
 * Returns:
 *  - note
 *  - markdownHardware
 *  - markdownMaintenance
 *  - markdownDataService
 *
 * Email body examples:
 *  - Hardware only:   {{ result("run_javascript_1").note }}\n\n{{ result("run_javascript_1").markdownHardware }}
 *  - Maint+DS only:   {{ result("run_javascript_1").note }}\n\n{{ result("run_javascript_1").markdownMaintenance }}\n\n{{ result("run_javascript_1").markdownDataService }}
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // 1) Auth (ID-only; validated)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // 2) CATEGORY COLUMNS (EXACT ENUMS)
  // ==============================
  const HW_Cats = [
    "kCPU","kChassis","kCluster","kDisk","kFan","kFirmware","kMemory","kNIC",
    "kNode","kNodeHealth","kOperatingSystem","kPowerSupply","kStorageDevice",
    "kStoragePool","kTemperature"
  ].sort();

  const MAINT_Cats = [
    "kAuditLog","kClusterManagement","kConfiguration","kFaultTolerance",
    "kGeneralSoftwareFailure","kHelios","kLicense","kNetworking","kSecurity",
    "kStorageUsage","kSystemService","kUpgrade"
  ].sort();

  const DS_Cats = [
    "kAgent","kAppMarketPlace","kArchivalRestore","kBackupRestore","kCDP",
    "kDataPath","kDataSourceConnector","kDisasterRecovery","kIndexing","kMetadata",
    "kNetBackup","kQuota","kRemoteReplication","kViewFailover"
  ].sort();

  // ==============================
  // 3) SYMBOLS
  // ==============================
  const SYM_HEALTHY = "✅";
  const SYM_C = "⛔";   // Critical
  const SYM_W = "⚠️";  // Warning
  const SYM_I = "ℹ️";  // Info
  const SYM_U = "❓";  // Unknown / unexpected severity

  // ==============================
  // 4) HELPERS
  // ==============================
  function sevBucket(sev) {
    switch (sev) {
      case "kCritical": return "C";
      case "kWarning":  return "W";
      case "kInfo":     return "I";
      default:          return "U"; // Unknown
    }
  }

  function normalizeAlerts(resp) {
    if (Array.isArray(resp)) return resp;
    if (Array.isArray(resp?.alerts)) return resp.alerts;
    if (Array.isArray(resp?.items)) return resp.items;
    return [];
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const err = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      err.httpStatus = resp.status;
      err.bodyText = txt;
      err.url = url;
      throw err;
    }
    return resp.json();
  }

  async function getJsonSafe(url, headers) {
    try {
      const data = await getJson(url, headers);
      return { ok: true, data, status: 200, bodyText: "", url };
    } catch (e) {
      return {
        ok: false,
        data: null,
        status: e?.httpStatus || 0,
        bodyText: e?.bodyText || String(e || ""),
        url: e?.url || url
      };
    }
  }

  // ==============================
  // 5) Fetch clusters (for accessClusterId fan-out)
  // ==============================
  const cluUrl = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const cluResp = await getJsonSafe(cluUrl, { ...commonHeaders, Accept: "application/json" });
  const clusters = Array.isArray(cluResp?.data?.cohesityClusters) ? cluResp.data.cohesityClusters : [];

  if (!cluResp.ok || !clusters.length) {
    const msg = cluResp.ok ? "No clusters returned from Helios." : `Cluster list failed: ${cluResp.status} ${cluResp.bodyText || ""}`;
    throw new Error(msg);
  }

  // ==============================
  // 6) Cluster-scoped alerts pull
  // ==============================
  async function getActiveAlertsByBucketForCluster(bucketEnum, clusterId) {
    const qs = new URLSearchParams({
      alertStateList: "kOpen",
      alertTypeBucketList: bucketEnum
      // maxAlerts: "500" // optional cap if desired
    });

    const url = `${baseUrl}/mcm/alerts?${qs.toString()}`;
    const headers = {
      ...commonHeaders,
      Accept: "application/json",
      accessClusterId: String(clusterId)
    };

    const r = await getJsonSafe(url, headers);
    if (!r.ok) {
      // fail-open per cluster: keep report building
      return { ok: false, alerts: [], err: r };
    }
    return { ok: true, alerts: normalizeAlerts(r.data), err: null };
  }

  // ==============================
  // 7) Build wide tables (short output)
  // ==============================
  function cellValue(C, W, I, U) {
    if (C === 0 && W === 0 && I === 0 && U === 0) return SYM_HEALTHY;
    return `${SYM_C}${C} ${SYM_W}${W} ${SYM_I}${I} ${SYM_U}${U}`;
  }

  function buildMarkdownTable(rows, categories) {
    if (!rows?.length) return "No Active alerts (no clusters to display).";

    const header = ["ClusterName", ...categories];
    const sep = header.map(() => "---");

    const lines = [];
    lines.push(`| ${header.join(" | ")} |`);
    lines.push(`| ${sep.join(" | ")} |`);

    for (const row of rows) {
      const vals = [row.ClusterName, ...categories.map((c) => row[c] ?? SYM_HEALTHY)];
      lines.push(`| ${vals.join(" | ")} |`);
    }
    return lines.join("\n");
  }

  async function buildWideTileTableSeverityShort(bucketEnum, categories) {
    // counts["clusterName||category"] = {C,W,I,U}
    const counts = new Map();
    const clustersWithAny = new Set(); // only clusters that have at least 1 active alert in this bucket

    for (const cl of clusters) {
      const clusterId = cl?.clusterId;
      const clusterName = String(cl?.clusterName || "").trim();
      if (!clusterId || !clusterName) continue;

      const res = await getActiveAlertsByBucketForCluster(bucketEnum, clusterId);
      const alerts = res.alerts || [];

      for (const a of alerts) {
        const cat = String(a?.alertCategory ?? "").trim();
        if (!cat) continue;
        if (!categories.includes(cat)) continue;

        const sevKey = sevBucket(String(a?.severity ?? ""));
        const key = `${clusterName}||${cat}`;

        if (!counts.has(key)) counts.set(key, { C: 0, W: 0, I: 0, U: 0 });
        counts.get(key)[sevKey] += 1;

        clustersWithAny.add(clusterName);
      }
    }

    const clusterList = Array.from(clustersWithAny).sort((a, b) => a.localeCompare(b));
    if (!clusterList.length) return { markdown: "" };

    const rows = clusterList.map((cn) => {
      const row = { ClusterName: cn };
      for (const cat of categories) {
        const key = `${cn}||${cat}`;
        if (!counts.has(key)) {
          row[cat] = SYM_HEALTHY;
        } else {
          const { C, W, I, U } = counts.get(key);
          row[cat] = cellValue(C, W, I, U);
        }
      }
      return row;
    });

    return { markdown: buildMarkdownTable(rows, categories) };
  }

  const note =
    `**NOTE:** This mimics the **System → Health → Components** page of the cluster.\n` +
    `- Shows ONLY clusters that currently have Active (kOpen) alerts for the selected section.\n` +
    `- Clusters not displayed have no Active alerts for that section (healthy for these tiles).\n` +
    `- Cells show "${SYM_HEALTHY}" or "${SYM_C}<n> ${SYM_W}<n> ${SYM_I}<n> ${SYM_U}<n>".\n` +
    `- Data source: per-cluster pull using accessClusterId (no dedupe).`;

  const hw  = await buildWideTileTableSeverityShort("kHardware", HW_Cats);
  const mnt = await buildWideTileTableSeverityShort("kMaintenance", MAINT_Cats);
  const ds  = await buildWideTileTableSeverityShort("kDataService", DS_Cats);

  const markdownHardware =
    `**Hardware**\n${hw.markdown || "No Active alerts (no clusters to display)."}`;

  const markdownMaintenance =
    `**Maintenance**\n${mnt.markdown || "No Active alerts (no clusters to display)."}`;

  const markdownDataService =
    `**Data Service**\n${ds.markdown || "No Active alerts (no clusters to display)."}`;

  return {
    note,
    markdownHardware,
    markdownMaintenance,
    markdownDataService
  };
}
