import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alert Tiles (Cluster-scoped via accessClusterId)
 * - Uses /v2/mcm/alerts
 * - GET-only
 * - ONLY clusters that currently have Active (kOpen) alerts are shown (short output)
 * - Time filter: TODAY (00:00:00 → now) in US Eastern (ET), expressed as startTimeUsecs/endTimeUsecs
 * - Sections: Hardware / Maintenance / Data Service
 * - Columns: EXACT alertCategory enums (alphabetical)
 * - Cell: ✅ if healthy, else ⛔<n> ⚠️<n> ℹ️<n> ❓<n>
 * - NO dedupe (raw per-cluster counts)
 *
 * Returns:
 *  - note
 *  - markdownHardware
 *  - markdownMaintenance
 *  - markdownDataService
 *  - startTimeUsecs, endTimeUsecs (so you can verify)
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // 1) Auth (ID-only; validated)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // 2) TIME WINDOW (TODAY in ET)
  //    startTimeUsecs = ET midnight today
  //    endTimeUsecs   = now
  // ==============================
  function epochUsecsNow() {
    return BigInt(Date.now()) * 1000n;
  }

  function tzOffsetMinutesAt(date, timeZone) {
    // returns offset minutes: UTC - TZ (e.g., ET winter => 300)
    const dtf = new Intl.DateTimeFormat("en-US", {
      timeZone,
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      hour12: false
    });
    const parts = dtf.formatToParts(date);
    const m = {};
    for (const p of parts) m[p.type] = p.value;

    const asUTC = Date.UTC(
      Number(m.year),
      Number(m.month) - 1,
      Number(m.day),
      Number(m.hour),
      Number(m.minute),
      Number(m.second)
    );
    // if `date` is the real instant, then date.getTime() - asUTC = offset in ms (TZ relative to UTC)
    return Math.round((date.getTime() - asUTC) / 60000);
  }

  function startOfTodayUsecsInTZ(timeZone) {
    // Build "today" calendar date in target TZ
    const now = new Date();
    const dtf = new Intl.DateTimeFormat("en-US", {
      timeZone,
      year: "numeric", month: "2-digit", day: "2-digit",
      hour12: false
    });
    const parts = dtf.formatToParts(now);
    const m = {};
    for (const p of parts) m[p.type] = p.value;

    // Midnight UTC for that Y-M-D
    const utcMidnightMs = Date.UTC(
      Number(m.year),
      Number(m.month) - 1,
      Number(m.day),
      0, 0, 0
    );

    // Convert that wall-clock midnight in TZ to real UTC instant by subtracting TZ offset at that moment
    const approx = new Date(utcMidnightMs);
    const offMin = tzOffsetMinutesAt(approx, timeZone);
    const realMs = utcMidnightMs + offMin * 60 * 1000;

    return BigInt(realMs) * 1000n;
  }

  const TZ = "America/New_York"; // ET/EDT depending on date
  const startTimeUsecs = startOfTodayUsecsInTZ(TZ).toString();
  const endTimeUsecs = epochUsecsNow().toString();

  // ==============================
  // 3) CATEGORY COLUMNS (EXACT ENUMS)
  // ==============================
  const HW_Cats = [
    "kCPU","kChassis","kCluster","kDisk","kFan","kFirmware","kMemory","kNIC",
    "kNode","kNodeHealth","kOperatingSystem","kPowerSupply","kStorageDevice",
    "kStoragePool","kTemperature"
  ].sort();

  const MAINT_Cats = [
    "kAuditLog","kClusterManagement","kConfiguration","kFaultTolerance",
    "kGeneralSoftwareFailure","kHelios","kLicense","kNetworking","kSecurity",
    "kStorageUsage","kSystemService","kUpgrade"
  ].sort();

  const DS_Cats = [
    "kAgent","kAppMarketPlace","kArchivalRestore","kBackupRestore","kCDP",
    "kDataPath","kDataSourceConnector","kDisasterRecovery","kIndexing","kMetadata",
    "kNetBackup","kQuota","kRemoteReplication","kViewFailover"
  ].sort();

  // ==============================
  // 4) SYMBOLS
  // ==============================
  const SYM_HEALTHY = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";
  const SYM_U = "❓";

  // ==============================
  // 5) HELPERS
  // ==============================
  function sevBucket(sev) {
    switch (sev) {
      case "kCritical": return "C";
      case "kWarning":  return "W";
      case "kInfo":     return "I";
      default:          return "U";
    }
  }

  function normalizeAlerts(resp) {
    if (Array.isArray(resp)) return resp;
    if (Array.isArray(resp?.alerts)) return resp.alerts;
    if (Array.isArray(resp?.items)) return resp.items;
    return [];
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const err = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      err.httpStatus = resp.status;
      err.bodyText = txt;
      err.url = url;
      throw err;
    }
    return resp.json();
  }

  async function getJsonSafe(url, headers) {
    try {
      const data = await getJson(url, headers);
      return { ok: true, data, status: 200, bodyText: "", url };
    } catch (e) {
      return {
        ok: false,
        data: null,
        status: e?.httpStatus || 0,
        bodyText: e?.bodyText || String(e || ""),
        url: e?.url || url
      };
    }
  }

  // ==============================
  // 6) Fetch clusters
  // ==============================
  const cluUrl = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const cluResp = await getJsonSafe(cluUrl, { ...commonHeaders, Accept: "application/json" });
  const clusters = Array.isArray(cluResp?.data?.cohesityClusters) ? cluResp.data.cohesityClusters : [];

  if (!cluResp.ok || !clusters.length) {
    const msg = cluResp.ok ? "No clusters returned from Helios." : `Cluster list failed: ${cluResp.status} ${cluResp.bodyText || ""}`;
    throw new Error(msg);
  }

  // ==============================
  // 7) Cluster-scoped alerts pull (v2 endpoint + time filter)
  // ==============================
  async function getActiveAlertsByBucketForCluster(bucketEnum, clusterId) {
    const qs = new URLSearchParams({
      alertStateList: "kOpen",
      alertTypeBucketList: bucketEnum,
      startTimeUsecs,
      endTimeUsecs
      // maxAlerts: "500"
    });

    const url = `${baseUrl}/v2/mcm/alerts?${qs.toString()}`;
    const headers = {
      ...commonHeaders,
      Accept: "application/json",
      accessClusterId: String(clusterId)
    };

    const r = await getJsonSafe(url, headers);
    if (!r.ok) return { ok: false, alerts: [], err: r };
    return { ok: true, alerts: normalizeAlerts(r.data), err: null };
  }

  // ==============================
  // 8) Build tables (short output)
  // ==============================
  function cellValue(C, W, I, U) {
    if (C === 0 && W === 0 && I === 0 && U === 0) return SYM_HEALTHY;
    return `${SYM_C}${C} ${SYM_W}${W} ${SYM_I}${I} ${SYM_U}${U}`;
  }

  function buildMarkdownTable(rows, categories) {
    if (!rows?.length) return "No Active alerts (no clusters to display).";

    const header = ["ClusterName", ...categories];
    const sep = header.map(() => "---");

    const lines = [];
    lines.push(`| ${header.join(" | ")} |`);
    lines.push(`| ${sep.join(" | ")} |`);

    for (const row of rows) {
      const vals = [row.ClusterName, ...categories.map((c) => row[c] ?? SYM_HEALTHY)];
      lines.push(`| ${vals.join(" | ")} |`);
    }
    return lines.join("\n");
  }

  async function buildWideTileTableSeverityShort(bucketEnum, categories) {
    const counts = new Map();           // "clusterName||category" -> {C,W,I,U}
    const clustersWithAny = new Set();  // only clusters that have at least 1 active alert in this bucket

    for (const cl of clusters) {
      const clusterId = cl?.clusterId;
      const clusterName = String(cl?.clusterName || "").trim();
      if (!clusterId || !clusterName) continue;

      const res = await getActiveAlertsByBucketForCluster(bucketEnum, clusterId);
      const alerts = res.alerts || [];

      for (const a of alerts) {
        const cat = String(a?.alertCategory ?? "").trim();
        if (!cat) continue;
        if (!categories.includes(cat)) continue;

        const sevKey = sevBucket(String(a?.severity ?? ""));
        const key = `${clusterName}||${cat}`;

        if (!counts.has(key)) counts.set(key, { C: 0, W: 0, I: 0, U: 0 });
        counts.get(key)[sevKey] += 1;

        clustersWithAny.add(clusterName);
      }
    }

    const clusterList = Array.from(clustersWithAny).sort((a, b) => a.localeCompare(b));
    if (!clusterList.length) return { markdown: "" };

    const rows = clusterList.map((cn) => {
      const row = { ClusterName: cn };
      for (const cat of categories) {
        const key = `${cn}||${cat}`;
        if (!counts.has(key)) row[cat] = SYM_HEALTHY;
        else {
          const { C, W, I, U } = counts.get(key);
          row[cat] = cellValue(C, W, I, U);
        }
      }
      return row;
    });

    return { markdown: buildMarkdownTable(rows, categories) };
  }

  // ==============================
  // 9) Output sections separately
  // ==============================
  const note =
    `**NOTE:** This mimics the **System → Health → Components** page of the cluster.\n` +
    `- Shows ONLY clusters that currently have Active (kOpen) alerts for the selected section.\n` +
    `- Clusters not displayed have no Active alerts for that section (healthy for these tiles).\n` +
    `- Cells show "${SYM_HEALTHY}" or "${SYM_C}<n> ${SYM_W}<n> ${SYM_I}<n> ${SYM_U}<n>".\n` +
    `- Filter: TODAY in ET via startTimeUsecs/endTimeUsecs.\n` +
    `- Data source: per-cluster pull using accessClusterId (no dedupe).`;

  const hw  = await buildWideTileTableSeverityShort("kHardware", HW_Cats);
  const mnt = await buildWideTileTableSeverityShort("kMaintenance", MAINT_Cats);
  const ds  = await buildWideTileTableSeverityShort("kDataService", DS_Cats);

  const markdownHardware =
    `**Hardware**\n${hw.markdown || "No Active alerts (no clusters to display)."}`;

  const markdownMaintenance =
    `**Maintenance**\n${mnt.markdown || "No Active alerts (no clusters to display)."}`;

  const markdownDataService =
    `**Data Service**\n${ds.markdown || "No Active alerts (no clusters to display)."}`;

  return {
    startTimeUsecs,
    endTimeUsecs,
    note,
    markdownHardware,
    markdownMaintenance,
    markdownDataService
  };
}
