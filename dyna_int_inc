// Cohesity Helios – Interface DOWN → Allowlist Generator (Discovery Run)
// GET-only, safe. No allowlist filtering.
// Output includes "allowlistPasteBlock" so you can copy/paste lines later.

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) Credential vault: name -> id -> manual (same style as your scripts)
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find((c) => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (detail && (detail.token || detail.password)) || null;
      authMode = "vault-id";
      console.log("✓ Helios key from vault (id): " + (detail && detail.name ? detail.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE"; // last resort
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available (vault + manual failed).");

  const commonHeaders = { accept: "application/json", apiKey: apiKey };

  // ------------------------------
  // 2) Helpers
  // ------------------------------
  function norm(v) {
    return (v ?? "").toString().trim();
  }
  function normLower(v) {
    return norm(v).toLowerCase();
  }
  function isDownLinkState(v) {
    // handles "down", "kLinkStateDown", etc.
    return normLower(v).includes("down");
  }
  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      const v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) v.forEach((val) => usp.append(k, String(val)));
      else usp.append(k, String(v));
    }
    return usp.toString();
  }
  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  // Eth-level allowlist key
  function allowKeyEth(cluster, nodeId, bondName, slaveName) {
    return `${cluster}|${nodeId}|${bondName}|${slaveName}`;
  }

  // Copy/paste line with comments (you’ll paste this into your allowlist input later)
  function allowlistLineWithDetails(row) {
    const key = row.AllowKey;
    // Keep comments compact but useful
    const comment =
      `# NodeIP=${row.NodeIP || "-"} MAC=${row.MAC || "-"} Speed=${row.Speed || "-"} ` +
      `LinkState=${row.LinkState || "-"} SlotType=${row.SlotType || "-"} Chassis=${row.ChassisSerial || "-"}`;
    return `${key} ${comment}`;
  }

  function uniqSorted(arr) {
    return Array.from(new Set(arr.filter(Boolean))).sort((a, b) => a.localeCompare(b));
  }

  function safeCell(v) {
    if (v == null) return "";
    return String(v).replace(/\|/g, " ");
  }

  // ------------------------------
  // 3) Collect DOWN rows for one cluster
  // ------------------------------
  async function collectDownsForCluster(cluster) {
    const clusterName =
      cluster.clusterName || cluster.name || cluster.displayName || ("Unknown-" + cluster.clusterId);

    const headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: String(cluster.clusterId)
    };

    // Use query params (GET body is unreliable in many runtimes)
    const qs = buildQuery({
      bondInterfaceOnly: "true",
      ifaceGroupAssignedOnly: "true",
      includeUplinkSwitc
