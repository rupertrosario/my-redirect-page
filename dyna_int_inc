// Cohesity Helios – Interface DOWN Discovery (All Clusters)
// Goal: FIRST RUN ONLY → list *all* DOWN slave interfaces (no allowlist, no suppression)
//
// Output:
// {
//   authMode: "vault-name" | "vault-id" | "manual",
//   count: <number>,
//   downs: [ { Cluster, NodeID, NodeIP, ChassisSerial, BondName, Slave, LinkState, MAC, Speed, SlotType } ],
//   markdownTable: "<markdown intro + table>"
// }
//
// Notes:
// - Uses query params (NOT GET body). Many runtimes ignore GET bodies.
// - "DOWN" detection is simple: linkState contains "down" (case-insensitive).

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) Credential vault: name -> id -> manual
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find((c) => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (detail && (detail.token || detail.password)) || null;
      authMode = "vault-id";
      console.log("✓ Helios key from vault (id): " + (detail && detail.name ? detail.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE"; // last resort
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available (vault + manual failed).");

  const commonHeaders = { accept: "application/json", apiKey: apiKey };

  // ------------------------------
  // 2) Helpers
  // ------------------------------
  function norm(v) {
    return (v ?? "").toString().trim();
  }
  function normLower(v) {
    return norm(v).toLowerCase();
  }
  function isDownLinkState(v) {
    const s = normLower(v);
    // Handles "down", "kLinkStateDown", "LinkStateDown", etc.
    return s.includes("down");
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      const v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) v.forEach((val) => usp.append(k, String(val)));
      else usp.append(k, String(v));
    }
    return usp.toString();
  }

  function safeCell(v) {
    if (v == null) return "";
    return String(v).replace(/\|/g, " "); // markdown-safe
  }

  // ------------------------------
  // 3) Collect DOWN details for one cluster
  // ------------------------------
  async function collectClusterDowns(cluster) {
    const clusterName =
      cluster.clusterName || cluster.name || cluster.displayName || ("Unknown-" + cluster.clusterId);

    const headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: String(cluster.clusterId)
    };

    const qs = buildQuery({
      bondInterfaceOnly: "true",
      ifaceGroupAssignedOnly: "true",
      includeUplinkSwitchInfo: "true",
      includeBondSlaveDetails: "true"
    });

    const url = baseUrl + "/irisservices/api/v1/public/interface?" + qs;

    let data;
    try {
      data = await getJson(url, headers);
    } catch (e) {
      // For discovery mode: just log error and return none (or you can return an ERROR row)
      console.log(`✗ ${clusterName}: interface API failed: ${e.message}`);
      return [];
    }

    if (!Array.isArray(data) || data.length === 0) return [];

    const downs = [];

    for (const node of data) {
      const nodeId = norm(node?.nodeId);
      const nodeIp = norm(node?.nodeIp);
      const chassisSerial = norm(node?.chassisSerial);

      const interfaces = node?.interfaces;
      const ifList = Array.isArray(interfaces) ? interfaces : (interfaces ? [interfaces] : []);

      for (const bond of ifList) {
        const bondName = norm(bond?.name);
        if (!bondName) continue;

        const slaves = Array.isArray(bond?.bondSlaves)
          ? bond.bondSlaves
          : (bond?.bondSlaves ? [bond.bondSlaves] : []);

        const details = Array.isArray(bond?.bondSlavesDetails)
          ? bond.bondSlavesDetails
          : (bond?.bondSlavesDetails ? [bond.bondSlavesDetails] : []);

        const slotTypes = Array.isArray(bond?.bondSlavesSlotTypes)
          ? bond.bondSlavesSlotTypes
          : (bond?.bondSlavesSlotTypes ? [bond?.bondSlavesSlotTypes] : []);

        // Index details by name if available (more robust than relying on same ordering)
        const detailsByName = new Map();
        for (const d of details) {
          const nm = norm(d?.name);
          if (nm) detailsByName.set(nm, d);
        }

        for (let i = 0; i < slaves.length; i++) {
          const slaveName = norm(slaves[i]);
          if (!slaveName) continue;

          const d = detailsByName.get(slaveName) || details[i] || {};

          const linkState = norm(d?.linkState);
          if (!isDownLinkState(linkState)) continue;

          const mac = norm(d?.macAddr);
          const speed = d?.speed;
          const slotType = norm(slotTypes[i]);

          downs.push({
            Cluster: clusterName,
            NodeID: nodeId,
            NodeIP: nodeIp,
            ChassisSerial: chassisSerial,
            BondName: bondName,
            Slave: slaveName,
            LinkState: linkState,
            MAC: mac,
            Speed: speed != null ? String(speed) : "",
            SlotType: slotType
          });
        }
      }
    }

    return downs;
  }

  // ------------------------------
  // 4) Collect all clusters
  // ------------------------------
  async function collectAllDowns() {
    const clu = await getJson(baseUrl + "/v2/mcm/cluster-mgmt/info", commonHeaders);
    const clusters = clu.cohesityClusters || [];
    if (!clusters.length) return [];

    const promises = clusters.map((c) => collectClusterDowns(c));
    const results = await Promise.all(promises);

    const all = [];
    for (const arr of results) {
      if (arr && arr.length) all.push(...arr);
    }

    all.sort((a, b) =>
      safeCell(a.Cluster).localeCompare(safeCell(b.Cluster)) ||
      safeCell(a.NodeID).localeCompare(safeCell(b.NodeID)) ||
      safeCell(a.BondName).localeCompare(safeCell(b.BondName)) ||
      safeCell(a.Slave).localeCompare(safeCell(b.Slave))
    );

    return all;
  }

  // ------------------------------
  // 5) Markdown table (for quick viewing)
  // ------------------------------
  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) return "✅ No DOWN slave interfaces found.";

    const intro = [
      "### Cohesity: DOWN slave interfaces (discovery run)",
      "",
      "_Scope: Helios `/public/interface` with bondInterfaceOnly + ifaceGroupAssignedOnly + includeBondSlaveDetails._",
      "_This run does **no allowlist filtering**._",
      ""
    ].join("\n");

    const cols = ["Cluster", "NodeID", "NodeIP", "BondName", "Slave", "LinkState", "Speed", "MAC", "SlotType"];
    const header = "| " + cols.join(" | ") + " |";
    const sep = "| " + cols.map(() => "---").join(" | ") + " |";

    const body = rows.map((r) => {
      const vals = cols.map((c) => safeCell(r[c]));
      return "| " + vals.join(" | ") + " |";
    });

    return intro + [header, sep].concat(body).join("\n");
  }

  // ------------------------------
  // 6) Run + print
  // ------------------------------
  const downs = await collectAllDowns();

  console.log("=== Cohesity Interface DOWN Discovery ===");
  console.log("AuthMode: " + authMode);
  console.log("DownCount: " + downs.length);

  // Print a few lines (avoid massive logs)
  for (let i = 0; i < Math.min(downs.length, 50); i++) {
    const r = downs[i];
    console.log(
      `#${i + 1} Cluster=${r.Cluster} NodeID=${r.NodeID} NodeIP=${r.NodeIP} Bond=${r.BondName} Slave=${r.Slave} LinkState=${r.LinkState} Speed=${r.Speed} MAC=${r.MAC}`
    );
  }
  if (downs.length > 50) console.log(`... (printed first 50 of ${downs.length})`);

  const markdownTable = toMarkdownTable(downs);

  return {
    authMode: authMode,
    count: downs.length,
    downs: downs,
    markdownTable: markdownTable
  };
}
