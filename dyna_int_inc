// Cohesity Helios – SIMPLE: Alerts -> node_ip -> Interface details (search all clusters)
// GET-only, safe. COMPAT: no optional chaining (?.), no nullish coalescing (??)
//
// Default: returns ONLY rows where LinkState contains "down" (case-insensitive)

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  var baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 0) Auth (same pattern you use)
  // ------------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId = "credentials_vault-312312";

  var apiKey = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    var found = null;
    for (var i = 0; i < all.credentials.length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;

    var detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      var d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
      console.log("✓ Helios key from vault (id): " + (d2 && d2.name ? d2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  var commonHeaders = { accept: "application/json", apiKey: apiKey };

  // ------------------------------
  // 1) Helpers
  // ------------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }
  function toLower(v) { return norm(v).toLowerCase(); }
  function isDown(v) { return toLower(v).indexOf("down") >= 0; }

  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  function buildQuery(params) {
    var usp = new URLSearchParams();
    for (var k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      var v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) {
        for (var i = 0; i < v.length; i++) usp.append(k, String(v[i]));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  async function getJson(url, headers) {
    var resp = await fetch(url, { method: "GET", headers: headers });
    if (!resp.ok) {
      var txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  // propertyList can be:
  // - array of {key,value}
  // - object { node_ip: "x.x.x.x" }
  function extractNodeIpFromPropertyList(plist, outSet) {
    if (!plist) return;

    // object form
    if (!Array.isArray(plist) && typeof plist === "object") {
      if (plist.node_ip) outSet[norm(plist.node_ip)] = true;
      return;
    }

    // array form
    var arr = toArrayMaybe(plist);
    for (var i = 0; i < arr.length; i++) {
      var kv = arr[i];
      if (!kv) continue;
      if (norm(kv.key) === "node_ip") {
        var ip = norm(kv.value);
        if (ip) outSet[ip] = true;
      }
    }
  }

  // Robust: look in multiple likely places for propertyList
  function extractNodeIpsFromAlert(alert, outSet) {
    if (!alert) return;

    // common: alert.propertyList
    extractNodeIpFromPropertyList(alert.propertyList, outSet);

    // sometimes nested
    if (alert.alertDocument) {
      extractNodeIpFromPropertyList(alert.alertDocument.propertyList, outSet);

      if (alert.alertDocument.alertSummary) {
        extractNodeIpFromPropertyList(alert.alertDocument.alertSummary.propertyList, outSet);
      }
    }

    // fallback: if a field named "propertyList" exists elsewhere
    // (cheap shallow scan)
    for (var k in alert) {
      if (!Object.prototype.hasOwnProperty.call(alert, k)) continue;
      if (k === "propertyList") continue;
      if (k.toLowerCase().indexOf("property") >= 0 && alert[k]) {
        extractNodeIpFromPropertyList(alert[k], outSet);
      }
    }
  }

  // interface parsing helpers
  function extractSlaveName(slaveItem) {
    if (slaveItem === null || slaveItem === undefined) return "";
    if (typeof slaveItem === "string") return slaveItem.trim();
    if (typeof slaveItem === "number") return String(slaveItem);
    if (typeof slaveItem === "object") {
      return norm(slaveItem.name) ||
             norm(slaveItem["@name"]) ||
             norm(slaveItem.iface) ||
             norm(slaveItem.ifaceName) ||
             norm(slaveItem.interfaceName) ||
             "";
    }
    return norm(slaveItem);
  }

  function extractDetailName(detailItem) {
    if (!detailItem || typeof detailItem !== "object") return "";
    return norm(detailItem.name) ||
           norm(detailItem["@name"]) ||
           norm(detailItem.iface) ||
           norm(detailItem.ifaceName) ||
           norm(detailItem.interfaceName) ||
           "";
  }

  function extractLinkState(detailItem) {
    if (!detailItem || typeof detailItem !== "object") return "";
    return norm(detailItem.linkState || detailItem.link_state || detailItem.state || "");
  }

  function extractMac(detailItem) {
    if (!detailItem || typeof detailItem !== "object") return "";
    return norm(detailItem.macAddr || detailItem.mac || detailItem.mac_address || "");
  }

  function extractSpeed(detailItem) {
    if (!detailItem || typeof detailItem !== "object") return "";
    var v = detailItem.speed;
    if (v === undefined || v === null) v = detailItem.linkSpeed;
    if (v === undefined || v === null) v = detailItem.link_speed;
    return norm(v);
  }

  // ------------------------------
  // 2) Step 1: GET Alerts -> IPs
  // ------------------------------
  var alertsUrl =
    baseUrl +
    "/v2/alerts?" +
    buildQuery({
      maxAlerts: 50,
      alertTypes: "1105",
      alertStates: "kOpen,kNote",
      alertCategories: "kNetworking"
    });

  var alertsData = await getJson(alertsUrl, commonHeaders);

  var alerts = alertsData && alertsData.alerts ? alertsData.alerts : [];
  // sometimes alerts is an object not array when maxAlerts=1
  if (!Array.isArray(alerts)) alerts = toArrayMaybe(alerts);

  var ipSet = {};
  for (var a = 0; a < alerts.length; a++) extractNodeIpsFromAlert(alerts[a], ipSet);

  var alertIps = Object.keys(ipSet).filter(Boolean).sort();

  console.log("=== Step1: Alerts ===");
  console.log("AuthMode: " + authMode);
  console.log("Alerts returned: " + alerts.length);
  console.log("node_ip extracted: " + alertIps.length);
  if (alertIps.length) console.log("IPs: " + alertIps.join(", "));

  if (!alertIps.length) {
    return {
      authMode: authMode,
      alertCount: alerts.length,
      alertIpCount: 0,
      alertIps: [],
      matchedRows: [],
      markdownTable: "✅ No node_ip found in Helios alerts (1105 / Networking / Open,Note).",
      markdownEmail: "✅ No node_ip found in Helios alerts (1105 / Networking / Open,Note).",
      errors: []
    };
  }

  // ------------------------------
  // 3) Step 2: Get clusters
  // ------------------------------
  var clu = await getJson(baseUrl + "/v2/mcm/cluster-mgmt/info", commonHeaders);
  var clusters = (clu && clu.cohesityClusters) ? clu.cohesityClusters : [];
  if (!Array.isArray(clusters)) clusters = [];

  console.log("=== Step2: Clusters ===");
  console.log("Clusters returned: " + clusters.length);

  // ------------------------------
  // 4) Step 3: For each cluster -> interface -> match IPs -> only DOWN rows
  // ------------------------------
  var ifaceQs = buildQuery({
    bondInterfaceOnly: "true",
    ifaceGroupAssignedOnly: "true",
    includeUplinkSwitchInfo: "true",
    includeBondSlaveDetails: "true"
  });

  var matchedRows = [];
  var errors = [];

  // quick set for lookup
  var ipLookup = {};
  for (var i = 0; i < alertIps.length; i++) ipLookup[alertIps[i]] = true;

  for (var c = 0; c < clusters.length; c++) {
    var cluster = clusters[c];
    var clusterName = cluster.clusterName || cluster.name || cluster.displayName || ("Unknown-" + cluster.clusterId);

    var headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: String(cluster.clusterId)
    };

    var url = baseUrl + "/irisservices/api/v1/public/interface?" + ifaceQs;

    var data;
    try {
      data = await getJson(url, headers);
    } catch (e) {
      errors.push({ Cluster: clusterName, Reason: e.message });
      continue;
    }

    var nodes = Array.isArray(data) ? data : toArrayMaybe(data);
    for (var ni = 0; ni < nodes.length; ni++) {
      var node = nodes[ni];
      var nodeIp = norm(node && node.nodeIp);
      if (!nodeIp || !ipLookup[nodeIp]) continue;

      var nodeId = norm(node && node.nodeId);
      var chassisSerial = norm(node && node.chassisSerial);

      var ifList = toArrayMaybe(node && node.interfaces);
      for (var bi = 0; bi < ifList.length; bi++) {
        var bond = ifList[bi];
        var bondName = norm(bond && bond.name);
        if (!bondName) continue;

        var slavesRaw = toArrayMaybe(bond && bond.bondSlaves);
        var slaves = [];
        for (var si = 0; si < slavesRaw.length; si++) {
          var sn = extractSlaveName(slavesRaw[si]);
          if (sn) slaves.push(sn);
        }

        var detailsRaw = bond && bond.bondSlavesDetails;
        var detailsArr = [];
        var detailsByName = {};

        if (Array.isArray(detailsRaw)) {
          detailsArr = detailsRaw;
          for (var di = 0; di < detailsArr.length; di++) {
            var dn = extractDetailName(detailsArr[di]);
            if (dn) detailsByName[dn] = detailsArr[di];
          }
        } else if (detailsRaw && typeof detailsRaw === "object") {
          for (var k in detailsRaw) {
            if (!Object.prototype.hasOwnProperty.call(detailsRaw, k)) continue;
            if (detailsRaw[k] && typeof detailsRaw[k] === "object") detailsByName[k] = detailsRaw[k];
          }
        }

        var slotTypesRaw = toArrayMaybe(bond && bond.bondSlavesSlotTypes);
        var slotTypes = [];
        for (var st = 0; st < slotTypesRaw.length; st++) slotTypes.push(norm(slotTypesRaw[st]));

        for (var s = 0; s < slaves.length; s++) {
          var slaveName = slaves[s];
          var d = detailsByName[slaveName] || detailsArr[s] || null;

          var linkState = extractLinkState(d);
          if (!isDown(linkState)) continue; // ONLY DOWN rows

          matchedRows.push({
            Cluster: clusterName,
            NodeIP: nodeIp,
            NodeID: nodeId,
            ChassisSerial: chassisSerial,
            BondName: bondName,
            Slave: slaveName,
            LinkState: linkState,
            MAC: extractMac(d),
            Speed: extractSpeed(d),
            SlotType: slotTypes[s] || ""
          });
        }
      }
    }
  }

  matchedRows.sort(function (a, b) {
    return safeCell(a.Cluster).localeCompare(safeCell(b.Cluster)) ||
           safeCell(a.NodeIP).localeCompare(safeCell(b.NodeIP)) ||
           safeCell(a.BondName).localeCompare(safeCell(b.BondName)) ||
           safeCell(a.Slave).localeCompare(safeCell(b.Slave));
  });

  // ------------------------------
  // 5) Markdown output
  // ------------------------------
  function toMarkdown(rows, errors) {
    if (!rows || rows.length === 0) {
      var msg =
        "⚠️ Alerts had node_ip, but interface search found **no DOWN slaves** for those IPs.\n\n" +
        "IPs: " + alertIps.join(", ");
      if (errors && errors.length) msg += "\n\nErrors: " + errors.length;
      return msg;
    }

    var intro =
      "### Cohesity: DOWN interface details for IPs from alerts (1105)\n\n" +
      "IPs (" + alertIps.length + "): " + alertIps.join(", ") + "\n\n";

    var cols = ["Cluster","NodeIP","NodeID","BondName","Slave","LinkState","Speed","MAC","SlotType"];
    var header = "| " + cols.join(" | ") + " |";
    var sep = "| " + cols.map(function(){return "---";}).join(" | ") + " |";

    var body = rows.map(function (r) {
      var vals = cols.map(function (c) { return safeCell(r[c]); });
      return "| " + vals.join(" | ") + " |";
    });

    var errBlock = "";
    if (errors && errors.length) {
      errBlock =
        "\n\n---\n\n### Errors\n\n" +
        errors.map(function (e, i) {
          return "- #" + (i + 1) + " **" + safeCell(e.Cluster) + "**: " + safeCell(e.Reason);
        }).join("\n");
    }

    return intro + [header, sep].concat(body).join("\n") + errBlock;
  }

  var markdownTable = toMarkdown(matchedRows, errors);

  console.log("=== Step3: Matches ===");
  console.log("Matched DOWN rows: " + matchedRows.length);
  if (matchedRows.length) console.log("First match: " + JSON.stringify(matchedRows[0]));

  return {
    authMode: authMode,
    alertCount: alerts.length,
    alertIpCount: alertIps.length,
    alertIps: alertIps,
    matchedRowCount: matchedRows.length,
    matchedRows: matchedRows,
    markdownTable: markdownTable,
    markdownEmail: markdownTable,
    errors: errors
  };
}
