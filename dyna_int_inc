import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  var baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // Auth (same style you use)
  // ------------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId   = "credentials_vault-312312";

  var apiKey = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    var found = null;
    for (var i = 0; i < all.credentials.length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;

    var detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      var d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
      console.log("✓ Helios key from vault (id): " + (d2 && d2.name ? d2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  // ------------------------------
  // Helpers
  // ------------------------------
  function buildQuery(params) {
    var usp = new URLSearchParams();
    for (var k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      var v = params[k];
      if (v === undefined || v === null) continue;

      // Arrays -> repeated params (key=a&key=b)
      if (Array.isArray(v)) {
        for (var i = 0; i < v.length; i++) usp.append(k, String(v[i]));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  async function getJson(url, headers) {
    var resp = await fetch(url, { method: "GET", headers: headers });
    if (!resp.ok) {
      var txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }

  // Find node_ip in propertyList (array of {key,value} / sometimes {key,values})
  function extractNodeIpFromAlert(alertObj) {
    var plist = alertObj ? alertObj.propertyList : null;
    if (!plist || !Array.isArray(plist)) return "";

    for (var i = 0; i < plist.length; i++) {
      var kv = plist[i] || {};
      if (norm(kv.key) !== "node_ip") continue;

      // PowerShell logic: value else values
      var ip = kv.value;
      if (!ip) ip = kv.values;

      // values could be array
      if (Array.isArray(ip)) {
        if (ip.length > 0) return norm(ip[0]);
        return "";
      }

      return norm(ip);
    }
    return "";
  }

  // ------------------------------
  // 1) Get clusters
  // ------------------------------
  var commonHeaders = { accept: "application/json", apiKey: apiKey };

  var clusterUrl = baseUrl + "/v2/mcm/cluster-mgmt/info";
  var clusterData = await getJson(clusterUrl, commonHeaders);
  var clusters = toArrayMaybe(clusterData && clusterData.cohesityClusters);

  if (!clusters.length) {
    return { authMode: authMode, count: 0, results: [], note: "No clusters returned from /cluster-mgmt/info" };
  }

  // ------------------------------
  // 2) Get alerts per cluster (with accessClusterId)
  // ------------------------------
  var alertsQuery = buildQuery({
    maxAlerts: 200,
    alertTypes: "1105",
    alertStates: "kOpen,kNote",          // keep EXACT string like your PS
    alertCategories: "kNetworking"
  });

  var alertsUrl = baseUrl + "/v2/alerts?" + alertsQuery;

  var results = [];

  for (var c = 0; c < clusters.length; c++) {
    var clus = clusters[c] || {};
    var clusterName = norm(clus.clusterName);
    var clusterId = norm(clus.clusterId);

    if (!clusterId) continue;

    var headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: clusterId
    };

    var data;
    try {
      data = await getJson(alertsUrl, headers);
    } catch (e) {
      // keep going like your PS would
      console.log("⚠️ Alerts fetch failed for cluster " + clusterName + " (" + clusterId + "): " + norm(e.message || e));
      continue;
    }

    var alerts = toArrayMaybe(data && data.alerts);

    for (var a = 0; a < alerts.length; a++) {
      var alt = alerts[a] || {};
      var ip = extractNodeIpFromAlert(alt);

      results.push({
        AlertCode: norm(alt.alertCode),
        IP: ip,
        ClusterName: clusterName,
        ClusterId: clusterId,
        Severity: norm(alt.severity),
        AlertState: norm(alt.alertState),
        Id: norm(alt.id)
      });
    }
  }

  return {
    authMode: authMode,
    count: results.length,
    results: results,
    alertsUrl: alertsUrl
  };
}
