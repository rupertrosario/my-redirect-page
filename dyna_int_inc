// Cohesity Helios – Alerts Viewer (List 10 alerts)
// GET-only, safe. COMPAT: no optional chaining (?.), no nullish coalescing (??)
//
// What it does:
// 1) GET /v2/alerts?maxAlerts=10 (with optional filters you can adjust)
// 2) Prints the first 10 alerts in logs
// 3) Returns a compact alertsPreview for workflow/email usage

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  var baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 0) API key: vault-name -> vault-id -> manual
  // ------------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId = "credentials_vault-312312";

  var apiKey = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    var found = null;
    for (var i = 0; i < all.credentials.length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;

    var detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      var d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
      console.log("✓ Helios key from vault (id): " + (d2 && d2.name ? d2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  var commonHeaders = { accept: "application/json", apiKey: apiKey };

  // ------------------------------
  // Helpers
  // ------------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }

  function buildQuery(params) {
    var usp = new URLSearchParams();
    for (var k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      var v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) {
        for (var i = 0; i < v.length; i++) usp.append(k, String(v[i]));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  async function getJson(url, headers) {
    var resp = await fetch(url, { method: "GET", headers: headers });
    if (!resp.ok) {
      var txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  // ------------------------------
  // 1) Build alerts query (keep it broad for first test)
  // ------------------------------
  // If you want your original filters back later, we’ll add them once we confirm structure.
  var alertsUrl =
    baseUrl +
    "/v2/alerts?" +
    buildQuery({
      maxAlerts: 10
      // optional later:
      // alertTypes: "1105",
      // alertStates: "kOpen,kNote",
      // alertCategories: "kNetworking"
    });

  // ------------------------------
  // 2) Get alerts
  // ------------------------------
  var data = await getJson(alertsUrl, commonHeaders);

  var alerts = data && data.alerts ? data.alerts : [];
  if (!Array.isArray(alerts)) alerts = (alerts ? [alerts] : []);

  // Some APIs return "total" fields even when alerts[] is limited
  var total =
    (data && (data.totalAlerts || data.totalCount || data.count || data.total)) || null;

  // ------------------------------
  // 3) Build a compact preview (10 rows)
  // ------------------------------
  var preview = [];

  for (var i = 0; i < alerts.length; i++) {
    var a = alerts[i] || {};

    preview.push({
      index: i + 1,
      id: norm(a.id || a.alertId || a.alertDocumentId || ""),
      type: norm(a.alertType || a.type || ""),
      state: norm(a.alertState || a.state || ""),
      category: norm(a.alertCategory || a.category || ""),
      severity: norm(a.severity || ""),
      createdTimeUsecs: norm(a.createdTimeUsecs || a.createdTime || a.raiseTimeUsecs || ""),
      summary: norm(a.summary || a.description || a.title || "")
    });
  }

  // ------------------------------
  // 4) Print to logs
  // ------------------------------
  console.log("=== Helios Alerts Viewer ===");
  console.log("AuthMode: " + authMode);
  console.log("Requested maxAlerts=10");
  console.log("alerts.length returned: " + alerts.length);
  if (total !== null) console.log("Total (reported by API): " + total);
  console.log("");

  for (var j = 0; j < preview.length; j++) {
    var p = preview[j];
    console.log(
      "#" + p.index +
      " id=" + (p.id || "-") +
      " type=" + (p.type || "-") +
      " state=" + (p.state || "-") +
      " category=" + (p.category || "-") +
      " severity=" + (p.severity || "-") +
      " summary=" + (p.summary || "-")
    );
  }

  // ------------------------------
  // 5) Return
  // ------------------------------
  return {
    authMode: authMode,
    requestedMaxAlerts: 10,
    returnedAlerts: alerts.length,
    totalReportedByApi: total,
    alertsPreview: preview,
    rawKeysTopLevel: (alerts.length ? Object.keys(alerts[0] || {}) : [])
  };
}
