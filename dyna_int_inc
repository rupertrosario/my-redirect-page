// Cohesity Helios – Alerts Viewer DEBUG (maxAlerts=5)
// GET-only, safe. Prints + returns response shape so we can fix parsing.
// COMPAT: no optional chaining (?.), no nullish coalescing (??)

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  var baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // Auth (same as your other scripts)
  // ------------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId = "credentials_vault-312312";

  var apiKey = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    var found = null;
    for (var i = 0; i < all.credentials.length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;

    var detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      var d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
      console.log("✓ Helios key from vault (id): " + (d2 && d2.name ? d2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  var headers = { accept: "application/json", apiKey: apiKey };

  function buildQuery(params) {
    var usp = new URLSearchParams();
    for (var k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      var v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) {
        for (var i = 0; i < v.length; i++) usp.append(k, String(v[i]));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  async function getJsonDebug(url, headers) {
    var resp = await fetch(url, { method: "GET", headers: headers });

    var text = "";
    try { text = await resp.text(); } catch (e) {}

    // Always return status + a snippet even if JSON parse fails
    var json = null;
    try { json = text ? JSON.parse(text) : null; } catch (e2) {}

    return {
      ok: resp.ok,
      status: resp.status,
      statusText: resp.statusText || "",
      textSnippet: text ? text.slice(0, 2500) : "",
      json: json
    };
  }

  // ------------------------------
  // Request 5 alerts (broad)
  // ------------------------------
  var url = baseUrl + "/v2/alerts?" + buildQuery({ maxAlerts: 5 });

  var dbg = await getJsonDebug(url, headers);

  console.log("=== Helios Alerts DEBUG ===");
  console.log("AuthMode: " + authMode);
  console.log("URL: " + url);
  console.log("HTTP: " + dbg.status + " " + dbg.statusText);
  console.log("OK: " + (dbg.ok ? "true" : "false"));

  // If response isn't OK, print snippet and return
  if (!dbg.ok) {
    console.log("Body snippet:\n" + dbg.textSnippet);
    return {
      authMode: authMode,
      url: url,
      http: { ok: dbg.ok, status: dbg.status, statusText: dbg.statusText },
      topLevelKeys: [],
      parsed: false,
      bodySnippet: dbg.textSnippet
    };
  }

  // If JSON parse failed, return snippet
  if (!dbg.json) {
    console.log("⚠️ JSON parse failed. Body snippet:\n" + dbg.textSnippet);
    return {
      authMode: authMode,
      url: url,
      http: { ok: dbg.ok, status: dbg.status, statusText: dbg.statusText },
      topLevelKeys: [],
      parsed: false,
      bodySnippet: dbg.textSnippet
    };
  }

  var data = dbg.json;
  var keys = Object.keys(data || {});
  console.log("Top-level keys: " + keys.join(", "));

  // Try common candidate arrays
  var candidates = ["alerts", "alertDocuments", "items", "data", "results"];
  var foundName = null;
  var foundArr = null;

  for (var i = 0; i < candidates.length; i++) {
    var k = candidates[i];
    if (data && Object.prototype.hasOwnProperty.call(data, k) && Array.isArray(data[k])) {
      foundName = k;
      foundArr = data[k];
      break;
    }
  }

  var preview = [];
  if (foundArr) {
    for (var n = 0; n < foundArr.length; n++) {
      var a = foundArr[n] || {};
      preview.push({
        idx: n + 1,
        keys: Object.keys(a || {}).slice(0, 40) // show keys so we see where propertyList lives
      });
    }
    console.log("Found array: " + foundName + " length=" + foundArr.length);
    console.log("First item keys: " + (preview.length ? preview[0].keys.join(", ") : ""));
  } else {
    console.log("No common alert array found (alerts/alertDocuments/items/data/results).");
  }

  return {
    authMode: authMode,
    requestedMaxAlerts: 5,
    url: url,
    http: { ok: dbg.ok, status: dbg.status, statusText: dbg.statusText },
    topLevelKeys: keys,
    foundArrayName: foundName,
    foundArrayLength: foundArr ? foundArr.length : 0,
    firstItemKeys: (foundArr && foundArr.length) ? Object.keys(foundArr[0] || {}) : [],
    bodySnippet: dbg.textSnippet
  };
}
