import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  var baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // Auth (keep your exact block)
  // ------------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId = "credentials_vault-312312";

  var apiKey = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    var found = null;
    for (var i = 0; i < all.credentials.length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;

    var detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      var d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
      console.log("✓ Helios key from vault (id): " + (d2 && d2.name ? d2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  var headers = { accept: "application/json", apiKey: apiKey };

  // ------------------------------
  // Helpers
  // ------------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }

  function pick(obj, keys) {
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i];
      if (!obj) continue;
      if (Object.prototype.hasOwnProperty.call(obj, k) && obj[k] !== null && obj[k] !== undefined) {
        return obj[k];
      }
    }
    return null;
  }

  function buildQuery(params) {
    var usp = new URLSearchParams();
    for (var k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      var v = params[k];
      if (v === undefined || v === null) continue;

      // IMPORTANT: Arrays become repeated params: key=a&key=b
      if (Array.isArray(v)) {
        for (var i = 0; i < v.length; i++) usp.append(k, String(v[i]));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  async function getJsonDebug(url, headers) {
    var resp = await fetch(url, { method: "GET", headers: headers });

    var text = "";
    try { text = await resp.text(); } catch (e) {}

    var json = null;
    try { json = text ? JSON.parse(text) : null; } catch (e2) {}

    return {
      ok: resp.ok,
      status: resp.status,
      statusText: resp.statusText || "",
      textSnippet: text ? text.slice(0, 2500) : "",
      json: json
    };
  }

  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  // ------------------------------
  // 1) Alerts query (LIST 5)
  // Use arrays so params are repeated, not comma-string.
  // ------------------------------
  var url =
    baseUrl +
    "/v2/alerts?" +
    buildQuery({
      maxAlerts: 5,
      alertTypes: ["1105"],              // repeatable
      alertStates: ["kOpen", "kNote"],   // repeatable
      alertCategories: ["kNetworking"]   // repeatable
    });

  var dbg = await getJsonDebug(url, headers);

  console.log("=== Helios Alerts (List 5) ===");
  console.log("AuthMode: " + authMode);
  console.log("URL: " + url);
  console.log("HTTP: " + dbg.status + " " + dbg.statusText);

  if (!dbg.ok) {
    console.log("Body snippet:\n" + dbg.textSnippet);
    throw new Error("Alerts call failed: HTTP " + dbg.status);
  }
  if (!dbg.json) {
    console.log("Body snippet:\n" + dbg.textSnippet);
    throw new Error("Alerts call returned non-JSON or JSON parse failed.");
  }

  var json = dbg.json;

  // Alerts array name is typically json.alerts, but keep it safe
  var alertsRaw = pick(json, ["alerts", "alertDocuments", "items", "results"]);
  var alerts = toArrayMaybe(alertsRaw);

  console.log("Top-level keys: " + Object.keys(json || {}).join(", "));
  console.log("Alerts array length: " + alerts.length);

  // ------------------------------
  // 2) Print a clean view (these fields vary across versions)
  // ------------------------------
  var preview = [];
  for (var i = 0; i < alerts.length; i++) {
    var a = alerts[i] || {};

    // try multiple likely field names
    var id = pick(a, ["id", "alertId", "alertDocumentId"]);
    var type = pick(a, ["alertType", "type", "alertTypeId"]);
    var state = pick(a, ["alertState", "state"]);
    var category = pick(a, ["alertCategory", "category"]);
    var severity = pick(a, ["severity", "alertSeverity"]);
    var created = pick(a, ["createdTimeUsecs", "createTimeUsecs", "raisedTimeUsecs", "raisedTime", "createdTime"]);

    // summary/description/title might be nested; print what exists
    var summary = pick(a, ["summary", "title", "description"]);
    if (!summary && a.alertDocument && a.alertDocument.alertSummary) {
      summary = pick(a.alertDocument.alertSummary, ["summary", "title", "description", "alertSummary"]);
    }

    // Also show whether propertyList exists (where node_ip usually is)
    var propListPresent = false;
    if (a.propertyList) propListPresent = true;
    else if (a.alertDocument && a.alertDocument.alertSummary && a.alertDocument.alertSummary.propertyList) propListPresent = true;
    else if (a.alertDocument && a.alertDocument.propertyList) propListPresent = true;

    var line =
      "#" + (i + 1) +
      " id=" + norm(id || "-") +
      " type=" + norm(type || "-") +
      " state=" + norm(state || "-") +
      " category=" + norm(category || "-") +
      " sev=" + norm(severity || "-") +
      " created=" + norm(created || "-") +
      " hasPropertyList=" + (propListPresent ? "yes" : "no") +
      " summary=" + norm(summary || "-");

    console.log(line);

    // return compact object too
    preview.push({
      index: i + 1,
      id: norm(id),
      type: norm(type),
      state: norm(state),
      category: norm(category),
      severity: norm(severity),
      created: norm(created),
      hasPropertyList: propListPresent,
      summary: norm(summary),
      // raw keys so you can see schema without dumping full payload
      keys: Object.keys(a || {}).slice(0, 60)
    });
  }

  return {
    authMode: authMode,
    requestedUrl: url,
    http: { ok: dbg.ok, status: dbg.status, statusText: dbg.statusText },
    topLevelKeys: Object.keys(json || {}),
    alertsReturned: alerts.length,
    alertsPreview: preview,
    bodySnippet: dbg.textSnippet
  };
}
