// Cohesity Helios – Interface details ONLY for node IPs found in Helios alerts (type 1105 Networking)
// GET-only, safe. COMPAT: no optional chaining (?.), no nullish coalescing (??)
//
// Change requested: maxAlerts = 50
//
// Output:
// {
//   authMode,
//   alertIpCount, alertIps,
//   matchedNodeCount, matchedRowCount,
//   matchedRows: [...],
//   markdownTable,
//   errors: [...]
// }

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  var baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) API key: vault-name -> vault-id -> manual
  // ------------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId = "credentials_vault-312312";

  var apiKey = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    var found = null;
    for (var i = 0; i < all.credentials.length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;

    var detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      var detail2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (detail2 && (detail2.token || detail2.password)) || null;
      authMode = "vault-id";
      console.log("✓ Helios key from vault (id): " + (detail2 && detail2.name ? detail2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available (vault + manual failed).");

  var commonHeaders = { accept: "application/json", apiKey: apiKey };

  // ------------------------------
  // 2) Helpers
  // ------------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }
  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }
  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  function buildQuery(params) {
    var usp = new URLSearchParams();
    for (var k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      var v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) {
        for (var i = 0; i < v.length; i++) usp.append(k, String(v[i]));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  async function getJson(url, headers) {
    var resp = await fetch(url, { method: "GET", headers: headers });
    if (!resp.ok) {
      var txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  // bondSlaves may be strings OR objects
  function extractSlaveName(slaveItem) {
    if (slaveItem === null || slaveItem === undefined) return "";
    if (typeof slaveItem === "string") return slaveItem.trim();
    if (typeof slaveItem === "number") return String(slaveItem);
    if (typeof slaveItem === "object") {
      return norm(slaveItem.name) ||
             norm(slaveItem["@name"]) ||
             norm(slaveItem.iface) ||
             norm(slaveItem.ifaceName) ||
             norm(slaveItem.interfaceName) ||
             "";
    }
    return norm(slaveItem);
  }

  function extractDetailName(detailItem) {
    if (!detailItem || typeof detailItem !== "object") return "";
    return norm(detailItem.name) ||
           norm(detailItem["@name"]) ||
           norm(detailItem.iface) ||
           norm(detailItem.ifaceName) ||
           norm(detailItem.interfaceName) ||
           "";
  }

  function extractLinkState(detailItem) {
    if (!detailItem || typeof detailItem !== "object") return "";
    return norm(detailItem.linkState || detailItem.link_state || detailItem.state || "");
  }

  function extractMac(detailItem) {
    if (!detailItem || typeof detailItem !== "object") return "";
    return norm(detailItem.macAddr || detailItem.mac || detailItem.mac_address || "");
  }

  function extractSpeed(detailItem) {
    if (!detailItem || typeof detailItem !== "object") return "";
    var v = detailItem.speed;
    if (v === undefined || v === null) v = detailItem.linkSpeed;
    if (v === undefined || v === null) v = detailItem.link_speed;
    return norm(v);
  }

  // ------------------------------
  // 3) Get IPs from Helios alerts (type 1105, Networking) - maxAlerts=50
  // ------------------------------
  async function getAlertNodeIps() {
    var url =
      baseUrl +
      "/v2/alerts?" +
      buildQuery({
        maxAlerts: 50,
        alertTypes: "1105",
        alertStates: "kOpen,kNote",
        alertCategories: "kNetworking"
      });

    var data = await getJson(url, commonHeaders);

    var alerts = data && data.alerts ? data.alerts : [];
    if (!Array.isArray(alerts)) alerts = [];

    var ipSet = {};
    for (var i = 0; i < alerts.length; i++) {
      var a = alerts[i];

      // propertyList is usually: [{key:"node_ip", value:"x.x.x.x"}, ...]
      var plist = a && a.propertyList ? a.propertyList : null;
      if (!plist) continue;

      var arr = toArrayMaybe(plist);
      for (var j = 0; j < arr.length; j++) {
        var kv = arr[j];
        if (!kv) continue;

        if (norm(kv.key) === "node_ip") {
          var ip = norm(kv.value);
          if (ip) ipSet[ip] = true;
        }
      }
    }

    return Object.keys(ipSet).sort();
  }

  // ------------------------------
  // 4) Interface details for those IPs (across all clusters)
  // ------------------------------
  async function collectInterfaceRowsForIps(alertIps) {
    var ipSet = {};
    for (var i = 0; i < alertIps.length; i++) ipSet[String(alertIps[i])] = true;

    // clusters
    var clu = await getJson(baseUrl + "/v2/mcm/cluster-mgmt/info", commonHeaders);
    var clusters = (clu && clu.cohesityClusters) ? clu.cohesityClusters : [];
    if (!Array.isArray(clusters)) clusters = [];

    var matchedNodeKeySet = {};
    var matchedRows = [];
    var errors = [];

    // interface query
    var ifaceQs = buildQuery({
      bondInterfaceOnly: "true",
      ifaceGroupAssignedOnly: "true",
      includeUplinkSwitchInfo: "true",
      includeBondSlaveDetails: "true"
    });

    for (var c = 0; c < clusters.length; c++) {
      var cluster = clusters[c];
      var clusterName = cluster.clusterName || cluster.name || cluster.displayName || ("Unknown-" + cluster.clusterId);

      var headers = {
        accept: "application/json",
        apiKey: apiKey,
        accessClusterId: String(cluster.clusterId)
      };

      var url = baseUrl + "/irisservices/api/v1/public/interface?" + ifaceQs;

      var data;
      try {
        data = await getJson(url, headers);
      } catch (e) {
        errors.push({ Cluster: clusterName, Reason: e.message });
        continue;
      }

      var nodes = Array.isArray(data) ? data : toArrayMaybe(data);
      for (var ni = 0; ni < nodes.length; ni++) {
        var node = nodes[ni];
        var nodeIp = norm(node && node.nodeIp);

        // FILTER: only nodes that match alert IP list
        if (!nodeIp || !ipSet[nodeIp]) continue;

        var nodeId = norm(node && node.nodeId);
        var chassisSerial = norm(node && node.chassisSerial);

        // unique node match count (cluster+nodeId+ip)
        var nodeKey = clusterName + "|" + nodeId + "|" + nodeIp;
        matchedNodeKeySet[nodeKey] = true;

        var ifList = toArrayMaybe(node && node.interfaces);

        for (var bi = 0; bi < ifList.length; bi++) {
          var bond = ifList[bi];
          var bondName = norm(bond && bond.name);
          if (!bondName) continue;

          var slavesRaw = toArrayMaybe(bond && bond.bondSlaves);
          var slaves = [];
          for (var si = 0; si < slavesRaw.length; si++) {
            var sn = extractSlaveName(slavesRaw[si]);
            if (sn) slaves.push(sn);
          }

          var detailsRaw = bond && bond.bondSlavesDetails;
          var detailsArr = [];
          var detailsByName = {};

          if (Array.isArray(detailsRaw)) {
            detailsArr = detailsRaw;
            for (var di = 0; di < detailsArr.length; di++) {
              var dn = extractDetailName(detailsArr[di]);
              if (dn) detailsByName[dn] = detailsArr[di];
            }
          } else if (detailsRaw && typeof detailsRaw === "object") {
            for (var k in detailsRaw) {
              if (!Object.prototype.hasOwnProperty.call(detailsRaw, k)) continue;
              if (detailsRaw[k] && typeof detailsRaw[k] === "object") detailsByName[k] = detailsRaw[k];
            }
          }

          var slotTypesRaw = toArrayMaybe(bond && bond.bondSlavesSlotTypes);
          var slotTypes = [];
          for (var st = 0; st < slotTypesRaw.length; st++) slotTypes.push(norm(slotTypesRaw[st]));

          for (var i = 0; i < slaves.length; i++) {
            var slaveName = slaves[i];
            var d = detailsByName[slaveName] || detailsArr[i] || null;

            matchedRows.push({
              Cluster: clusterName,
              NodeIP: nodeIp,
              NodeID: nodeId,
              ChassisSerial: chassisSerial,
              BondName: bondName,
              Slave: slaveName,
              LinkState: extractLinkState(d),
              MAC: extractMac(d),
              Speed: extractSpeed(d),
              SlotType: slotTypes[i] || ""
            });
          }
        }
      }
    }

    matchedRows.sort(function (a, b) {
      return safeCell(a.Cluster).localeCompare(safeCell(b.Cluster)) ||
             safeCell(a.NodeIP).localeCompare(safeCell(b.NodeIP)) ||
             safeCell(a.NodeID).localeCompare(safeCell(b.NodeID)) ||
             safeCell(a.BondName).localeCompare(safeCell(b.BondName)) ||
             safeCell(a.Slave).localeCompare(safeCell(b.Slave));
    });

    return {
      matchedNodeCount: Object.keys(matchedNodeKeySet).length,
      matchedRows: matchedRows,
      errors: errors
    };
  }

  // ------------------------------
  // 5) Markdown table
  // ------------------------------
  function toMarkdownTable(alertIps, rows, errors) {
    if (!rows || rows.length === 0) {
      var msg = "✅ No interface rows matched the alert node_ip list.\n\n";
      msg += "Alert IPs (" + (alertIps ? alertIps.length : 0) + "): " + (alertIps || []).join(", ");
      return msg;
    }

    var intro =
      "### Cohesity: Interface details for IPs found in Helios alerts (1105)\n\n" +
      "Alert IPs (" + alertIps.length + "): " + alertIps.join(", ") + "\n\n";

    var cols = ["Cluster","NodeIP","NodeID","BondName","Slave","LinkState","Speed","MAC","SlotType"];
    var header = "| " + cols.join(" | ") + " |";
    var sep = "| " + cols.map(function(){return "---";}).join(" | ") + " |";

    var body = rows.map(function (r) {
      var vals = cols.map(function (c) { return safeCell(r[c]); });
      return "| " + vals.join(" | ") + " |";
    });

    var errBlock = "";
    if (errors && errors.length) {
      errBlock =
        "\n\n---\n\n### Errors\n\n" +
        errors.map(function (e, i) {
          return "- #" + (i + 1) + " **" + safeCell(e.Cluster) + "**: " + safeCell(e.Reason);
        }).join("\n");
    }

    return intro + [header, sep].concat(body).join("\n") + errBlock;
  }

  // ------------------------------
  // 6) Run
  // ------------------------------
  var alertIps = [];
  try {
    alertIps = await getAlertNodeIps();
  } catch (e) {
    var failMsg = "❌ Failed to query alerts: " + e.message;
    return {
      authMode: authMode,
      alertIpCount: 0,
      alertIps: [],
      matchedNodeCount: 0,
      matchedRowCount: 0,
      matchedRows: [],
      markdownTable: failMsg,
      markdownEmail: failMsg,
      errors: [{ Cluster: "ALERTS", Reason: e.message }]
    };
  }

  if (!alertIps.length) {
    var noIpMsg = "✅ No node_ip values found in current Helios alerts (1105 / Networking / open,note).";
    return {
      authMode: authMode,
      alertIpCount: 0,
      alertIps: [],
      matchedNodeCount: 0,
      matchedRowCount: 0,
      matchedRows: [],
      markdownTable: noIpMsg,
      markdownEmail: noIpMsg,
      errors: []
    };
  }

  var match = await collectInterfaceRowsForIps(alertIps);
  var markdown = toMarkdownTable(alertIps, match.matchedRows, match.errors);

  console.log("=== Alerts -> IPs -> Interface Details ===");
  console.log("AuthMode: " + authMode);
  console.log("Alert IP count: " + alertIps.length);
  console.log("Matched nodes: " + match.matchedNodeCount);
  console.log("Matched rows: " + match.matchedRows.length);

  // Print first 30 rows to logs
  for (var i = 0; i < Math.min(match.matchedRows.length, 30); i++) {
    var r = match.matchedRows[i];
    console.log(
      "#" + (i + 1) +
      " Cluster=" + r.Cluster +
      " NodeIP=" + r.NodeIP +
      " NodeID=" + r.NodeID +
      " Bond=" + r.BondName +
      " Slave=" + r.Slave +
      " LinkState=" + r.LinkState +
      " MAC=" + r.MAC
    );
  }
  if (match.matchedRows.length > 30) console.log("... (printed first 30 of " + match.matchedRows.length + ")");

  return {
    authMode: authMode,
    alertIpCount: alertIps.length,
    alertIps: alertIps,
    matchedNodeCount: match.matchedNodeCount,
    matchedRowCount: match.matchedRows.length,
    matchedRows: match.matchedRows,
    markdownTable: markdown,
    markdownEmail: markdown,
    errors: match.errors
  };
}
