// Cohesity Helios – Backup Failures (All Environments, per Protection Group)
// Only FAILED runs with NO later successful backup (per RunType),
// and includes Host + ObjectName (object-level) similar to your PowerShell script.
//
// Output:
// {
//   authMode: "vault-name" | "vault-id" | "manual",
//   count: <number>,
//   failures: [ { ... } ],
//   incidentText_create: "<plain text, NO FailedMessage>",
//   incidentText_update: "<plain text, WITH FailedMessage>",
//   markdownTable: "<markdown string including intro + table (NO Environment col, FULL Message)>",
//   markdownEmail: "<markdownTable>"
// }

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) Credential vault: name -> id -> manual
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  let apiKey   = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find(function (c) { return c.name === name; });
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey       = (detail && (detail.token || detail.password)) || null;
      authMode     = "vault-id";
      console.log("✓ Helios key from vault (id): " + (detail && detail.name ? detail.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey   = "PASTE_YOUR_API_KEY_HERE"; // last resort
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available (vault + manual failed).");

  const commonHeaders = { accept: "application/json", apiKey: apiKey };

  // ------------------------------
  // 2) Helpers (GET-only)
  // ------------------------------
  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers: headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  // Time in US Eastern (ET) WITHOUT appending EST/EDT in the value
  function usecsToDateString(usecs) {
    if (!usecs) return null;
    var ms = Number(usecs) / 1000; // microseconds -> ms
    if (!Number.isFinite(ms)) return null;

    return new Date(ms).toLocaleString("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    });
  }

  function cleanMessage(msg) {
    if (msg == null) return "";
    if (Array.isArray(msg)) msg = msg.join(" | ");
    msg = String(msg);
    return msg
      .replace(/[\r\n]+/g, " ")
      .replace(/,/g, " ")
      .replace(/"/g, "'")
      .trim();
  }

  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      const v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) v.forEach(function (val) { usp.append(k, String(val)); });
      else usp.append(k, String(v));
    }
    return usp.toString();
  }

  function toInfoArray(localBackupInfo) {
    if (!localBackupInfo) return [];
    if (Array.isArray(localBackupInfo)) return localBackupInfo;
    return [localBackupInfo];
  }

  // Environment maps (kept for incident text + failures array)
  const ENV_LABELS = {
    kOracle:        "Oracle",
    kSQL:           "SQL",
    kPhysical:      "Physical",
    kGenericNas:    "NAS",
    kIsilon:        "NAS",
    kHyperV:        "HyperV",
    kAcropolis:     "Acropolis",
    kRemoteAdapter: "RemoteAdapter"
  };

  const ENV_OBJECT_TYPES = {
    kOracle:        "kDatabase",
    kSQL:           "kDatabase",
    kPhysical:      "kHost",
    kGenericNas:    "kHost",
    kIsilon:        "kHost",
    kHyperV:        "kVirtualMachine",
    kAcropolis:     "kVirtualMachine",
    kRemoteAdapter: "kRemoteAdapter"
  };

  const ENV_FILTERS = {
    kOracle:        ["kOracle"],
    kSQL:           ["kSQL"],
    kPhysical:      ["kPhysical"],
    kGenericNas:    ["kGenericNas", "kIsilon"],
    kIsilon:        ["kIsilon", "kGenericNas"],
    kHyperV:        ["kHyperV"],
    kAcropolis:     ["kAcropolis"],
    kRemoteAdapter: ["kRemoteAdapter"]
  };

  function getEnvCode(pg) {
    let envRaw = pg.environment;
    if (!envRaw && Array.isArray(pg.environmentTypes) && pg.environmentTypes.length > 0) {
      envRaw = pg.environmentTypes[0];
    }
    return envRaw || null;
  }

  function mapEnvironmentLabel(envCode) {
    if (!envCode) return "Unknown";
    return ENV_LABELS[envCode] || envCode;
  }

  function isFailedStatus(status) { return status === "Failed"; }
  function isSuccessStatus(status) { return status === "Succeeded" || status === "SucceededWithWarning"; }

  // RemoteAdapter: extract host + DB name
  function extractRemoteAdapterInfo(pg) {
    var raHost = null;
    var raDB   = null;

    var ra = pg.remoteAdapterParams || {};
    var hosts = ra.hosts || ra.host || ra.hostList || null;
    var firstHost = null;

    if (Array.isArray(hosts) && hosts.length > 0) firstHost = hosts[0];
    else if (hosts && typeof hosts === "object") firstHost = hosts;

    if (firstHost) {
      raHost = firstHost.hostname || firstHost.hostName || firstHost.name || null;

      var inc =
        firstHost.incrementalBackupScript ||
        firstHost.backupScript ||
        ra.incrementalBackupScript ||
        ra.backupScript ||
        {};

      var args = inc.params || inc.arguments || inc.args || null;
      if (Array.isArray(args)) args = args.join(" ");
      if (typeof args === "string") {
        var m = args.match(/-o\s+(\S+)/i);
        if (m) raDB = m[1];
      }
    }

    return { raHost: raHost, raDB: raDB };
  }

  // ------------------------------
  // 3) Per-PG collector
  // ------------------------------
  async function collectPgFailure(clusterName, headers, pg) {
    const pgId       = pg.id;
    const pgName     = pg.name || "Unknown PG";
    const envCode    = getEnvCode(pg);
    const envLbl     = mapEnvironmentLabel(envCode);
    const targetType = ENV_OBJECT_TYPES[envCode] || null;
    const envFilter  = ENV_FILTERS[envCode] || null;
    const parentHostNeeded = (envCode === "kOracle" || envCode === "kSQL");

    var raHost = null;
    var raDB   = null;
    if (envCode === "kRemoteAdapter") {
      var raInfo = extractRemoteAdapterInfo(pg);
      raHost = raInfo.raHost;
      raDB   = raInfo.raDB;
    }

    const runQuery = buildQuery({
      numRuns: 30,
      excludeNonRestorableRuns: false,
      includeObjectDetails: true
    });

    let runData;
    try {
      runData = await getJson(
        baseUrl + "/v2/data-protect/protection-groups/" + encodeURIComponent(pgId) + "/runs?" + runQuery,
        headers
      );
    } catch (e) {
      return [];
    }

    const runs = runData.runs || [];
    if (!runs.length) return [];

    const records = [];
    for (let i = 0; i < runs.length; i++) {
      const run = runs[i];
      const infos = toInfoArray(run.localBackupInfo);
      if (!infos.length) continue;
      const info = infos[0];

      const status     = info.status || "Unknown";
      const runType    = info.runType || "";
      const startUsecs = info.startTimeUsecs || 0;
      const endUsecs   = info.endTimeUsecs || 0;

      records.push({
        status:       status,
        runType:      runType,
        startUsecs:   startUsecs,
        endUsecs:     endUsecs,
        startTimeStr: usecsToDateString(startUsecs),
        endTimeStr:   usecsToDateString(endUsecs),
        message:      cleanMessage(info.messages),
        run:          run
      });
    }

    if (!records.length) return [];

    // Group by RunType
    const byType = {};
    for (let i = 0; i < records.length; i++) {
      const rec = records[i];
      const key = rec.runType || "UNKNOWN";
      if (!byType[key]) byType[key] = [];
      byType[key].push(rec);
    }

    const typeKeys = Object.keys(byType);
    const out = [];

    for (let t = 0; t < typeKeys.length; t++) {
      const rType = typeKeys[t];
      const rows  = byType[rType];
      if (!rows.length) continue;

      rows.sort(function (a, b) { return (a.endUsecs || 0) - (b.endUsecs || 0); });

      let latestFailed = null;
      for (let i = rows.length - 1; i >= 0; i--) {
        if (isFailedStatus(rows[i].status)) { latestFailed = rows[i]; break; }
      }
      if (!latestFailed) continue;

      const failEnd = latestFailed.endUsecs || 0;

      let hasLaterSuccess = false;
      for (let i = 0; i < rows.length; i++) {
        const r = rows[i];
        if (!isSuccessStatus(r.status)) continue;
        if ((r.startUsecs || 0) > failEnd) { hasLaterSuccess = true; break; }
      }
      if (hasLaterSuccess) continue;

      // RemoteAdapter: PG-level row
      if (envCode === "kRemoteAdapter") {
        out.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            raHost,
          ObjectName:      raDB || raHost || "Unknown RemoteAdapter",
          FailedMessage:   latestFailed.message,
          StartTimeUsecs:  latestFailed.startUsecs,
          EndTimeUsecs:    latestFailed.endUsecs
        });
        continue;
      }

      // Expand objects
      const runObj  = latestFailed.run;
      const objects = (runObj && runObj.objects) ? runObj.objects : [];

      if (!objects.length) {
        out.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            null,
          ObjectName:      null,
          FailedMessage:   latestFailed.message,
          StartTimeUsecs:  latestFailed.startUsecs,
          EndTimeUsecs:    latestFailed.endUsecs
        });
        continue;
      }

      // id -> name map for parent-host resolution
      const idToName = {};
      for (let oi = 0; oi < objects.length; oi++) {
        const ob  = objects[oi];
        const obj = ob && ob.object ? ob.object : null;
        if (obj && obj.id != null && obj.name) idToName[String(obj.id)] = obj.name;
      }

      const envSet         = envFilter;
      const hasTargetType  = !!targetType;
      const rowsForRunType = [];

      // Host-level rows for Oracle/SQL
      if (parentHostNeeded) {
        for (let oi = 0; oi < objects.length; oi++) {
          const ob  = objects[oi];
          const obj = ob && ob.object ? ob.object : {};
          const isHostObj = (obj.objectType === "kHost") || (obj.environment === "kPhysical");
          if (!isHostObj) continue;

          const lsi            = ob.localSnapshotInfo || {};
          const failedAttempts = lsi.failedAttempts || [];
          if (!failedAttempts.length) continue;

          let msgCombined = "";
          for (let fi = 0; fi < failedAttempts.length; fi++) {
            const part = cleanMessage(failedAttempts[fi] && failedAttempts[fi].message);
            if (!part) continue;
            msgCombined = msgCombined ? (msgCombined + " | " + part) : part;
          }
          if (!msgCombined) continue;

          rowsForRunType.push({
            Environment:     envLbl,
            Cluster:         clusterName,
            ProtectionGroup: pgName,
            RunType:         rType,
            StartTime:       latestFailed.startTimeStr,
            EndTime:         latestFailed.endTimeStr,
            Status:          latestFailed.status,
            Host:            obj.name || null,
            ObjectName:      "No DBs Found (Host-Level Failure)",
            FailedMessage:   msgCombined,
            StartTimeUsecs:  latestFailed.startUsecs,
            EndTimeUsecs:    latestFailed.endUsecs
          });
        }
      }

      // Object-level rows
      for (let oi = 0; oi < objects.length; oi++) {
        const ob  = objects[oi];
        const obj = ob && ob.object ? ob.object : {};

        if (hasTargetType && obj.objectType !== targetType) continue;
        if (envSet && obj.environment && envSet.indexOf(obj.environment) === -1) continue;

        const lsi            = ob.localSnapshotInfo || {};
        const failedAttempts = lsi.failedAttempts || [];
        if (!failedAttempts.length) continue;

        let msgCombined = "";
        for (let fi = 0; fi < failedAttempts.length; fi++) {
          const part = cleanMessage(failedAttempts[fi] && failedAttempts[fi].message);
          if (!part) continue;
          msgCombined = msgCombined ? (msgCombined + " | " + part) : part;
        }
        if (!msgCombined) continue;

        let hostName = null;
        if (parentHostNeeded && obj.sourceId != null) {
          const sid = String(obj.sourceId);
          if (idToName[sid]) hostName = idToName[sid];
        }

        rowsForRunType.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            hostName,
          ObjectName:      obj.name || null,
          FailedMessage:   msgCombined,
          StartTimeUsecs:  latestFailed.startUsecs,
          EndTimeUsecs:    latestFailed.endUsecs
        });
      }

      if (rowsForRunType.length === 0) {
        out.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            null,
          ObjectName:      null,
          FailedMessage:   latestFailed.message,
          StartTimeUsecs:  latestFailed.startUsecs,
          EndTimeUsecs:    latestFailed.endUsecs
        });
      } else {
        for (let i = 0; i < rowsForRunType.length; i++) out.push(rowsForRunType[i]);
      }
    }

    return out;
  }

  // ------------------------------
  // 4) Per-cluster collector
  // ------------------------------
  async function collectClusterFailures(cluster) {
    const clusterName =
      cluster.name || cluster.clusterName || cluster.displayName || ("Unknown-" + cluster.clusterId);

    const headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: String(cluster.clusterId)
    };

    const pgQuery = buildQuery({ isDeleted: false, isPaused: false, isActive: true });

    let pgData;
    try {
      pgData = await getJson(baseUrl + "/v2/data-protect/protection-groups?" + pgQuery, headers);
    } catch (e) {
      return [];
    }

    const pgs = pgData.protectionGroups || [];
    if (!pgs.length) return [];

    const pgPromises = pgs.map(function (pg) { return collectPgFailure(clusterName, headers, pg); });
    const results = await Promise.all(pgPromises);

    const allRows = [];
    for (let i = 0; i < results.length; i++) {
      const arr = results[i];
      if (arr && arr.length) for (let j = 0; j < arr.length; j++) allRows.push(arr[j]);
    }
    return allRows;
  }

  // ------------------------------
  // 5) Collect all clusters, flatten, sort
  // ------------------------------
  async function collectAllFailures() {
    const clusterData = await getJson(baseUrl + "/v2/mcm/cluster-mgmt/info", commonHeaders);
    const clusters = clusterData.cohesityClusters || [];
    if (!clusters.length) return [];

    const clusterPromises = clusters.map(function (cluster) { return collectClusterFailures(cluster); });
    const clusterResults = await Promise.all(clusterPromises);

    const allRows = [];
    for (let i = 0; i < clusterResults.length; i++) {
      const arr = clusterResults[i];
      if (arr && arr.length) for (let j = 0; j < arr.length; j++) allRows.push(arr[j]);
    }

    // Sort by end time (usecs) desc
    allRows.sort(function (a, b) {
      return (b.EndTimeUsecs || 0) - (a.EndTimeUsecs || 0);
    });

    return allRows;
  }

  // ------------------------------
  // 6) Incident text (create/update)
  // ------------------------------
  function toIncidentTextCreate(rows) {
    if (!rows || rows.length === 0) return "✅ No FAILED backup runs without a later successful run.";

    const lines = [];
    lines.push("=== Backup Failures Without a Later Successful Run ===");
    lines.push("Count: " + rows.length);
    lines.push("");

    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];
      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${r.ObjectName || "-"} | Start(ET)=${r.StartTime || "-"} | End(ET)=${r.EndTime || "-"}`
      );
    }
    return lines.join("\n");
  }

  function toIncidentTextUpdate(rows) {
    if (!rows || rows.length === 0) return "✅ No FAILED backup runs without a later successful run.";

    const lines = [];
    lines.push("=== Backup Failures Without a Later Successful Run ===");
    lines.push("Count: " + rows.length);
    lines.push("");

    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];
      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${r.ObjectName || "-"} | Start(ET)=${r.StartTime || "-"} | End(ET)=${r.EndTime || "-"}`
      );
      if (r.FailedMessage) lines.push("    Message: " + String(r.FailedMessage));
      lines.push("");
    }
    return lines.join("\n");
  }

  // ------------------------------
  // 7) Email markdown table (NO Environment col, FULL Message)
  // ------------------------------
  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) {
      return "✅ No FAILED backup runs without a later successful run.";
    }

    // Markdown tables break if cells contain '|'
    function safeCell(v) {
      if (v == null) return "";
      return String(v).replace(/\|/g, " ");
    }

    const headerLabels = [
      "Cluster",
      "ProtectionGroup",
      "Host",
      "ObjectName",
      "RunType",
      "StartTime ET",
      "EndTime ET",
      "Message"
    ];

    const headerRow = "| " + headerLabels.join(" | ") + " |";
    const separator = "| " + headerLabels.map(function () { return "---"; }).join(" | ") + " |";

    const bodyRows = rows.map(function (r) {
      const vals = [
        safeCell(r.Cluster),
        safeCell(r.ProtectionGroup),
        safeCell(r.Host),
        safeCell(r.ObjectName),
        safeCell(r.RunType),
        safeCell(r.StartTime),
        safeCell(r.EndTime),
        safeCell(r.FailedMessage)
      ];
      return "| " + vals.join(" | ") + " |";
    });

    const introLines = [
      "### Backup failures without a latest successful run",
      "",
      "_Scope: last 30 runs per Protection Group / RunType. Only **FAILED** runs that have **no later** Succeeded/SucceededWithWarning run are shown._",
      ""
    ];

    return introLines.join("\n") + "\n" + [headerRow, separator].concat(bodyRows).join("\n");
  }

  // ------------------------------
  // 8) Run + return
  // ------------------------------
  const failures = await collectAllFailures();
  const markdownTable = toMarkdownTable(failures);

  return {
    authMode: authMode,
    count: failures.length,
    failures: failures,
    incidentText_create: toIncidentTextCreate(failures),
    incidentText_update: toIncidentTextUpdate(failures),
    markdownTable: markdownTable,
    markdownEmail: markdownTable
  };
}


function executionTimeET() {
  return new Date().toLocaleString("en-US", {
    timeZone: "America/New_York",
    weekday: "short",
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
}
