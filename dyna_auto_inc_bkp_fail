// Cohesity Helios – Backup Failures (All Environments, per Protection Group)
// Only FAILED runs with NO later successful backup (per RunType),
// includes Host + ObjectName (object-level).
//
// - Uses Dynatrace classic credential vault (name -> id -> manual)
// - All Helios calls are HTTP GET
//
// Output:
// {
//   authMode: "vault-name" | "vault-id" | "manual",
//   count: <number>,
//   failures: [ { ... } ],
//   incidentText_create: "<plain text FULL list, NO FailedMessage>",
//   incidentText_update: "<plain text FULL list, WITH FailedMessage>",
//   markdownTable: "<markdown table for email (WITH FailedMessage)>"
// }

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) Credential vault: name -> id -> manual
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  let apiKey   = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find(function (c) { return c.name === name; });
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey       = (detail && (detail.token || detail.password)) || null;
      authMode     = "vault-id";
      console.log("✓ Helios key from vault (id): " + (detail && detail.name ? detail.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey   = "PASTE_YOUR_API_KEY_HERE"; // last resort, still GET-only
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available (vault + manual failed).");

  const commonHeaders = { accept: "application/json", apiKey: apiKey };

  // ------------------------------
  // 2) Helpers
  // ------------------------------
  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers: headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function usecsToIso(usecs) {
    if (!usecs) return null;
    const ms = Number(usecs) / 1000; // microseconds -> ms
    if (!Number.isFinite(ms)) return null;
    return new Date(ms).toISOString();
  }

  function cleanMessage(msg) {
    if (msg == null) return "";
    if (Array.isArray(msg)) msg = msg.join(" | ");
    msg = String(msg);
    return msg.replace(/[\r\n]+/g, " ").replace(/,/g, " ").replace(/"/g, "'").trim();
  }

  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      const v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) v.forEach(function (val) { usp.append(k, String(val)); });
      else usp.append(k, String(v));
    }
    return usp.toString();
  }

  function toInfoArray(localBackupInfo) {
    if (!localBackupInfo) return [];
    if (Array.isArray(localBackupInfo)) return localBackupInfo;
    return [localBackupInfo];
  }

  const ENV_LABELS = {
    kOracle:        "Oracle",
    kSQL:           "SQL",
    kPhysical:      "Physical",
    kGenericNas:    "NAS",
    kIsilon:        "NAS",
    kHyperV:        "HyperV",
    kAcropolis:     "Acropolis",
    kRemoteAdapter: "RemoteAdapter"
  };

  const ENV_OBJECT_TYPES = {
    kOracle:        "kDatabase",
    kSQL:           "kDatabase",
    kPhysical:      "kHost",
    kGenericNas:    "kHost",
    kIsilon:        "kHost",
    kHyperV:        "kVirtualMachine",
    kAcropolis:     "kVirtualMachine",
    kRemoteAdapter: "kRemoteAdapter"
  };

  const ENV_FILTERS = {
    kOracle:        ["kOracle"],
    kSQL:           ["kSQL"],
    kPhysical:      ["kPhysical"],
    kGenericNas:    ["kGenericNas", "kIsilon"],
    kIsilon:        ["kIsilon", "kGenericNas"],
    kHyperV:        ["kHyperV"],
    kAcropolis:     ["kAcropolis"],
    kRemoteAdapter: ["kRemoteAdapter"]
  };

  function getEnvCode(pg) {
    let envRaw = pg.environment;
    if (!envRaw && Array.isArray(pg.environmentTypes) && pg.environmentTypes.length > 0) {
      envRaw = pg.environmentTypes[0];
    }
    return envRaw || null;
  }

  function mapEnvironmentLabel(envCode) {
    if (!envCode) return "Unknown";
    return ENV_LABELS[envCode] || envCode;
  }

  function isFailedStatus(status) { return status === "Failed"; }

  function isSuccessStatus(status) {
    return status === "Succeeded" || status === "SucceededWithWarning";
  }

  // ------------------------------
  // 3) Per-PG collector (RunType-based)
  // ------------------------------
  async function collectPgFailure(clusterName, headers, pg) {
    const pgId       = pg.id;
    const pgName     = pg.name || "Unknown PG";
    const envCode    = getEnvCode(pg);
    const envLbl     = mapEnvironmentLabel(envCode);
    const targetType = ENV_OBJECT_TYPES[envCode] || null;
    const envFilter  = ENV_FILTERS[envCode] || null;
    const parentHostNeeded = (envCode === "kOracle" || envCode === "kSQL");

    // RemoteAdapter params
    let raHost = null;
    let raDB   = null;
    if (envCode === "kRemoteAdapter") {
      try {
        const hosts  = (pg.remoteAdapterParams && pg.remoteAdapterParams.hosts) || {};
        let hostname = hosts.hostname;
        if (Array.isArray(hostname)) hostname = hostname.join(",");
        raHost = hostname || null;

        let args = hosts.incrementalBackupScript && hosts.incrementalBackupScript.params;
        if (Array.isArray(args)) args = args.join(" ");
        if (typeof args === "string") {
          const m = args.match(/-o\s+(\S+)/);
          if (m) raDB = m[1];
        }
      } catch (eRA) {}
    }

    const runQuery = buildQuery({
      numRuns: 30,
      excludeNonRestorableRuns: false,
      includeObjectDetails: true
    });

    let runData;
    try {
      runData = await getJson(
        baseUrl + "/v2/data-protect/protection-groups/" + encodeURIComponent(pgId) + "/runs?" + runQuery,
        headers
      );
    } catch (e) {
      return [];
    }

    const runs = runData.runs || [];
    if (!runs.length) return [];

    const records = [];
    for (let i = 0; i < runs.length; i++) {
      const run = runs[i];
      const infos = toInfoArray(run.localBackupInfo);
      if (!infos.length) continue;
      const info = infos[0];

      const status     = info.status || "Unknown";
      const runType    = info.runType || "";
      const startUsecs = info.startTimeUsecs || 0;
      const endUsecs   = info.endTimeUsecs || 0;

      records.push({
        status:       status,
        runType:      runType,
        startUsecs:   startUsecs,
        endUsecs:     endUsecs,
        startTimeStr: usecsToIso(startUsecs),
        endTimeStr:   usecsToIso(endUsecs),
        message:      cleanMessage(info.messages),
        run:          run
      });
    }
    if (!records.length) return [];

    const byType = {};
    for (let i = 0; i < records.length; i++) {
      const rec = records[i];
      const key = rec.runType || "UNKNOWN";
      if (!byType[key]) byType[key] = [];
      byType[key].push(rec);
    }

    const out = [];
    const typeKeys = Object.keys(byType);

    for (let t = 0; t < typeKeys.length; t++) {
      const rType = typeKeys[t];
      const rows  = byType[rType];
      if (!rows.length) continue;

      rows.sort(function (a, b) { return (a.endUsecs || 0) - (b.endUsecs || 0); });

      let latestFailed = null;
      for (let i = rows.length - 1; i >= 0; i--) {
        if (isFailedStatus(rows[i].status)) { latestFailed = rows[i]; break; }
      }
      if (!latestFailed) continue;

      const failEnd = latestFailed.endUsecs || 0;

      let hasLaterSuccess = false;
      for (let i = 0; i < rows.length; i++) {
        const r = rows[i];
        if (!isSuccessStatus(r.status)) continue;
        if ((r.startUsecs || 0) > failEnd) { hasLaterSuccess = true; break; }
      }
      if (hasLaterSuccess) continue;

      if (envCode === "kRemoteAdapter") {
        out.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            null,
          ObjectName:      raDB || raHost || null,
          FailedMessage:   latestFailed.message
        });
        continue;
      }

      const runObj  = latestFailed.run;
      const objects = (runObj && runObj.objects) ? runObj.objects : [];

      if (!objects.length) {
        out.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            null,
          ObjectName:      null,
          FailedMessage:   latestFailed.message
        });
        continue;
      }

      const idToName = {};
      for (let oi = 0; oi < objects.length; oi++) {
        const ob  = objects[oi];
        const obj = ob && ob.object ? ob.object : null;
        if (obj && obj.id != null && obj.name) idToName[String(obj.id)] = obj.name;
      }

      const envSet = envFilter;
      const hasTargetType = !!targetType;

      const rowsForRunType = [];

      if (parentHostNeeded) {
        for (let oi = 0; oi < objects.length; oi++) {
          const ob  = objects[oi];
          const obj = ob && ob.object ? ob.object : {};
          const isHostObj = (obj.objectType === "kHost") || (obj.environment === "kPhysical");
          if (!isHostObj) continue;

          const lsi            = ob.localSnapshotInfo || {};
          const failedAttempts = lsi.failedAttempts || [];
          if (!failedAttempts.length) continue;

          let msgCombined = "";
          for (let fi = 0; fi < failedAttempts.length; fi++) {
            const part = cleanMessage(failedAttempts[fi] && failedAttempts[fi].message);
            if (!part) continue;
            msgCombined = msgCombined ? (msgCombined + " | " + part) : part;
          }
          if (!msgCombined) continue;

          rowsForRunType.push({
            Environment:     envLbl,
            Cluster:         clusterName,
            ProtectionGroup: pgName,
            RunType:         rType,
            StartTime:       latestFailed.startTimeStr,
            EndTime:         latestFailed.endTimeStr,
            Status:          latestFailed.status,
            Host:            obj.name || null,
            ObjectName:      "No DBs Found (Host-Level Failure)",
            FailedMessage:   msgCombined
          });
        }
      }

      for (let oi = 0; oi < objects.length; oi++) {
        const ob  = objects[oi];
        const obj = ob && ob.object ? ob.object : {};

        if (hasTargetType && obj.objectType !== targetType) continue;
        if (envSet && obj.environment && envSet.indexOf(obj.environment) === -1) continue;

        const lsi            = ob.localSnapshotInfo || {};
        const failedAttempts = lsi.failedAttempts || [];
        if (!failedAttempts.length) continue;

        let msgCombined = "";
        for (let fi = 0; fi < failedAttempts.length; fi++) {
          const part = cleanMessage(failedAttempts[fi] && failedAttempts[fi].message);
          if (!part) continue;
          msgCombined = msgCombined ? (msgCombined + " | " + part) : part;
        }
        if (!msgCombined) continue;

        let hostName = null;
        if (parentHostNeeded && obj.sourceId != null) {
          const sid = String(obj.sourceId);
          if (idToName[sid]) hostName = idToName[sid];
        }

        rowsForRunType.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            hostName,
          ObjectName:      obj.name || null,
          FailedMessage:   msgCombined
        });
      }

      if (rowsForRunType.length === 0) {
        out.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            null,
          ObjectName:      null,
          FailedMessage:   latestFailed.message
        });
      } else {
        for (let i = 0; i < rowsForRunType.length; i++) out.push(rowsForRunType[i]);
      }
    }

    return out;
  }

  // ------------------------------
  // 4) Per-cluster collector
  // ------------------------------
  async function collectClusterFailures(cluster) {
    const clusterName =
      cluster.name || cluster.clusterName || cluster.displayName || ("Unknown-" + cluster.clusterId);

    const headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: String(cluster.clusterId)
    };

    const pgQuery = buildQuery({ isDeleted: false, isPaused: false, isActive: true });

    let pgData;
    try {
      pgData = await getJson(baseUrl + "/v2/data-protect/protection-groups?" + pgQuery, headers);
    } catch (e) {
      return [];
    }

    const pgs = pgData.protectionGroups || [];
    if (!pgs.length) return [];

    const pgPromises = pgs.map(function (pg) { return collectPgFailure(clusterName, headers, pg); });
    const results = await Promise.all(pgPromises);

    const allRows = [];
    for (let i = 0; i < results.length; i++) {
      const arr = results[i];
      if (arr && arr.length) for (let j = 0; j < arr.length; j++) allRows.push(arr[j]);
    }
    return allRows;
  }

  // ------------------------------
  // 5) All clusters
  // ------------------------------
  async function collectAllFailures() {
    const clusterData = await getJson(baseUrl + "/v2/mcm/cluster-mgmt/info", commonHeaders);
    const clusters = clusterData.cohesityClusters || [];
    if (!clusters.length) return [];

    const clusterPromises = clusters.map(function (cluster) { return collectClusterFailures(cluster); });
    const clusterResults = await Promise.all(clusterPromises);

    const allRows = [];
    for (let i = 0; i < clusterResults.length; i++) {
      const arr = clusterResults[i];
      if (arr && arr.length) for (let j = 0; j < arr.length; j++) allRows.push(arr[j]);
    }

    allRows.sort(function (a, b) {
      const c1 = (a.Cluster || "").localeCompare(b.Cluster || "");
      if (c1 !== 0) return c1;
      const c2 = (a.Environment || "").localeCompare(b.Environment || "");
      if (c2 !== 0) return c2;
      const c3 = (a.ProtectionGroup || "").localeCompare(b.ProtectionGroup || "");
      if (c3 !== 0) return c3;
      const c4 = (a.Host || "").localeCompare(b.Host || "");
      if (c4 !== 0) return c4;
      const c5 = (a.ObjectName || "").localeCompare(b.ObjectName || "");
      if (c5 !== 0) return c5;
      const tA = a.EndTime ? new Date(a.EndTime).getTime() : 0;
      const tB = b.EndTime ? new Date(b.EndTime).getTime() : 0;
      return tB - tA;
    });

    return allRows;
  }

  // ------------------------------
  // 6) Incident text builders
  // ------------------------------
  function toIncidentTextCreate(rows) {
    if (!rows || rows.length === 0) {
      return "✅ No FAILED backup runs without a later successful run.";
    }

    const lines = [];
    lines.push(`❌ Cohesity backup failures (no later success): ${rows.length}`);
    lines.push("");

    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];
      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${r.ObjectName || "-"} | Start=${r.StartTime || "-"} | End=${r.EndTime || "-"} | ` +
        `Status=${r.Status || "-"}`
      );
    }

    return lines.join("\n");
  }

  function toIncidentTextUpdate(rows) {
    if (!rows || rows.length === 0) {
      return "✅ No FAILED backup runs without a later successful run.";
    }

    const lines = [];
    lines.push(`❌ Cohesity backup failures (no later success): ${rows.length}`);
    lines.push("");

    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];

      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${r.ObjectName || "-"} | Start=${r.StartTime || "-"} | End=${r.EndTime || "-"} | ` +
        `Status=${r.Status || "-"}`
      );

      if (r.FailedMessage) {
        lines.push(`    Message: ${String(r.FailedMessage).replace(/[\r\n]+/g, " ").trim()}`);
      }

      lines.push("");
    }

    return lines.join("\n");
  }

  // ------------------------------
  // 7) Markdown table for email
  // ------------------------------
  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) {
      return "✅ No FAILED backup runs without a later successful run.";
    }

    const headers = [
      "Environment",
      "Cluster",
      "ProtectionGroup",
      "Host",
      "ObjectName",
      "RunType",
      "StartTime",
      "EndTime",
      "Status",
      "FailedMessage"
    ];

    const headerRow = "| " + headers.join(" | ") + " |";
    const separator = "| " + headers.map(function () { return "---"; }).join(" | ") + " |";

    const bodyRows = rows.map(function (r) {
      const vals = headers.map(function (h) {
        const v = r[h] != null ? r[h] : "";
        const s = String(v);
        return s.length > 300 ? s.slice(0, 297) + "..." : s;
      });
      return "| " + vals.join(" | ") + " |";
    });

    return [headerRow, separator].concat(bodyRows).join("\n");
  }

  // ------------------------------
  // 8) Run + return
  // ------------------------------
  const failures      = await collectAllFailures();
  const markdownTable = toMarkdownTable(failures);

  const incidentText_create = toIncidentTextCreate(failures);
  const incidentText_update = toIncidentTextUpdate(failures);

  return {
    authMode: authMode,
    count: failures.length,
    failures: failures,
    incidentText_create: incidentText_create,
    incidentText_update: incidentText_update,
    markdownTable: markdownTable
  };
}
