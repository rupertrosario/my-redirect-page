// Cohesity Helios – Combined Backup Failures (All Environments, per Protection Group)
// - Dynatrace classic credential vault (name -> id -> manual)
// - READ-ONLY: Helios is accessed with HTTP GET only
// - Performance-optimized: per-PG latest run only, parallelized per cluster & PG
//
// Output:
// {
//   authMode: "vault-name" | "vault-id" | "manual",
//   count: <number>,
//   failures: [
//     {
//       Environment,
//       Cluster,
//       ProtectionGroup,
//       RunType,
//       StartTime,
//       EndTime,
//       Status,
//       FailedMessage
//     }
//   ],
//   markdownTable: "<markdown table string>"
// }

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) Credential vault: name -> id -> manual (same pattern as your capacity script)
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  let apiKey   = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find(c => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log(`✓ Helios key from vault (name): ${found.name}`);
    return detail?.token || detail?.password || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey       = detail?.token || detail?.password || null;
      authMode     = "vault-id";
      console.log(`✓ Helios key from vault (id): ${detail?.name || vaultId}`);
    } catch {
      authMode = "manual";
      apiKey   = "PASTE_YOUR_API_KEY_HERE";  // last resort, still GET-only
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) {
    throw new Error("No Helios API key available (vault + manual failed).");
  }

  const commonHeaders = { accept: "application/json", apiKey };

  // ------------------------------
  // 2) Helpers (all GET, no writes)
  // ------------------------------
  async function getJson(url, headers = {}) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  function usecsToDateString(usecs) {
    if (!usecs) return null;
    const ms = Number(usecs) / 1000;  // microseconds -> ms
    if (!Number.isFinite(ms)) return null;
    return new Date(ms).toISOString();
  }

  function cleanMessage(msg) {
    if (msg == null) return "";
    if (Array.isArray(msg)) msg = msg.join(" | ");
    msg = String(msg);
    return msg.replace(/[\r\n]+/g, " ").replace(/,/g, " ").replace(/"/g, "'").trim();
  }

  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const [k, v] of Object.entries(params)) {
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) {
        v.forEach(val => usp.append(k, String(val)));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  function toInfoArray(localBackupInfo) {
    if (!localBackupInfo) return [];
    return Array.isArray(localBackupInfo) ? localBackupInfo : [localBackupInfo];
  }

  const ENV_LABELS = {
    kOracle:        "Oracle",
    kSQL:           "SQL",
    kPhysical:      "Physical",
    kGenericNas:    "NAS",
    kIsilon:        "NAS",
    kHyperV:        "HyperV",
    kAcropolis:     "Acropolis",
    kRemoteAdapter: "RemoteAdapter"
  };

  function mapEnvironment(pg) {
    let envRaw = pg.environment;
    if (!envRaw && Array.isArray(pg.environmentTypes) && pg.environmentTypes.length > 0) {
      envRaw = pg.environmentTypes[0];
    }
    if (!envRaw) return "Unknown";
    return ENV_LABELS[envRaw] || envRaw;
  }

  // ------------------------------
  // 3) Per-PG failure collector (fast, latest run only)
  // ------------------------------
  async function collectPgFailure(clusterName, headers, pg) {
    const pgId   = pg.id;
    const pgName = pg.name || "Unknown PG";
    const envLbl = mapEnvironment(pg);

    // Only latest run; no object details = smaller payload
    const runQuery = buildQuery({
      numRuns: 1,
      excludeNonRestorableRuns: false,
      includeObjectDetails: false
    });

    let runData;
    try {
      runData = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs?${runQuery}`,
        headers
      );
    } catch {
      // Fail quietly per PG; we don't want one bad PG to kill the whole report
      return [];
    }

    const runs = runData.runs || [];
    if (!runs.length) return [];

    const run = runs[0]; // numRuns=1 → latest
    const infoArr = toInfoArray(run.localBackupInfo);
    if (!infoArr.length) return [];

    const info   = infoArr[0];
    const status = info.status || "Unknown";
    const runType = info.runType || "";

    // Only report failures (anything not Succeeded / SucceededWithWarning)
    if (status === "Succeeded" || status === "SucceededWithWarning") return [];

    const startTimeStr = usecsToDateString(info.startTimeUsecs || 0);
    const endTimeStr   = usecsToDateString(info.endTimeUsecs || 0);
    const msg          = cleanMessage(info.messages);

    return [{
      Environment:     envLbl,
      Cluster:         clusterName,
      ProtectionGroup: pgName,
      RunType:         runType,
      StartTime:       startTimeStr,
      EndTime:         endTimeStr,
      Status:          status,
      FailedMessage:   msg
    }];
  }

  // ------------------------------
  // 4) Per-cluster collector (parallel over PGs)
  // ------------------------------
  async function collectClusterFailures(cluster) {
    const clusterName =
      cluster.name ||
      cluster.clusterName ||
      cluster.displayName ||
      `Unknown-${cluster.clusterId}`;

    const headers = { ...commonHeaders, accessClusterId: String(cluster.clusterId) };

    const pgQuery = buildQuery({
      isDeleted: false,
      isPaused: false,
      isActive: true
    });

    let pgData;
    try {
      pgData = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups?${pgQuery}`,
        headers
      );
    } catch {
      return [];
    }

    const pgs = pgData.protectionGroups || [];
    if (!pgs.length) return [];

    // Parallelize PG-level /runs calls for speed
    const pgPromises = pgs.map(pg => collectPgFailure(clusterName, headers, pg));
    const results = await Promise.all(pgPromises);

    const allRows = [];
    for (const arr of results) {
      if (arr && arr.length) allRows.push(...arr);
    }
    return allRows;
  }

  // ------------------------------
  // 5) Collect all clusters, flatten, sort
  // ------------------------------
  async function collectAllFailures() {
    const clusterData = await getJson(
      `${baseUrl}/v2/mcm/cluster-mgmt/info`,
      commonHeaders
    );
    const clusters = clusterData.cohesityClusters || [];
    if (!clusters.length) return [];

    // Parallelize per-cluster collection as well
    const clusterPromises = clusters.map(cluster => collectClusterFailures(cluster));
    const clusterResults  = await Promise.all(clusterPromises);

    const allRows = [];
    for (const arr of clusterResults) {
      if (arr && arr.length) allRows.push(...arr);
    }

    // Sort: Cluster, Environment, ProtectionGroup, EndTime (latest first)
    allRows.sort((a, b) => {
      const c1 = (a.Cluster || "").localeCompare(b.Cluster || "");
      if (c1 !== 0) return c1;
      const c2 = (a.Environment || "").localeCompare(b.Environment || "");
      if (c2 !== 0) return c2;
      const c3 = (a.ProtectionGroup || "").localeCompare(b.ProtectionGroup || "");
      if (c3 !== 0) return c3;
      const tA = a.EndTime ? new Date(a.EndTime).getTime() : 0;
      const tB = b.EndTime ? new Date(b.EndTime).getTime() : 0;
      return tB - tA;
    });

    return allRows;
  }

  // ------------------------------
  // 6) Markdown table for email
  // ------------------------------
  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) {
      return "✅ No backup failures found in the selected scope.";
    }

    const headers = [
      "Environment",
      "Cluster",
      "ProtectionGroup",
      "RunType",
      "StartTime",
      "EndTime",
      "Status",
      "FailedMessage"
    ];

    const headerRow = `| ${headers.join(" | ")} |`;
    const separator = `| ${headers.map(() => "---").join(" | ")} |`;

    const bodyRows = rows.map(r => {
      const vals = headers.map(h => {
        const v = r[h] ?? "";
        const s = String(v);
        return s.length > 300 ? s.slice(0, 297) + "..." : s;
      });
      return `| ${vals.join(" | ")} |`;
    });

    return [headerRow, separator, ...bodyRows].join("\n");
  }

  // ------------------------------
  // 7) Run + return consolidated output
  // ------------------------------
  const failures      = await collectAllFailures();
  const markdownTable = toMarkdownTable(failures);

  return {
    authMode,
    count: failures.length,
    failures,
    markdownTable
  };
}
