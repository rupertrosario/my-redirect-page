// Cohesity Helios — Backup Failures (FORMATTER) — SPLIT #2 (NO SNOW)
// Input expected: cohesityPayload = output object from Script #1
//
// Output (exact style like your picture):
// return {
//   authMode: authMode,
//   count: failures.length,
//   failures: failures,
//   incidentText_create: ...,
//   incidentText_update: ...,
//   markdownTable: markdownTable,
//   markdownEmail: markdownTable
// };

export default async function ({ cohesityPayload }) {
  const p = cohesityPayload || {};
  const authMode = p.authMode || "unknown";
  const failures = Array.isArray(p.failures) ? p.failures : [];

  function safeCell(v) {
    if (v == null) return "";
    return String(v).replace(/\|/g, " ").replace(/[\r\n]+/g, " ").trim();
  }

  function toIncidentTextCreate(rows) {
    if (!rows || rows.length === 0) return "✅ No FAILED backup objects without a later successful run (last 10 runs scope).";
    const lines = [];
    lines.push("=== Backup Failures (Latest Uncleared Only) ===");
    lines.push("Count: " + rows.length);
    lines.push("");
    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];
      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${r.ObjectName || "-"} | End(ET)=${r.EndTime || "-"}`
      );
    }
    return lines.join("\n");
  }

  function toIncidentTextUpdate(rows) {
    if (!rows || rows.length === 0) return "✅ No FAILED backup objects without a later successful run (last 10 runs scope).";
    const lines = [];
    lines.push("=== Backup Failures (Latest Uncleared Only) ===");
    lines.push("Count: " + rows.length);
    lines.push("");
    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];
      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${r.ObjectName || "-"} | End(ET)=${r.EndTime || "-"}`
      );
      if (r.FailedMessage) lines.push("    Message: " + String(r.FailedMessage));
      lines.push("");
    }
    return lines.join("\n");
  }

  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) {
      return "✅ No FAILED backup objects without a later successful run (last 10 runs scope).";
    }

    const headerLabels = [
      "Cluster",
      "ProtectionGroup",
      "Host",
      "ObjectName",
      "RunType",
      "StartTime ET",
      "EndTime ET",
      "FailedMessage"
    ];

    const headerRow = "| " + headerLabels.join(" | ") + " |";
    const separator = "| " + headerLabels.map(() => "---").join(" | ") + " |";

    const bodyRows = rows.map((r) => {
      const vals = [
        safeCell(r.Cluster),
        safeCell(r.ProtectionGroup),
        safeCell(r.Host),
        safeCell(r.ObjectName),
        safeCell(r.RunType),
        safeCell(r.StartTime),
        safeCell(r.EndTime),
        safeCell(r.FailedMessage)
      ];
      return "| " + vals.join(" | ") + " |";
    });

    const introLines = [
      "### Backup failures without a latest successful run",
      "",
      //"_Scope: last 10 runs per Protection Group / RunType. Only FAILED objects with no later success within those 10 runs are shown._",
      ""
    ];

    return introLines.join("\n") + "\n" + [headerRow, separator].concat(bodyRows).join("\n");
  }

  const markdownTable = toMarkdownTable(failures);

  return {
    authMode: authMode,
    count: failures.length,
    failures: failures,
    incidentText_create: toIncidentTextCreate(failures),
    incidentText_update: toIncidentTextUpdate(failures),
    markdownTable: markdownTable,
    markdownEmail: markdownTable
  };
}
