// Cohesity Helios – Backup Failures (All Environments, per Protection Group)
// Only FAILED runs with NO later successful backup (per RunType),
// and includes Host + ObjectName (object-level) similar to your PowerShell script.
//
// - Uses Dynatrace classic credential vault (name -> id -> manual)
// - All Helios calls are HTTP GET
// - Per Protection Group + RunType, expanded to objects
//
// Output:
// {
//   authMode: "vault-name" | "vault-id" | "manual",
//   count: <number>,
//   failures: [
//     {
//       Environment,
//       Cluster,
//       ProtectionGroup,
//       RunType,
//       StartTime,
//       EndTime,
//       Status,
//       Host,
//       ObjectName,
//       FailedMessage
//     }
//   ],
//   markdownTable: "<markdown table string>"
// }

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) Credential vault: name -> id -> manual
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  let apiKey   = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find(function (c) { return c.name === name; });
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey       = (detail && (detail.token || detail.password)) || null;
      authMode     = "vault-id";
      console.log("✓ Helios key from vault (id): " + (detail && detail.name ? detail.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey   = "PASTE_YOUR_API_KEY_HERE";  // last resort, still GET-only
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) {
    throw new Error("No Helios API key available (vault + manual failed).");
  }

  const commonHeaders = { accept: "application/json", apiKey: apiKey };

  // ------------------------------
  // 2) Helpers (GET-only)
  // ------------------------------
  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers: headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function usecsToDateString(usecs) {
    if (!usecs) return null;
    const ms = Number(usecs) / 1000;  // microseconds -> ms
    if (!Number.isFinite(ms)) return null;
    return new Date(ms).toISOString();
  }

  function cleanMessage(msg) {
    if (msg == null) return "";
    if (Array.isArray(msg)) msg = msg.join(" | ");
    msg = String(msg);
    return msg.replace(/[\r\n]+/g, " ").replace(/,/g, " ").replace(/"/g, "'").trim();
  }

  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      const v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) {
        v.forEach(function (val) { usp.append(k, String(val)); });
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  function toInfoArray(localBackupInfo) {
    if (!localBackupInfo) return [];
    if (Array.isArray(localBackupInfo)) return localBackupInfo;
    return [localBackupInfo];
  }

  // Environment maps
  const ENV_LABELS = {
    kOracle:        "Oracle",
    kSQL:           "SQL",
    kPhysical:      "Physical",
    kGenericNas:    "NAS",
    kIsilon:        "NAS",
    kHyperV:        "HyperV",
    kAcropolis:     "Acropolis",
    kRemoteAdapter: "RemoteAdapter"
  };

  const ENV_OBJECT_TYPES = {
    kOracle:        "kDatabase",
    kSQL:           "kDatabase",
    kPhysical:      "kHost",
    kGenericNas:    "kHost",
    kIsilon:        "kHost",
    kHyperV:        "kVirtualMachine",
    kAcropolis:     "kVirtualMachine",
    kRemoteAdapter: "kRemoteAdapter"
  };

  const ENV_FILTERS = {
    kOracle:        ["kOracle"],
    kSQL:           ["kSQL"],
    kPhysical:      ["kPhysical"],
    kGenericNas:    ["kGenericNas", "kIsilon"],
    kIsilon:        ["kIsilon", "kGenericNas"],
    kHyperV:        ["kHyperV"],
    kAcropolis:     ["kAcropolis"],
    kRemoteAdapter: ["kRemoteAdapter"]
  };

  function getEnvCode(pg) {
    let envRaw = pg.environment;
    if (!envRaw && Array.isArray(pg.environmentTypes) && pg.environmentTypes.length > 0) {
      envRaw = pg.environmentTypes[0];
    }
    return envRaw || null;
  }

  function mapEnvironmentLabel(envCode) {
    if (!envCode) return "Unknown";
    return ENV_LABELS[envCode] || envCode;
  }

  function isFailedStatus(status) {
    return status === "Failed";  // align with your RA logic
  }

  function isSuccessStatus(status) {
    return status === "Succeeded" || status === "SucceededWithWarning";
  }

  // ------------------------------
  // 3) Per-PG collector (RunType-based, RA semantics applied to all envs)
  // ------------------------------
  async function collectPgFailure(clusterName, headers, pg) {
    const pgId     = pg.id;
    const pgName   = pg.name || "Unknown PG";
    const envCode  = getEnvCode(pg);
    const envLbl   = mapEnvironmentLabel(envCode);
    const targetType = ENV_OBJECT_TYPES[envCode] || null;
    const envFilter = ENV_FILTERS[envCode] || null;
    const parentHostNeeded = (envCode === "kOracle" || envCode === "kSQL");

    // RemoteAdapter params (for Host/ObjectName)
    let raHost = null;
    let raDB   = null;
    if (envCode === "kRemoteAdapter") {
      try {
        const hosts  = (pg.remoteAdapterParams && pg.remoteAdapterParams.hosts) || {};
        let hostname = hosts.hostname;
        if (Array.isArray(hostname)) hostname = hostname.join(",");
        raHost = hostname || null;

        let args = hosts.incrementalBackupScript && hosts.incrementalBackupScript.params;
        if (Array.isArray(args)) args = args.join(" ");
        if (typeof args === "string") {
          const m = args.match(/-o\s+(\S+)/);
          if (m) raDB = m[1];
        }
      } catch (eRA) {
        // ignore parsing issues
      }
    }

    const runQuery = buildQuery({
      numRuns: 30,                       // last 30 runs
      excludeNonRestorableRuns: false,
      includeObjectDetails: true         // we need objects + failedAttempts
    });

    let runData;
    try {
      runData = await getJson(
        baseUrl + "/v2/data-protect/protection-groups/" + encodeURIComponent(pgId) + "/runs?" + runQuery,
        headers
      );
    } catch (e) {
      return [];
    }

    const runs = runData.runs || [];
    if (!runs.length) return [];

    // Flatten to records (per run) with first localBackupInfo
    const records = [];
    for (let i = 0; i < runs.length; i++) {
      const run = runs[i];
      const infos = toInfoArray(run.localBackupInfo);
      if (!infos.length) continue;
      const info = infos[0];

      const status  = info.status || "Unknown";
      const runType = info.runType || "";
      const startUsecs = info.startTimeUsecs || 0;
      const endUsecs   = info.endTimeUsecs || 0;

      records.push({
        status:       status,
        runType:      runType,
        startUsecs:   startUsecs,
        endUsecs:     endUsecs,
        startTimeStr: usecsToDateString(startUsecs),
        endTimeStr:   usecsToDateString(endUsecs),
        message:      cleanMessage(info.messages),
        run:          run
      });
    }

    if (!records.length) return [];

    // Group by RunType (like $flat | Group-Object RunType)
    const byType = {};
    for (let i = 0; i < records.length; i++) {
      const rec = records[i];
      const key = rec.runType || "UNKNOWN";
      if (!byType[key]) byType[key] = [];
      byType[key].push(rec);
    }

    const typeKeys = Object.keys(byType);
    const out = [];

    for (let t = 0; t < typeKeys.length; t++) {
      const rType = typeKeys[t];
      const rows  = byType[rType];
      if (!rows.length) continue;

      // Sort by endUsecs ascending so "later" is at the end
      rows.sort(function (a, b) {
        return (a.endUsecs || 0) - (b.endUsecs || 0);
      });

      // Latest Failed run
      let latestFailed = null;
      for (let i = rows.length - 1; i >= 0; i--) {
        if (isFailedStatus(rows[i].status)) {
          latestFailed = rows[i];
          break;
        }
      }
      if (!latestFailed) continue;  // no failed runs at all for this RunType

      const failEnd = latestFailed.endUsecs || 0;

      // Any later success? (StartTimeUsecs > latestFailed.EndTimeUsecs)
      let hasLaterSuccess = false;
      for (let i = 0; i < rows.length; i++) {
        const r = rows[i];
        if (!isSuccessStatus(r.status)) continue;
        if ((r.startUsecs || 0) > failEnd) {
          hasLaterSuccess = true;
          break;
        }
      }

      if (hasLaterSuccess) {
        // "resolved" by a later success → skip this runType
        continue;
      }

      // Now we know: latestFailed is a FAILED run with no later success for this RunType.

      // RemoteAdapter: PG-level row with RA DB/Host (like your RA collector)
      if (envCode === "kRemoteAdapter") {
        out.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            null,
          ObjectName:      raDB || raHost || null,
          FailedMessage:   latestFailed.message
        });
        continue;
      }

      // Non-RA: expand objects/failedAttempts from latest failed run
      const runObj = latestFailed.run;
      const objects = (runObj && runObj.objects) ? runObj.objects : [];
      if (!objects.length) {
        // Fallback PG-level row if no objects present
        out.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            null,
          ObjectName:      null,
          FailedMessage:   latestFailed.message
        });
        continue;
      }

      // Build id -> name map for parent-host resolution
      const idToName = {};
      for (let oi = 0; oi < objects.length; oi++) {
        const ob  = objects[oi];
        const obj = ob && ob.object ? ob.object : null;
        if (obj && obj.id != null && obj.name) {
          idToName[String(obj.id)] = obj.name;
        }
      }

      const envSet = envFilter;
      const hasTargetType = !!targetType;
      const rowsForRunType = [];

      // Host-level rows for Oracle/SQL (host discovery failures)
      if (parentHostNeeded) {
        for (let oi = 0; oi < objects.length; oi++) {
          const ob  = objects[oi];
          const obj = ob && ob.object ? ob.object : {};
          const isHostObj =
            (obj.objectType === "kHost") || (obj.environment === "kPhysical");
          if (!isHostObj) continue;

          const lsi            = ob.localSnapshotInfo || {};
          const failedAttempts = lsi.failedAttempts || [];
          if (!failedAttempts.length) continue;

          // Combine messages for this host
          let msgCombined = "";
          for (let fi = 0; fi < failedAttempts.length; fi++) {
            const fa   = failedAttempts[fi];
            const part = cleanMessage(fa && fa.message);
            if (!part) continue;
            msgCombined = msgCombined ? (msgCombined + " | " + part) : part;
          }
          if (!msgCombined) continue;

          rowsForRunType.push({
            Environment:     envLbl,
            Cluster:         clusterName,
            ProtectionGroup: pgName,
            RunType:         rType,
            StartTime:       latestFailed.startTimeStr,
            EndTime:         latestFailed.endTimeStr,
            Status:          latestFailed.status,
            Host:            obj.name || null,
            ObjectName:      "No DBs Found (Host-Level Failure)",
            FailedMessage:   msgCombined
          });
        }
      }

      // Object-level rows (DB/VM/host, etc.)
      for (let oi = 0; oi < objects.length; oi++) {
        const ob  = objects[oi];
        const obj = ob && ob.object ? ob.object : {};
        if (hasTargetType && obj.objectType !== targetType) continue;
        if (envSet && obj.environment && envSet.indexOf(obj.environment) === -1) continue;

        const lsi            = ob.localSnapshotInfo || {};
        const failedAttempts = lsi.failedAttempts || [];
        if (!failedAttempts.length) continue;

        // Combine messages for this object
        let msgCombined = "";
        for (let fi = 0; fi < failedAttempts.length; fi++) {
          const fa   = failedAttempts[fi];
          const part = cleanMessage(fa && fa.message);
          if (!part) continue;
          msgCombined = msgCombined ? (msgCombined + " | " + part) : part;
        }
        if (!msgCombined) continue;

        let hostName = null;
        if (parentHostNeeded && obj.sourceId != null) {
          const sid = String(obj.sourceId);
          if (idToName[sid]) hostName = idToName[sid];
        }

        rowsForRunType.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            hostName,
          ObjectName:      obj.name || null,
          FailedMessage:   msgCombined
        });
      }

      if (rowsForRunType.length === 0) {
        // As a last fallback, emit one PG-level row
        out.push({
          Environment:     envLbl,
          Cluster:         clusterName,
          ProtectionGroup: pgName,
          RunType:         rType,
          StartTime:       latestFailed.startTimeStr,
          EndTime:         latestFailed.endTimeStr,
          Status:          latestFailed.status,
          Host:            null,
          ObjectName:      null,
          FailedMessage:   latestFailed.message
        });
      } else {
        for (let i = 0; i < rowsForRunType.length; i++) {
          out.push(rowsForRunType[i]);
        }
      }
    }

    return out;
  }

  // ------------------------------
  // 4) Per-cluster collector (parallel over PGs)
  // ------------------------------
  async function collectClusterFailures(cluster) {
    const clusterName =
      cluster.name ||
      cluster.clusterName ||
      cluster.displayName ||
      ("Unknown-" + cluster.clusterId);

    const headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: String(cluster.clusterId)
    };

    const pgQuery = buildQuery({
      isDeleted: false,
      isPaused: false,
      isActive: true
    });

    let pgData;
    try {
      pgData = await getJson(
        baseUrl + "/v2/data-protect/protection-groups?" + pgQuery,
        headers
      );
    } catch (e) {
      return [];
    }

    const pgs = pgData.protectionGroups || [];
    if (!pgs.length) return [];

    const pgPromises = pgs.map(function (pg) {
      return collectPgFailure(clusterName, headers, pg);
    });
    const results = await Promise.all(pgPromises);

    const allRows = [];
    for (let i = 0; i < results.length; i++) {
      const arr = results[i];
      if (arr && arr.length) {
        for (let j = 0; j < arr.length; j++) {
          allRows.push(arr[j]);
        }
      }
    }
    return allRows;
  }

  // ------------------------------
  // 5) Collect all clusters, flatten, sort
  // ------------------------------
  async function collectAllFailures() {
    const clusterData = await getJson(
      baseUrl + "/v2/mcm/cluster-mgmt/info",
      commonHeaders
    );
    const clusters = clusterData.cohesityClusters || [];
    if (!clusters.length) return [];

    const clusterPromises = clusters.map(function (cluster) {
      return collectClusterFailures(cluster);
    });
    const clusterResults = await Promise.all(clusterPromises);

    const allRows = [];
    for (let i = 0; i < clusterResults.length; i++) {
      const arr = clusterResults[i];
      if (arr && arr.length) {
        for (let j = 0; j < arr.length; j++) {
          allRows.push(arr[j]);
        }
      }
    }

    // Sort: Cluster, Environment, PG, Host, ObjectName, EndTime desc
    allRows.sort(function (a, b) {
      const c1 = (a.Cluster || "").localeCompare(b.Cluster || "");
      if (c1 !== 0) return c1;
      const c2 = (a.Environment || "").localeCompare(b.Environment || "");
      if (c2 !== 0) return c2;
      const c3 = (a.ProtectionGroup || "").localeCompare(b.ProtectionGroup || "");
      if (c3 !== 0) return c3;
      const c4 = (a.Host || "").localeCompare(b.Host || "");
      if (c4 !== 0) return c4;
      const c5 = (a.ObjectName || "").localeCompare(b.ObjectName || "");
      if (c5 !== 0) return c5;
      const tA = a.EndTime ? new Date(a.EndTime).getTime() : 0;
      const tB = b.EndTime ? new Date(b.EndTime).getTime() : 0;
      return tB - tA;
    });

    return allRows;
  }

  // ------------------------------
  // 6) Markdown table for email (with Host + ObjectName)
  // ------------------------------
  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) {
      return "✅ No FAILED backup runs without a later successful run.";
    }

    const headers = [
      "Environment",
      "Cluster",
      "ProtectionGroup",
      "Host",
      "ObjectName",
      "RunType",
      "StartTime",
      "EndTime",
      "Status",
      "FailedMessage"
    ];

    const headerRow = "| " + headers.join(" | ") + " |";
    const separator = "| " + headers.map(function () { return "---"; }).join(" | ") + " |";

    const bodyRows = rows.map(function (r) {
      const vals = headers.map(function (h) {
        const v = r[h] != null ? r[h] : "";
        const s = String(v);
        return s.length > 300 ? s.slice(0, 297) + "..." : s;
      });
      return "| " + vals.join(" | ") + " |";
    });

    return [headerRow, separator].concat(bodyRows).join("\n");
  }

  // ------------------------------
  // 7) Run + return
  // ------------------------------
  const failures = await collectAllFailures();
  const markdownTable = toMarkdownTable(failures);

  return {
    authMode: authMode,
    count: failures.length,
    failures: failures,
    markdownTable: markdownTable
  };
}
