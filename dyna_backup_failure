// Cohesity Helios — Format output (SPLIT #2, FORMAT ONLY)
// Input expected: cohesityPayload = output object from Script #1

export default async function ({ cohesityPayload }) {
  const authMode = (cohesityPayload && cohesityPayload.authMode) ? cohesityPayload.authMode : "unknown";
  const failures = (cohesityPayload && Array.isArray(cohesityPayload.failures)) ? cohesityPayload.failures : [];

  function safeCell(v) {
    if (v == null) return "";
    return String(v).replace(/\|/g, " ").replace(/[\r\n]+/g, " ").trim();
  }

  function toIncidentTextCreate(rows) {
    if (!rows || rows.length === 0) return "✅ No FAILED backup objects without a later successful run (last 10 runs scope).";
    const lines = [];
    lines.push("=== Backup Failures (Latest Uncleared Only) ===");
    lines.push(`Count: ${rows.length}`);
    lines.push("");
    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];
      const obj = r.DatabaseName || r.ObjectName || "-";
      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${obj} | End(ET)=${r.EndTime || "-"}`
      );
    }
    return lines.join("\n");
  }

  function toIncidentTextUpdate(rows) {
    if (!rows || rows.length === 0) return "✅ No FAILED backup objects without a later successful run (last 10 runs scope).";
    const lines = [];
    lines.push("=== Backup Failures (Latest Uncleared Only) ===");
    lines.push(`Count: ${rows.length}`);
    lines.push("");
    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];
      const obj = r.DatabaseName || r.ObjectName || "-";
      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${obj} | End(ET)=${r.EndTime || "-"}`
      );
      if (r.FailedMessage) lines.push(`    Message: ${String(r.FailedMessage)}`);
      lines.push("");
    }
    return lines.join("\n");
  }

  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) {
      return "✅ No FAILED backup objects without a later successful run (last 10 runs scope).";
    }

    const headerLabels = ["Cluster", "ProtectionGroup", "Host", "ObjectName", "RunType", "StartTime ET", "EndTime ET", "FailedMessage"];
    const headerRow = "| " + headerLabels.join(" | ") + " |";
    const separator = "| " + headerLabels.map(() => "---").join(" | ") + " |";

    const bodyRows = rows.map((r) => {
      const obj = r.DatabaseName || r.ObjectName || "";
      const vals = [
        safeCell(r.Cluster),
        safeCell(r.ProtectionGroup),
        safeCell(r.Host),
        safeCell(obj),
        safeCell(r.RunType),
        safeCell(r.StartTime),
        safeCell(r.EndTime),
        safeCell(r.FailedMessage)
      ];
      return "| " + vals.join(" | ") + " |";
    });

    const introLines = [
      "### Backup failures without a latest successful run",
      ""
    ];

    return introLines.join("\n") + "\n" + [headerRow, separator].concat(bodyRows).join("\n");
  }

  const markdownTable = toMarkdownTable(failures);

  return {
    authMode: authMode,
    count: failures.length,
    failures: failures,
    incidentText_create: toIncidentTextCreate(failures),
    incidentText_update: toIncidentTextUpdate(failures),
    markdownTable: markdownTable,
    markdownEmail: markdownTable
  };
}
