// Cohesity Helios – Backup Failures (Latest Uncleared Only, Last 10 Runs) — SPLIT (Phase 2)
// GET-only | NO SNOW calls | 502/429 safe (best-effort) | Output format kept (incl snow_* fields)
//
// IMPORTANT:
// - This script produces the FINAL output (same keys as your unsplit).
// - It reads candidates from Script 1 using result("run_javascript_1").
// - It still pulls objectDetails=true (object-level), but only for candidate PG/RunTypes.

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";
import { result } from "@dynatrace-sdk/automation-utils";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ======================
  // Load candidates from Script 1
  // ======================
  const phase1 = await result("run_javascript_1");
  const NUM_RUNS = (phase1 && phase1.NUM_RUNS) ? phase1.NUM_RUNS : 10;
  const candidates = (phase1 && Array.isArray(phase1.candidates)) ? phase1.candidates : [];

  // ======================
  // Tunables (runtime)
  // ======================
  const MAX_ROWS_TOTAL = 6000;
  const CANDIDATE_CONCURRENCY = 3;

  // ======================
  // AUTH (READ-ONLY)
  // ======================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find((c) => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (detail && (detail.token || detail.password)) || null;
      authMode = "vault-id";
    } catch {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }
  if (!apiKey) throw new Error("No Helios API key available (vault + manual failed).");

  // ======================
  // Helpers
  // ======================
  function buildQuery(params) {
    const usp = new URLSearchParams();
    Object.keys(params || {}).forEach((k) => {
      const v = params[k];
      if (v === undefined || v === null) return;
      if (Array.isArray(v)) v.forEach((x) => usp.append(k, String(x)));
      else usp.append(k, String(v));
    });
    return usp.toString();
  }

  function usecsToET(usecs) {
    if (!usecs) return null;
    const ms = Number(usecs) / 1000;
    if (!Number.isFinite(ms)) return null;
    return new Date(ms).toLocaleString("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    });
  }

  function cleanMessage(msg) {
    if (msg == null) return "";
    if (Array.isArray(msg)) msg = msg.join(" | ");
    msg = String(msg);
    return msg.replace(/[\r\n]+/g, " ").replace(/,/g, " ").replace(/"/g, "'").trim();
  }

  function combineFailedAttempts(failedAttempts) {
    if (!failedAttempts || !failedAttempts.length) return "";
    const parts = [];
    for (let i = 0; i < failedAttempts.length; i++) {
      const p = cleanMessage(failedAttempts[i] && failedAttempts[i].message);
      if (p) parts.push(p);
    }
    return parts.join(" | ").trim();
  }

  function toInfoArray(localBackupInfo) {
    if (!localBackupInfo) return [];
    return Array.isArray(localBackupInfo) ? localBackupInfo : [localBackupInfo];
  }

  function isSuccessStatus(status) {
    return status === "Succeeded" || status === "SucceededWithWarning";
  }

  // Object key used for “cleared by later success”
  function getObjKey(ob) {
    if (!ob || !ob.object) return null;
    if (ob.object.id != null) return String(ob.object.id);
    const sid = (ob.object.sourceId != null) ? String(ob.object.sourceId) : "";
    return `${ob.object.environment || ""}|${ob.object.objectType || ""}|${ob.object.name || ""}|${sid}`;
  }

  function hasFailedAttempts(ob) {
    const lsi = ob && ob.localSnapshotInfo;
    const fa = lsi && lsi.failedAttempts;
    return !!(fa && fa.length);
  }

  // present + no failedAttempts => “success for clear”
  function isSuccessForClear(ob) {
    if (!ob || !ob.localSnapshotInfo) return false;
    return !hasFailedAttempts(ob);
  }

  async function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
  }

  async function getJson(url, headers, attempt = 0) {
    const resp = await fetch(url, { method: "GET", headers });
    if (resp.ok) return resp.json();

    const status = resp.status;
    let txt = "";
    try { txt = await resp.text(); } catch {}

    if ((status === 429 || status === 502 || status === 503 || status === 504) && attempt < 2) {
      await sleep(250 * (attempt + 1));
      return getJson(url, headers, attempt + 1);
    }
    throw new Error(`GET ${url} -> HTTP ${status} ${txt}`);
  }

  async function mapLimit(items, limit, fn) {
    const out = [];
    let idx = 0;
    const workers = new Array(Math.min(limit, items.length)).fill(0).map(async () => {
      while (idx < items.length) {
        const i = idx++;
        try {
          out[i] = await fn(items[i], i);
        } catch {
          out[i] = null;
        }
      }
    });
    await Promise.all(workers);
    return out;
  }

  // ======================
  // Environment maps
  // ======================
  const ENV_LABELS = {
    kOracle: "Oracle",
    kSQL: "SQL",
    kPhysical: "Physical",
    kGenericNas: "NAS",
    kIsilon: "NAS",
    kHyperV: "HyperV",
    kAcropolis: "Acropolis",
    kRemoteAdapter: "RemoteAdapter"
  };

  const ENV_OBJECT_TYPES = {
    kOracle: "kDatabase",
    kSQL: "kDatabase",
    kPhysical: "kHost",
    kGenericNas: "kHost",
    kIsilon: "kHost",
    kHyperV: "kVirtualMachine",
    kAcropolis: "kVirtualMachine",
    kRemoteAdapter: "kRemoteAdapter"
  };

  const ENV_FILTERS = {
    kOracle: ["kOracle"],
    kSQL: ["kSQL"],
    kPhysical: ["kPhysical"],
    kGenericNas: ["kGenericNas", "kIsilon"],
    kIsilon: ["kIsilon", "kGenericNas"],
    kHyperV: ["kHyperV"],
    kAcropolis: ["kAcropolis"],
    kRemoteAdapter: ["kRemoteAdapter"]
  };

  function mapEnvironmentLabel(envCode) {
    if (!envCode) return "Unknown";
    return ENV_LABELS[envCode] || envCode;
  }

  // RemoteAdapter: best-effort host + DB
  function extractRemoteAdapterInfo(pg) {
    let raHost = null;
    let raDB = null;

    const ra = pg.remoteAdapterParams || {};
    const hosts = ra.hosts || ra.host || ra.hostList || null;

    let firstHost = null;
    if (Array.isArray(hosts) && hosts.length > 0) firstHost = hosts[0];
    else if (hosts && typeof hosts === "object") firstHost = hosts;

    if (firstHost) {
      raHost = firstHost.hostname || firstHost.hostName || firstHost.name || null;

      const inc =
        firstHost.incrementalBackupScript ||
        firstHost.backupScript ||
        ra.incrementalBackupScript ||
        ra.backupScript ||
        {};

      let args = inc.params || inc.arguments || inc.args || null;
      if (Array.isArray(args)) args = args.join(" ");
      if (typeof args === "string") {
        const m = args.match(/-o\s+(\S+)/i);
        if (m) raDB = m[1];
      }
    }
    return { raH
