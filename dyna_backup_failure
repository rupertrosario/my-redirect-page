// ============================================================
// SCRIPT #2/2 — Formatter (MATCHES YOUR PICTURE RETURN BLOCK)
// Input: payload = output from Script #1
// Output keys EXACTLY like your screenshot:
//   authMode, count, failures, incidentText_create, incidentText_update, markdownTable, markdownEmail
// (NO snow fields, NO extra return keys)
// ============================================================

export default async function ({ payload }) {
  const p = payload || {};
  const authMode = p.authMode || "unknown";
  const failures = Array.isArray(p.failures) ? p.failures : [];
  const count = failures.length;

  function usecsToET(usecs) {
    if (!usecs) return "";
    const ms = Number(usecs) / 1000; // microseconds -> ms
    if (!Number.isFinite(ms)) return "";
    return new Date(ms).toLocaleString("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    });
  }

  function safeCell(v) {
    if (v == null) return "";
    return String(v).replace(/\|/g, " ").replace(/[\r\n]+/g, " ").trim();
  }

  // Build incident text (create = no message, update = with message)
  function toIncidentTextCreate(rows) {
    if (!rows || rows.length === 0) return "✅ No FAILED backup objects without a later successful run (last 10 runs scope).";
    const lines = [];
    lines.push("=== Backup Failures (Latest Uncleared Only) ===");
    lines.push(`Count: ${rows.length}`);
    lines.push("");
    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];
      const obj = r.DatabaseName || r.ObjectName || "-";
      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${obj} | End(ET)=${usecsToET(r.EndTimeUsecs) || "-"}`
      );
    }
    return lines.join("\n");
  }

  function toIncidentTextUpdate(rows) {
    if (!rows || rows.length === 0) return "✅ No FAILED backup objects without a later successful run (last 10 runs scope).";
    const lines = [];
    lines.push("=== Backup Failures (Latest Uncleared Only) ===");
    lines.push(`Count: ${rows.length}`);
    lines.push("");
    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];
      const obj = r.DatabaseName || r.ObjectName || "-";
      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${obj} | End(ET)=${usecsToET(r.EndTimeUsecs) || "-"}`
      );
      if (r.FailedMessage) lines.push(`    Message: ${String(r.FailedMessage)}`);
      lines.push("");
    }
    return lines.join("\n");
  }

  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) {
      return "✅ No FAILED backup objects without a later successful run (last 10 runs scope).";
    }

    // EXACT headers from your earlier script style (no Environment column)
    const headerLabels = ["Cluster", "ProtectionGroup", "Host", "ObjectName", "RunType", "StartTime ET", "EndTime ET", "Message"];
    const headerRow = "| " + headerLabels.join(" | ") + " |";
    const separator = "| " + headerLabels.map(() => "---").join(" | ") + " |";

    const bodyRows = rows.map((r) => {
      const obj = r.DatabaseName || r.ObjectName || "";
      const vals = [
        safeCell(r.Cluster),
        safeCell(r.ProtectionGroup),
        safeCell(r.Host),
        safeCell(obj),
        safeCell(r.RunType),
        safeCell(usecsToET(r.StartTimeUsecs)),
        safeCell(usecsToET(r.EndTimeUsecs)),
        safeCell(r.FailedMessage)
      ];
      return "| " + vals.join(" | ") + " |";
    });

    // Intro EXACT style like your picture snippet
    const introLines = [
      "### Backup failures without a latest successful run",
      "",
      "_Scope: last 10 runs per Protection Group / RunType. Only FAILED objects that have NO later Succeeded/SucceededWithWarning in-scope are shown._",
      ""
    ];

    return introLines.join("\n") + "\n" + [headerRow, separator].concat(bodyRows).join("\n");
  }

  // Sort newest first for readability
  const sorted = failures.slice().sort((a, b) => (b.EndTimeUsecs || 0) - (a.EndTimeUsecs || 0));

  const incidentText_create = toIncidentTextCreate(sorted);
  const incidentText_update = toIncidentTextUpdate(sorted);
  const markdownTable = toMarkdownTable(sorted);

  // RETURN BLOCK EXACTLY LIKE YOUR PICTURE
  return {
    authMode: authMode,
    count: count,
    failures: sorted,
    incidentText_create: incidentText_create,
    incidentText_update: incidentText_update,
    markdownTable: markdownTable,
    markdownEmail: markdownTable
  };
}
