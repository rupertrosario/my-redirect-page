// ================================
// Script 1 (Run JavaScript #1)
// Cohesity Helios â€“ Backup Failures (Phase 1: Candidates Only)
// GET-only | 502/429 safe | NO objectDetails
//
// Output (consumed by Script 2 via result("run_javascript_1")):
// {
//   authMode,
//   NUM_RUNS,
//   candidates: [
//     { clusterId, clusterName, pgId, pgName, envCode, envLbl, runTypes: [...], remoteAdapterParams? }
//   ]
// }
// ================================

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // Tunables
  const NUM_RUNS = 10;
  const CLUSTER_CONCURRENCY = 2;
  const PG_CONCURRENCY = 6;

  // AUTH
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find((c) => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (detail && (detail.token || detail.password)) || null;
      authMode = "vault-id";
    } catch {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }
  if (!apiKey) throw new Error("No Helios API key available (vault + manual failed).");

  function buildQuery(params) {
    const usp = new URLSearchParams();
    Object.keys(params || {}).forEach((k) => {
      const v = params[k];
      if (v === undefined || v === null) return;
      if (Array.isArray(v)) v.forEach((x) => usp.append(k, String(x)));
      else usp.append(k, String(v));
    });
    return usp.toString();
  }

  function toInfoArray(localBackupInfo) {
    if (!localBackupInfo) return [];
    return Array.isArray(localBackupInfo) ? localBackupInfo : [localBackupInfo];
  }

  async function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
  }

  async function getJson(url, headers, attempt = 0) {
    const resp = await fetch(url, { method: "GET", headers });
    if (resp.ok) return resp.json();

    const status = resp.status;
    let txt = "";
    try { txt = await resp.text(); } catch {}

    if ((status === 429 || status === 502 || status === 503 || status === 504) && attempt < 2) {
      await sleep(250 * (attempt + 1));
      return getJson(url, headers, attempt + 1);
    }
    throw new Error(`GET ${url} -> HTTP ${status} ${txt}`);
  }

  async function mapLimit(items, limit, fn) {
    const out = [];
    let idx = 0;
    const workers = new Array(Math.min(limit, items.length)).fill(0).map(async () => {
      while (idx < items.length) {
        const i = idx++;
        try { out[i] = await fn(items[i], i); } catch { out[i] = null; }
      }
    });
    await Promise.all(workers);
    return out;
  }

  const ENV_LABELS = {
    kOracle: "Oracle",
    kSQL: "SQL",
    kPhysical: "Physical",
    kGenericNas: "NAS",
    kIsilon: "NAS",
    kHyperV: "HyperV",
    kAcropolis: "Acropolis",
    kRemoteAdapter: "RemoteAdapter"
  };

  function getEnvCode(pg) {
    let envRaw = pg.environment;
    if (!envRaw && Array.isArray(pg.environmentTypes) && pg.environmentTypes.length > 0) {
      envRaw = pg.environmentTypes[0];
    }
    return envRaw || null;
  }

  function mapEnvironmentLabel(envCode) {
    if (!envCode) return "Unknown";
    return ENV_LABELS[envCode] || envCode;
  }

  // Conservative candidate selection:
  // If any run in last NUM_RUNS for a RunType is Failed or SucceededWithWarning => candidate.
  async function collectPgCandidates(clusterName, clusterId, headers, pg) {
    const pgId = pg.id;
    const pgName = pg.name || "Unknown PG";
    const envCode = getEnvCode(pg);
    const envLbl = mapEnvironmentLabel(envCode);

    const q = buildQuery({
      numRuns: NUM_RUNS,
      excludeNonRestorableRuns: false,
      includeObjectDetails: false
    });

    let runData;
    try {
      runData = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs?${q}`,
        headers
      );
    } catch {
      return null;
    }

    const runs = runData && runData.runs ? runData.runs : [];
    if (!runs.length) return null;

    const runTypes = new Set();
    for (let i = 0; i < runs.length; i++) {
      const infos = toInfoArray(runs[i].localBackupInfo);
      if (!infos.length) continue;
      const rt = infos[0]?.runType ? infos[0].runType : "UNKNOWN";
      const st = infos[0]?.status ? infos[0].status : "Unknown";
      if (st === "Failed" || st === "SucceededWithWarning") runTypes.add(rt);
    }
    if (!runTypes.size) return null;

    const out = {
      clusterId: String(clusterId),
      clusterName: clusterName,
      pgId: String(pgId),
      pgName: pgName,
      envCode: envCode,
      envLbl: envLbl,
      runTypes: Array.from(runTypes)
    };

    // keep RemoteAdapter params so Script 2 can extract host/db without extra calls
    if (envCode === "kRemoteAdapter" && pg.remoteAdapterParams) {
      out.remoteAdapterParams = pg.remoteAdapterParams;
    }

    return out;
  }

  async function collectClusterCandidates(cluster) {
    const clusterId = cluster.clusterId;
    const clusterName =
      cluster.name || cluster.clusterName || cluster.displayName || `Unknown-${clusterId}`;

    const headers = {
      accept: "application/json",
      apiKey,
      accessClusterId: String(clusterId)
    };

    let pgData;
    try {
      pgData = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups?${buildQuery({
          isDeleted: false,
          isPaused: false,
          isActive: true
        })}`,
        headers
      );
    } catch {
      return [];
    }

    const pgs = pgData && pgData.protectionGroups ? pgData.protectionGroups : [];
    if (!pgs.length) return [];

    const pgResults = await mapLimit(pgs, PG_CONCURRENCY, async (pg) =>
      collectPgCandidates(clusterName, clusterId, headers, pg)
    );

    return pgResults.filter(Boolean);
  }

  const clustersResp = await getJson(
    `${baseUrl}/v2/mcm/cluster-mgmt/info`,
    { accept: "application/json", apiKey }
  );
  const clusters = clustersResp && clustersResp.cohesityClusters ? clustersResp.cohesityClusters : [];

  const clusterResults = await mapLimit(clusters, CLUSTER_CONCURRENCY, async (c) =>
    collectClusterCandidates(c)
  );

  const candidates = [];
  for (let i = 0; i < clusterResults.length; i++) {
    const r = clusterResults[i];
    if (r && r.length) candidates.push(...r);
  }

  return {
    authMode: authMode,
    NUM_RUNS: NUM_RUNS,
    candidates: candidates
  };
}
