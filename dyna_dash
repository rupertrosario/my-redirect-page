export default async function () {
  console.log("üöÄ Cohesity Helios ‚Äì Capacity + Garbage via timeSeriesStats (GET with query)");

  // üîê Paste your working Helios API key
  const apiKey  = "PASTE_YOUR_API_KEY_HERE";
  const baseUrl = "https://helios.cohesity.com";
  const oneTiB  = 1099511627776;
  const commonHeaders = { accept: "application/json", apiKey };

  // 1) Get clusters (name + id)
  const listResp = await fetch(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { headers: commonHeaders });
  if (listResp.status !== 200) throw new Error(`Cluster list HTTP ${listResp.status}`);
  const listJson = await listResp.json();
  const clusters = listJson?.cohesityClusters?.map(c => ({ clusterName: c.clusterName, clusterId: c.clusterId })) || [];

  if (clusters.length === 0) {
    console.log("‚ö†Ô∏è No clusters returned.");
    return { clusters: [] };
  }

  const results = [];

  // 2) Per-cluster: GET timeSeriesStats (EstimatedGarbageBytes) + GET storage
  for (const { clusterName, clusterId } of clusters) {
    if (!clusterName || !clusterId) continue;

    console.log(`üìä ${clusterName} ‚Äî fetching garbage & capacity...`);
    // Headers must include accessClusterId for per-cluster views
    const h = { ...commonHeaders, accessClusterId: String(clusterId) };

    // ---- Garbage via GET /statistics/timeSeriesStats (querystring, not body)
    // These are the exact fields you had in your original script‚Äôs body
    const qs = new URLSearchParams({
      schemaName:         "ApolloV2ClusterStats",
      metricName:         "EstimatedGarbageBytes",
      startTimeMsecs:     "2",
      entityId:           `cluster name (ID ${clusterId})`,
      rollupFunction:     "latest",
      rollupIntervalSecs: "30",
      metricUnitType:     "0",
      range:              "day"
    }).toString();

    const tsUrl = `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats?${qs}`;
    const tsResp = await fetch(tsUrl, { headers: h, method: "GET" });
    if (tsResp.status !== 200) {
      console.log(`‚ö†Ô∏è timeSeriesStats failed for ${clusterName} (HTTP ${tsResp.status})`);
      continue;
    }

    const tsJson = await tsResp.json();
    const latest = Array.isArray(tsJson?.dataPointVec) ? tsJson.dataPointVec[tsJson.dataPointVec.length - 1] : undefined;
    const garbageBytes = latest?.data?.int64Value ?? 0;
    const garbageGB = +(garbageBytes / (1024 ** 3)).toFixed(2);
    const garbageTB = +(garbageBytes / (1024 ** 4)).toFixed(3);

    // ---- Capacity via GET /stats/storage
    const capResp = await fetch(`${baseUrl}/irisservices/api/v1/public/stats/storage`, { headers: h });
    if (capResp.status !== 200) {
      console.log(`‚ö†Ô∏è storage stats failed for ${clusterName} (HTTP ${capResp.status})`);
      continue;
    }
    const s = await capResp.json();
    const totalTiB = +(s.totalCapacityBytes    / oneTiB).toFixed(2);
    const usedTiB  = +(s.localUsageBytes       / oneTiB).toFixed(2);
    const availTiB = +(s.localAvailableBytes   / oneTiB).toFixed(2);
    const consumed = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

    results.push({
      clusterName,
      clusterId,
      totalTiB,
      usedTiB,
      availTiB,
      consumedPercent: consumed,
      garbageGB,
      garbageTB
    });

    console.log(`‚úÖ ${clusterName}: %used=${consumed} (${usedTiB}/${totalTiB} TiB), garbage=${garbageGB} GB (${garbageTB} TB)`);
  }

  console.log("üìÑ Final Summary:");
  console.log(JSON.stringify(results, null, 2));
  return { clusters: results };
}
