/**
 * Cohesity Helios ‚Äì Cluster Interface Health Dashboard
 * -----------------------------------------------------
 * Endpoints: exactly as in original PowerShell script
 * /v2/mcm/cluster-mgmt/info
 * /irisservices/api/v1/public/statistics/timeSeriesStats
 * /irisservices/api/v1/public/stats/storage
 * 
 * Secure: Loads API key from Dynatrace Credentials Vault (AppEngine scope)
 */

// 1Ô∏è‚É£ Load API key from Dynatrace credentials vault
const helios = workflow.credential("cohesity-helios-api-key");
const apiKey = helios?.value || helios?.token || helios?.password;
if (!apiKey) fail("‚ùå Helios API key not found in Dynatrace credentials vault.");

// 2Ô∏è‚É£ Base configuration
const baseUrl = "https://helios.cohesity.com";
const oneTiB = 1099511627776;
const headers = { "accept": "application/json", "apiKey": apiKey };

log.info("üîπ Fetching clusters from Helios...");

// 3Ô∏è‚É£ Get Clusters (ClusterName + ClusterId)
const urlClusters = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
const clusterResponse = http.get(urlClusters, { headers });

if (clusterResponse.statusCode !== 200) {
  fail(`‚ùå Failed to fetch clusters: HTTP ${clusterResponse.statusCode}`);
}

const jsonCluster = JSON.parse(clusterResponse.body);
const clusters = jsonCluster.cohesityClusters || [];

log.info(`‚úÖ Found ${clusters.length} clusters.`);

// 4Ô∏è‚É£ Loop through clusters
const results = [];

for (const clus of clusters) {
  const clusterName = clus.ClusterName;
  const clusterId = clus.ClusterId;
  log.info(`üìä Processing cluster: ${clusterName}`);

  const hdrs = {
    "accept": "application/json",
    "apiKey": apiKey,
    "accessClusterId": clusterId
  };

  // URLs from your PowerShell script (exact same)
  const url1 = `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats`;
  const url2 = `${baseUrl}/irisservices/api/v1/public/stats/storage`;

  // Body for EstimatedGarbageBytes (same schema and fields)
  const body = {
    schemaName: "ApolloV2ClusterStats",
    metricName: "EstimatedGarbageBytes",
    startTimeMsecs: "2",
    entityId: `cluster name (ID ${clusterId})`,
    rollupFunction: "latest",
    rollupIntervalSecs: "30",
    metricUnitType: "0",
    range: "day"
  };

  // --- GET Garbage Data (POST in original PowerShell, same preserved) ---
  const garbageResponse = http.post(url1, {
    headers: hdrs,
    body: JSON.stringify(body)
  });

  if (garbageResponse.statusCode !== 200) {
    log.warn(`‚ö†Ô∏è Failed to fetch garbage data for ${clusterName}`);
    continue;
  }

  const garbageJson = JSON.parse(garbageResponse.body);
  const lastDataPoint = garbageJson.dataPointVec?.slice(-1)[0];
  const bytes = lastDataPoint?.data?.int64Value ?? 0;
  const gb = +(bytes / (1024 ** 3)).toFixed(2);
  const tb = +(bytes / (1024 ** 4)).toFixed(4);

  // --- GET Storage Stats ---
  const storageResponse = http.get(url2, { headers: hdrs });
  if (storageResponse.statusCode !== 200) {
    log.warn(`‚ö†Ô∏è Failed to fetch storage stats for ${clusterName}`);
    continue;
  }

  const storageJson = JSON.parse(storageResponse.body);

  const totalTiB = +(storageJson.totalCapacityBytes / oneTiB).toFixed(1);
  const usedTiB = +(storageJson.localUsageBytes / oneTiB).toFixed(1);
  const availTiB = +(storageJson.localAvailableBytes / oneTiB).toFixed(1);
  const consumed = +((storageJson.localUsageBytes / storageJson.totalCapacityBytes) * 100).toFixed(1);

  // --- Collect results ---
  results.push({
    Cluster: clusterName,
    Garbage_Data_In_GB: gb,
    Garbage_Data_In_TB: tb,
    Total_Capacity_Bytes_TiB: totalTiB,
    Local_Usage_Bytes_TiB: usedTiB,
    Local_Available_Bytes_TiB: availTiB,
    Consumed: `${consumed}%`
  });

  // --- Emit metrics (optional dashboard support) ---
  emitMetric("custom.cohesity.cluster.garbageData.GB", gb, { cluster: clusterName });
  emitMetric("custom.cohesity.cluster.garbageData.TB", tb, { cluster: clusterName });
  emitMetric("custom.cohesity.cluster.capacity.totalTiB", totalTiB, { cluster: clusterName });
  emitMetric("custom.cohesity.cluster.capacity.usedTiB", usedTiB, { cluster: clusterName });
  emitMetric("custom.cohesity.cluster.capacity.availableTiB", availTiB, { cluster: clusterName });
  emitMetric("custom.cohesity.cluster.capacity.percentUsed", consumed, { cluster: clusterName });

  log.info(`‚úÖ ${clusterName}: ${consumed}% used (${usedTiB}/${totalTiB} TiB), Garbage ${gb} GB`);
}

// 5Ô∏è‚É£ Log output (no return)
log.info("üìÑ Final Summary Table:");
log.info(JSON.stringify(results, null, 2));

// Optional: make results accessible to next workflow step
workflow.setOutput("results", results);
