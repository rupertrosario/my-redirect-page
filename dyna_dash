import { metrics } from '@dynatrace-sdk/automation-utils';

export default async function () {
  console.log("üöÄ Cohesity Helios ‚Äì Capacity + Garbage (GET-only with GB & TB metrics)");

  const apiKey  = "PASTE_YOUR_API_KEY_HERE";   // temporary ‚Äì replace with vault later
  const baseUrl = "https://helios.cohesity.com";
  const oneTiB  = 1099511627776;
  const headers = { accept: "application/json", apiKey };

  // 1Ô∏è‚É£ Fetch cluster list
  const resp = await fetch(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { headers });
  if (resp.status !== 200) throw new Error(`‚ùå Cluster list HTTP ${resp.status}`);
  const data = await resp.json();

  const clusters = data?.cohesityClusters?.map(c => ({
    clusterName: c.clusterName,
    clusterId:   c.clusterId
  })) || [];

  if (clusters.length === 0) {
    console.log("‚ö†Ô∏è No clusters returned ‚Äì check key scope or region.");
    return { clusters: [] };
  }

  const results = [];

  // 2Ô∏è‚É£ Capacity + Garbage for each cluster
  for (const c of clusters) {
    const h = { ...headers, accessClusterId: c.clusterId };
    console.log(`üìä Fetching capacity + garbage for ${c.clusterName}`);

    // Capacity (GET)
    const capResp = await fetch(`${baseUrl}/irisservices/api/v1/public/stats/storage`, { headers: h });
    if (capResp.status !== 200) {
      console.log(`‚ö†Ô∏è Capacity fetch failed for ${c.clusterName}`);
      continue;
    }
    const s = await capResp.json();
    const totalTiB = +(s.totalCapacityBytes / oneTiB).toFixed(2);
    const usedTiB  = +(s.localUsageBytes / oneTiB).toFixed(2);
    const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
    const consumed = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

    // Garbage (GET)
    const garResp = await fetch(`${baseUrl}/irisservices/api/v1/public/mcm/stats/garbageData`, { headers: h });
    let garbageBytes = 0;
    if (garResp.status === 200) {
      const g = await garResp.json();
      garbageBytes = g?.garbageDataBytes ?? 0;
    } else {
      console.log(`‚ö†Ô∏è Garbage data fetch failed for ${c.clusterName}`);
    }
    const garbageGB = +(garbageBytes / (1024 ** 3)).toFixed(2);
    const garbageTB = +(garbageBytes / (1024 ** 4)).toFixed(3);

    // Emit metrics for dashboard (GB and TB)
    const dims = { cluster: c.clusterName };
    await metrics.emit('cohesity.capacity.totalTiB', totalTiB, dims);
    await metrics.emit('cohesity.capacity.usedTiB',  usedTiB,  dims);
    await metrics.emit('cohesity.capacity.availTiB', availTiB, dims);
    await metrics.emit('cohesity.capacity.percentUsed', consumed, dims);
    await metrics.emit('cohesity.garbage.garbageGB', garbageGB, dims);
    await metrics.emit('cohesity.garbage.garbageTB', garbageTB, dims);

    results.push({
      clusterName: c.clusterName,
      clusterId:   c.clusterId,
      totalTiB, usedTiB, availTiB,
      consumedPercent: consumed,
      garbageGB, garbageTB
    });

    console.log(`‚úÖ ${c.clusterName}: ${consumed}% used (${usedTiB}/${totalTiB} TiB), Garbage ${garbageGB} GB (${garbageTB} TB)`);
  }

  // 3Ô∏è‚É£ Summary
  console.log("üìÑ Final Summary:");
  console.log(JSON.stringify(results, null, 2));
  return { clusters: results };
}
