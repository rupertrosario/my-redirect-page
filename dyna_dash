export default async function () {
  console.log("üöÄ Cohesity Helios ‚Äì Capacity + Garbage Data Dashboard (run-anywhere version)");

  // üîê Paste your Helios API key temporarily here for testing
  const apiKey = "PASTE_YOUR_API_KEY_HERE";  // remove later when using vault
  const baseUrl = "https://helios.cohesity.com";
  const oneTiB = 1099511627776;
  const headers = { accept: "application/json", apiKey };

  // 1Ô∏è‚É£ Get cluster list
  console.log("üîπ Fetching Cohesity clusters ...");
  const clusterResp = await fetch(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { headers });
  console.log(`‚û°Ô∏è Cluster list HTTP ${clusterResp.status}`);

  if (clusterResp.status !== 200) throw new Error(`‚ùå Failed to fetch clusters (${clusterResp.status})`);

  const clusterData = await clusterResp.json();
  const clusters = clusterData?.cohesityClusters || [];
  console.log(`‚úÖ Found ${clusters.length} clusters.`);

  const results = [];

  // 2Ô∏è‚É£ Loop each cluster
  for (const c of clusters) {
    const clusterName = c.ClusterName;
    const clusterId = c.ClusterId;

    if (!clusterName || !clusterId) {
      console.log("‚ö†Ô∏è Skipping cluster with missing info.");
      continue;
    }

    console.log(`üìä Processing cluster: ${clusterName}`);

    const h = { accept: "application/json", apiKey, accessClusterId: clusterId };

    // --- Garbage Data (EstimatedGarbageBytes) ---
    const garbageBody = {
      schemaName: "ApolloV2ClusterStats",
      metricName: "EstimatedGarbageBytes",
      startTimeMsecs: "2",
      entityId: `cluster name (ID ${clusterId})`,
      rollupFunction: "latest",
      rollupIntervalSecs: "30",
      metricUnitType: "0",
      range: "day"
    };

    const garbageResp = await fetch(
      `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats`,
      {
        method: "POST",
        headers: { ...h, "content-type": "application/json" },
        body: JSON.stringify(garbageBody)
      }
    );

    if (garbageResp.status !== 200) {
      console.log(`‚ö†Ô∏è Garbage data fetch failed for ${clusterName} (${garbageResp.status})`);
      continue;
    }

    const gdata = await garbageResp.json();
    const latestPoint = gdata.dataPointVec?.slice(-1)[0];
    const bytes = latestPoint?.data?.int64Value ?? 0;
    const garbageGB = +(bytes / (1024 ** 3)).toFixed(2);
    const garbageTB = +(bytes / (1024 ** 4)).toFixed(4);

    // --- Storage Capacity ---
    const storageResp = await fetch(`${baseUrl}/irisservices/api/v1/public/stats/storage`, { headers: h });
    if (storageResp.status !== 200) {
      console.log(`‚ö†Ô∏è Storage stats fetch failed for ${clusterName} (${storageResp.status})`);
      continue;
    }

    const s = await storageResp.json();
    const totalTiB = +(s.totalCapacityBytes / oneTiB).toFixed(1);
    const usedTiB = +(s.localUsageBytes / oneTiB).toFixed(1);
    const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(1);
    const consumed = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(1);

    results.push({
      Cluster: clusterName,
      Garbage_GB: garbageGB,
      Garbage_TB: garbageTB,
      Total_TiB: totalTiB,
      Used_TiB: usedTiB,
      Available_TiB: availTiB,
      Consumed_Percent: consumed
    });

    console.log(`‚úÖ ${clusterName}: ${consumed}% used (${usedTiB}/${totalTiB} TiB), Garbage ${garbageGB} GB`);
  }

  // 3Ô∏è‚É£ Summary
  console.log("üìÑ Final Summary :");
  console.log(JSON.stringify(results, null, 2));

  // 4Ô∏è‚É£ Return to workflow result
  return { clusters: results };
}
