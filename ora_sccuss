# Define your clusters list explicitly (example with multiple clusters)
$clusters = @(
    @{ id = "cluster1-id"; name = "Cluster-A" },
    @{ id = "cluster2-id"; name = "Cluster-B" },
    @{ id = "cluster3-id"; name = "Cluster-C" }
)

$apiBase = 'https://your-api'
$apiKey  = 'YOUR_API_KEY'
$headers = @{ apiKey = $apiKey; Accept = 'application/json' }

# Store all latest successful backups per DB
$allSuccesses = @()

# Iterate through clusters and their protection groups
foreach ($cluster in $clusters) {
    $clusterId   = $cluster.id
    $clusterName = $cluster.name

    # Fetch Protection Groups with object details
    $pgUrl      = "$apiBase/clusters/$clusterId/protection-groups?includeObjectDetails=true"
    $pgResponse = Invoke-RestMethod -Uri $pgUrl -Headers $headers -Method Get
    $pgs        = $pgResponse.protectionGroups

    foreach ($pg in $pgs) {
        $pgId   = $pg.id
        $pgName = $pg.name

        # Fetch recent runs for this PG
        $runUrl = "$apiBase/protection-groups/$pgId/runs?numRuns=10"
        $runs   = (Invoke-RestMethod -Uri $runUrl -Headers $headers -Method Get).runs
        if (-not $runs) { continue }

        # Flatten backup info per DB, capturing server and database names
        $flatRuns = foreach ($run in $runs) {
            $objs       = $run.objects.object
            $serverName = if ($objs.Count -ge 1) { $objs[0].name } else { '' }
            foreach ($obj in $objs) {
                if ($obj.name -eq $serverName) { continue }
                foreach ($info in $run.localBackupInfo | Where-Object { $_.objectId -eq $obj.id }) {
                    [PSCustomObject]@{
                        Cluster         = $clusterName
                        ProtectionGroup = $pgName
                        ServerName      = $serverName
                        DBName          = $obj.name
                        RunType         = $info.runType
                        Status          = $info.status
                        StartTime       = ([datetime]"1970-01-01".AddMilliseconds($info.startTimeUsecs/1000)).ToString("yyyy-MM-dd HH:mm")
                        EndTime         = ([datetime]"1970-01-01".AddMilliseconds($info.endTimeUsecs/1000)).ToString("yyyy-MM-dd HH:mm")
                    }
                }
            }
        }

        # Select only successful runs
        $successes = $flatRuns | Where-Object { $_.Status -in @('Succeeded','SucceededWithWarning') }
        if (-not $successes) { continue }

        # Group by DBName and RunType and pick the latest
        $grouped = $successes | Group-Object DBName, RunType
        foreach ($g in $grouped) {
            $latest = $g.Group | Sort-Object EndTime -Descending | Select-Object -First 1
            $allSuccesses += $latest
        }
    }
}

# Output latest successful backups per DB
if ($allSuccesses.Count -gt 0) {
    Write-Host "=== Latest Successful Backups per DB ==="
    $allSuccesses | Format-Table Cluster, ProtectionGroup, ServerName, DBName, RunType, Status, StartTime, EndTime -AutoSize
} else {
    Write-Host "No successful backups found."
}


# 0) Drop both CSVs in one folder
$dir = 'C:\drop'         # change me
$t1  = Import-Csv (Join-Path $dir 'first.csv')   # from API 1 (must have DBName)
$t2  = Import-Csv (Join-Path $dir 'second.csv')  # from API 2 (must have DBName)

# 1) Build a case-insensitive lookup on table 2 by DBName
$ix = New-Object System.Collections.Hashtable ([StringComparer]::OrdinalIgnoreCase)
$t2 | ForEach-Object { if ($_.DBName) { $ix[$_.DBName] = $_ } }

# 2) LEFT JOIN t1 with t2 on DBName and export
$merged =
$t1 | ForEach-Object {
  $b = if ($_.DBName) { $ix[$_.DBName] }
  # Generic merge: keep all t1 props; add t2 props (prefix collisions with t2_)
  $h = [ordered]@{}
  $_.psobject.Properties | ForEach-Object { $h[$_.Name] = $_.Value }
  if ($b) {
    $b.psobject.Properties | ForEach-Object {
      if ($h.Contains($_.Name)) { $h["t2_$($_.Name)"] = $_.Value } else { $h[$_.Name] = $_.Value }
    }
  }
  [pscustomobject]$h
}

$merged | Export-Csv (Join-Path $dir 'merged.csv') -NoTypeInformation
Write-Host "Done â†’ $(Join-Path $dir 'merged.csv')"
 
