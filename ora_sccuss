# Inputs
$dir = 'C:\drop'
$t1  = Import-Csv (Join-Path $dir 'first.csv')
$t2  = Import-Csv (Join-Path $dir 'second.csv')

# Case-insensitive lookup on DBName for table 2
$ix = New-Object System.Collections.Hashtable ([StringComparer]::OrdinalIgnoreCase)
$t2 | ForEach-Object { if ($_.DBName) { $ix[$_.DBName] = $_ } }

# LEFT JOIN, skipping DBName from t2 to avoid t2_DBName
$merged =
$t1 | ForEach-Object {
  $b = if ($_.DBName) { $ix[$_.DBName] }

  $h = [ordered]@{}
  $_.psobject.Properties | ForEach-Object { $h[$_.Name] = $_.Value }

  if ($b) {
    $b.psobject.Properties | ForEach-Object {
      if ($_.Name -eq 'DBName') { return } # <-- skip DBName from t2
      if ($h.Contains($_.Name)) { $h["t2_$($_.Name)"] = $_.Value } else { $h[$_.Name] = $_.Value }
    }
  }

  [pscustomobject]$h
}

# Build a column order with DBName as the SECOND column
$props = ($merged | Select-Object -First 1 | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name)
$first = ($props | Where-Object { $_ -ne 'DBName' } | Select-Object -First 1)
$order = @()
if ($first) { $order += $first }
$order += 'DBName'
$order += ($props | Where-Object { $_ -ne $first -and $_ -ne 'DBName' -and $_ -ne 't2_DBName' })

# Show nicely and export
$merged |
  Select-Object $order |
  Tee-Object -Variable mergedOut |
  Export-Csv (Join-Path $dir 'merged.csv') -NoTypeInformation

Write-Host "Done â†’ $(Join-Path $dir 'merged.csv')" -ForegroundColor Green
$mergedOut | Format-Table -AutoSize
