# === ONE-RUN, ONE-TABLE (JOINED BY DBName) ===
$apikey = Read-Host "Enter Your API Key"
$clustersAvailable = @(
    "8823423-23423-23423-23434 whatever"
    "052248592834423 whatever"
)

$oneGiB  = 1073741824
$regRows = @()   # Script 1 rows (registration / DB attributes)
$pgRows  = @()   # Script 2 rows (PG/policy/host info)

foreach ($cluster in $clustersAvailable) {
    $cluster_id, $cluster_name = $cluster -split " "
    $headers = @{
        apiKey          = $apikey
        accessClusterId = $cluster_id
    }

    # ---------- Script 1 (DB attributes) ----------
    # Use kOracle and pass flags as query params (GET body is often ignored)
    $uri1 = "https://helios.cohesity.com/irisservices/api/v1/public/protectionSources/registrationInfo" +
            "?environments=kOracle&includeDBApplicationInfo=true&includeApplicationsTreeInfo=true" +
            "&allUnderHierarchy=true&includeData=true"

    $json1 = (Invoke-WebRequest -Method Get -Uri $uri1 -Headers $headers).Content | ConvertFrom-Json

    # Safely walk arrays to reach oracleProtectionSource nodes
    $db_nodes = @()
    foreach ($root in ($json1.rootNodes | Where-Object { $_ })) {
      foreach ($app in ($root.applications | Where-Object { $_ })) {
        foreach ($ati in ($app.applicationTreeInfo | Where-Object { $_ })) {
          $ora = $ati.protectionSource.oracleProtectionSource
          if ($ora) { $db_nodes += $ora }
        }
      }
    }

    foreach ($node in $db_nodes) {
        # CPU_Count: keep your original source path; add a display fallback so it never appears blank
        $cpu = (@($node.hosts.cpuCount) -join ',')
        if ([string]::IsNullOrWhiteSpace($cpu)) { $cpu = 'N/A' }
        # DbHome: collect like CPU_Count, join if multiple, fallback to N/A
        $DbHome = (@($node.hosts.sessions.location) -join ',')
        
        if ([string]::IsNullOrWhiteSpace($DbHome)) { $DbHome = 'N/A' }

        $regRows += [PSCustomObject]@{
            Cluster            = $cluster_name
            DBName             = $node.databaseUniqueName
            DBVersion          = $node.version
            ArchiveLog_Enabled = $node.archiveLogEnabled
            BCT_Enabled       = $node.bctEnabled
            DB_Type            = $node.dbType
            DB_Size_in_GB      = [math]::Round(((@($node.size) | ForEach-Object { $_ }) / $oneGiB), 4)
            DB_Instances       = @($node.hosts.sessions.systemIdentifier) -join ','
            CPU_Count          = $cpu
            DB_Home           = $DbHome
            SharedPool_Size    = $node.sgaTargetSize
            Fragment_Size      = $node.sharedPoolSize
            FRA_Size_in_GB     = [math]::Round(((@($node.fraSize) | ForEach-Object { $_ }) / $oneGiB), 4)
        }
    }

    # ---------- Script 2 (PG/Policy/Host) ----------
    # Also kOracle here; note includeLastRunInfo (singular 'include')
    $uri2 = "https://helios.cohesity.com/v2/data-protect/protection-groups" +
            "?environments=kOracle&isDeleted=false&isActive=true&includeLastRunInfo=true"

    $json2 = (Invoke-WebRequest -Method Get -Uri $uri2 -Headers $headers).Content | ConvertFrom-Json

    foreach ($dbd in ($json2.protectionGroups | Where-Object { $_ })) {
        foreach ($channels in ($dbd.oracleParams.objects | Where-Object { $_ })) {
            foreach ($channel in ($channels.dbParams.dbChannels | Where-Object { $_ })) {
                $policyName = (
                    Invoke-RestMethod -Uri "https://helios.cohesity.com/v2/data-protect/policies?ids=$($dbd.policyId)" `
                                      -Headers $headers -Method Get -ErrorAction Stop
                ).policies | Where-Object { $_.id -eq $dbd.policyId } | Select-Object -ExpandProperty name -First 1

                # --- Hostname EXACT as you wrote it ---
                $HostName = $(
                    try {
                        $hostId     = $channel.databaseNodeList.hostId
                        $ipAPIurl   = "https://helios.cohesity.com/v2/data-protect/objects/$hostId"
                        $ipResponse = Invoke-WebRequest -Method Get -Uri $ipAPIurl -Headers $headers
                        $ipJson     = $ipResponse.Content | ConvertFrom-Json
                        $ip         = $ipJson.name
                        [system.net.dns]::GetHostEntry($ip).HostName
                    }
                    catch { $nameOrIp = $ip }   # kept EXACT â€” no value emitted on failure
                )

                $pgRows += [PSCustomObject]@{
                    Cluster            = $cluster_name
                    PGName             = $dbd.name
                    PolicyName         = $policyName
                    SourceName         = $channels.SourceName
                    DBName             = $channel.databaseUniqueName
                    PersistMountPoints = $dbd.oracleParams.persistMountPoints
                    LogRetentionDays   = $channel.archiveLogRetentionDays
                    ChannelCount       = $channel.databaseNodeList.ChannelCount
                    Port               = $channel.databaseNodeList.port
                    HostName           = $HostName
                }
            }
        }
    }
}

# ---------- JOIN BOTH OUTPUTS BY DBName (case-insensitive) ----------
$ix = New-Object System.Collections.Hashtable ([StringComparer]::OrdinalIgnoreCase)
foreach ($r in $pgRows) { $ix[$r.DBName] = $r }

$final = @()

# Left join: all DBs from Script 1, enrich with Script 2 when present
foreach ($a in $regRows) {
    $b = $ix[$a.DBName]
    $final += [PSCustomObject]@{
        Cluster            = $a.Cluster
        DBName             = $a.DBName
        HostName           = if ($b) { $b.HostName } else { "" }
        PGName             = if ($b) { $b.PGName } else { "" }
        PolicyName         = if ($b) { $b.PolicyName } else { "" }
        SourceName         = if ($b) { $b.SourceName } else { "" }
        PersistMountPoints = if ($b) { $b.PersistMountPoints } else { "" }
        LogRetentionDays   = if ($b) { $b.LogRetentionDays } else { "" }
        ChannelCount       = if ($b) { $b.ChannelCount } else { "" }
        Port               = if ($b) { $b.Port } else { "" }

        DBVersion          = $a.DBVersion
        ArchiveLog_Enabled = $a.ArchiveLog_Enabled
        BCT_Enabled       = $a.BCT_Enabled
        DB_Type            = $a.DB_Type
        DB_Size_in_GB      = $a.DB_Size_in_GB
        DB_Instances       = @($a.DB_Instances) -join ','
        CPU_Count          = @($a.CPU_Count) -join ','
        DB_Home           = @($a.DB_Home) -join ','
        SharedPool_Size    = $a.SharedPool_Size
        Fragment_Size      = $a.Fragment_Size
        FRA_Size_in_GB     = $a.FRA_Size_in_GB
    }
}

# (Optional) include DBs that exist only in Script 2 but not in Script 1
$onlyInPg = $pgRows | Where-Object { -not ($regRows.DBName -contains $_.DBName) }
foreach ($b in $onlyInPg) {
    $final += [PSCustomObject]@{
        Cluster            = $b.Cluster
        DBName             = $b.DBName
        HostName           = $b.HostName
        PGName             = $b.PGName
        PolicyName         = $b.PolicyName
        SourceName         = $b.SourceName
        PersistMountPoints = $b.PersistMountPoints
        LogRetentionDays   = $b.LogRetentionDays
        ChannelCount       = $b.ChannelCount
        Port               = $b.Port

        DBVersion          = ""
        ArchiveLog_Enabled = ""
        BCT_Enabled       = ""
        DB_Type            = ""
        DB_Size_in_GB      = ""
        DB_Instances       = ""
        CPU_Count          = ""
        DB_Home           = ""
        SharedPool_Size    = ""
        Fragment_Size      = ""
        FRA_Size_in_GB     = ""
    }
}

# ---------- ONE CLEAN TABLE (aligned by DBName) ----------
$final = $final | Sort-Object Cluster, DBName

# Explicit columns with labels to avoid any header/value confusion
$colsDef = @(
  @{Label='Cluster';            Expression = { $_.Cluster } },
  @{Label='DBName';             Expression = { $_.DBName } },
  @{Label='HostName';           Expression = { $_.HostName } },
  @{Label='PGName';             Expression = { $_.PGName } },
  @{Label='PolicyName';         Expression = { $_.PolicyName } },
  @{Label='SourceName';         Expression = { $_.SourceName } },
  @{Label='PersistMountPoints'; Expression = { $_.PersistMountPoints } },
  @{Label='LogRetentionDays';   Expression = { $_.LogRetentionDays } },
  @{Label='ChannelCount';       Expression = { $_.ChannelCount } },
  @{Label='Port';               Expression = { $_.Port } },
  @{Label='DBVersion';          Expression = { $_.DBVersion } },
    @{Label='ArchiveLog_Enabled'; Expression = { $_.ArchiveLog_Enabled } },
  @{Label='BCT_Enabled';       Expression = { $_.BCT_Enabled } },
  @{Label='DB_Type';            Expression = { $_.DB_Type } },
  @{Label='DB_Size_in_GB';      Expression = { $_.DB_Size_in_GB } },
  @{Label='DB_Instances';       Expression = { $_.DB_Instances } },
    @{Label='CPU_Count';          Expression = { $_.CPU_Count } },  @{Label='DB_Home';            Expression = { $_.DB_Home } },

  @{Label='SharedPool_Size';    Expression = { $_.SharedPool_Size } },
  @{Label='Fragment_Size';      Expression = { $_.Fragment_Size } },
  @{Label='FRA_Size_in_GB';     Expression = { $_.FRA_Size_in_GB } }
)

# Optional: widen console buffer for long single-line rows (ignored in some hosts)
try { $raw = $Host.UI.RawUI; $raw.BufferSize = New-Object Management.Automation.Host.Size (10000, $raw.BufferSize.Height) } catch {}

$txt = $final | Format-Table -Property $colsDef -AutoSize | Out-String -Width 10000
$txt

# ----- Optional helpers -----
# Out-GridView for interactive view
# $final | Select-Object * | Out-GridView -Title 'Oracle DB Combined'

# Export to CSV (same visual order)
# $stamp = Get-Date -Format 'yyyy-MM-dd_HHmm'
# $final | Select-Object ($colsDef | ForEach-Object { $_.Label }) | Export-Csv "C:\Cohesity_API\Logs\Oracle_DB_Combined_$stamp.csv" -NoTypeInformation
# Debug a single row to verify CPU/Instances/DB_Home values
# $final | Select-Object DBName, DB_Instances, CPU_Count, DB_Home | Select-Object -First 1 | Format-List *
