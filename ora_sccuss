$dir = 'C:\drop'
$t1  = Import-Csv (Join-Path $dir 'first.csv')
$t2  = Import-Csv (Join-Path $dir 'second.csv')

# normalize keys (trim + case-insensitive); skip rows missing DBName
$t1 = $t1 | ForEach-Object { if ($_.DBName) { $_ | Add-Member _Key ($_.DBName.Trim().ToLower()) -Force }; $_ }
$t2 = $t2 | ForEach-Object { if ($_.DBName) { $_ | Add-Member _Key ($_.DBName.Trim().ToLower()) -Force }; $_ }

# index by key
$ix1 = @{}; $t1 | Where-Object { $_._Key } | ForEach-Object { $ix1[$_._Key] = $_ }
$ix2 = @{}; $t2 | Where-Object { $_._Key } | ForEach-Object { $ix2[$_._Key] = $_ }

# union of keys (FULL OUTER)
$keys = @{}
$ix1.Keys | ForEach-Object { $keys[$_] = $true }
$ix2.Keys | ForEach-Object { $keys[$_] = $true }

# merge rows; keep DBName once; keep all other columns; collisions from t2 → t2_<name>
$merged = foreach ($k in $keys.Keys) {
  $a = $ix1[$k]; $b = $ix2[$k]
  $h = [ordered]@{}

  # Prefer DBName from t1 if present, else from t2
  $h['DBName'] = if ($a) { $a.DBName } else { $b.DBName }

  if ($a) {
    $a.psobject.Properties | ForEach-Object {
      if ($_.Name -notin @('_Key','DBName')) { $h[$_.Name] = $_.Value }
    }
  }
  if ($b) {
    $b.psobject.Properties | ForEach-Object {
      if ($_.Name -in @('_Key','DBName')) { return }
      if ($h.Contains($_.Name)) { $h["t2_$($_.Name)"] = $_.Value } else { $h[$_.Name] = $_.Value }
    }
  }
  [pscustomobject]$h
}

# Show EVERYTHING on screen (no columns hidden) and still export full CSV if you want
$csvPath = Join-Path $dir 'merged.csv'
$merged | Tee-Object -Variable mergedOut | Export-Csv $csvPath -NoTypeInformation
Write-Host "Merged → $csvPath" -ForegroundColor Green

# Display: vertical per row so all properties are visible in console
$mergedOut | Sort-Object DBName | Format-List *
# Optional GUI grid (shows all columns clearly on Windows):
# $mergedOut | Out-GridView -Title 'Merged by DBName'
