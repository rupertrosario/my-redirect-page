$dir = 'C:\drop'
$t1  = Import-Csv (Join-Path $dir 'first.csv')
$t2  = Import-Csv (Join-Path $dir 'second.csv')

function Norm([string]$s){ if($s){ $s.Trim().ToLower() } }

# Index by normalized DBName
$ix1=@{}; foreach($r in $t1){ $k=Norm $r.DBName; if($k){ $ix1[$k]=$r } }
$ix2=@{}; foreach($r in $t2){ $k=Norm $r.DBName; if($k){ $ix2[$k]=$r } }

# Union of keys (so rows from second-only are kept too)
$allKeys = @($ix1.Keys + $ix2.Keys) | Sort-Object -Unique

# Merge: keep DBName once; on name clashes, t2_* gets prefixed so nothing is dropped
$merged = foreach($k in $allKeys){
  $a = $ix1[$k]; $b = $ix2[$k]
  $db = if($a){ $a.DBName } else { $b.DBName }
  $h = [ordered]@{ DBName = $db }

  if($a){
    foreach($p in $a.psobject.Properties){
      if($p.Name -ne 'DBName'){
        if(-not $h.Contains($p.Name)){ $h[$p.Name]=$p.Value } else { $h["t1_$($p.Name)"]=$p.Value }
      }
    }
  }
  if($b){
    foreach($p in $b.psobject.Properties){
      if($p.Name -ne 'DBName'){
        if($h.Contains($p.Name)){ $h["t2_$($p.Name)"]=$p.Value } else { $h[$p.Name]=$p.Value }
      }
    }
  }
  [pscustomobject]$h
}

# PRINT everything (vertical view avoids hidden columns)
$merged | Sort-Object DBName | Format-List *
