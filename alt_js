import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) AUTH (vault-name -> vault-id -> manual)
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    let found = null;
    for (let i = 0; i < (all.credentials || []).length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  const commonHeaders = { accept: "application/json", apiKey };

  // ------------------------------
  // 2) USER OPTIONS (match your PowerShell)
  // ------------------------------
  const AlertTypes = ["11001", "1105"];     // add more: ["11001","1105","XXXXX"]
  const AlertStates = ["kOpen"];           // or ["kOpen","kNote"]
  const AlertCategories = [];              // optional e.g. ["kNodeHealth","kNetworking"]
  const MaxAlerts = 200;

  const NodeIds = []; // optional filter list like ["1","2","3"]

  // ------------------------------
  // 3) HELPERS
  // ------------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }

  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      const v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) {
        // PowerShell uses comma-separated for these; Helios accepts comma-separated
        usp.append(k, v.join(","));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  function getProp(propertyList, keys) {
    const plist = Array.isArray(propertyList) ? propertyList : [];
    for (let k = 0; k < keys.length; k++) {
      const key = keys[k];
      for (let i = 0; i < plist.length; i++) {
        const p = plist[i] || {};
        if (norm(p.key) !== key) continue;
        if (p.value) return p.value;
        if (p.values) return p.values;
      }
    }
    return null;
  }

  // ET last 24 hours -> usecs
  function toUsecs(d) { return Math.floor(d.getTime() * 1000); } // ms -> usecs
  const now = new Date();
  const endUsecs = toUsecs(now);
  const startUsecs = toUsecs(new Date(now.getTime() - (24 * 60 * 60 * 1000)));

  function usecsToEtString(usecs) {
    if (!usecs) return "";
    const ms = Math.floor(Number(usecs) / 1000); // usecs -> ms
    if (!Number.isFinite(ms)) return "";
    return new Date(ms).toLocaleString("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    });
  }

  // ------------------------------
  // 4) GET CLUSTERS + BUILD LOCATION MAP
  // ------------------------------
  const clusterData = await getJson(baseUrl + "/v2/mcm/cluster-mgmt/info", commonHeaders);
  const clusters = toArrayMaybe(clusterData && clusterData.cohesityClusters);
  if (!clusters.length) throw new Error("No clusters returned from Helios.");

  // Map clusterId -> {name, location}
  const clusterMap = {};
  for (let i = 0; i < clusters.length; i++) {
    const c = clusters[i] || {};
    const cid = norm(c.clusterId);
    if (!cid) continue;

    // location can be string or object depending on tenant/version
    const locRaw = c.location;
    let loc = "";
    if (typeof locRaw === "string") loc = locRaw;
    else if (locRaw && typeof locRaw === "object") {
      // try common fields
      loc =
        norm(locRaw.name) ||
        norm(locRaw.city) ||
        norm(locRaw.site) ||
        norm(locRaw.region) ||
        "";
    }

    clusterMap[cid] = {
      ClusterName: norm(c.clusterName),
      Location: loc,
      ClusterLocationRaw: locRaw || null
    };
  }

  // ------------------------------
  // 5) FETCH ALERTS PER CLUSTER
  // ------------------------------
  const q = buildQuery({
    maxAlerts: MaxAlerts,
    alertTypes: AlertTypes,
    alertStates: AlertStates,
    ...(AlertCategories.length ? { alertCategories: AlertCategories } : {}),
    startDateUsecs: startUsecs,
    endDateUsecs: endUsecs
  });

  const results = [];

  for (let ci = 0; ci < clusters.length; ci++) {
    const clus = clusters[ci] || {};
    const clusterId = norm(clus.clusterId);
    if (!clusterId) continue;

    const meta = clusterMap[clusterId] || {};
    const clusterName = meta.ClusterName || norm(clus.clusterName);
    const location = meta.Location || "";

    const headers = {
      accept: "application/json",
      apiKey,
      accessClusterId: clusterId
    };

    const alertsUrl = baseUrl + "/v2/alerts?" + q;

    let aData;
    try {
      aData = await getJson(alertsUrl, headers);
    } catch (e) {
      // keep going, one cluster failing shouldn't kill the workflow
      console.log("⚠️ Alerts fetch failed for " + clusterName + " (" + clusterId + "): " + norm(e.message || e));
      continue;
    }

    const alerts = toArrayMaybe(aData && aData.alerts);
    for (let ai = 0; ai < alerts.length; ai++) {
      const alt = alerts[ai] || {};

      const latestUsecs = Number(alt.latestTimestampUsecs || 0);
      if (!latestUsecs) continue;

      // enforce 24h locally too (matches your PS behavior)
      if (latestUsecs < startUsecs || latestUsecs > endUsecs) continue;

      const nodeId = getProp(alt.propertyList, ["node_id", "nodeId"]);
      const ip = getProp(alt.propertyList, ["node_ip", "ip", "ipAddress", "host_ip", "source_ip", "sourceIp", "remote_ip", "remoteIp"]);

      if (NodeIds.length && nodeId && !NodeIds.includes(String(nodeId))) continue;

      results.push({
        ClusterName: clusterName,
        ClusterId: clusterId,
        Location: location,                 // ✅ ADDED
        ClusterNodeId: nodeId ? String(nodeId) : "",
        IP: Array.isArray(ip) ? (ip[0] ? String(ip[0]) : "") : (ip ? String(ip) : ""),
        AlertCode: norm(alt.alertCode),
        Severity: norm(alt.severity),
        AlertState: norm(alt.alertState),
        AlertCause: norm(alt.alertDocument && alt.alertDocument.alertCause),
        LatestTimeET: usecsToEtString(latestUsecs),
        LatestUsecs: latestUsecs
      });
    }
  }

  // ------------------------------
  // 6) LATEST PER (ClusterId + NodeId) like your PS
  // ------------------------------
  const best = {};
  for (let i = 0; i < results.length; i++) {
    const r = results[i];
    if (!r.ClusterNodeId) continue;
    const k = r.ClusterId + "|" + r.ClusterNodeId;
    if (!best[k] || (r.LatestUsecs > best[k].LatestUsecs)) best[k] = r;
  }

  const latestPerClusterNode = Object.values(best).sort((a, b) => (b.LatestUsecs || 0) - (a.LatestUsecs || 0));

  return {
    authMode,
    count: latestPerClusterNode.length,
    results: latestPerClusterNode
  };
}
