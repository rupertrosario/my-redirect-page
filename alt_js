// ------------------------------------------------------------
// Dynatrace JS | Cohesity Helios Alerts (GET only)
// Matches your PowerShell logic:
//
// - Multiple alertTypes (comma-separated in URL)
// - Optional alertCategories, alertStates
// - Optional filter to multiple node_ids
// - Window: last 24 hours in ET, enforced locally via latestTimestampUsecs
// - Latest per (ClusterId + NodeId)
// - Output: table with IP + human readable ET time (no truncation)
//
// Output:
// {
//   authMode,
//   windowStartET,
//   windowEndET,
//   totalRowsCollected,
//   results: [
//     { ClusterName, ClusterId, ClusterNodeId, IP, AlertCode, Severity, AlertState, AlertCause, LatestTimeET, LatestUsecs }
//   ],
//   markdownTable
// }
// ------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  var baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) Auth (vault name -> vault id -> manual)
  // ------------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId   = "credentials_vault-312312";

  var apiKey   = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    var creds = (all && all.credentials) ? all.credentials : [];
    var found = null;
    for (var i = 0; i < creds.length; i++) {
      if (creds[i] && creds[i].name === name) { found = creds[i]; break; }
    }
    if (!found) return null;

    var detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      var d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
      console.log("✓ Helios key from vault (id): " + (d2 && d2.name ? d2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE"; // last resort
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  // ------------------------------
  // 2) User options (edit here)
  // ------------------------------
  var AlertTypes      = ["11001", "1105"];   // edit as needed
  var AlertStates     = ["kOpen"];           // or ["kOpen","kNote"]
  var AlertCategories = [];                  // optional; e.g. ["kNodeHealth","kNetworking"]
  var MaxAlerts       = 200;

  var NodeIds         = [];                  // optional; e.g. ["1","2","3"]

  // ------------------------------
  // 3) Helpers
  // ------------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }

  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  function buildQuery(params) {
    var q = [];

    function add(k, v) {
      if (v === undefined || v === null) return;
      var s = String(v).trim();
      if (!s) return;
      q.push(encodeURIComponent(k) + "=" + encodeURIComponent(s));
    }

    // We build comma-separated like your PowerShell Join-Query
    if (params.maxAlerts != null) add("maxAlerts", params.maxAlerts);

    if (params.alertTypes && params.alertTypes.length) {
      add("alertTypes", params.alertTypes.join(","));
    }
    if (params.alertStates && params.alertStates.length) {
      add("alertStates", params.alertStates.join(","));
    }
    if (params.alertCategories && params.alertCategories.length) {
      add("alertCategories", params.alertCategories.join(","));
    }

    // include time window in query (like your PS) – still enforce locally too
    if (params.startDateUsecs != null) add("startDateUsecs", params.startDateUsecs);
    if (params.endDateUsecs != null) add("endDateUsecs", params.endDateUsecs);

    return q.join("&");
  }

  async function getJson(url, headers) {
    var resp = await fetch(url, { method: "GET", headers: headers });
    if (!resp.ok) {
      var txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  // ET human time (no timezone suffix) like your PS string
  function usecsToEtString(usecs) {
    if (!usecs) return null;

    // Helios timestamps are microseconds
    var ms = Number(usecs) / 1000;
    if (!Number.isFinite(ms)) return null;

    return new Date(ms).toLocaleString("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    }).replace(",", "");
  }

  // Get a property from propertyList by trying multiple keys
  function getProp(plist, keys) {
    if (!plist || !Array.isArray(plist)) return null;

    for (var k = 0; k < keys.length; k++) {
      var keyWant = keys[k];
      for (var i = 0; i < plist.length; i++) {
        var p = plist[i] || {};
        if (norm(p.key) !== keyWant) continue;

        // value or values (sometimes array)
        if (p.value) return p.value;
        if (p.values) return p.values;
        return null;
      }
    }
    return null;
  }

  // ------------------------------
  // 4) Build ET window (last 24h) in usecs
  // ------------------------------
  var now = new Date();

  // Convert "now" to ET, then subtract 24h in ET
  function toEtDate(d) {
    // build a Date representing the same instant; formatting is ET later
    return d;
  }

  // Use epoch ms boundaries, but compute display window in ET
  var endMs = now.getTime();
  var startMs = endMs - (24 * 60 * 60 * 1000);

  var endUsecs = Math.floor(endMs * 1000);
  var startUsecs = Math.floor(startMs * 1000);

  var windowStartET = new Date(startMs).toLocaleString("en-US", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false
  }).replace(",", "");

  var windowEndET = new Date(endMs).toLocaleString("en-US", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false
  }).replace(",", "");

  // ------------------------------
  // 5) Get clusters
  // ------------------------------
  var commonHeaders = { accept: "application/json", apiKey: apiKey };

  var clusterUri = baseUrl + "/v2/mcm/cluster-mgmt/info";
  var clusterData = await getJson(clusterUri, commonHeaders);
  var clusters = toArrayMaybe(clusterData && clusterData.cohesityClusters);

  if (!clusters.length) {
    return {
      authMode: authMode,
      windowStartET: windowStartET,
      windowEndET: windowEndET,
      totalRowsCollected: 0,
      results: [],
      markdownTable: "⚠️ No clusters returned from /v2/mcm/cluster-mgmt/info"
    };
  }

  // ------------------------------
  // 6) Build alerts query
  // ------------------------------
  var q = buildQuery({
    maxAlerts: MaxAlerts,
    alertTypes: AlertTypes,
    alertStates: AlertStates,
    alertCategories: AlertCategories,
    startDateUsecs: startUsecs,
    endDateUsecs: endUsecs
  });

  // IMPORTANT: query is same for all clusters; accessClusterId changes per cluster
  var alertsUrl = baseUrl + "/v2/alerts?" + q;

  // ------------------------------
  // 7) Fetch per cluster and collect rows
  // ------------------------------
  var rows = [];

  for (var ci = 0; ci < clusters.length; ci++) {
    var clus = clusters[ci] || {};
    var clusterName = norm(clus.clusterName);
    var clusterId = norm(clus.clusterId);

    if (!clusterId) continue;

    var headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: clusterId
    };

    var aData;
    try {
      aData = await getJson(alertsUrl, headers);
    } catch (e) {
      console.log("⚠️ Alerts fetch failed for cluster " + clusterName + " (" + clusterId + "): " + norm(e.message || e));
      continue;
    }

    var alerts = toArrayMaybe(aData && aData.alerts);
    if (!alerts.length) continue;

    for (var ai = 0; ai < alerts.length; ai++) {
      var alt = alerts[ai] || {};

      // Enforce last 24h locally using latestTimestampUsecs
      var latestUsecs = Number(alt.latestTimestampUsecs || 0);
      if (!latestUsecs) continue;
      if (latestUsecs < startUsecs || latestUsecs > endUsecs) continue;

      var plist = alt.propertyList || [];

      // Node ID
      var nodeId = getProp(plist, ["node_id", "nodeId"]);
      if (Array.isArray(nodeId)) nodeId = nodeId.length ? nodeId[0] : null;
      nodeId = norm(nodeId);

      // IP
      var ip = getProp(plist, ["node_ip","ip","ipAddress","host_ip","source_ip","sourceIp","remote_ip","remoteIp"]);
      if (Array.isArray(ip)) ip = ip.length ? ip[0] : null;
      ip = norm(ip);

      // Optional node filter
      if (NodeIds.length && nodeId) {
        var match = false;
        for (var ni = 0; ni < NodeIds.length; ni++) {
          if (String(NodeIds[ni]) === nodeId) { match = true; break; }
        }
        if (!match) continue;
      }

      rows.push({
        ClusterName: clusterName,
        ClusterId: clusterId,
        ClusterNodeId: nodeId,
        IP: ip,
        AlertCode: norm(alt.alertCode),
        Severity: norm(alt.severity),
        AlertState: norm(alt.alertState),
        AlertCause: norm(alt.alertDocument && alt.alertDocument.alertCause),
        LatestTimeET: usecsToEtString(latestUsecs),
        LatestUsecs: latestUsecs
      });
    }
  }

  // ------------------------------
  // 8) Latest per (ClusterId + NodeId), sorted newest first
  // ------------------------------
  // Key: ClusterId|ClusterNodeId
  var grouped = {};
  for (var r = 0; r < rows.length; r++) {
    var row = rows[r];
    if (!row.ClusterNodeId) continue;
    var key = row.ClusterId + "|" + row.ClusterNodeId;

    if (!grouped[key] || (row.LatestUsecs > grouped[key].LatestUsecs)) {
      grouped[key] = row;
    }
  }

  var results = Object.keys(grouped).map(function (k) { return grouped[k]; });
  results.sort(function (a, b) { return (b.LatestUsecs || 0) - (a.LatestUsecs || 0); });

  // ------------------------------
  // 9) Markdown table (optional)
  // ------------------------------
  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  function toMarkdownTable(list) {
    if (!list || !list.length) return "✅ No matching alerts in last 24 hours.";

    var cols = ["ClusterName","ClusterId","ClusterNodeId","IP","AlertCode","Severity","AlertState","AlertCause","LatestTimeET"];
    var header = "| " + cols.join(" | ") + " |";
    var sep = "| " + cols.map(function () { return "---"; }).join(" | ") + " |";

    var body = list.map(function (x) {
      return "| " + cols.map(function (c) { return safeCell(x[c]); }).join(" | ") + " |";
    });

    var intro =
      "### Cohesity Helios Alerts (latest per ClusterId + NodeId)\n\n" +
      "- Window (ET): " + windowStartET + " → " + windowEndET + "\n" +
      "- AlertTypes: " + AlertTypes.join(",") + "\n" +
      "- AlertStates: " + AlertStates.join(",") + "\n" +
      (AlertCategories.length ? ("- AlertCategories: " + AlertCategories.join(",") + "\n") : "") +
      "- Rows: " + list.length + "\n\n";

    return intro + [header, sep].concat(body).join("\n");
  }

  var markdownTable = toMarkdownTable(results);

  return {
    authMode: authMode,
    windowStartET: windowStartET,
    windowEndET: windowEndET,
    totalRowsCollected: rows.length,
    results: results,
    markdownTable: markdownTable,
    markdownEmail: markdownTable
  };
}
