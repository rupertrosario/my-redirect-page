import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ============================
  // 0) Auth (vault-name -> vault-id -> manual)
  // ============================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = (all && all.credentials) ? all.credentials : [];
    let found = null;
    for (let i = 0; i < creds.length; i++) {
      if (creds[i].name === name) { found = creds[i]; break; }
    }
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  const commonHeaders = { accept: "application/json", apiKey };

  // ============================
  // Helpers
  // ============================
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }
  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }
  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function usecsToEtString(usecs) {
    if (!usecs) return "";
    const ms = Math.floor(Number(usecs) / 1000);
    if (!Number.isFinite(ms)) return "";
    return new Date(ms).toLocaleString("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    });
  }

  function getProp(plist, keys) {
    const arr = toArrayMaybe(plist);
    for (let k = 0; k < keys.length; k++) {
      const key = keys[k];
      for (let i = 0; i < arr.length; i++) {
        const p = arr[i] || {};
        if (norm(p.key) !== key) continue;
        if (p.value) return norm(p.value);
        if (p.values) {
          if (Array.isArray(p.values)) return p.values.length ? norm(p.values[0]) : "";
          return norm(p.values);
        }
        return "";
      }
    }
    return "";
  }

  function joinCsv(arr) {
    const a = (arr || []).map(x => norm(x)).filter(Boolean);
    return a.length ? a.join(",") : "";
  }

  // ============================
  // User options (match your PS intent)
  // ============================
  const AlertTypes = ["11001", "1105"]; // add more if needed
  const AlertStates = ["kOpen"];        // or ["kOpen","kNote"]
  const AlertCategories = [];           // optional
  const MaxAlerts = 200;

  // Optional: only these node IDs
  const NodeIds = []; // e.g. ["1","2","3"]

  // ============================
  // 1) ET window last 24h in usecs (UTC)
  // ============================
  const endUsecs = Date.now() * 1000;
  const startUsecs = endUsecs - (24 * 60 * 60 * 1000000);

  // ============================
  // 2) Get clusters (need location)
  // ============================
  const clu = await getJson(baseUrl + "/v2/mcm/cluster-mgmt/info", commonHeaders);
  const clusters = toArrayMaybe(clu && clu.cohesityClusters);

  if (!clusters.length) {
    return {
      authMode,
      count: 0,
      results: [],
      markdownTable: "⚠️ No clusters returned from /v2/mcm/cluster-mgmt/info"
    };
  }

  // Build lookup: clusterId -> { name, location }
  const cluMap = {};
  for (let i = 0; i < clusters.length; i++) {
    const c = clusters[i] || {};
    const id = norm(c.clusterId);
    if (!id) continue;
    cluMap[id] = {
      ClusterName: norm(c.clusterName),
      Location: norm(c.location)
    };
  }

  // ============================
  // 3) Build alerts query (comma-separated filters)
  // ============================
  const q = [];
  q.push("maxAlerts=" + encodeURIComponent(String(MaxAlerts)));

  const at = joinCsv(AlertTypes);
  if (at) q.push("alertTypes=" + encodeURIComponent(at));

  const ast = joinCsv(AlertStates);
  if (ast) q.push("alertStates=" + encodeURIComponent(ast));

  const ac = joinCsv(AlertCategories);
  if (ac) q.push("alertCategories=" + encodeURIComponent(ac));

  q.push("startDateUsecs=" + encodeURIComponent(String(startUsecs)));
  q.push("endDateUsecs=" + encodeURIComponent(String(endUsecs)));

  const alertsBaseUrl = baseUrl + "/v2/alerts?" + q.join("&");

  // ============================
  // 4) Fetch alerts per cluster, collect rows
  // ============================
  const rows = [];

  for (let i = 0; i < clusters.length; i++) {
    const c = clusters[i] || {};
    const clusterId = norm(c.clusterId);
    if (!clusterId) continue;

    const meta = cluMap[clusterId] || {};
    const clusterName = meta.ClusterName || norm(c.clusterName);
    const location = meta.Location || norm(c.location);

    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };

    let data;
    try {
      data = await getJson(alertsBaseUrl, headers);
    } catch (e) {
      continue;
    }

    const alerts = toArrayMaybe(data && data.alerts);

    for (let j = 0; j < alerts.length; j++) {
      const alt = alerts[j] || {};
      const latestUsecs = Number(alt.latestTimestampUsecs || 0);
      if (!latestUsecs) continue;

      // local window enforcement
      if (latestUsecs < startUsecs || latestUsecs > endUsecs) continue;

      const nodeId = getProp(alt.propertyList, ["node_id", "nodeId"]);
      const ip = getProp(alt.propertyList, [
        "node_ip", "ip", "ipAddress", "host_ip",
        "source_ip", "sourceIp", "remote_ip", "remoteIp"
      ]);

      if (NodeIds.length && nodeId && !NodeIds.includes(String(nodeId))) continue;

      rows.push({
        Location: location,
        ClusterName: clusterName,
        ClusterId: clusterId,
        ClusterNodeId: nodeId,
        IP: ip,
        AlertCode: norm(alt.alertCode),
        Severity: norm(alt.severity),
        AlertState: norm(alt.alertState),
        AlertCause: norm(alt.alertDocument && alt.alertDocument.alertCause),
        LatestUsecs: latestUsecs,
        LatestTimeET: usecsToEtString(latestUsecs)
      });
    }
  }

  // ============================
  // 5) Latest per (ClusterId + NodeId)
  // ============================
  const latestMap = {};
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    if (!r.ClusterId || !r.ClusterNodeId) continue;
    const key = r.ClusterId + "|" + r.ClusterNodeId;
    if (!latestMap[key] || r.LatestUsecs > latestMap[key].LatestUsecs) latestMap[key] = r;
  }

  const latest = Object.keys(latestMap).map(k => latestMap[k]);
  latest.sort((a, b) => (b.LatestUsecs || 0) - (a.LatestUsecs || 0));

  // ============================
  // 6) Markdown
  // ============================
  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  function toMarkdownTable(arr) {
    if (!arr.length) return "✅ No alerts returned in last 24h (ET) window.";

    const cols = ["Location","ClusterName","ClusterId","ClusterNodeId","IP","AlertCode","Severity","AlertState","AlertCause","LatestTimeET"];
    const header = "| " + cols.join(" | ") + " |";
    const sep = "| " + cols.map(() => "---").join(" | ") + " |";
    const body = arr.map(r => "| " + cols.map(c => safeCell(r[c])).join(" | ") + " |");

    return "### Helios Alerts (latest per ClusterId+NodeId, last 24h ET)\n\n" + [header, sep].concat(body).join("\n");
  }

  return {
    authMode,
    count: latest.length,
    results: latest,
    markdownTable: toMarkdownTable(latest)
  };
}
