# process commandline arguments
[CmdletBinding()]
param (
    [Parameter()][string]$vip = 'helios.cohesity.com',
    [Parameter()][string]$username = 'helios',
    [Parameter()][string]$domain = 'local',
    [Parameter()][string]$tenant = $null,
    [Parameter()][switch]$useApiKey,
    [Parameter()][string]$password = $null,
    [Parameter()][switch]$noPrompt,
    [Parameter()][switch]$mcm,
    [Parameter()][string]$mfaCode = $null,
    [Parameter()][string]$clusterName = $null,

    [Parameter()][int]$numRuns = 100,
    [Parameter()][int]$days = 35,
    [Parameter()][int]$failureCount = 3,

    [Parameter()][string]$smtpServer,
    [Parameter()][string]$smtpPort = 25,
    [Parameter()][array]$sendTo,
    [Parameter()][string]$sendFrom
)

# --- cohesity API helper ---
. $(Join-Path -Path $PSScriptRoot -ChildPath cohesity-api.ps1)

# --- authenticate ---
apiauth -vip $vip -username $username -domain $domain -passwd $password `
    -apiKeyAuthentication $useApiKey -mfaCode $mfaCode `
    -heliosAuthentication $mcm -tenant $tenant -noPromptForPassword $noPrompt

if($USING_HELIOS -and -not $clusterName){
    Write-Host "Please provide -clusterName when connecting through helios" -ForegroundColor Yellow
    exit 1
}

if(!$cohesity_api.authorized){
    Write-Host "Not authenticated" -ForegroundColor Yellow
    exit 1
}

# --- main analysis function ---
function Analyze-RunsForJob {
    param(
        [Parameter(Mandatory=$true)]$Job,
        [Parameter(Mandatory=$true)][string]$RunTypesCsv,
        [Parameter(Mandatory=$true)][int64]$StartUsecs,
        [Parameter(Mandatory=$true)][int]$NumRuns,
        [Parameter(Mandatory=$true)][int]$FailureCount,
        [Parameter(Mandatory=$true)]$Failures,
        [Parameter(Mandatory=$true)]$Messages,
        [Parameter(Mandatory=$true)]$FailureTime,
        [Parameter(Mandatory=$true)]$LatestSuccessUsecs,
        [Parameter(Mandatory=$true)]$ConsecutiveFails,
        [Parameter(Mandatory=$true)]$SourceMap
    )

    $uri = "data-protect/protection-groups/$($Job.id)/runs?numRuns=$NumRuns&startTimeUsecs=$StartUsecs&includeObjectDetails=true&runTypes=$RunTypesCsv"
    $runs = api get -v2 $uri
    if(-not $runs.runs){ return }

    $jobName = $Job.name
    $env = $Job.environment

    # sort oldest to newest for accurate streak detection
    $runsSorted = $runs.runs | Sort-Object { $_.localBackupInfo.startTimeUsecs } -Ascending

    $streakData = @{}

    foreach($run in $runsSorted){
        foreach($object in $run.objects){
            if($object.object.environment -ne $env){ continue }

            $objName = $object.object.name
            $sourceName = if($object.object.PSObject.Properties['sourceId']){
                $id = $object.object.sourceId
                if($SourceMap.ContainsKey($id)){ $SourceMap[$id] } else { $id }
            } else { $objName }

            $key = "$jobName;;$objName;;$sourceName;;$RunTypesCsv"

            if(-not $streakData.ContainsKey($key)){
                $streakData[$key] = [ordered]@{
                    ConsecutiveFails = 0
                    LastSuccessUsecs = $null
                    LatestFailureUsecs = $null
                    Message = $null
                }
            }

            $status = $object.localSnapshotInfo.snapshotInfo.status

            switch ($status) {
                'kSuccess' {
                    $streakData[$key].ConsecutiveFails = 0
                    $streakData[$key].LastSuccessUsecs = $run.localBackupInfo.startTimeUsecs
                }
                'kWarning' {
                    $streakData[$key].ConsecutiveFails = 0
                    $streakData[$key].LastSuccessUsecs = $run.localBackupInfo.startTimeUsecs
                }
                'kFailed' {
                    $streakData[$key].ConsecutiveFails++
                    $streakData[$key].LatestFailureUsecs = $run.localBackupInfo.startTimeUsecs
                    $streakData[$key].Message = $object.localSnapshotInfo.failedAttempts[0].message
                }
            }
        }
    }

    foreach($k in $streakData.Keys){
        $data = $streakData[$k]
        if($data.ConsecutiveFails -ge $FailureCount){
            # only report if no success after last failure
            if(($null -eq $data.LastSuccessUsecs) -or ($data.LastSuccessUsecs -lt $data.LatestFailureUsecs)){
                $Failures[$k] = $true
                $Messages[$k] = $data.Message
                $FailureTime[$k] = $data.LatestFailureUsecs
                $LatestSuccessUsecs[$k] = $data.LastSuccessUsecs
                $ConsecutiveFails[$k] = $data.ConsecutiveFails
            }
        }
    }
}

# --- output prep ---
$cluster  = api get cluster
$outStamp = (Get-Date).ToString('yyyy-MM-dd_HHmmss')
$outfile  = "consecutiveFailureReport-$($cluster.name)-$outStamp.csv"

"Job Name,Last Successful Backup,Backup Type,Source,Object,ConsecutiveFailures,Message" | Out-File $outfile -Encoding UTF8

# --- get jobs, sources, timeframe ---
$jobs = api get -v2 "data-protect/protection-groups?isDeleted=false&isActive=true"
$rootNodes = api get "protectionSources/registrationInfo"
$sourceMap = @{}
foreach($node in $rootNodes.rootNodes){ $sourceMap[$node.rootNode.id] = $node.rootNode.name }

$startUsecs = timeAgo $days 'days'
$total = 0
$consoleReport = @()

foreach($job in $jobs.protectionGroups){
    $f = @{}; $m = @{}; $ft = @{}; $s = @{}; $cf = @{}
    Analyze-RunsForJob -Job $job -RunTypesCsv "kSystem,kFull,kIncremental" `
        -StartUsecs $startUsecs -NumRuns $numRuns -FailureCount $failureCount `
        -Failures $f -Messages $m -FailureTime $ft -LatestSuccessUsecs $s -ConsecutiveFails $cf -SourceMap $sourceMap

    Analyze-RunsForJob -Job $job -RunTypesCsv "kLog" `
        -StartUsecs $startUsecs -NumRuns $numRuns -FailureCount $failureCount `
        -Failures $f -Messages $m -FailureTime $ft -LatestSuccessUsecs $s -ConsecutiveFails $cf -SourceMap $sourceMap

    foreach($k in $f.Keys){
        $total++
        $jobName, $objName, $srcName, $rtype = $k -split ';;'
        $msg = ($m[$k] -replace '[\r\n,]', ';')
        if($msg.Length -gt 120){ $msg = $msg.Substring(0,120) }
        $lastSuccess = if($s[$k]){ (usecsToDate $s[$k]).ToString('yyyy-MM-dd HH:mm:ss') } else { 'Never' }

        "{0},{1},{2},{3},{4},{5},{6}" -f $jobName,$lastSuccess,$rtype,$srcName,$objName,$cf[$k],$msg | `
            Out-File -FilePath $outfile -Append -Encoding UTF8

        $consoleReport += [pscustomobject]@{
            JobName = $jobName
            Object = $objName
            Source = $srcName
            Type = $rtype
            ConsecutiveFails = $cf[$k]
            LastSuccess = $lastSuccess
        }
    }
}

Write-Host "`nTotal Consecutive Failures (3 or more in a row): $total"
Write-Host "Consecutive Failure Report saved to: $outfile`n"

if($consoleReport.Count -gt 0){
    Write-Host "--- Summary of Consecutive Failures (3 or more in a row) ---" -ForegroundColor Cyan
    $sortCriteria = @(
        @{ Expression = { $_.ConsecutiveFails }; Descending = $true }
        @{ Expression = { $_.JobName }; Descending = $false }
    )
    $consoleReport | Sort-Object @sortCriteria | Format-Table -AutoSize
}

# --- email if configured ---
if($smtpServer -and $sendFrom -and $sendTo){
    foreach($to in $sendTo){
        Send-MailMessage -From $sendFrom -To $to -SmtpServer $smtpServer -Port $smtpPort `
            -Subject "$clusterName Consecutive Failure Report ($total failures)" `
            -Body "Total Consecutive Failures (3 or more in a row): $total" `
            -Attachments $outfile -WarningAction SilentlyContinue
    }
}
