# =====================================================================
# Cohesity Helios - Consecutive Failure Report (≥3)
# Auth: API key (Helios)
# Mode: Read-only (GET only)
# Output: CSV + Console Summary
# =====================================================================

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# ---------------------------------------------------------------------
# Fixed Settings
# ---------------------------------------------------------------------
$ApiKeyPath      = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
$days            = 35
$numRuns         = 50
$failureCount    = 3
$CsvFolder       = "."
$BaseUri         = "https://helios.cohesity.com"

# ---------------------------------------------------------------------
# Authentication
# ---------------------------------------------------------------------
if (-not (Test-Path $ApiKeyPath)) { throw "API key file not found: $ApiKeyPath" }
$ApiKey = (Get-Content -Path $ApiKeyPath -Raw).Trim()
if ([string]::IsNullOrWhiteSpace($ApiKey)) { throw "API key file is empty" }

$Headers = @{ apiKey = $ApiKey }

# ---------------------------------------------------------------------
# API GET Wrapper
# ---------------------------------------------------------------------
function Invoke-HeliosGet {
    param([string]$Path, [string]$ClusterId)
    $uri = if ($Path -like "http*") { $Path } else { "$BaseUri$Path" }
    $h = @{}
    $Headers.GetEnumerator() | ForEach-Object { $h[$_.Key] = $_.Value }
    if ($ClusterId) { $h['clusterId'] = $ClusterId }

    try {
        $resp = Invoke-WebRequest -Uri $uri -Headers $h -Method GET -TimeoutSec 60
        if ($resp.Content) { return ($resp.Content | ConvertFrom-Json) } else { return $null }
    }
    catch {
        Write-Host "   Unable to reach $ClusterId for $Path" -ForegroundColor DarkGray
        return $null
    }
}

# ---------------------------------------------------------------------
# Helper Functions
# ---------------------------------------------------------------------
function UsecsToDate([long]$u) { if ($u) { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$u / 1000)).UtcDateTime } }
function TimeAgoUsecs([int]$n) { $dt = (Get-Date).ToUniversalTime().AddDays(-[double]$n); [int64]([DateTimeOffset]$dt).ToUnixTimeMilliseconds() * 1000 }

# ---------------------------------------------------------------------
# Get Clusters from Helios
# ---------------------------------------------------------------------
$clusterInfo = Invoke-HeliosGet "/v2/mcm/cluster-mgmt/info"
if (-not $clusterInfo -or -not $clusterInfo.cohesityClusters) { throw "No clusters found from Helios." }

$clusters = $clusterInfo.cohesityClusters | Sort-Object clusterName
Write-Host "`nFound $($clusters.Count) clusters in Helios.`n"

# ---------------------------------------------------------------------
# Output File
# ---------------------------------------------------------------------
$dateString = (Get-Date).ToString('yyyy-MM-dd_HHmm')
$outfileName = "ConsecutiveFailures-$dateString.csv"
"Cluster,Job Name,Last Successful Backup,Backup Type,Source Name,Object Name,ConsecutiveFails,Message" | Out-File -FilePath $outfileName -Encoding UTF8

$totalFailures = 0
$startUsecs = TimeAgoUsecs $days

# ---------------------------------------------------------------------
# Analyze Runs
# ---------------------------------------------------------------------
foreach ($c in $clusters) {
    $cid   = $c.clusterId
    $cname = $c.clusterName
    Write-Host "Analyzing cluster: $cname"

    $pgs = Invoke-HeliosGet "/v2/data-protect/protection-groups?isDeleted=false&isActive=true&includeTenants=true" $cid
    if (-not $pgs -or -not $pgs.protectionGroups) {
        Write-Host "   No protection groups." -ForegroundColor DarkGray
        continue
    }

    $rootNodes = Invoke-HeliosGet "/protectionSources/registrationInfo" $cid
    if (-not $rootNodes -or -not $rootNodes.rootNodes) { continue }

    foreach ($job in ($pgs.protectionGroups | Sort-Object name)) {
        $runs = Invoke-HeliosGet "/v2/data-protect/protection-groups/$($job.id)/runs?numRuns=$numRuns&startTimeUsecs=$startUsecs&includeTenants=true&includeObjectDetails=true&runTypes=kSystem,kFull,kIncremental" $cid
        if (-not $runs -or -not $runs.runs) { continue }

        $runsSorted = $runs.runs | Sort-Object { $_.localBackupInfo.startTimeUsecs } -Descending

        foreach ($object in ($runsSorted | ForEach-Object { $_.objects } | Where-Object { $_.object.environment -eq $job.environment })) {
            $objectName = $object.object.name
            $sourceName = if ($object.object.PSObject.Properties['sourceId']) {
                ($rootNodes.rootNodes | Where-Object { $_.rootNode.id -eq $object.object.sourceId }).rootNode.name
            } else { $objectName }

            $statusList = @()
            foreach ($r in $runsSorted) {
                $match = $r.objects | Where-Object { $_.object.name -eq $objectName }
                if ($match) { $statusList += $match.localSnapshotInfo.snapshotInfo.status }
            }

            # Count consecutive failures until first success
            $streak = 0
            foreach ($s in $statusList) {
                if ($s -eq 'kFailed') { $streak++ }
                elseif ($s -in @('kSuccess','kWarning')) { break }
            }

            if ($streak -ge $failureCount) {
                $msg = ""
                if ($object.localSnapshotInfo.failedAttempts) { $msg = $object.localSnapshotInfo.failedAttempts[0].message }
                if ($msg) { $msg = $msg.Replace("`n"," ").Replace(",",";") }
                if ($msg.Length -gt 150) { $msg = $msg.Substring(0,150) }

                $lastSuccess = ($runsSorted | ForEach-Object {
                    $_.objects | Where-Object { $_.object.name -eq $objectName -and $_.localSnapshotInfo.snapshotInfo.status -in @('kSuccess','kWarning') }
                } | Select-Object -First 1)

                $lastSuccessTime = if ($lastSuccess) {
                    (UsecsToDate $lastSuccess.parentRun.localBackupInfo.startTimeUsecs).ToString('yyyy-MM-dd HH:mm:ss')
                } else { "Never" }

                "{0},{1},{2},{3},{4},{5},{6},{7}" -f `
                    $cname, $job.name, $lastSuccessTime, "Backup", $sourceName, $objectName, $streak, $msg |
                    Out-File -FilePath $outfileName -Append -Encoding UTF8

                $totalFailures++
            }
        }
    }
}

# ---------------------------------------------------------------------
# Summary
# ---------------------------------------------------------------------
Write-Host "`nTotal Failures ≥ $failureCount: $totalFailures"
Write-Host "Output saved to: $outfileName`n"

if ($totalFailures -gt 0) {
    Import-Csv $outfileName | Sort-Object Cluster, JobName | Format-Table -AutoSize
}