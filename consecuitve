# =====================================================================
#  Cohesity Helios: Consecutive Failures Report (All or Selected Clusters)
#  Auth: API key only (no username/password)
#  Mode: Read-only (GET only)
#  Output: Combined CSV + Console Table (sorted alphabetically by Cluster)
# =====================================================================

# ---- Fixed Settings ----
$ApiKeyPath      = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
$ClusterListFile = "X:\PowerShell\Cohesity_API_Scripts\clusters.txt"
$numRuns         = 50
$days            = 35
$failureCount    = 3
$CsvFolder       = "."
$ShowTable       = $true
$ErrorActionPreference = 'Stop'

# ---- Load API key ----
if (-not (Test-Path $ApiKeyPath)) { throw "API key file not found: $ApiKeyPath" }
$ApiKey = (Get-Content -Path $ApiKeyPath -Raw).Trim()
if ([string]::IsNullOrWhiteSpace($ApiKey)) { throw "API key file is empty" }

$BaseUri = "https://helios.cohesity.com"
$Headers = @{ apiKey = $ApiKey }

# ---- API GET Wrapper ----
function Invoke-HeliosGet {
    param($Path, $ClusterId)
    $uri = if ($Path -like "http*") { $Path } else { "$BaseUri$Path" }
    $h = @{}
    $Headers.GetEnumerator() | ForEach-Object { $h[$_.Key] = $_.Value }
    if ($ClusterId) { $h['clusterId'] = $ClusterId }

    try {
        $resp = Invoke-WebRequest -Uri $uri -Headers $h -Method GET -TimeoutSec 60 -ErrorAction Stop
        if ($resp -and $resp.Content) {
            try { return ($resp.Content | ConvertFrom-Json) } catch { return $null }
        } else { return $null }
    }
    catch {
        Write-Host "Unable to reach cluster API for $ClusterId ($Path). Skipping..."
        return $null
    }
}

# ---- Helper Functions ----
function UsecsToDate([long]$u) { if ($u) { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$u / 1000)).UtcDateTime } }
function TimeAgoUsecs([int]$n) { $d = (Get-Date).ToUniversalTime().AddDays(-[double]$n); [int64]([DateTimeOffset]$d).ToUnixTimeMilliseconds() * 1000 }

# ---- Get all clusters from API ----
$cluInfo = Invoke-HeliosGet "/v2/mcm/cluster-mgmt/info"
if (-not $cluInfo -or -not $cluInfo.cohesityClusters) {
    Write-Host "No clusters returned from Helios API."
    exit
}

# Normalize cluster fields for consistent usage
$clusters = foreach ($c in $cluInfo.cohesityClusters) {
    [PSCustomObject]@{
        clusterId   = $c.clusterId
        clusterName = if ($c.PSObject.Properties['clusterName']) { $c.clusterName } else { $c.name }
        vip         = $c.vip
        status      = $c.status
    }
}

$clusters = $clusters | Sort-Object clusterName
if (-not $clusters) { Write-Host "No clusters found from Helios."; exit }

# ---- Load test file and filter ----
$TargetClusters = @()
if (Test-Path $ClusterListFile) {
    $TargetClusters = Get-Content $ClusterListFile |
        Where-Object { $_ -and $_ -notmatch '^\s*#' } |
        ForEach-Object { $_.Trim() }

    if ($TargetClusters.Count -gt 0) {
        $clusterNamesFromApi = $clusters.clusterName
        $ValidTargets = @()
        foreach ($t in $TargetClusters) {
            $match = $clusterNamesFromApi | Where-Object { $_ -ieq $t }
            if ($match) { $ValidTargets += $match }
        }

        if ($ValidTargets.Count -eq 0) {
            $available = $clusterNamesFromApi -join ', '
            Write-Host ""
            Write-Host "None of the cluster names in $ClusterListFile match those in Helios."
            Write-Host ""
            Write-Host "Available cluster names from Helios:"
            Write-Host $available
            exit
        }

        # Filter clusters while preserving properties
        $clusters = $clusters | Where-Object { $ValidTargets -icontains $_.clusterName }

        $vt = $ValidTargets -join ', '
        Write-Host ""
        Write-Host "Using cluster list from $ClusterListFile:"
        Write-Host $vt

        $clusterDisplay = ($clusters | ForEach-Object { "$($_.clusterName) ($($_.clusterId))" }) -join "`r`n"
        Write-Host ""
        Write-Host "Matched cluster IDs:"
        Write-Host $clusterDisplay
    }
    else {
        Write-Host ""
        Write-Host "Cluster list file exists but is empty or all commented. Using all clusters."
    }
}
else {
    Write-Host ""
    Write-Host "No cluster list file found. Using all clusters."
}

$runningList = ($clusters.clusterName -join ', ')
Write-Host ""
Write-Host "Running on $($clusters.Count) cluster(s): $runningList"

# ---- Initialize ----
$rows = @()
$startUsecs = TimeAgoUsecs $days

# ---- Job Analyzer ----
function Analyze-RunsForJob {
    param($Job,$RunTypesCsv,$Label,$ClusterId,$RootNodes,[int64]$StartUsecs,[int]$NumRuns,[int]$FailureCount,$Failures,$Messages,$LastSuccessUsecs,$ConsecutiveFails)
    $path = "/v2/data-protect/protection-groups/$($Job.id)/runs?numRuns=$NumRuns&startTimeUsecs=$StartUsecs&includeTenants=true&includeObjectDetails=true&runTypes=$RunTypesCsv"
    $runs = Invoke-HeliosGet $path $ClusterId
    if (-not $runs -or -not $runs.runs) { return }

    $runsSorted = $runs.runs | Sort-Object { $_.localBackupInfo.startTimeUsecs } -Descending
    $stillCounting = @{}

    foreach ($run in $runsSorted) {
        if (-not $run.objects) { continue }
        foreach ($object in ($run.objects | Where-Object { $_.object.environment -eq $Job.environment })) {
            $objectName = $object.object.name
            $sourceName = if ($object.object.PSObject.Properties['sourceId']) {
                ($RootNodes.rootNodes | Where-Object { $_.rootNode.id -eq $object.object.sourceId }).rootNode.name
            } else { $objectName }

            $key = "$ClusterId;;$($Job.name);;$objectName;;$sourceName;;$Label"
            if (-not $ConsecutiveFails.ContainsKey($key)) { $ConsecutiveFails[$key] = 0 }
            if (-not $stillCounting.ContainsKey($key)) { $stillCounting[$key] = $true }
            if (-not $LastSuccessUsecs.ContainsKey($key)) { $LastSuccessUsecs[$key] = $null }

            $snap = $object.localSnapshotInfo
            if (-not $snap -or -not $snap.snapshotInfo) { continue }
            $st = $snap.snapshotInfo.status

            if ($st -eq 'kSuccess' -or $st -eq 'kWarning') {
                if (-not $LastSuccessUsecs[$key]) { $LastSuccessUsecs[$key] = $run.localBackupInfo.startTimeUsecs }
                if ($stillCounting[$key]) { $stillCounting[$key] = $false }
            }
            elseif ($st -eq 'kFailed') {
                if ($stillCounting[$key]) { $ConsecutiveFails[$key]++ }
                if ($snap.failedAttempts) { $Messages[$key] = $snap.failedAttempts[0].message }
                $Failures[$key] = $true
            }
        }
    }

    foreach ($k in @($Failures.Keys)) {
        if ($ConsecutiveFails[$k] -lt $FailureCount) {
            $Failures.Remove($k) | Out-Null
            if ($Messages.ContainsKey($k)) { $Messages.Remove($k) | Out-Null }
        }
    }
}

# ---- Iterate clusters ----
foreach ($c in $clusters) {
    $cid = $c.clusterId
    $cname = $c.clusterName
    Write-Host ""
    Write-Host "Analyzing cluster: $cname"

    $pgs = Invoke-HeliosGet "/v2/data-protect/protection-groups?isDeleted=false&isActive=true&includeTenants=true" $cid
    if (-not $pgs -or -not $pgs.protectionGroups) { continue }

    $rootNodes = Invoke-HeliosGet "/protectionSources/registrationInfo" $cid
    if (-not $rootNodes -or -not $rootNodes.rootNodes) { continue }

    foreach ($job in ($pgs.protectionGroups | Sort-Object name)) {
        $failures = @{}; $messages = @{}; $lastSuccessU = @{}; $consecFails = @{}
        Analyze-RunsForJob $job "kSystem,kFull,kIncremental" "Backup" $cid $rootNodes $startUsecs $numRuns $failureCount $failures $messages $lastSuccessU $consecFails
        Analyze-RunsForJob $job "kLog" "Log Backup" $cid $rootNodes $startUsecs $numRuns $failureCount $failures $messages $lastSuccessU $consecFails

        foreach ($k in $failures.Keys | Sort-Object) {
            $clusterId, $jobName, $objectName, $sourceName, $runType = $k -split ';;'
            $msg = [string]$messages[$k]
            if ($msg) {
                $msg = $msg.Replace("`n", " ").Replace("`r", " ").Replace(",", ";")
                if ($msg.Length -gt 150) { $msg = $msg.Substring(0, 150) }
            } else { $msg = "" }
            $lastSuccessTxt = if ($lastSuccessU[$k]) { (UsecsToDate $lastSuccessU[$k]).ToString('yyyy-MM-dd HH:mm:ss') } else { 'Never' }

            $rows += [pscustomobject]@{
                ClusterName          = $cname
                JobName              = $jobName
                BackupType           = $runType
                SourceName           = $sourceName
                ObjectName           = $objectName
                ConsecutiveFailures  = [int]$consecFails[$k]
                LastSuccessfulBackup = $lastSuccessTxt
                Message              = $msg
            }
        }
    }
}

# ---- Final Output ----
$stamp = (Get-Date).ToString('yyyy-MM-dd_HHmmss')
$csv   = Join-Path $CsvFolder "Helios-ConsecutiveFailures-$stamp.csv"

$rows = $rows | Sort-Object ClusterName, JobName, BackupType, SourceName, ObjectName
$rows | Select-Object ClusterName, JobName, BackupType, SourceName, ObjectName, ConsecutiveFailures, LastSuccessfulBackup, Message |
    Export-Csv -Path $csv -NoTypeInformation -Encoding UTF8

Write-Host ""
Write-Host "Wrote: $csv"
Write-Host "Rows: $($rows.Count)"

if ($ShowTable) {
    if ($rows.Count -gt 0) {
        $rows |
            Format-Table `
            @{Label='Cluster'; Expression={$_.ClusterName}}, `
            @{Label='Job'; Expression={$_.JobName}}, `
            @{Label='Type'; Expression={$_.BackupType}}, `
            @{Label='Source/Object'; Expression={"$($_.SourceName)/$($_.ObjectName)"}}, `
            @{Label='Streak'; Expression={$_.ConsecutiveFailures}}, `
            @{Label='Last Success'; Expression={$_.LastSuccessfulBackup}}, `
            @{Label='Message'; Expression={$_.Message}} -AutoSize |
            Out-String -Width 220 | Write-Host
    }
    else {
        $since = (UsecsToDate $startUsecs).ToString('yyyy-MM-dd')
        Write-Host "No consecutive failures >= $failureCount found in the last $numRuns runs (since $since)."
    }
}
