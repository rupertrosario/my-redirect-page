# process commandline arguments
[CmdletBinding()]
param (
    [Parameter()][string]$vip = 'helios.cohesity.com',
    [Parameter()][string]$username = 'helios',
    [Parameter()][string]$domain = 'local',
    [Parameter()][string]$tenant = $null,
    [Parameter()][switch]$useApiKey,
    [Parameter()][string]$password = $null,
    [Parameter()][switch]$noPrompt,
    [Parameter()][switch]$mcm,
    [Parameter()][string]$mfaCode = $null,
    [Parameter()][string]$clusterName = $null,

    [Parameter()][int]$numRuns = 100,
    [Parameter()][int]$days = 35,
    [Parameter()][int]$failureCount = 3,

    [Parameter()][string]$smtpServer,
    [Parameter()][string]$smtpPort = 25,
    [Parameter()][array]$sendTo,
    [Parameter()][string]$sendFrom
)

# --- cohesity API helper ---
. $(Join-Path -Path $PSScriptRoot -ChildPath cohesity-api.ps1)

# --- authenticate ---
apiauth -vip $vip -username $username -domain $domain -passwd $password `
    -apiKeyAuthentication $useApiKey -mfaCode $mfaCode `
    -heliosAuthentication $mcm -tenant $tenant -noPromptForPassword $noPrompt

if($USING_HELIOS -and -not $clusterName){
    Write-Host "Please provide -clusterName when connecting through helios" -ForegroundColor Yellow
    exit 1
}

if(!$cohesity_api.authorized){
    Write-Host "Not authenticated" -ForegroundColor Yellow
    exit 1
}

# --- main analysis function ---
function Analyze-RunsForJob {
    param(
        [Parameter(Mandatory=$true)]$Job,
        [Parameter(Mandatory=$true)][string]$RunTypesCsv,
        [Parameter(Mandatory=$true)][string]$Label,
        [Parameter(Mandatory=$true)][int64]$StartUsecs,
        [Parameter(Mandatory=$true)][int]$NumRuns,
        [Parameter(Mandatory=$true)][int]$FailureCount,
        [Parameter(Mandatory=$true)]$Failures,
        [Parameter(Mandatory=$true)]$Messages,
        [Parameter(Mandatory=$true)]$FailureTime,
        [Parameter(Mandatory=$true)]$LatestSuccessUsecs,
        [Parameter(Mandatory=$true)]$ConsecutiveFails
    )

    $uri = "data-protect/protection-groups/$($Job.id)/runs?numRuns=$NumRuns&startTimeUsecs=$StartUsecs&includeObjectDetails=true&runTypes=$RunTypesCsv"
    $runs = api get -v2 $uri
    if(-not $runs.runs){ return }

    $jobName = $Job.name
    $env = $Job.environment

    # newest to oldest
    $runsSorted = $runs.runs | Sort-Object { $_.localBackupInfo.startTimeUsecs } -Descending
    $stillCounting = @{}

    foreach($run in $runsSorted){
        foreach($object in $run.objects){
            if($object.object.environment -ne $env){ continue }

            $objName = $object.object.name
            $sourceName = if($object.object.PSObject.Properties['sourceId']){ $object.object.sourceId } else { $objName }
            $key = "$jobName;;$objName;;$sourceName;;$Label"

            if(-not $ConsecutiveFails.ContainsKey($key)){ $ConsecutiveFails[$key] = 0; $stillCounting[$key] = $true }
            if(-not $LatestSuccessUsecs.ContainsKey($key)){ $LatestSuccessUsecs[$key] = $null }

            $status = $object.localSnapshotInfo.snapshotInfo.status

            switch ($status) {
                'kSuccess' { 
                    if($null -eq $LatestSuccessUsecs[$key]){ $LatestSuccessUsecs[$key] = $run.localBackupInfo.startTimeUsecs }
                    $stillCounting[$key] = $false
                }
                'kWarning' {
                    if($null -eq $LatestSuccessUsecs[$key]){ $LatestSuccessUsecs[$key] = $run.localBackupInfo.startTimeUsecs }
                    $stillCounting[$key] = $false
                }
                'kFailed' {
                    if($stillCounting[$key]){ $ConsecutiveFails[$key]++ }
                    $Failures[$key] = $true
                    $FailureTime[$key] = (usecsToDate $run.localBackupInfo.startTimeUsecs)
                    $Messages[$key] = $object.localSnapshotInfo.failedAttempts[0].message
                }
            }
        }
    }

    # keep only failures >= threshold
    foreach($k in @($Failures.Keys)){
        if($ConsecutiveFails[$k] -lt $FailureCount){
            $Failures.Remove($k) | Out-Null
            $FailureTime.Remove($k) | Out-Null
            if($Messages.ContainsKey($k)){ $Messages.Remove($k) | Out-Null }
        }
    }
}

# --- output prep ---
$cluster  = api get cluster
$outStamp = (Get-Date).ToString('yyyy-MM-dd_HHmmss')
$outfile  = "backupFailureReport-$($cluster.name)-$outStamp.csv"

"Job Name,Last Successful Backup,Backup Type,Source,Object,ConsecutiveFailures,Message" | Out-File $outfile -Encoding UTF8

# --- get jobs & timeframe ---
$jobs = api get -v2 "data-protect/protection-groups?isDeleted=false&isActive=true"
$startUsecs = timeAgo $days 'days'
$total = 0

foreach($job in $jobs.protectionGroups){
    $f = @{}; $m = @{}; $ft = @{}; $s = @{}; $cf = @{}
    Analyze-RunsForJob -Job $job -RunTypesCsv "kSystem,kFull,kIncremental" -Label "Backup" `
        -StartUsecs $startUsecs -NumRuns $numRuns -FailureCount $failureCount `
        -Failures $f -Messages $m -FailureTime $ft -LatestSuccessUsecs $s -ConsecutiveFails $cf
    Analyze-RunsForJob -Job $job -RunTypesCsv "kLog" -Label "Log Backup" `
        -StartUsecs $startUsecs -NumRuns $numRuns -FailureCount $failureCount `
        -Failures $f -Messages $m -FailureTime $ft -LatestSuccessUsecs $s -ConsecutiveFails $cf

    foreach($k in $f.Keys){
        $total++
        $jobName, $objName, $srcName, $rtype = $k -split ';;'
        $msg = ($m[$k] -replace '[\r\n,]', ';')
        if($msg.Length -gt 120){ $msg = $msg.Substring(0,120) }
        $lastSuccess = if($s[$k]){ (usecsToDate $s[$k]).ToString('yyyy-MM-dd HH:mm:ss') } else { 'Never' }

        "{0},{1},{2},{3},{4},{5},{6}" -f $jobName,$lastSuccess,$rtype,$srcName,$objName,$cf[$k],$msg | `
            Out-File -FilePath $outfile -Append -Encoding UTF8
    }
}

Write-Host "`nTotal Failures (≥3 in a row): $total"
Write-Host "Report saved to: $outfile`n"

# --- email if configured ---
if($smtpServer -and $sendFrom -and $sendTo){
    foreach($to in $sendTo){
        Send-MailMessage -From $sendFrom -To $to -SmtpServer $smtpServer -Port $smtpPort `
            -Subject "$clusterName Backup Failure Report ($total failures)" `
            -Body "Total Failures (≥3 in a row): $total" `
            -Attachments $outfile -WarningAction SilentlyContinue
    }
}
