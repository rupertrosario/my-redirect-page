# -------------------------------------------------------------
# Cohesity Helios â€” Active Alert Tiles (Wide Tables, Severity Split)
#   - GET-only
#   - ONLY clusters that currently have Active (kOpen) alerts are shown (short output)
#   - Sections: Hardware / Maintenance / Data Service (header line only)
#   - Columns: EXACT alertCategory enums (alphabetical)
#   - Cell:
#       - "Healthy" if no active alerts for that category on that cluster
#       - else "C:<n> W:<n> I:<n>"
#   - NOTE:
#       Clusters not shown have no Active alerts for that section (healthy for these tiles).
#   - DISPLAY:
#       Uses Format-Table * + Out-String -Width 5000 to avoid column truncation in console.
#       CSV exports always contain all columns.
# -------------------------------------------------------------
$ErrorActionPreference = "Stop"
$FormatEnumerationLimit = -1

# ---------- CONFIG ----------
$apiKeyPath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
$outDir     = "X:\PowerShell\Data\Cohesity\Alerts"

if (-not (Test-Path $apiKeyPath)) { throw "API key file not found at $apiKeyPath" }
if (-not (Test-Path $outDir))     { New-Item -ItemType Directory -Path $outDir | Out-Null }

$apiKey  = (Get-Content -Path $apiKeyPath -Raw).Trim()
$headers = @{ apiKey = $apiKey }

$uriAlerts = "https://helios.cohesity.com/mcm/alerts"

# ---------- CATEGORY COLUMNS (EXACT ENUMS) ----------
$HW_Cats = @(
  "kCPU","kChassis","kCluster","kDisk","kFan","kFirmware","kMemory","kNIC",
  "kNode","kNodeHealth","kOperatingSystem","kPowerSupply","kStorageDevice",
  "kStoragePool","kTemperature"
) | Sort-Object

$MAINT_Cats = @(
  "kAuditLog","kClusterManagement","kConfiguration","kFaultTolerance",
  "kGeneralSoftwareFailure","kHelios","kLicense","kNetworking","kSecurity",
  "kStorageUsage","kSystemService","kUpgrade"
) | Sort-Object

$DS_Cats = @(
  "kAgent","kAppMarketPlace","kArchivalRestore","kBackupRestore","kCDP",
  "kDataPath","kDataSourceConnector","kDisasterRecovery","kIndexing","kMetadata",
  "kNetBackup","kQuota","kRemoteReplication","kViewFailover"
) | Sort-Object

# ---------- HELPERS ----------
function SeverityKey {
  param([string]$sev)
  switch ($sev) {
    "kCritical" { "C" }
    "kWarning"  { "W" }
    "kInfo"     { "I" }
    default     { "I" } # treat unknown as Info
  }
}

function Get-ActiveAlertsByBucket {
  param([string]$bucketEnum) # kHardware / kMaintenance / kDataService

  $body = @{
    alertStateList      = "kOpen"       # Active only
    alertTypeBucketList = $bucketEnum
  }

  return (Invoke-RestMethod -Method Get -Uri $uriAlerts -Headers $headers -Body $body)
}

function Build-WideTileTableSeverity_Short {
  param(
    [string]$bucketEnum,
    [string[]]$Categories
  )

  $alerts = Get-ActiveAlertsByBucket -bucketEnum $bucketEnum

  # Cluster list ONLY from alerts (short output)
  $clusters = $alerts | ForEach-Object { [string]$_.clusterName } |
    Where-Object { $_ -and $_.Trim() -ne "" } | Sort-Object -Unique

  if (-not $clusters -or $clusters.Count -eq 0) {
    return @() # no active alerts for this bucket
  }

  # counts["cluster||category"] = @{C=n;W=n;I=n}
  $counts = @{}

  foreach ($a in $alerts) {
    $cluster = [string]$a.clusterName
    $cat     = [string]$a.alertCategory
    if (-not $cluster -or -not $cat) { continue }
    if ($Categories -notcontains $cat) { continue }

    $sevKey = SeverityKey ([string]$a.severity)
    $k = "$cluster||$cat"

    if (-not $counts.ContainsKey($k)) {
      $counts[$k] = @{ C = 0; W = 0; I = 0 }
    }
    $counts[$k][$sevKey]++
  }

  $rows = foreach ($c in $clusters) {
    $row = [ordered]@{ ClusterName = $c }

    foreach ($cat in $Categories) {
      $k = "$c||$cat"
      if (-not $counts.ContainsKey($k)) {
        $row[$cat] = "Healthy"
        continue
      }

      $cN = [int]$counts[$k]["C"]
      $wN = [int]$counts[$k]["W"]
      $iN = [int]$counts[$k]["I"]

      if ($cN -eq 0 -and $wN -eq 0 -and $iN -eq 0) {
        $row[$cat] = "Healthy"
      } else {
        $row[$cat] = "C:$cN W:$wN I:$iN"
      }
    }

    [PSCustomObject]$row
  }

  return $rows
}

function Write-WideTable {
  param(
    [string]$title,
    $rows
  )
  "`n$title"
  if (-not $rows -or $rows.Count -eq 0) {
    "No Active alerts (no clusters to display)."
    return
  }

  # Forces all properties (columns) to be rendered; Width avoids truncation
  $rows | Format-Table * | Out-String -Width 5000 | Write-Host
}

# ---------- NOTE ----------
$note = @"
NOTE:
- This report shows ONLY clusters that currently have Active (kOpen) alerts in each section.
- Clusters not displayed have no Active alerts for that section (healthy for these tiles).
- Cells show "Healthy" or "C:<n> W:<n> I:<n>".
"@
"`n$note"

# ---------- BUILD TABLES ----------
$hw  = Build-WideTileTableSeverity_Short -bucketEnum "kHardware"    -Categories $HW_Cats
$mnt = Build-WideTileTableSeverity_Short -bucketEnum "kMaintenance" -Categories $MAINT_Cats
$ds  = Build-WideTileTableSeverity_Short -bucketEnum "kDataService" -Categories $DS_Cats

# ---------- CONSOLE OUTPUT (full columns) ----------
Write-WideTable -title "Hardware"    -rows $hw
Write-WideTable -title "Maintenance" -rows $mnt
Write-WideTable -title "Data Service" -rows $ds

# ---------- EXPORT CSV ----------
$stamp  = Get-Date -Format "yyyy-MM-dd_HHmm"
$hwCsv  = Join-Path $outDir "Helios_Tiles_Hardware_Active_SHORT_$stamp.csv"
$mntCsv = Join-Path $outDir "Helios_Tiles_Maintenance_Active_SHORT_$stamp.csv"
$dsCsv  = Join-Path $outDir "Helios_Tiles_DataService_Active_SHORT_$stamp.csv"

if ($hw  -and $hw.Count  -gt 0) { $hw  | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $hwCsv }  else { "" | Set-Content -Path $hwCsv -Encoding UTF8 }
if ($mnt -and $mnt.Count -gt 0) { $mnt | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $mntCsv } else { "" | Set-Content -Path $mntCsv -Encoding UTF8 }
if ($ds  -and $ds.Count  -gt 0) { $ds  | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $dsCsv }  else { "" | Set-Content -Path $dsCsv -Encoding UTF8 }

Write-Host "`nSaved:`n$hwCsv`n$mntCsv`n$dsCsv"
