# -------------------------------------------------------------
# Cohesity Helios — Active Alert Tiles (Dynamic Columns + Cluster Menu)
#   - GET-only
#   - Menu: [0] All clusters seen in alerts OR [1..N] single cluster
#   - Sections: Hardware / Maintenance / Data Service (header line only)
#   - Columns: UNIQUE alertCategory values returned by API per bucket (sorted)
#   - Cell:
#       - "Healthy" if no active alerts for that category on that cluster
#       - else "C:<n> W:<n> I:<n> U:<n>" (U = unknown severity)
#   - NOTE:
#       Only clusters that have at least one Active (kOpen) alert in that bucket are listed.
# -------------------------------------------------------------
$ErrorActionPreference = "Stop"
$FormatEnumerationLimit = -1

# ---------- CONFIG ----------
$apiKeyPath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
$outDir     = "X:\PowerShell\Data\Cohesity\Alerts"

if (-not (Test-Path $apiKeyPath)) { throw "API key file not found at $apiKeyPath" }
if (-not (Test-Path $outDir))     { New-Item -ItemType Directory -Path $outDir | Out-Null }

$apiKey  = (Get-Content -Path $apiKeyPath -Raw).Trim()
$headers = @{ apiKey = $apiKey }
$uriAlerts = "https://helios.cohesity.com/mcm/alerts"

# ---------- HELPERS ----------
function SeverityKey {
  param([string]$sev)
  switch ($sev) {
    "kCritical" { "C" }
    "kWarning"  { "W" }
    "kInfo"     { "I" }
    default     { "U" }  # Unknown (do NOT treat as Info)
  }
}

function Get-ActiveAlertsByBucket {
  param([string]$bucketEnum) # kHardware / kMaintenance / kDataService
  $body = @{
    alertStateList      = "kOpen"       # Active only
    alertTypeBucketList = $bucketEnum
  }
  return (Invoke-RestMethod -Method Get -Uri $uriAlerts -Headers $headers -Body $body)
}

function Build-Section {
  param(
    [string]$title,
    [string]$bucketEnum,
    [string]$stamp
  )

  $alerts = Get-ActiveAlertsByBucket -bucketEnum $bucketEnum

  # Determine clusters and categories exactly from API output
  $clusters = $alerts | ForEach-Object { [string]$_.clusterName } |
    Where-Object { $_ -and $_.Trim() -ne "" } | Sort-Object -Unique

  $categories = $alerts | ForEach-Object { [string]$_.alertCategory } |
    Where-Object { $_ -and $_.Trim() -ne "" } | Sort-Object -Unique

  # If nothing, return empty
  if (-not $clusters -or $clusters.Count -eq 0 -or -not $categories -or $categories.Count -eq 0) {
    return @{
      Title = $title
      Alerts = $alerts
      Clusters = @()
      Categories = @()
      Rows = @()
    }
  }

  # --------------------------
  # Cluster selection menu
  # --------------------------
  Write-Host "`n$title — Cluster Selection (from Active alerts only)"
  Write-Host "[0] All clusters"
  for ($i=0; $i -lt $clusters.Count; $i++) {
    $n = $i + 1
    Write-Host ("[{0}] {1}" -f $n, $clusters[$i])
  }

  $choice = Read-Host "Select (0..$($clusters.Count))"
  [int]$choiceInt = 0
  if (-not [int]::TryParse($choice, [ref]$choiceInt)) { $choiceInt = 0 }

  $selectedClusters =
    if ($choiceInt -le 0 -or $choiceInt -gt $clusters.Count) { $clusters }
    else { @($clusters[$choiceInt - 1]) }

  # counts["cluster||category"] = @{C=n;W=n;I=n;U=n}
  $counts = @{}
  foreach ($a in $alerts) {
    $c = [string]$a.clusterName
    if ($selectedClusters -notcontains $c) { continue }

    $cat = [string]$a.alertCategory
    if (-not $cat) { continue }

    $k = "$c||$cat"
    if (-not $counts.ContainsKey($k)) {
      $counts[$k] = @{ C=0; W=0; I=0; U=0 }
    }

    $sevKey = SeverityKey ([string]$a.severity)
    $counts[$k][$sevKey]++
  }

  # Build rows
  $rows = foreach ($c in $selectedClusters) {
    $row = [ordered]@{ ClusterName = $c }

    foreach ($cat in $categories) {
      $k = "$c||$cat"
      if (-not $counts.ContainsKey($k)) {
        $row[$cat] = "Healthy"
        continue
      }

      $C = [int]$counts[$k]["C"]
      $W = [int]$counts[$k]["W"]
      $I = [int]$counts[$k]["I"]
      $U = [int]$counts[$k]["U"]

      if ($C -eq 0 -and $W -eq 0 -and $I -eq 0 -and $U -eq 0) {
        $row[$cat] = "Healthy"
      } else {
        $row[$cat] = "C:$C W:$W I:$I U:$U"
      }
    }

    [PSCustomObject]$row
  }

  return @{
    Title      = $title
    Alerts     = $alerts
    Clusters   = $clusters
    Categories = $categories
    Rows       = $rows
  }
}

function Write-WideTable {
  param([string]$title, $rows)

  "`n$title"
  if (-not $rows -or $rows.Count -eq 0) {
    "No Active alerts (no clusters to display)."
    return
  }
  $rows | Format-Table * | Out-String -Width 5000 | Write-Host
}

function Export-SectionCsv {
  param(
    [string]$titleSlug,
    $rows,
    [string]$stamp
  )

  $csv = Join-Path $outDir "Helios_Tiles_${titleSlug}_Active_$stamp.csv"
  if ($rows -and $rows.Count -gt 0) {
    $rows | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $csv
  } else {
    "" | Set-Content -Path $csv -Encoding UTF8
  }
  return $csv
}

# ---------- RUN ----------
$stamp = Get-Date -Format "yyyy-MM-dd_HHmm"

$note = @"
NOTE:
- This report shows ONLY Active (kOpen) alerts.
- Only clusters present in the Active alert output for a section are offered in that section’s menu.
- Columns are derived from the API output (unique alertCategory values per section).
- Cells show "Healthy" or "C:<n> W:<n> I:<n> U:<n>" (U = unknown severity).
"@
"`n$note"

$secHW  = Build-Section -title "Hardware"     -bucketEnum "kHardware"    -stamp $stamp
$secMNT = Build-Section -title "Maintenance"  -bucketEnum "kMaintenance" -stamp $stamp
$secDS  = Build-Section -title "Data Service" -bucketEnum "kDataService" -stamp $stamp

Write-WideTable -title "Hardware"     -rows $secHW.Rows
Write-WideTable -title "Maintenance"  -rows $secMNT.Rows
Write-WideTable -title "Data Service" -rows $secDS.Rows

$hwCsv  = Export-SectionCsv -titleSlug "Hardware"    -rows $secHW.Rows  -stamp $stamp
$mntCsv = Export-SectionCsv -titleSlug "Maintenance" -rows $secMNT.Rows -stamp $stamp
$dsCsv  = Export-SectionCsv -titleSlug "DataService" -rows $secDS.Rows  -stamp $stamp

Write-Host "`nSaved:`n$hwCsv`n$mntCsv`n$dsCsv"
