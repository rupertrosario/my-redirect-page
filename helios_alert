# -------------------------------------------------------------
# Cohesity Helios â€” Active Alert "Tiles" (Wide Health Tables)
#   - GET-only
#   - Rows: ALL clusters (from /mcm/clusters)
#   - Columns: Categories (alphabetical)
#   - Cell: "Healthy" if 0 active alerts else count
# Buckets:
#   1) Hardware
#   2) Maintenance
#   3) Data Service
# -------------------------------------------------------------
$ErrorActionPreference = "Stop"

# ---------- CONFIG ----------
$apiKeyPath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
$outDir     = "X:\PowerShell\Data\Cohesity\Alerts"

if (-not (Test-Path $apiKeyPath)) { throw "API key file not found at $apiKeyPath" }
if (-not (Test-Path $outDir))     { New-Item -ItemType Directory -Path $outDir | Out-Null }

$apiKey  = (Get-Content -Path $apiKeyPath -Raw).Trim()
$headers = @{ apiKey = $apiKey }

$uriAlerts = "https://helios.cohesity.com/mcm/alerts"

# ---------- CATEGORY DEFINITIONS ----------
# Map DisplayName -> regex patterns to match (alertCategory + description)
$HW_Map = [ordered]@{
  "Chassis"      = @("chassis","enclosure","backplane")
  "Cluster"      = @("cluster")
  "CPU"          = @("cpu","processor")
  "Disk"         = @("disk","drive","ssd","hdd","media error","storage device")
  "Fan"          = @("fan")
  "Firmware"     = @("firmware","bios","bmc","ipmi","upgrade firmware")
  "Memory"       = @("memory","dimm","ram","ecc")
  "NIC"          = @("nic","network","interface","link down","ethernet")
  "Node"         = @("node","host","appliance")
  "PowerSupply"  = @("psu","power supply","power-supply","\bpower\b")
  "Temperature"  = @("temp","temperature","thermal","overheat")
}

$MAINT_Map = [ordered]@{
  "ClusterManagement" = @("cluster management","cluster mgmt","management")
  "Configuration"     = @("configuration","config","misconfig")
  "FaultTolerance"    = @("fault tolerance","fault-tolerance","redundancy","replica","erasure")
  "License"           = @("license","licensing","entitlement")
  "Networking"        = @("networking","network","dns","ntp","gateway","route","interface")
  "Security"          = @("security","auth","authentication","authorization","certificate","tls","ssh","rbac")
  "StorageUsage"      = @("storage usage","capacity","full","space","utilization","usage","threshold")
  "Upgrade"           = @("upgrade","update","patch","version","rolling")
}

$DS_Map = [ordered]@{
  "ArchivalAndRestore"        = @("archival and restore","archive restore","archival","archive")
  "BackupAndRestore"          = @("backup and restore","backup","restore")
  "ContinuousDataProtection"  = @("continuous data protection","cdp","journal")
  "DataSourceConnector"       = @("data source connector","connector","agent","plugin","registration")
  "DisasterRecovery"          = @("disaster recovery","dr","failover","failback","runbook")
  "Quota"                     = @("quota","limit","throttle")
  "RemoteReplication"         = @("remote replication","replication","replicate")
  "ViewFailover"              = @("view failover","view","mount","instant volume","failover view")
}

# ---------- HELPERS ----------
function Normalize-Text {
  param([string]$s)
  if (-not $s) { return "" }
  return $s.ToLowerInvariant()
}

function Resolve-Category {
  param(
    $alert,
    [hashtable]$Map
  )
  $cat  = Normalize-Text ([string]$alert.alertCategory)
  $desc = Normalize-Text ([string]$alert.alertDocument.alertDescription)
  $t = "$cat $desc"

  foreach ($display in $Map.Keys) {
    foreach ($pat in $Map[$display]) {
      if ($t -match $pat) { return $display }
    }
  }
  return "Other"
}

function Get-ActiveAlertsByBucket {
  param([string]$bucketEnum) # e.g. kHardware / kMaintenance / kDataService

  $body = @{
    alertStateList      = "kOpen"       # UI: Active
    alertTypeBucketList = $bucketEnum
  }

  return (Invoke-RestMethod -Method Get -Uri $uriAlerts -Headers $headers -Body $body)
}

function Get-AllHeliosClusters {
  $endpoints = @(
    "https://helios.cohesity.com/mcm/clusters",
    "https://helios.cohesity.com/v2/mcm/clusters"
  )

  foreach ($u in $endpoints) {
    try {
      $resp = Invoke-RestMethod -Method Get -Uri $u -Headers $headers
      if (-not $resp) { continue }

      $items =
        if ($resp.clusters) { $resp.clusters }
        elseif ($resp.items) { $resp.items }
        elseif ($resp -is [System.Array]) { $resp }
        else { @($resp) }

      $names = $items | ForEach-Object {
        $_.name ?? $_.clusterName ?? $_.cluster ?? $_.clusterInfo.name
      } | Where-Object { $_ -and $_.ToString().Trim() -ne "" } | Sort-Object -Unique

      if ($names.Count -gt 0) { return $names }
    } catch { }
  }

  throw "Could not fetch cluster list from /mcm/clusters. If your tenant uses a different endpoint, adjust Get-AllHeliosClusters()."
}

function Build-WideTileTable {
  param(
    [string]$bucketLabel,
    [string]$bucketEnum,
    [hashtable]$CategoryMap,
    [string[]]$AllClusters
  )

  $alerts = Get-ActiveAlertsByBucket -bucketEnum $bucketEnum

  $norm = foreach ($a in $alerts) {
    [PSCustomObject]@{
      ClusterName = [string]$a.clusterName
      Category    = Resolve-Category -alert $a -Map $CategoryMap
    }
  }

  $clusters = $AllClusters | Where-Object { $_ -and $_.Trim() -ne "" } | Sort-Object -Unique
  $cats     = $CategoryMap.Keys | Sort-Object

  # Cluster|Category -> count
  $counts = @{}
  foreach ($n in $norm) {
    if ($n.Category -eq "Other") { continue }  # unmapped ignored for quick-look
    if (-not $n.ClusterName) { continue }
    $k = "$($n.ClusterName)||$($n.Category)"
    if (-not $counts.ContainsKey($k)) { $counts[$k] = 0 }
    $counts[$k]++
  }

  $rows = foreach ($c in $clusters) {
    $row = [ordered]@{
      ClusterName = $c
      Status      = "Active"
      Bucket      = $bucketLabel
    }

    foreach ($cat in $cats) {
      $k = "$c||$cat"
      $row[$cat] = if ($counts.ContainsKey($k)) { [string]$counts[$k] } else { "Healthy" }
    }

    [PSCustomObject]$row
  }

  return $rows
}

# ---------- ALL CLUSTERS ----------
$allClusters = Get-AllHeliosClusters

# ---------- BUILD TABLES ----------
$hw  = Build-WideTileTable -bucketLabel "Hardware"    -bucketEnum "kHardware"    -CategoryMap $HW_Map    -AllClusters $allClusters
$mnt = Build-WideTileTable -bucketLabel "Maintenance" -bucketEnum "kMaintenance" -CategoryMap $MAINT_Map -AllClusters $allClusters
$ds  = Build-WideTileTable -bucketLabel "DataService" -bucketEnum "kDataService" -CategoryMap $DS_Map    -AllClusters $allClusters

# ---------- CONSOLE (quick look) ----------
$hw  | Format-Table -AutoSize
$mnt | Format-Table -AutoSize
$ds  | Format-Table -AutoSize

# ---------- EXPORT ----------
$stamp  = Get-Date -Format "yyyy-MM-dd_HHmm"
$hwCsv  = Join-Path $outDir "Helios_Tiles_Hardware_Active_$stamp.csv"
$mntCsv = Join-Path $outDir "Helios_Tiles_Maintenance_Active_$stamp.csv"
$dsCsv  = Join-Path $outDir "Helios_Tiles_DataService_Active_$stamp.csv"

$hw  | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $hwCsv
$mnt | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $mntCsv
$ds  | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $dsCsv

Write-Host "Saved:`n$hwCsv`n$mntCsv`n$dsCsv"
