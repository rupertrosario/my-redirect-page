# -------------------------------------------------------------
# Cohesity Helios â€” Active/Note Alert Tiles (USING /v2/alerts-summary)
#   Endpoint: https://helios.cohesity.com/v2/alerts-summary
#   - GET-only
#   - States: kOpen + kNote (per your curl)
#   - NO CSV export
#   - NO cluster selection (shows only clusters present in summary output per section)
#   - Sections: Hardware / Maintenance / Data Service (header line only)
#   - Columns: UNIQUE category values returned by API per section (sorted)
#   - Cell:
#       - "Healthy" if no alerts for that category on that cluster
#       - else "C:<n> W:<n> I:<n> U:<n>" (U = unknown severity)
# -------------------------------------------------------------
$ErrorActionPreference = "Stop"
$FormatEnumerationLimit = -1

# ---------- CONFIG ----------
$apiKeyPath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apiKeyPath)) { throw "API key file not found at $apiKeyPath" }

$apiKey  = (Get-Content -Path $apiKeyPath -Raw).Trim()
$headers = @{ apiKey = $apiKey; Accept = "application/json" }

$uriSummary = "https://helios.cohesity.com/v2/alerts-summary"

# States per your curl
$states = @("kOpen","kNote")

# ---------- HELPERS ----------
function SeverityKey {
  param([string]$sev)
  switch ($sev) {
    "kCritical" { "C" }
    "kWarning"  { "W" }
    "kInfo"     { "I" }
    default     { "U" }  # Unknown (do NOT treat as Info)
  }
}

function Build-QueryString {
  param([string[]]$statesList, [int]$mode)

  # mode 1: repeated param => ?statesList=kOpen&statesList=kNote
  if ($mode -eq 1) {
    return ($statesList | ForEach-Object { "statesList=$_" }) -join "&"
  }

  # mode 2: indexed => ?statesList[0]=kOpen&statesList[1]=kNote
  $i = 0
  $parts = @()
  foreach ($s in $statesList) {
    $parts += ("statesList[{0}]={1}" -f $i, $s)
    $i++
  }
  return ($parts -join "&")
}

function Invoke-AlertsSummary {
  param([string[]]$statesList)

  # Try both query styles to match server expectations
  $qs1 = Build-QueryString -statesList $statesList -mode 1
  $qs2 = Build-QueryString -statesList $statesList -mode 2

  foreach ($qs in @($qs1,$qs2)) {
    $u = "$uriSummary`?$qs"
    try {
      return (Invoke-RestMethod -Method Get -Uri $u -Headers $headers)
    } catch {
      # try next
    }
  }

  throw "Failed calling /v2/alerts-summary with statesList. Verify API key + endpoint availability."
}

function Get-Prop {
  param($obj, [string[]]$names)
  foreach ($n in $names) {
    $p = $obj.PSObject.Properties[$n]
    if ($p -and $null -ne $p.Value -and $p.Value.ToString().Trim() -ne "") { return $p.Value }
  }
  return $null
}

function Normalize-Records {
  param($summaryResp)

  # Attempt to locate an array of records (common shapes)
  $records =
    if ($summaryResp.items) { $summaryResp.items }
    elseif ($summaryResp.alertsSummary) { $summaryResp.alertsSummary }
    elseif ($summaryResp.alertSummary) { $summaryResp.alertSummary }
    elseif ($summaryResp.summary) { $summaryResp.summary }
    elseif ($summaryResp -is [System.Array]) { $summaryResp }
    else { @() }

  if (-not $records -or $records.Count -eq 0) { return @() }

  # Normalize each record to fields we need:
  # clusterName, category, typeBucket, severity, count
  $norm = @()
  foreach ($r in $records) {
    $cluster = Get-Prop $r @("clusterName","cluster","cluster_name","clusterInfoName","clusterDisplayName","sourceClusterName")
    $cat     = Get-Prop $r @("category","alertCategory","alert_category","categoryType")
    $bucket  = Get-Prop $r @("typeBucket","alertTypeBucket","bucket","alert_type_bucket","type")
    $sev     = Get-Prop $r @("severity","alertSeverity","alert_severity","level")
    $cnt     = Get-Prop $r @("count","totalCount","alertsCount","numAlerts","value")

    # Some APIs embed dimensions under a "groupBy"/"group" object
    if (-not $cluster -or -not $cat -or -not $bucket -or -not $sev) {
      $g = Get-Prop $r @("group","groupBy","dimensions","key")
      if ($g) {
        if (-not $cluster) { $cluster = Get-Prop $g @("clusterName","cluster") }
        if (-not $cat)     { $cat     = Get-Prop $g @("category","alertCategory") }
        if (-not $bucket)  { $bucket  = Get-Prop $g @("typeBucket","alertTypeBucket") }
        if (-not $sev)     { $sev     = Get-Prop $g @("severity","alertSeverity") }
      }
    }

    if (-not $cnt) { $cnt = 0 }
    $cnt = [int]$cnt

    # If the endpoint does NOT return clusterName, we cannot build tiles per cluster.
    if (-not $cluster) { continue }
    if (-not $cat)     { continue }
    if (-not $bucket)  { continue }
    if (-not $sev)     { $sev = "Unknown" }

    $norm += [PSCustomObject]@{
      ClusterName = [string]$cluster
      Category    = [string]$cat
      TypeBucket  = [string]$bucket
      Severity    = [string]$sev
      Count       = $cnt
    }
  }

  return $norm
}

function BucketTitle {
  param([string]$bucket)
  switch ($bucket) {
    "kHardware"     { "Hardware" }
    "kMaintenance"  { "Maintenance" }
    "kDataService"  { "Data Service" }
    default {
      # If API returns non-k* values, keep as-is
      $bucket
    }
  }
}

function Build-WideTilesFromNorm {
  param(
    $normRecords,
    [string]$bucketEnum
  )

  $rec = $normRecords | Where-Object { $_.TypeBucket -eq $bucketEnum }
  if (-not $rec -or $rec.Count -eq 0) { return @() }

  $clusters = $rec | Select-Object -ExpandProperty ClusterName | Sort-Object -Unique
  $cats     = $rec | Select-Object -ExpandProperty Category    | Sort-Object -Unique

  # counts["cluster||category"] = @{C=n;W=n;I=n;U=n}
  $counts = @{}
  foreach ($r in $rec) {
    $k = "$($r.ClusterName)||$($r.Category)"
    if (-not $counts.ContainsKey($k)) { $counts[$k] = @{ C=0; W=0; I=0; U=0 } }

    $sKey = SeverityKey $r.Severity
    $counts[$k][$sKey] += [int]$r.Count
  }

  $rows = foreach ($c in $clusters) {
    $row = [ordered]@{ ClusterName = $c }
    foreach ($cat in $cats) {
      $k = "$c||$cat"
      if (-not $counts.ContainsKey($k)) { $row[$cat] = "Healthy"; continue }

      $C = [int]$counts[$k]["C"]
      $W = [int]$counts[$k]["W"]
      $I = [int]$counts[$k]["I"]
      $U = [int]$counts[$k]["U"]

      if ($C -eq 0 -and $W -eq 0 -and $I -eq 0 -and $U -eq 0) {
        $row[$cat] = "Healthy"
      } else {
        $row[$cat] = "C:$C W:$W I:$I U:$U"
      }
    }
    [PSCustomObject]$row
  }

  return $rows
}

function Write-WideTable {
  param([string]$title, $rows)

  "`n$title"
  if (-not $rows -or $rows.Count -eq 0) {
    "No alerts in summary output for this section."
    return
  }

  # Full-column render (avoids truncation)
  $rows | Format-Table * | Out-String -Width 5000 | Write-Host
}

# ---------- RUN ----------
$note = @"
NOTE:
- Using /v2/alerts-summary with statesList = kOpen, kNote.
- Sections show ONLY clusters present in the summary output for that bucket.
- Columns are derived from the API output (unique category values per section).
- Cells show "Healthy" or "C:<n> W:<n> I:<n> U:<n>" (U = unknown severity).
"@
"`n$note"

$summaryRaw = Invoke-AlertsSummary -statesList $states
$norm = Normalize-Records -summaryResp $summaryRaw

if (-not $norm -or $norm.Count -eq 0) {
  throw "No usable records returned from /v2/alerts-summary (or response lacks clusterName/category/typeBucket)."
}

# Determine which buckets actually appear
$buckets = $norm | Select-Object -ExpandProperty TypeBucket | Sort-Object -Unique

# Prefer these three buckets if present
$preferred = @("kHardware","kMaintenance","kDataService")
$orderedBuckets = @()
foreach ($b in $preferred) { if ($buckets -contains $b) { $orderedBuckets += $b } }
foreach ($b in $buckets)   { if ($orderedBuckets -notcontains $b) { $orderedBuckets += $b } }

foreach ($b in $orderedBuckets) {
  $title = BucketTitle $b
  $rows  = Build-WideTilesFromNorm -normRecords $norm -bucketEnum $b
  Write-WideTable -title $title -rows $rows
}
