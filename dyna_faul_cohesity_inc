// compute_window (ET window starts at 18:00 America/New_York)
//
// Outputs:
// - correlationId : "Cohesity_Backup_Failures" (constant)
// - windowKey     : "YYYY-MM-DD_1800ET"       (e.g., 2025-12-18_1800ET)
// - shortDescKey  : "Cohesity Backup Failures | YYYY-MM-DD_1800ET"
// - windowLabel   : "YYYY-MM-DD 18:00 ET → YYYY-MM-DD 18:00 ET"

export default async function () {
  const TZ = "America/New_York";
  const START_HOUR = 18;
  const correlationId = "Cohesity_Backup_Failures";

  const pad2 = (n) => String(n).padStart(2, "0");

  function tzParts(date) {
    const dtf = new Intl.DateTimeFormat("en-US", {
      timeZone: TZ,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      hour12: false
    });
    const parts = dtf.formatToParts(date);
    const get = (t) => parts.find(p => p.type === t)?.value;
    return {
      y: Number(get("year")),
      m: Number(get("month")),
      d: Number(get("day")),
      h: Number(get("hour"))
    };
  }

  const ymd = (y, m, d) => `${y}-${pad2(m)}-${pad2(d)}`;

  // DST-safe date math using UTC noon anchor
  function addDays(ymdStr, days) {
    const [yy, mm, dd] = ymdStr.split("-").map(Number);
    const dt = new Date(Date.UTC(yy, mm - 1, dd, 12, 0, 0));
    dt.setUTCDate(dt.getUTCDate() + days);
    return ymd(dt.getUTCFullYear(), dt.getUTCMonth() + 1, dt.getUTCDate());
  }

  const now = new Date();
  const p = tzParts(now);

  // If ET time is before 18:00, the current window started yesterday at 18:00 ET
  let startDateStr = ymd(p.y, p.m, p.d);
  if (p.h < START_HOUR) {
    const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const py = tzParts(yesterday);
    startDateStr = ymd(py.y, py.m, py.d);
  }

  const endDateStr = addDays(startDateStr, 1);

  const windowKey    = `${startDateStr}_1800ET`;
  const shortDescKey = `Cohesity Backup Failures | ${windowKey}`;
  const windowLabel  = `${startDateStr} 18:00 ET → ${endDateStr} 18:00 ET`;

  return { correlationId, windowKey, shortDescKey, windowLabel };
}
