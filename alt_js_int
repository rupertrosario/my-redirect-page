// ------------------------------------------------------------
// Dynatrace JS2 | Helios Interface DOWN validator (clean)
// Input: alertTargets = result("Get_Alerts").results   (or wrapper)
// Output: markdownEmail + incidentText
// ------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function ({ alertTargets = [] } = {}) {
  const baseUrl = "https://helios.cohesity.com";

  // ---------- tiny helpers ----------
  const norm = (v) => (v === null || v === undefined) ? "" : String(v).trim();
  const safe = (v) => norm(v).replace(/\|/g, " ");

  function unwrap(v) {
    if (Array.isArray(v)) return v;
    if (v && Array.isArray(v.results)) return v.results; // ✅ common Dynatrace wrapper
    return [];
  }

  function pick(obj, keys) {
    for (const k of keys) {
      const val = obj?.[k];
      const s = norm(val);
      if (s) return s;
    }
    return "";
  }

  // ---------- auth ----------
  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = (all && all.credentials) ? all.credentials : [];
    const found = creds.find(c => c && c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey   = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch {
      authMode = "manual";
      apiKey   = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey || apiKey === "PASTE_YOUR_API_KEY_HERE") {
    return {
      authMode,
      targetsProvided: unwrap(alertTargets).length,
      targetsMatched: 0,
      clustersTargeted: 0,
      downCount: 0,
      markdownEmail: "❌ No valid Helios API key available.",
      incidentText: "❌ Helios interface validation failed: missing API key."
    };
  }

  // ---------- 1) filter interface alerts ----------
  const TRIGGER_EXACT = "CE030601105";
  const TRIGGER_NUM   = "1105";

  function isTrigger(code) {
    code = norm(code);
    if (!code) return false;
    if (code === TRIGGER_EXACT) return true;
    if (code === TRIGGER_NUM) return true;
    return code.includes(TRIGGER_NUM);
  }

  const rowsIn = unwrap(alertTargets);

  const interfaceTargets = [];
  for (const r of rowsIn) {
    const alertCode = pick(r, ["AlertCode", "alertCode"]);
    if (!isTrigger(alertCode)) continue;

    const clusterId   = pick(r, ["ClusterId", "clusterId"]);
    const clusterName = pick(r, ["ClusterName", "clusterName"]);
    const location    = pick(r, ["Location", "location"]);

    // ✅ Robust IP pickup (covers common variants)
    const ip = pick(r, ["IP", "ip", "NodeIP", "nodeIp", "node_ip", "hostIp", "host_ip"]);

    if (!clusterId || !ip) continue;

    interfaceTargets.push({
      Location: location,
      ClusterName: clusterName || `cluster-${clusterId}`,
      ClusterId: clusterId,
      IP: ip,
      AlertCode: alertCode
    });
  }

  if (!interfaceTargets.length) {
    // Minimal diagnostics (clean): shows if IP keys differ
    const firstKeys = rowsIn[0] ? Object.keys(rowsIn[0]).join(", ") : "(none)";
    return {
      authMode,
      targetsProvided: rowsIn.length,
      targetsMatched: 0,
      clustersTargeted: 0,
      downCount: 0,
      markdownEmail: "⏭️ No CE030601105 targets found OR IP/ClusterId not picked.\n\nFirst row keys:\n" + firstKeys,
      incidentText: "No interface-alert targets picked by JS2 (check keys: IP/ClusterId/AlertCode)."
    };
  }

  // ---------- 2) group by cluster -> IP set + location ----------
  const byCluster = {};
  for (const t of interfaceTargets) {
    const cid = t.ClusterId;
    if (!byCluster[cid]) {
      byCluster[cid] = {
        Location: t.Location,
        ClusterName: t.ClusterName,
        Ips: {}
      };
    }
    byCluster[cid].Ips[t.IP] = true;
  }

  const clusterIds = Object.keys(byCluster);

  // ---------- 3) call /public/interface per cluster ----------
  const ifaceUrl =
    baseUrl +
    "/irisservices/api/v1/public/interface" +
    "?bondInterfaceOnly=true" +
    "&ifaceGroupAssignedOnly=true" +
    "&includeUplinkSwitchInfo=true" +
    "&includeBondSlaveDetails=true";

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return resp.json();
  }

  const looksDown = (v) => norm(v).toLowerCase().includes("down");

  function indexDetails(details) {
    const map = {};
    const arr = Array.isArray(details) ? details : (details ? [details] : []);
    for (const d of arr) {
      const name = norm(d?.name || d?.["@name"] || d?.ifaceName || d?.interfaceName);
      if (name) map[name] = d;
    }
    return map;
  }

  const downRows = [];

  for (const cid of clusterIds) {
    const entry = byCluster[cid];

    let data;
    try {
      data = await getJson(ifaceUrl, {
        accept: "application/json",
        apiKey,
        accessClusterId: String(cid)
      });
    } catch {
      continue; // keep simple
    }

    const nodes = Array.isArray(data) ? data : (data ? [data] : []);
    for (const node of nodes) {
      const nodeIp = norm(node?.nodeIp);
      if (!nodeIp) continue;

      // ✅ match only the IPs from alerts
      if (!entry.Ips[nodeIp]) continue;

      const ifaces = Array.isArray(node?.interfaces) ? node.interfaces : (node?.interfaces ? [node.interfaces] : []);
      for (const bond of ifaces) {
        const bondName = norm(bond?.name);
        const slaves = Array.isArray(bond?.bondSlaves) ? bond.bondSlaves : (bond?.bondSlaves ? [bond.bondSlaves] : []);
        const slotTypes = Array.isArray(bond?.bondSlavesSlotTypes) ? bond.bondSlavesSlotTypes : [];
        const dmap = indexDetails(bond?.bondSlavesDetails);

        for (let i = 0; i < slaves.length; i++) {
          const s = slaves[i];
          const slaveName = norm(typeof s === "string" ? s : (s?.name || s?.["@name"]));
          if (!slaveName) continue;

          const d = dmap[slaveName] || {};
          const linkState = norm(d.linkState || d.state || d.status);
          if (!looksDown(linkState)) continue;

          downRows.push({
            Location: entry.Location,
            ClusterName: entry.ClusterName,
            NodeIP: nodeIp,
            BondName: bondName,
            Slave: slaveName,
            LinkState: linkState,
            Speed: norm(d.speed || d.linkSpeed || d.link_speed),
            MAC: norm(d.macAddr || d.mac || d.mac_address),
            SlotType: (slotTypes[i] !== null && slotTypes[i] !== undefined) ? String(slotTypes[i]) : ""
          });
        }
      }
    }
  }

  // ---------- 4) markdown + incident text ----------
  downRows.sort((a, b) =>
    safe(a.Location).localeCompare(safe(b.Location)) ||
    safe(a.ClusterName).localeCompare(safe(b.ClusterName)) ||
    safe(a.NodeIP).localeCompare(safe(b.NodeIP))
  );

  function toMarkdown(rows) {
    if (!rows.length) {
      return `✅ No confirmed DOWN slave interfaces.\n\n- Targets matched: ${interfaceTargets.length}\n- Clusters targeted: ${clusterIds.length}\n`;
    }
    const cols = ["Location","ClusterName","NodeIP","BondName","Slave","LinkState","Speed","MAC","SlotType"];
    const header = "| " + cols.join(" | ") + " |";
    const sep    = "| " + cols.map(() => "---").join(" | ") + " |";
    const body   = rows.map(r => "| " + cols.map(c => safe(r[c])).join(" | ") + " |");

    return (
      "### Cohesity: Confirmed DOWN slave interfaces\n\n" +
      `- Trigger: ${TRIGGER_EXACT}\n` +
      `- Confirmed DOWN rows: ${rows.length}\n\n` +
      [header, sep].concat(body).join("\n")
    );
  }

  const markdownEmail = toMarkdown(downRows);

  const incidentText = !downRows.length
    ? `Helios interface validation: no confirmed DOWN slave interfaces.\nTrigger: ${TRIGGER_EXACT}\nTargets: ${interfaceTargets.length}`
    : `Confirmed DOWN slave interfaces (Location matters for DC routing)\nTrigger: ${TRIGGER_EXACT}\nCount: ${downRows.length}\n` +
      downRows.slice(0, 25).map(r =>
        `- ${r.Location} | ${r.ClusterName} | ${r.NodeIP} | ${r.BondName}/${r.Slave} = ${r.LinkState}`
      ).join("\n") +
      (downRows.length > 25 ? `\n...and ${downRows.length - 25} more` : "");

  return {
    authMode,
    targetsProvided: rowsIn.length,
    targetsMatched: interfaceTargets.length,
    clustersTargeted: clusterIds.length,
    downCount: downRows.length,
    markdownEmail,
    markdownTable: markdownEmail,
    incidentText
  };
}
