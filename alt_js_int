// ------------------------------------------------------------
// Cohesity Helios – Interface DOWN Validator (GET only)
// Input (from workflow):
//   alertTargets: Array of alert rows (already filtered to CE3601105)
//     Each item should include at least:
//       - ClusterId
//       - ClusterName (optional)
//       - IP  (node_ip)
//
// What it does:
// - Groups IPs by ClusterId
// - Calls /irisservices/api/v1/public/interface (GET) per cluster
// - Finds matching node.nodeIp in targets
// - Emits rows only when bond slave linkState is DOWN
//
// Output:
// {
//   targetsProvided,
//   clustersTargeted,
//   downCount,
//   downRows: [...],
//   markdownTable
// }
// ------------------------------------------------------------

export default async function ({ alertTargets = [] } = {}) {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 0) Basic input validation
  // ------------------------------
  const targets = Array.isArray(alertTargets) ? alertTargets : [];
  if (!targets.length) {
    return {
      targetsProvided: 0,
      clustersTargeted: 0,
      downCount: 0,
      downRows: [],
      markdownTable: "⏭️ Interface validator: no alertTargets provided as input."
    };
  }

  // ------------------------------
  // 1) Helpers
  // ------------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }

  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function looksDown(v) {
    v = norm(v).toLowerCase();
    // variations: "down", "kLinkStateDown", etc.
    return v.includes("down");
  }

  function indexSlaveDetails(details) {
    const map = {};
    const arr = toArrayMaybe(details);
    for (let i = 0; i < arr.length; i++) {
      const d = arr[i] || {};
      const name = norm(d.name || d["@name"] || d.ifaceName || d.interfaceName || d.iface);
      if (name) map[name] = d;
    }
    return map;
  }

  // ------------------------------
  // 2) Build cluster -> ip set map from alertTargets
  // ------------------------------
  const byCluster = {};
  for (let i = 0; i < targets.length; i++) {
    const t = targets[i] || {};
    const clusterId = norm(t.ClusterId || t.clusterId);
    const clusterName = norm(t.ClusterName || t.clusterName);
    const ip = norm(t.IP || t.ip);

    if (!clusterId || !ip) continue;

    if (!byCluster[clusterId]) {
      byCluster[clusterId] = {
        ClusterId: clusterId,
        ClusterName: clusterName || ("cluster-" + clusterId),
        Ips: {}
      };
    }
    if (!byCluster[clusterId].ClusterName && clusterName) {
      byCluster[clusterId].ClusterName = clusterName;
    }
    byCluster[clusterId].Ips[ip] = true;
  }

  const clusterIds = Object.keys(byCluster);
  if (!clusterIds.length) {
    return {
      targetsProvided: targets.length,
      clustersTargeted: 0,
      downCount: 0,
      downRows: [],
      markdownTable: "⏭️ Interface validator: alertTargets had no usable ClusterId+IP."
    };
  }

  // ------------------------------
  // 3) Auth: expects Helios API key to be provided by Workflow HTTP settings
  // BUT: since your earlier scripts used Dynatrace credential vault in JS #1,
  // the simplest here is: REQUIRE apiKey be injected as a secret or reuse the same approach.
  //
  // ✅ Best practice: keep auth in ONE place (JS #1), but if you want this step standalone,
  // paste your vault auth block here.
  //
  // For now: assume apiKey is provided in request header by Dynatrace secret mapping:
  //   headers.apiKey = <your Helios key>
  // If your workflow doesn’t do that, tell me and I’ll paste the vault-auth block here.
  // ------------------------------

  // ✅ If you DO have vault auth in this script, set apiKey here.
  // For now, placeholder:
  const apiKey = "PASTE_YOUR_API_KEY_HERE";

  if (!apiKey || apiKey === "PASTE_YOUR_API_KEY_HERE") {
    return {
      targetsProvided: targets.length,
      clustersTargeted: clusterIds.length,
      downCount: 0,
      downRows: [],
      markdownTable:
        "⚠️ Interface validator: Helios apiKey not configured in JS #2. " +
        "Paste vault auth block here OR inject apiKey via workflow secret."
    };
  }

  // ------------------------------
  // 4) Interface endpoint (GET)
  // ------------------------------
  const ifaceUrl =
    baseUrl +
    "/irisservices/api/v1/public/interface" +
    "?bondInterfaceOnly=true" +
    "&ifaceGroupAssignedOnly=true" +
    "&includeUplinkSwitchInfo=true" +
    "&includeBondSlaveDetails=true";

  const downRows = [];

  // ------------------------------
  // 5) Query interface data per targeted clusterId
  // ------------------------------
  for (let k = 0; k < clusterIds.length; k++) {
    const cid = clusterIds[k];
    const entry = byCluster[cid];
    const clusterName = entry.ClusterName || ("cluster-" + cid);

    const headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: String(cid)
    };

    let ifaceData;
    try {
      ifaceData = await getJson(ifaceUrl, headers);
    } catch (e) {
      console.log("⚠️ Interface fetch failed for " + clusterName + " (" + cid + "): " + norm(e.message || e));
      continue;
    }

    const nodes = toArrayMaybe(ifaceData);

    for (let ni = 0; ni < nodes.length; ni++) {
      const node = nodes[ni] || {};
      const nodeIp = norm(node.nodeIp);
      if (!nodeIp) continue;

      // only nodes that are in alertTargets for this cluster
      if (!entry.Ips[nodeIp]) continue;

      const nodeId = norm(node.nodeId);
      const chassisSerial = norm(node.chassisSerial);

      const ifaces = toArrayMaybe(node.interfaces);

      for (let bi = 0; bi < ifaces.length; bi++) {
        const bond = ifaces[bi] || {};
        const bondName = norm(bond.name);
        const mtu = (bond.mtu === null || bond.mtu === undefined) ? "" : String(bond.mtu);

        const slaves = toArrayMaybe(bond.bondSlaves);
        const slotTypes = toArrayMaybe(bond.bondSlavesSlotTypes);
        const dmap = indexSlaveDetails(bond.bondSlavesDetails);

        for (let si = 0; si < slaves.length; si++) {
          const s = slaves[si];
          const slaveName = norm(
            typeof s === "string"
              ? s
              : (s && (s.name || s["@name"] || s.ifaceName || s.interfaceName))
          );
          if (!slaveName) continue;

          const d = dmap[slaveName] || {};
          const linkState = norm(d.linkState || d.link_state || d.state);

          // only DOWN
          if (!looksDown(linkState)) continue;

          downRows.push({
            ClusterName: clusterName,
            ClusterId: String(cid),
            NodeIP: nodeIp,
            NodeID: nodeId,
            ChassisSerial: chassisSerial,
            BondName: bondName,
            MTU: mtu,
            Slave: slaveName,
            LinkState: linkState,
            MAC: norm(d.macAddr || d.mac || d.mac_address),
            Speed: norm(d.speed || d.linkSpeed || d.link_speed),
            SlotType: (slotTypes[si] !== null && slotTypes[si] !== undefined) ? String(slotTypes[si]) : ""
          });
        }
      }
    }
  }

  // ------------------------------
  // 6) Markdown output
  // ------------------------------
  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  downRows.sort((a, b) =>
    safeCell(a.ClusterName).localeCompare(safeCell(b.ClusterName)) ||
    safeCell(a.NodeIP).localeCompare(safeCell(b.NodeIP)) ||
    safeCell(a.BondName).localeCompare(safeCell(b.BondName)) ||
    safeCell(a.Slave).localeCompare(safeCell(b.Slave))
  );

  function toMarkdownTable(rows, targetsProvided, clustersTargeted) {
    if (!rows || rows.length === 0) {
      return (
        "✅ No confirmed DOWN slave interfaces found for CE3601105 targets.\n\n" +
        "- Targets provided: " + targetsProvided + "\n" +
        "- Clusters targeted: " + clustersTargeted + "\n"
      );
    }

    const cols = ["ClusterName","ClusterId","NodeIP","NodeID","BondName","Slave","LinkState","Speed","MAC","SlotType"];
    const header = "| " + cols.join(" | ") + " |";
    const sep = "| " + cols.map(() => "---").join(" | ") + " |";
    const body = rows.map(r => "| " + cols.map(c => safeCell(r[c])).join(" | ") + " |");

    return (
      "### Cohesity: Interface DOWN details (confirmed via /public/interface)\n\n" +
      "- Targets provided: " + targetsProvided + "\n" +
      "- Clusters targeted: " + clustersTargeted + "\n" +
      "- Confirmed DOWN rows: " + rows.length + "\n\n" +
      [header, sep].concat(body).join("\n")
    );
  }

  const markdownTable = toMarkdownTable(downRows, targets.length, clusterIds.length);

  return {
    targetsProvided: targets.length,
    clustersTargeted: clusterIds.length,
    downCount: downRows.length,
    downRows: downRows,
    markdownTable: markdownTable
  };
}
