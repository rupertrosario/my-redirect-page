// ------------------------------------------------------------
// Dynatrace JS2 | Cohesity Helios Interface DOWN validator (GET only)
// Input (workflow mapping):
//   alertTargets: {{ result("get_alerts").results }}
//
// Output:
// - markdownEmail  -> send in email body
// - incidentText   -> paste into incident (includes Location for DC routing)
// ------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function ({ alertTargets = [] } = {}) {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // Helpers
  // ------------------------------
  const norm = (v) => (v === null || v === undefined) ? "" : String(v).trim();
  const safe = (v) => norm(v).replace(/\|/g, " ");
  const toArray = (v) => Array.isArray(v) ? v : (v && Array.isArray(v.results) ? v.results : []);

  function isDown(v) {
    return norm(v).toLowerCase().includes("down");
  }

  function indexDetails(details) {
    const map = {};
    const arr = Array.isArray(details) ? details : (details ? [details] : []);
    for (const d of arr) {
      const name = norm(d?.name || d?.["@name"] || d?.ifaceName || d?.interfaceName);
      if (name) map[name] = d;
    }
    return map;
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      const txt = await resp.text().catch(() => "");
      throw new Error(`HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // ------------------------------
  // Auth (vault-name -> vault-id -> manual)
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = (all && all.credentials) ? all.credentials : [];
    const found = creds.find(c => c && c.name === name);
    if (!found) return null;

    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey   = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch {
      authMode = "manual";
      apiKey   = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey || apiKey === "PASTE_YOUR_API_KEY_HERE") {
    return {
      authMode,
      targetsProvided: toArray(alertTargets).length,
      targetsMatched: 0,
      clustersTargeted: 0,
      downCount: 0,
      downRows: [],
      markdownEmail: "❌ No valid Helios API key available.",
      incidentText: "❌ Helios interface validation failed: missing API key."
    };
  }

  // ------------------------------
  // 1) Filter interface-trigger alerts
  // ------------------------------
  const TRIGGER_EXACT = "CE030601105";
  const TRIGGER_NUM   = "1105";

  function isTrigger(code) {
    code = norm(code);
    if (!code) return false;
    if (code === TRIGGER_EXACT) return true;
    if (code === TRIGGER_NUM) return true;
    return code.includes(TRIGGER_NUM);
  }

  const rowsIn = toArray(alertTargets);

  const interfaceTargets = [];
  for (const r of rowsIn) {
    const alertCode = norm(r?.AlertCode || r?.alertCode);
    if (!isTrigger(alertCode)) continue;

    const clusterId   = norm(r?.ClusterId || r?.clusterId);
    const clusterName = norm(r?.ClusterName || r?.clusterName);
    const location    = norm(r?.Location || r?.location);

    // IP from JS1 results
    const ip = norm(r?.IP || r?.ip || r?.NodeIP || r?.nodeIp || r?.node_ip);

    if (!clusterId || !ip) continue;

    interfaceTargets.push({
      Location: location,
      ClusterName: clusterName || `cluster-${clusterId}`,
      ClusterId: clusterId,
      IP: ip,
      AlertCode: alertCode
    });
  }

  if (!interfaceTargets.length) {
    return {
      authMode,
      targetsProvided: rowsIn.length,
      targetsMatched: 0,
      clustersTargeted: 0,
      downCount: 0,
      downRows: [],
      markdownEmail: "⏭️ No CE030601105/1105 targets found with ClusterId+IP in input.",
      incidentText: "No interface-alert targets (CE030601105/1105) found with ClusterId+IP."
    };
  }

  // ------------------------------
  // 2) Group by ClusterId -> IP set + meta
  // ------------------------------
  const byCluster = {};
  for (const t of interfaceTargets) {
    const cid = t.ClusterId;
    if (!byCluster[cid]) {
      byCluster[cid] = {
        ClusterId: cid,
        ClusterName: t.ClusterName,
        Location: t.Location,
        Ips: {}
      };
    }
    byCluster[cid].Ips[t.IP] = true;
    if (!byCluster[cid].Location && t.Location) byCluster[cid].Location = t.Location;
    if (!byCluster[cid].ClusterName && t.ClusterName) byCluster[cid].ClusterName = t.ClusterName;
  }

  const clusterIds = Object.keys(byCluster);

  // ------------------------------
  // 3) Fetch /public/interface per cluster and match by IP
  // ------------------------------
  const ifaceUrl =
    baseUrl +
    "/irisservices/api/v1/public/interface" +
    "?bondInterfaceOnly=true" +
    "&ifaceGroupAssignedOnly=true" +
    "&includeUplinkSwitchInfo=true" +
    "&includeBondSlaveDetails=true";

  const downRows = [];

  for (const cid of clusterIds) {
    const entry = byCluster[cid];

    let data;
    try {
      data = await getJson(ifaceUrl, {
        accept: "application/json",
        apiKey,
        accessClusterId: String(cid)
      });
    } catch {
      continue; // keep simple
    }

    const nodes = Array.isArray(data) ? data : (data ? [data] : []);
    for (const node of nodes) {
      const nodeIp = norm(node?.nodeIp || node?.ip);
      if (!nodeIp) continue;

      // ✅ THIS is the IP comparison (alert IPs vs interface nodeIp)
      if (!entry.Ips[nodeIp]) continue;

      const ifaces = Array.isArray(node?.interfaces) ? node.interfaces : (node?.interfaces ? [node.interfaces] : []);
      for (const bond of ifaces) {
        const bondName = norm(bond?.name);
        const slaves = Array.isArray(bond?.bondSlaves) ? bond.bondSlaves : (bond?.bondSlaves ? [bond.bondSlaves] : []);
        const slotTypes = Array.isArray(bond?.bondSlavesSlotTypes) ? bond.bondSlavesSlotTypes : [];
        const dmap = indexDetails(bond?.bondSlavesDetails);

        for (let i = 0; i < slaves.length; i++) {
          const s = slaves[i];
          const slaveName = norm(typeof s === "string" ? s : (s?.name || s?.["@name"]));
          if (!slaveName) continue;

          const d = dmap[slaveName] || {};
          const linkState = norm(d.linkState || d.state || d.status);
          if (!isDown(linkState)) continue;

          downRows.push({
            Location: entry.Location,
            ClusterName: entry.ClusterName,
            ClusterId: String(cid),
            IP: nodeIp,
            BondName: bondName,
            Slave: slaveName,
            LinkState: linkState,
            Speed: norm(d.speed || d.linkSpeed || d.link_speed),
            MAC: norm(d.macAddr || d.mac || d.mac_address),
            SlotType: (slotTypes[i] !== null && slotTypes[i] !== undefined) ? String(slotTypes[i]) : ""
          });
        }
      }
    }
  }

  // ------------------------------
  // 4) Build markdownEmail + incidentText
  // ------------------------------
  downRows.sort((a, b) =>
    safe(a.Location).localeCompare(safe(b.Location)) ||
    safe(a.ClusterName).localeCompare(safe(b.ClusterName)) ||
    safe(a.IP).localeCompare(safe(b.IP)) ||
    safe(a.BondName).localeCompare(safe(b.BondName)) ||
    safe(a.Slave).localeCompare(safe(b.Slave))
  );

  function toMarkdown(rows) {
    if (!rows.length) {
      return (
        "✅ No confirmed DOWN slave interfaces found.\n\n" +
        `- Trigger: ${TRIGGER_EXACT}\n` +
        `- Targets matched: ${interfaceTargets.length}\n` +
        `- Clusters targeted: ${clusterIds.length}\n`
      );
    }

    const cols = ["Location","ClusterName","ClusterId","IP","BondName","Slave","LinkState","Speed","MAC","SlotType"];
    const header = "| " + cols.join(" | ") + " |";
    const sep    = "| " + cols.map(() => "---").join(" | ") + " |";
    const body   = rows.map(r => "| " + cols.map(c => safe(r[c])).join(" | ") + " |");

    return (
      "### Cohesity: Confirmed DOWN slave interfaces (Helios /public/interface)\n\n" +
      `- Trigger: ${TRIGGER_EXACT}\n` +
      `- Confirmed DOWN rows: ${rows.length}\n\n` +
      [header, sep].concat(body).join("\n")
    );
  }

  const markdownEmail = toMarkdown(downRows);

  const incidentText = !downRows.length
    ? `Helios interface validation complete: no confirmed DOWN slave interfaces.\nTrigger: ${TRIGGER_EXACT}\nTargets: ${interfaceTargets.length}, Clusters: ${clusterIds.length}`
    : `Confirmed DOWN slave interfaces (Location for DC routing)\nTrigger: ${TRIGGER_EXACT}\nCount: ${downRows.length}\n` +
      downRows.slice(0, 30).map(r =>
        `- ${r.Location} | ${r.ClusterName} | ${r.IP} | ${r.BondName}/${r.Slave} = ${r.LinkState}`
      ).join("\n") +
      (downRows.length > 30 ? `\n...and ${downRows.length - 30} more` : "");

  return {
    authMode,
    targetsProvided: rowsIn.length,
    targetsMatched: interfaceTargets.length,
    clustersTargeted: clusterIds.length,
    downCount: downRows.length,
    downRows,
    markdownEmail,
    markdownTable: markdownEmail,
    incidentText
  };
}
