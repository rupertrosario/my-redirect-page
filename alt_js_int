// ------------------------------------------------------------
// Dynatrace JS2 | Cohesity Helios Interface DOWN validator + SNOW payloads (GET only)
// Sanity-checked for: "credentialVaultClient already declared" => uses alias import `vault`
//
// Reads alerts from workflow step: "get_alerts"
// Calls Helios interface API (GET) per cluster
// Matches by IP from alerts vs nodeIp from interface API
// Builds SNOW payloads (simple):
//   teamIncident (one) + dcIncidents (one per allowlisted location)
//
// DC allowlist: San Antonio, Carrollton, Detroit
// ------------------------------------------------------------

import { credentialVaultClient as vault } from "@dynatrace-sdk/client-classic-environment-v2";
import { result as wfResult } from "@dynatrace-sdk/automation-utils";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";
  const PREDECESSOR_TASK = "get_alerts";

  // DC allowlist
  const DC_ALLOWLIST_ENABLED = true; // later: set false to process ALL locations
  const DC_ALLOWLIST = ["San Antonio", "Carrollton", "Detroit"];

  // Trigger codes
  const TRIGGER_EXACT = "CE030601105";
  const TRIGGER_NUM = "1105";

  // Vault
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  // ------------------------------
  // small helpers
  // ------------------------------
  const norm = (v) => (v === null || v === undefined) ? "" : String(v).trim();
  const normLoc = (s) => norm(s).toLowerCase().replace(/\s+/g, " ");
  const slug = (s) => norm(s).toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");

  function isTrigger(code) {
    code = norm(code);
    if (!code) return false;
    if (code === TRIGGER_EXACT) return true;
    if (code === TRIGGER_NUM) return true;
    return code.includes(TRIGGER_NUM);
  }

  function pickIP(r) {
    return norm(r?.IP || r?.ip || r?.NodeIP || r?.nodeIp || r?.node_ip);
  }

  function toArray(v) {
    if (Array.isArray(v)) return v;
    if (v && Array.isArray(v.results)) return v.results;
    if (v && v.result && Array.isArray(v.result.results)) return v.result.results;
    return [];
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      const txt = await resp.text().catch(() => "");
      throw new Error(`HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  function indexDetails(details) {
    const map = {};
    const arr = Array.isArray(details) ? details : (details ? [details] : []);
    for (const d of arr) {
      const name = norm(d?.name || d?.["@name"] || d?.ifaceName || d?.interfaceName);
      if (name) map[name] = d;
    }
    return map;
  }

  function looksDown(v) {
    return norm(v).toLowerCase().includes("down");
  }

  // ------------------------------
  // 0) Read JS1 output from workflow context
  // ------------------------------
  let upstream;
  try {
    upstream = await wfResult(PREDECESSOR_TASK);
  } catch (e) {
    return {
      ok: false,
      error: `Cannot read result("${PREDECESSOR_TASK}")`,
      details: norm(e?.message || e),
      teamIncident: null,
      dcIncidents: []
    };
  }

  const alertRows = toArray(upstream?.results ?? upstream);

  // Build targets + map of AlertCause by (ClusterId|IP)
  const interfaceTargets = [];
  const alertCauseByKey = {}; // key: clusterId|ip -> AlertCause

  for (const r of alertRows) {
    const alertCode = norm(r?.AlertCode || r?.alertCode);
    if (!isTrigger(alertCode)) continue;

    const clusterId = norm(r?.ClusterId || r?.clusterId);
    const ip = pickIP(r);
    if (!clusterId || !ip) continue;

    const clusterName = norm(r?.ClusterName || r?.clusterName) || `cluster-${clusterId}`;
    const location = norm(r?.Location || r?.location);
    const alertCause = norm(r?.AlertCause || r?.alertCause);

    interfaceTargets.push({
      ClusterId: clusterId,
      ClusterName: clusterName,
      Location: location,
      IP: ip
    });

    const key = `${clusterId}|${ip}`;
    if (alertCause && !alertCauseByKey[key]) alertCauseByKey[key] = alertCause;
  }

  if (!interfaceTargets.length) {
    return {
      ok: true,
      message: "No matching interface alert targets found.",
      teamIncident: null,
      dcIncidents: []
    };
  }

  // ------------------------------
  // 1) Group targets by cluster -> IP set + meta
  // ------------------------------
  const byCluster = {};
  for (const t of interfaceTargets) {
    const cid = t.ClusterId;
    if (!byCluster[cid]) {
      byCluster[cid] = {
        ClusterId: cid,
        ClusterName: t.ClusterName,
        Location: t.Location,
        Ips: {}
      };
    }
    byCluster[cid].Ips[t.IP] = true;
    if (!byCluster[cid].ClusterName && t.ClusterName) byCluster[cid].ClusterName = t.ClusterName;
    if (!byCluster[cid].Location && t.Location) byCluster[cid].Location = t.Location;
  }

  const clusterIds = Object.keys(byCluster);

  // ------------------------------
  // 2) Helios API key (vault-name -> vault-id -> manual)
  // ------------------------------
  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await vault.getCredentials();
    const creds = (all && all.credentials) ? all.credentials : [];
    const found = creds.find(c => c && c.name === name);
    if (!found) return null;
    const detail = await vault.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const d2 = await vault.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey || apiKey === "PASTE_YOUR_API_KEY_HERE") {
    return {
      ok: false,
      error: "No valid Helios API key available.",
      authMode,
      teamIncident: null,
      dcIncidents: []
    };
  }

  // ------------------------------
  // 3) Call interface API per cluster and confirm DOWN slaves
  // ------------------------------
  const ifaceUrl =
    baseUrl +
    "/irisservices/api/v1/public/interface" +
    "?bondInterfaceOnly=true" +
    "&ifaceGroupAssignedOnly=true" +
    "&includeUplinkSwitchInfo=true" +
    "&includeBondSlaveDetails=true";

  // Keep only what you asked for:
  // ClusterName, IP, Serial, MAC, AlertCause, Location (for DC grouping)
  const downRows = [];

  for (const cid of clusterIds) {
    const entry = byCluster[cid];

    let data;
    try {
      data = await getJson(ifaceUrl, {
        accept: "application/json",
        apiKey,
        accessClusterId: String(cid)
      });
    } catch {
      continue;
    }

    const nodes = Array.isArray(data) ? data : (data ? [data] : []);
    for (const node of nodes) {
      const nodeIp = norm(node?.nodeIp || node?.ip);
      if (!nodeIp) continue;

      // âœ… IP match here (alerts IP set vs nodeIp)
      if (!entry.Ips[nodeIp]) continue;

      const serial = norm(node?.chassisSerial);

      const ifaces = Array.isArray(node?.interfaces) ? node.interfaces : (node?.interfaces ? [node.interfaces] : []);
      for (const bond of ifaces) {
        const slaves = Array.isArray(bond?.bondSlaves) ? bond.bondSlaves : (bond?.bondSlaves ? [bond.bondSlaves] : []);
        const dmap = indexDetails(bond?.bondSlavesDetails);

        for (const s of slaves) {
          const slaveName = norm(typeof s === "string" ? s : (s?.name || s?.["@name"]));
          if (!slaveName) continue;

          const d = dmap[slaveName] || {};
          const linkState = norm(d.linkState || d.state || d.status);
          if (!looksDown(linkState)) continue;

          const mac = norm(d.macAddr || d.mac || d.mac_address);

          const causeKey = `${cid}|${nodeIp}`;
          const alertCause = alertCauseByKey[causeKey] || norm(alertCauseByKey[`${cid}|${pickIP({ IP: nodeIp })}`]) || "";

          downRows.push({
            Location: entry.Location,
            ClusterName: entry.ClusterName,
            ClusterId: String(cid),
            IP: nodeIp,
            Serial: serial,
            MAC: mac,
            AlertCause: alertCause
          });
        }
      }
    }
  }

  if (!downRows.length) {
    return {
      ok: true,
      authMode,
      message: "No confirmed DOWN interfaces found.",
      downRows: [],
      teamIncident: null,
      dcIncidents: [],
      dcAllowlistEnabled: DC_ALLOWLIST_ENABLED,
      dcAllowlist: DC_ALLOWLIST
    };
  }

  // ------------------------------
  // 4) Build SNOW payloads (simple, no counts, no extras)
  // ------------------------------
  function shortLine(r) {
    return `Cohesity Interface DOWN on Cluster: ${r.ClusterName}  IP: ${r.IP}  Serial NO: ${r.Serial}  Mac: ${r.MAC}`;
  }

  function fullLine(r) {
    const cause = r.AlertCause ? ` and the description from the alert: ${r.AlertCause}` : "";
    return `${shortLine(r)}${cause}`;
  }

  // Team: short from first row; description lists all
  const first = downRows[0];

  const teamIncident = {
    correlation_id: "cohesity_ifdown_team",
    short_description: shortLine(first),
    description: downRows.map(fullLine).join("\n")
  };

  // DC: group by location, apply allowlist
  const allowSet = new Set(DC_ALLOWLIST.map(normLoc));
  const dcByLoc = {};

  for (const r of downRows) {
    const loc = norm(r.Location) || "Unknown";
    if (!dcByLoc[loc]) dcByLoc[loc] = [];
    dcByLoc[loc].push(r);
  }

  const dcIncidents = [];
  for (const loc of Object.keys(dcByLoc)) {
    const allowed = !DC_ALLOWLIST_ENABLED || allowSet.has(normLoc(loc));
    if (!allowed) continue;

    const rows = dcByLoc[loc];
    const f = rows[0];

    dcIncidents.push({
      location: loc,
      correlation_id: `cohesity_ifdown_dc_${slug(loc)}`,
      short_description: shortLine(f),
      description: rows.map(fullLine).join("\n")
    });
  }

  return {
    ok: true,
    authMode,
    downRows,
    teamIncident,
    dcIncidents,
    dcAllowlistEnabled: DC_ALLOWLIST_ENABLED,
    dcAllowlist: DC_ALLOWLIST
  };
}
