import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Dynatrace Workflow Action (JS)
 * Input:
 *   {
 *     alertTargets: [ { ClusterId, ClusterName, IP, AlertCode, ... }, ... ]
 *   }
 *
 * Output:
 *   {
 *     authMode,
 *     targetsProvided,
 *     debugAlertCodes,
 *     targetsMatched,
 *     clustersTargeted,
 *     downCount,
 *     interfaceTargets,
 *     downRows,
 *     markdownTable,
 *     markdownEmail
 *   }
 */

export default async function ({ alertTargets = [] } = {}) {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) AUTH (vault-name -> vault-id -> manual)
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    let found = null;
    for (let i = 0; i < (all.credentials || []).length; i++) {
      if (all.credentials[i].name === name) {
        found = all.credentials[i];
        break;
      }
    }
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) {
    return {
      authMode,
      targetsProvided: Array.isArray(alertTargets) ? alertTargets.length : 0,
      debugAlertCodes: [],
      targetsMatched: 0,
      clustersTargeted: 0,
      downCount: 0,
      interfaceTargets: [],
      downRows: [],
      markdownTable: "❌ No Helios API key available."
    };
  }

  // ------------------------------
  // 2) Helpers
  // ------------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }

  function normLower(v) {
    return norm(v).toLowerCase();
  }

  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try {
        txt = await resp.text();
      } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function looksDown(v) {
    const s = normLower(v);
    return s.includes("down"); // covers "down", "kLinkStateDown", etc.
  }

  // bondSlavesDetails index by interface name
  function indexSlaveDetails(details) {
    const map = {};
    const arr = toArrayMaybe(details);
    for (let i = 0; i < arr.length; i++) {
      const d = arr[i] || {};
      const name = norm(d.name || d["@name"] || d.ifaceName || d.interfaceName || d.iface);
      if (name) map[name] = d;
    }
    return map;
  }

  // ------------------------------
  // 3) DC detection from cluster location
  // ------------------------------
  function detectDC(locationStr) {
    const s = normLower(locationStr);

    // ✅ your DCs
    if (s.includes("san antonio")) return "San Antonio";
    if (s.includes("carrollton")) return "Carrollton";

    return "OTHER";
  }

  async function getClusterLocationMap() {
    const url = baseUrl + "/v2/mcm/cluster-mgmt/info";
    const headers = { accept: "application/json", apiKey };

    const data = await getJson(url, headers);
    const clusters = toArrayMaybe(data && data.cohesityClusters);

    const map = {};
    for (let i = 0; i < clusters.length; i++) {
      const c = clusters[i] || {};
      const cid = norm(c.clusterId);
      if (!cid) continue;
      // you said: cohesityClusters.location
      map[cid] = norm(c.location);
    }
    return map;
  }

  // ------------------------------
  // 4) Filter input alertTargets to ONLY interface-related codes
  //    Edit this list if needed.
  // ------------------------------
  const TRIGGER_CODES = ["CE3601105", "1105"]; // <-- adjust if your env uses a different CE-code

  function isTriggerAlertCode(code) {
    const c = norm(code);
    if (!c) return false;

    // exact match OR contains numeric 1105 (covers CE...1105 variations)
    for (let i = 0; i < TRIGGER_CODES.length; i++) {
      const t = TRIGGER_CODES[i];
      if (!t) continue;
      if (c === t) return true;
      if (t === "1105" && c.includes("1105")) return true;
    }
    return false;
  }

  const targetsIn = Array.isArray(alertTargets) ? alertTargets : [];

  // Debug: show top 10 alert codes received (so you can confirm what’s coming)
  const codesSeen = {};
  for (let i = 0; i < targetsIn.length; i++) {
    const r = targetsIn[i] || {};
    const code = norm(r.AlertCode || r.alertCode);
    if (code) codesSeen[code] = (codesSeen[code] || 0) + 1;
  }
  const debugAlertCodes = Object.keys(codesSeen)
    .sort((a, b) => codesSeen[b] - codesSeen[a])
    .slice(0, 10)
    .map((c) => ({ AlertCode: c, Count: codesSeen[c] }));

  // Build interfaceTargets (dedupe by ClusterId+IP)
  const uniq = {};
  const interfaceTargets = [];

  for (let i = 0; i < targetsIn.length; i++) {
    const r = targetsIn[i] || {};

    const alertCode = norm(r.AlertCode || r.alertCode);
    if (!isTriggerAlertCode(alertCode)) continue;

    const clusterId = norm(r.ClusterId || r.clusterId);
    const clusterName = norm(r.ClusterName || r.clusterName);
    const ip = norm(r.IP || r.ip);

    if (!clusterId || !ip) continue;

    const key = clusterId + "|" + ip;
    if (uniq[key]) continue;
    uniq[key] = true;

    interfaceTargets.push({
      ClusterId: clusterId,
      ClusterName: clusterName,
      IP: ip,
      AlertCode: alertCode,
      Severity: norm(r.Severity || r.severity),
      AlertState: norm(r.AlertState || r.alertState),
      Id: norm(r.Id || r.id)
    });
  }

  // ⏭️ If nothing to validate, exit early (fast)
  if (!interfaceTargets.length) {
    return {
      authMode,
      targetsProvided: targetsIn.length,
      debugAlertCodes,
      targetsMatched: 0,
      clustersTargeted: 0,
      downCount: 0,
      interfaceTargets: [],
      downRows: [],
      markdownTable:
        "⏭️ Skipped interface validation (no matching interface alert codes found).\n\n" +
        "Top alert codes seen:\n" +
        (debugAlertCodes.length
          ? debugAlertCodes.map((x) => `- ${x.AlertCode} (${x.Count})`).join("\n")
          : "- (none)")
    };
  }

  // ------------------------------
  // 5) Cluster location map (for DC routing)
  // ------------------------------
  let clusterLocMap = {};
  try {
    clusterLocMap = await getClusterLocationMap();
  } catch (e) {
    // still proceed without location
    clusterLocMap = {};
  }

  // Group targets by clusterId -> IP set
  const byCluster = {};
  for (let i = 0; i < interfaceTargets.length; i++) {
    const t = interfaceTargets[i];
    const cid = t.ClusterId;
    if (!byCluster[cid]) {
      byCluster[cid] = {
        ClusterId: cid,
        ClusterName: t.ClusterName || ("cluster-" + cid),
        Ips: {}
      };
    }
    byCluster[cid].Ips[t.IP] = true;
    if (!byCluster[cid].ClusterName && t.ClusterName) byCluster[cid].ClusterName = t.ClusterName;
  }

  const clusterIds = Object.keys(byCluster);

  // ------------------------------
  // 6) Interface check (GET-only)
  // ------------------------------
  const ifaceUrl =
    baseUrl +
    "/irisservices/api/v1/public/interface" +
    "?bondInterfaceOnly=true" +
    "&ifaceGroupAssignedOnly=true" +
    "&includeUplinkSwitchInfo=true" +
    "&includeBondSlaveDetails=true";

  const downRows = [];

  for (let k = 0; k < clusterIds.length; k++) {
    const cid = clusterIds[k];
    const entry = byCluster[cid];
    const clusterName = entry.ClusterName || ("cluster-" + cid);

    const headers = { accept: "application/json", apiKey, accessClusterId: String(cid) };

    let ifaceData;
    try {
      ifaceData = await getJson(ifaceUrl, headers);
    } catch (e) {
      // skip cluster if interface API fails
      continue;
    }

    const nodes = toArrayMaybe(ifaceData);
    const location = clusterLocMap[String(cid)] || "";
    const dc = detectDC(location);

    for (let ni = 0; ni < nodes.length; ni++) {
      const node = nodes[ni] || {};
      const nodeIp = norm(node.nodeIp);
      if (!nodeIp) continue;

      // only nodes that are in the alertTargets list for this cluster
      if (!entry.Ips[nodeIp]) continue;

      const nodeId = norm(node.nodeId);
      const chassisSerial = norm(node.chassisSerial);
      const ifaces = toArrayMaybe(node.interfaces);

      for (let bi = 0; bi < ifaces.length; bi++) {
        const bond = ifaces[bi] || {};
        const bondName = norm(bond.name);
        const mtu = bond.mtu === null || bond.mtu === undefined ? "" : String(bond.mtu);

        const slaves = toArrayMaybe(bond.bondSlaves);
        const slotTypes = toArrayMaybe(bond.bondSlavesSlotTypes);
        const dmap = indexSlaveDetails(bond.bondSlavesDetails);

        for (let si = 0; si < slaves.length; si++) {
          const s = slaves[si];
          const slaveName = norm(
            typeof s === "string"
              ? s
              : (s && (s.name || s["@name"] || s.ifaceName || s.interfaceName))
          );
          if (!slaveName) continue;

          const d = dmap[slaveName] || {};
          const linkState = norm(d.linkState || d.link_state || d.state);

          if (!looksDown(linkState)) continue;

          // Correlation IDs
          const ourCorrelationId =
            "COH_IFACE_DOWN|CL=" +
            String(cid) +
            "|IP=" +
            nodeIp +
            "|BOND=" +
            bondName +
            "|SLV=" +
            slaveName;

          const dcCorrelationId =
            "COH_DC_NET|DC=" + dc + "|CL=" + String(cid) + "|IP=" + nodeIp;

          downRows.push({
            ClusterName: clusterName,
            ClusterId: String(cid),
            Location: location,
            DC: dc,

            NodeIP: nodeIp,
            NodeID: nodeId,
            ChassisSerial: chassisSerial,

            BondName: bondName,
            MTU: mtu,
            Slave: slaveName,
            LinkState: linkState,
            MAC: norm(d.macAddr || d.mac || d.mac_address),
            Speed: norm(d.speed || d.linkSpeed || d.link_speed),
            SlotType: slotTypes[si] !== null && slotTypes[si] !== undefined ? String(slotTypes[si]) : "",

            OurCorrelationId: ourCorrelationId,
            DcCorrelationId: dcCorrelationId
          });
        }
      }
    }
  }

  // ------------------------------
  // 7) Markdown output
  // ------------------------------
  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  downRows.sort((a, b) =>
    safeCell(a.DC).localeCompare(safeCell(b.DC)) ||
    safeCell(a.ClusterName).localeCompare(safeCell(b.ClusterName)) ||
    safeCell(a.NodeIP).localeCompare(safeCell(b.NodeIP)) ||
    safeCell(a.BondName).localeCompare(safeCell(b.BondName)) ||
    safeCell(a.Slave).localeCompare(safeCell(b.Slave))
  );

  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) {
      return (
        "✅ No confirmed DOWN slave interfaces found for matching interface alerts.\n\n" +
        "- Targets matched: " + interfaceTargets.length + "\n" +
        "- Clusters targeted: " + clusterIds.length + "\n"
      );
    }

    const cols = [
      "DC",
      "Location",
      "ClusterName",
      "ClusterId",
      "NodeIP",
      "BondName",
      "Slave",
      "LinkState",
      "Speed",
      "MAC",
      "OurCorrelationId",
      "DcCorrelationId"
    ];

    const header = "| " + cols.join(" | ") + " |";
    const sep = "| " + cols.map(() => "---").join(" | ") + " |";

    const body = rows.map((r) => {
      return "| " + cols.map((c) => safeCell(r[c])).join(" | ") + " |";
    });

    return (
      "### Cohesity: Interface DOWN details (confirmed via /public/interface)\n\n" +
      "- Targets matched: " + interfaceTargets.length + "\n" +
      "- Clusters targeted: " + clusterIds.length + "\n" +
      "- Confirmed DOWN rows: " + rows.length + "\n\n" +
      [header, sep].concat(body).join("\n")
    );
  }

  const markdownTable = toMarkdownTable(downRows);

  return {
    authMode,
    targetsProvided: targetsIn.length,
    debugAlertCodes,
    targetsMatched: interfaceTargets.length,
    clustersTargeted: clusterIds.length,
    downCount: downRows.length,
    interfaceTargets,
    downRows,
    markdownTable,
    markdownEmail: markdownTable
  };
}
