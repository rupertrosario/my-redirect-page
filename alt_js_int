import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

// JS2: Interface status check by IP (no alert filtering here)
// Input: { alertTargets: [ { ClusterId, ClusterName, IP, ... } ] }
export default async function ({ alertTargets = [] } = {}) {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) AUTH (vault-name -> vault-id -> manual)
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    let found = null;
    for (let i = 0; i < (all.credentials || []).length; i++) {
      if (all.credentials[i].name === name) {
        found = all.credentials[i];
        break;
      }
    }
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) {
    return {
      authMode,
      targetsProvided: Array.isArray(alertTargets) ? alertTargets.length : 0,
      targetsUsable: 0,
      clustersTargeted: 0,
      nodesMatched: 0,
      downCount: 0,
      debug: { reason: "No Helios API key available" },
      downRows: [],
      markdownTable: "❌ No Helios API key available."
    };
  }

  // ------------------------------
  // 2) Helpers
  // ------------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }
  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }
  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }
  function looksDown(v) {
    const s = norm(v).toLowerCase();
    return s.includes("down");
  }

  // build map slaveName -> detail object
  function indexSlaveDetails(details) {
    const map = {};
    const arr = toArrayMaybe(details);
    for (let i = 0; i < arr.length; i++) {
      const d = arr[i] || {};
      const name = norm(d.name || d["@name"] || d.ifaceName || d.interfaceName || d.iface);
      if (name) map[name] = d;
    }
    return map;
  }

  // ------------------------------
  // 3) Normalize input -> group by ClusterId
  // ------------------------------
  const targetsIn = Array.isArray(alertTargets) ? alertTargets : [];

  // Accept either ClusterId/clusterId and IP/ip/node_ip etc.
  const usable = [];
  for (let i = 0; i < targetsIn.length; i++) {
    const r = targetsIn[i] || {};
    const clusterId = norm(r.ClusterId || r.clusterId);
    const clusterName = norm(r.ClusterName || r.clusterName);
    const ip = norm(r.IP || r.ip || r.node_ip || r.nodeIp);

    if (!clusterId || !ip) continue;

    usable.push({
      ClusterId: clusterId,
      ClusterName: clusterName,
      IP: ip
    });
  }

  if (!usable.length) {
    return {
      authMode,
      targetsProvided: targetsIn.length,
      targetsUsable: 0,
      clustersTargeted: 0,
      nodesMatched: 0,
      downCount: 0,
      debug: {
        reason: "No usable targets (need ClusterId + IP).",
        sampleInputFirst: targetsIn.length ? targetsIn[0] : null
      },
      downRows: [],
      markdownTable: "⏭️ No usable targets (need ClusterId + IP)."
    };
  }

  const byCluster = {};
  for (let i = 0; i < usable.length; i++) {
    const t = usable[i];
    if (!byCluster[t.ClusterId]) {
      byCluster[t.ClusterId] = { ClusterId: t.ClusterId, ClusterName: t.ClusterName || ("cluster-" + t.ClusterId), Ips: {} };
    }
    if (!byCluster[t.ClusterId].ClusterName && t.ClusterName) byCluster[t.ClusterId].ClusterName = t.ClusterName;
    byCluster[t.ClusterId].Ips[t.IP] = true;
  }
  const clusterIds = Object.keys(byCluster);

  // ------------------------------
  // 4) Interface endpoint (GET)
  // ------------------------------
  const ifaceUrl =
    baseUrl +
    "/irisservices/api/v1/public/interface" +
    "?bondInterfaceOnly=true" +
    "&ifaceGroupAssignedOnly=true" +
    "&includeUplinkSwitchInfo=true" +
    "&includeBondSlaveDetails=true";

  const downRows = [];
  let nodesMatched = 0;

  // useful debug if “no details” again:
  const debug = {
    targetIpsByCluster: Object.keys(byCluster).slice(0, 10).map(cid => ({
      ClusterId: cid,
      ClusterName: byCluster[cid].ClusterName,
      TargetIps: Object.keys(byCluster[cid].Ips).slice(0, 10)
    })),
    interfaceNodeIpsSeenSample: [] // filled only when no match
  };

  for (let k = 0; k < clusterIds.length; k++) {
    const cid = clusterIds[k];
    const entry = byCluster[cid];
    const clusterName = entry.ClusterName || ("cluster-" + cid);

    const headers = { accept: "application/json", apiKey, accessClusterId: String(cid) };

    let ifaceData;
    try {
      ifaceData = await getJson(ifaceUrl, headers);
    } catch (e) {
      downRows.push({
        ClusterName: clusterName,
        ClusterId: String(cid),
        NodeIP: "",
        NodeID: "",
        BondName: "",
        Slave: "",
        LinkState: "",
        Speed: "",
        MAC: "",
        SlotType: "",
        Note: "Interface API call failed: " + norm(e.message || e)
      });
      continue;
    }

    const nodes = toArrayMaybe(ifaceData);

    // If nothing matches, capture some nodeIps for you to compare quickly
    let matchedAnyInThisCluster = false;

    for (let ni = 0; ni < nodes.length; ni++) {
      const node = nodes[ni] || {};
      const nodeIp = norm(node.nodeIp);
      if (!nodeIp) continue;

      if (!entry.Ips[nodeIp]) continue; // <-- THIS is the IP comparison you asked for

      matchedAnyInThisCluster = true;
      nodesMatched++;

      const nodeId = norm(node.nodeId);
      const chassisSerial = norm(node.chassisSerial);
      const ifaces = toArrayMaybe(node.interfaces);

      let anyDownForNode = false;

      for (let bi = 0; bi < ifaces.length; bi++) {
        const bond = ifaces[bi] || {};
        const bondName = norm(bond.name);
        const slaves = toArrayMaybe(bond.bondSlaves);
        const slotTypes = toArrayMaybe(bond.bondSlavesSlotTypes);
        const dmap = indexSlaveDetails(bond.bondSlavesDetails);

        for (let si = 0; si < slaves.length; si++) {
          const s = slaves[si];
          const slaveName = norm(
            typeof s === "string"
              ? s
              : (s && (s.name || s["@name"] || s.ifaceName || s.interfaceName))
          );
          if (!slaveName) continue;

          const d = dmap[slaveName] || {};
          const linkState = norm(d.linkState || d.link_state || d.state);

          if (!looksDown(linkState)) continue;

          anyDownForNode = true;

          downRows.push({
            ClusterName: clusterName,
            ClusterId: String(cid),
            NodeIP: nodeIp,
            NodeID: nodeId,
            ChassisSerial: chassisSerial,
            BondName: bondName,
            Slave: slaveName,
            LinkState: linkState,
            MAC: norm(d.macAddr || d.mac || d.mac_address),
            Speed: norm(d.speed || d.linkSpeed || d.link_speed),
            SlotType: (slotTypes[si] !== null && slotTypes[si] !== undefined) ? String(slotTypes[si]) : "",
            Note: ""
          });
        }
      }

      // If the node matched by IP but no slaves are DOWN, still show a “worked” row
      if (!anyDownForNode) {
        downRows.push({
          ClusterName: clusterName,
          ClusterId: String(cid),
          NodeIP: nodeIp,
          NodeID: nodeId,
          ChassisSerial: chassisSerial,
          BondName: "",
          Slave: "",
          LinkState: "",
          MAC: "",
          Speed: "",
          SlotType: "",
          Note: "Matched node IP, but no DOWN slave interfaces found right now."
        });
      }
    }

    if (!matchedAnyInThisCluster) {
      // store some nodeIps returned by interface API (helps prove mismatch)
      const sampleIps = [];
      for (let i = 0; i < nodes.length && sampleIps.length < 10; i++) {
        const ip = norm((nodes[i] || {}).nodeIp);
        if (ip) sampleIps.push(ip);
      }
      debug.interfaceNodeIpsSeenSample.push({
        ClusterId: String(cid),
        ClusterName: clusterName,
        NodeIpsFromInterfaceSample: sampleIps
      });
    }
  }

  // ------------------------------
  // 5) Markdown (optional)
  // ------------------------------
  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) return "✅ No rows returned.";

    const cols = ["ClusterName","ClusterId","NodeIP","NodeID","BondName","Slave","LinkState","Speed","MAC","SlotType","Note"];
    const header = "| " + cols.join(" | ") + " |";
    const sep = "| " + cols.map(() => "---").join(" | ") + " |";
    const body = rows.map(r => "| " + cols.map(c => safeCell(r[c])).join(" | ") + " |");

    return (
      "### Cohesity: Interface status for alert IPs\n\n" +
      "- Targets usable: " + usable.length + "\n" +
      "- Clusters targeted: " + clusterIds.length + "\n" +
      "- Nodes matched by IP: " + nodesMatched + "\n" +
      "- Rows: " + rows.length + "\n\n" +
      [header, sep].concat(body).join("\n")
    );
  }

  return {
    authMode,
    targetsProvided: targetsIn.length,
    targetsUsable: usable.length,
    clustersTargeted: clusterIds.length,
    nodesMatched,
    downCount: downRows.filter(r => norm(r.LinkState)).length,
    downRows,
    markdownTable: toMarkdownTable(downRows),
    debug
  };
}
