// ------------------------------------------------------------
// Dynatrace JS | Cohesity Helios Interface DOWN Validator (GET only)
// BRANCH script (downstream):
// - DOES NOT fetch alerts
// - Input: alertTargets[] from upstream alerts step
// - Groups by ClusterId, matches node.nodeIp, then checks /public/interface
// - Outputs ONLY confirmed DOWN slave interfaces
//
// Expected input shape (per item):
// { ClusterId, ClusterName, IP, AlertCode, Severity, AlertState, ... }
//
// Output:
// {
//   authMode,
//   inputCount,
//   targetCount,
//   clustersChecked,
//   downCount,
//   downRows: [ { ClusterName, ClusterId, NodeIP, NodeID, ChassisSerial, BondName, MTU, Slave, LinkState, MAC, Speed, SlotType } ],
//   markdownTable
// }
// ------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function (args) {
  var baseUrl = "https://helios.cohesity.com";

  // ---------------------------
  // Inputs (from workflow mapping)
  // ---------------------------
  // Map this from upstream step, e.g.
  // {{ result("Get_Alerts").results | selectattr("AlertCode","equalto","1105") | list }}
  var alertTargets = (args && args.alertTargets) ? args.alertTargets : [];

  // ---------------------------
  // Auth (same pattern)
  // ---------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId   = "credentials_vault-312312";

  var apiKey = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    var creds = (all && all.credentials) ? all.credentials : [];
    var found = null;
    for (var i = 0; i < creds.length; i++) {
      if (creds[i] && creds[i].name === name) { found = creds[i]; break; }
    }
    if (!found) return null;
    var detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("✓ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      var d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
      console.log("✓ Helios key from vault (id): " + (d2 && d2.name ? d2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE"; // last resort
      console.log("⚠️ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  // ---------------------------
  // Helpers
  // ---------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }

  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  function buildQuery(params) {
    var usp = new URLSearchParams();
    for (var k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      var v = params[k];
      if (v === undefined || v === null) continue;

      if (Array.isArray(v)) {
        for (var i = 0; i < v.length; i++) {
          var item = v[i];
          if (item === undefined || item === null) continue;
          var s = String(item).trim();
          if (!s) continue;
          usp.append(k, s);
        }
      } else {
        var sv = String(v).trim();
        if (!sv) continue;
        usp.append(k, sv);
      }
    }
    return usp.toString();
  }

  async function getJson(url, headers) {
    var resp = await fetch(url, { method: "GET", headers: headers });
    if (!resp.ok) {
      var txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function looksDown(v) {
    v = norm(v).toLowerCase();
    // handles: "Down", "kLinkStateDown", "linkDown", etc.
    return v.indexOf("down") >= 0;
  }

  // bondSlavesDetails sometimes comes as array of objects with "@name" / name
  // you explicitly saw: { @name= ; macAddr }
  function indexSlaveDetails(details) {
    var map = {};
    var arr = toArrayMaybe(details);

    for (var i = 0; i < arr.length; i++) {
      var d = arr[i] || {};
      // name fields observed across payloads
      var name = norm(d.name || d["@name"] || d.ifaceName || d.interfaceName || d.iface);
      if (name) map[name] = d;
    }
    return map;
  }

  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  // ---------------------------
  // Guard: no targets
  // ---------------------------
  var inputCount = Array.isArray(alertTargets) ? alertTargets.length : 0;
  if (!inputCount) {
    return {
      authMode: authMode,
      inputCount: inputCount,
      targetCount: 0,
      clustersChecked: 0,
      downCount: 0,
      downRows: [],
      markdownTable: "⚠️ Interface validator: no alertTargets provided as input."
    };
  }

  // ---------------------------
  // Build cluster -> IP set from targets
  // ---------------------------
  var byCluster = {}; // { [clusterId]: { ClusterId, ClusterName, Ips: {ip:true} } }

  for (var i = 0; i < alertTargets.length; i++) {
    var t = alertTargets[i] || {};
    var cid = norm(t.ClusterId);
    var ip  = norm(t.IP);
    if (!cid || !ip) continue;

    if (!byCluster[cid]) {
      byCluster[cid] = { ClusterId: cid, ClusterName: norm(t.ClusterName) || ("cluster-" + cid), Ips: {} };
    }
    byCluster[cid].Ips[ip] = true;
    if (!byCluster[cid].ClusterName && t.ClusterName) byCluster[cid].ClusterName = norm(t.ClusterName);
  }

  var clusterIds = Object.keys(byCluster);
  if (!clusterIds.length) {
    return {
      authMode: authMode,
      inputCount: inputCount,
      targetCount: 0,
      clustersChecked: 0,
      downCount: 0,
      downRows: [],
      markdownTable: "⚠️ Interface validator: input targets had no usable ClusterId+IP."
    };
  }

  // Count unique targets
  var targetCount = 0;
  for (var c = 0; c < clusterIds.length; c++) {
    var ipsObj = byCluster[clusterIds[c]].Ips || {};
    targetCount += Object.keys(ipsObj).length;
  }

  // ---------------------------
  // Interface API (your flags)
  // NOTE: We keep these as query params (GET-only)
  // ---------------------------
  var ifaceQs = buildQuery({
    bondInterfaceOnly: "true",
    ifaceGroupAssignedOnly: "true",
    includeUplinkSwitchInfo: "true",
    includeBondSlaveDetails: "true"
  });

  var ifaceUrl = baseUrl + "/irisservices/api/v1/public/interface?" + ifaceQs;

  // ---------------------------
  // Collect DOWN rows
  // ---------------------------
  var downRows = [];

  for (var k = 0; k < clusterIds.length; k++) {
    var clusterId = clusterIds[k];
    var entry = byCluster[clusterId];
    var clusterName = entry.ClusterName;

    var headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: String(clusterId)
    };

    var ifaceData;
    try {
      ifaceData = await getJson(ifaceUrl, headers);
    } catch (e) {
      console.log("⚠️ Interface fetch failed for " + clusterName + " (" + clusterId + "): " + norm(e.message || e));
      continue;
    }

    var nodes = toArrayMaybe(ifaceData);

    for (var ni = 0; ni < nodes.length; ni++) {
      var node = nodes[ni] || {};
      var nodeIp = norm(node.nodeIp);
      if (!nodeIp) continue;

      // only nodes we care about from alerts
      if (!entry.Ips[nodeIp]) continue;

      var nodeId = norm(node.nodeId);
      var chassisSerial = norm(node.chassisSerial);

      var bonds = toArrayMaybe(node.interfaces);

      for (var bi = 0; bi < bonds.length; bi++) {
        var bond = bonds[bi] || {};

        var bondName = norm(bond.name);
        var mtu = (bond.mtu === null || bond.mtu === undefined) ? "" : String(bond.mtu);

        var slaves = toArrayMaybe(bond.bondSlaves);
        var slotTypes = toArrayMaybe(bond.bondSlavesSlotTypes);
        var dmap = indexSlaveDetails(bond.bondSlavesDetails);

        for (var si = 0; si < slaves.length; si++) {
          var s = slaves[si];
          var slaveName = norm(
            (typeof s === "string") ? s :
            (s && (s.name || s["@name"] || s.ifaceName || s.interfaceName || s.iface))
          );
          if (!slaveName) continue;

          var d = dmap[slaveName] || {};
          var linkState = norm(d.linkState || d.link_state || d.state);

          if (!looksDown(linkState)) continue;

          downRows.push({
            ClusterName: clusterName,
            ClusterId: String(clusterId),
            NodeIP: nodeIp,
            NodeID: nodeId,
            ChassisSerial: chassisSerial,
            BondName: bondName,
            MTU: mtu,
            Slave: slaveName,
            LinkState: linkState,
            MAC: norm(d.macAddr || d.mac || d.mac_address),
            Speed: norm(d.speed || d.linkSpeed || d.link_speed),
            SlotType: (slotTypes[si] !== null && slotTypes[si] !== undefined) ? String(slotTypes[si]) : ""
          });
        }
      }
    }
  }

  // Sort for readability
  downRows.sort(function (a, b) {
    return safeCell(a.ClusterName).localeCompare(safeCell(b.ClusterName)) ||
           safeCell(a.NodeIP).localeCompare(safeCell(b.NodeIP)) ||
           safeCell(a.BondName).localeCompare(safeCell(b.BondName)) ||
           safeCell(a.Slave).localeCompare(safeCell(b.Slave));
  });

  // ---------------------------
  // Markdown output
  // ---------------------------
  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) {
      return (
        "✅ No confirmed DOWN slave interfaces for provided alertTargets.\n\n" +
        "- Input targets: " + inputCount + "\n" +
        "- Unique ClusterId+IP targets: " + targetCount + "\n" +
        "- Clusters checked: " + clusterIds.length + "\n"
      );
    }

    var cols = ["ClusterName","ClusterId","NodeIP","NodeID","BondName","Slave","LinkState","Speed","MAC","SlotType"];
    var header = "| " + cols.join(" | ") + " |";
    var sep = "| " + cols.map(function () { return "---"; }).join(" | ") + " |";

    var body = rows.map(function (r) {
      return "| " + cols.map(function (c) { return safeCell(r[c]); }).join(" | ") + " |";
    });

    var intro =
      "### Cohesity: Confirmed Interface DOWN (via /public/interface)\n\n" +
      "- Input targets: " + inputCount + "\n" +
      "- Unique ClusterId+IP targets: " + targetCount + "\n" +
      "- Clusters checked: " + clusterIds.length + "\n" +
      "- DOWN rows: " + rows.length + "\n\n";

    return intro + [header, sep].concat(body).join("\n");
  }

  return {
    authMode: authMode,
    inputCount: inputCount,
    targetCount: targetCount,
    clustersChecked: clusterIds.length,
    downCount: downRows.length,
    downRows: downRows,
    markdownTable: toMarkdownTable(downRows),
    markdownEmail: toMarkdownTable(downRows)
  };
}
