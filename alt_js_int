import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function ({ alertTargets = [] } = {}) {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // AUTH (vault-name -> vault-id -> manual)
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    let found = null;
    for (let i = 0; i < (all.credentials || []).length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey   = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (e2) {
      authMode = "manual";
      apiKey   = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) {
    return { authMode, downRows: [], debug: { reason: "No Helios API key" } };
  }

  // ------------------------------
  // Helpers
  // ------------------------------
  const norm = (v) => (v === null || v === undefined) ? "" : String(v).trim();
  const toArrayMaybe = (v) => (!v ? [] : (Array.isArray(v) ? v : [v]));

  // Normalize IP formats: "1.2.3.4/32", "1.2.3.4:443", " 1.2.3.4 "
  function cleanIp(ip) {
    ip = norm(ip);
    if (!ip) return "";
    ip = ip.split("/")[0];     // drop CIDR
    ip = ip.split(":")[0];     // drop port (also drops IPv6; fine if you only use IPv4)
    return ip.trim();
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  function looksDown(v) {
    return norm(v).toLowerCase().includes("down");
  }

  function indexSlaveDetails(details) {
    const map = {};
    const arr = toArrayMaybe(details);
    for (let i = 0; i < arr.length; i++) {
      const d = arr[i] || {};
      const name = norm(d.name || d["@name"] || d.ifaceName || d.interfaceName || d.iface);
      if (name) map[name] = d;
    }
    return map;
  }

  // ------------------------------
  // INPUT UNWRAP (this is usually why “it suddenly fails”)
  // ------------------------------
  let targetsIn = alertTargets;

  // If you passed the whole action output by mistake, unwrap common shapes:
  if (targetsIn && !Array.isArray(targetsIn)) {
    if (Array.isArray(targetsIn.results)) targetsIn = targetsIn.results;
    else if (Array.isArray(targetsIn.alertTargets)) targetsIn = targetsIn.alertTargets;
  }
  if (!Array.isArray(targetsIn)) targetsIn = [];

  // Normalize usable targets
  const usable = [];
  for (let i = 0; i < targetsIn.length; i++) {
    const r = targetsIn[i] || {};
    const clusterId = norm(r.ClusterId || r.clusterId);
    const clusterName = norm(r.ClusterName || r.clusterName);
    const ip = cleanIp(r.IP || r.ip || r.node_ip || r.nodeIp);

    if (!clusterId || !ip) continue;

    usable.push({ ClusterId: clusterId, ClusterName: clusterName, IP: ip });
  }

  if (!usable.length) {
    return {
      authMode,
      downRows: [],
      debug: {
        reason: "No usable targets (need ClusterId + IP).",
        receivedType: typeof alertTargets,
        receivedIsArray: Array.isArray(alertTargets),
        unwrappedCount: targetsIn.length,
        firstRecord: targetsIn[0] || null
      }
    };
  }

  // Group by cluster
  const byCluster = {};
  for (const t of usable) {
    if (!byCluster[t.ClusterId]) {
      byCluster[t.ClusterId] = { ClusterName: t.ClusterName || ("cluster-" + t.ClusterId), Ips: {} };
    }
    byCluster[t.ClusterId].Ips[t.IP] = true;
  }
  const clusterIds = Object.keys(byCluster);

  // ------------------------------
  // Interface check
  // ------------------------------
  const ifaceUrl =
    baseUrl +
    "/irisservices/api/v1/public/interface" +
    "?bondInterfaceOnly=true" +
    "&ifaceGroupAssignedOnly=true" +
    "&includeUplinkSwitchInfo=true" +
    "&includeBondSlaveDetails=true";

  const downRows = [];
  const debugNodeIpSamples = [];

  for (const cid of clusterIds) {
    const entry = byCluster[cid];
    const headers = { accept: "application/json", apiKey, accessClusterId: String(cid) };

    let ifaceData;
    try {
      ifaceData = await getJson(ifaceUrl, headers);
    } catch (e) {
      downRows.push({
        ClusterId: cid,
        ClusterName: entry.ClusterName,
        NodeIP: "",
        Note: "Interface API failed: " + norm(e.message || e)
      });
      continue;
    }

    const nodes = toArrayMaybe(ifaceData);

    // sample nodeIps for debugging mismatch
    const sample = [];
    for (let i = 0; i < nodes.length && sample.length < 8; i++) {
      const ip = cleanIp(nodes[i]?.nodeIp);
      if (ip) sample.push(ip);
    }
    debugNodeIpSamples.push({ ClusterId: cid, ClusterName: entry.ClusterName, NodeIpSample: sample });

    for (const node of nodes) {
      const nodeIp = cleanIp(node?.nodeIp);
      if (!nodeIp) continue;

      if (!entry.Ips[nodeIp]) continue; // <-- the IP compare you wanted

      const nodeId = norm(node?.nodeId);
      const chassisSerial = norm(node?.chassisSerial);
      const ifaces = toArrayMaybe(node?.interfaces);

      let anyDown = false;

      for (const bond of ifaces) {
        const bondName = norm(bond?.name);
        const slaves = toArrayMaybe(bond?.bondSlaves);
        const slotTypes = toArrayMaybe(bond?.bondSlavesSlotTypes);
        const dmap = indexSlaveDetails(bond?.bondSlavesDetails);

        for (let si = 0; si < slaves.length; si++) {
          const s = slaves[si];
          const slaveName = norm(typeof s === "string" ? s : (s?.name || s?.["@name"] || s?.ifaceName || s?.interfaceName));
          if (!slaveName) continue;

          const d = dmap[slaveName] || {};
          const linkState = norm(d.linkState || d.link_state || d.state);

          if (!looksDown(linkState)) continue;

          anyDown = true;
          downRows.push({
            ClusterId: cid,
            ClusterName: entry.ClusterName,
            NodeIP: nodeIp,
            NodeID: nodeId,
            ChassisSerial: chassisSerial,
            BondName: bondName,
            Slave: slaveName,
            LinkState: linkState,
            MAC: norm(d.macAddr || d.mac || d.mac_address),
            Speed: norm(d.speed || d.linkSpeed || d.link_speed),
            SlotType: slotTypes[si] != null ? String(slotTypes[si]) : ""
          });
        }
      }

      // If matched node IP but no DOWN slaves
      if (!anyDown) {
        downRows.push({
          ClusterId: cid,
          ClusterName: entry.ClusterName,
          NodeIP: nodeIp,
          NodeID: nodeId,
          Note: "Matched node IP, but no DOWN slave interfaces right now."
        });
      }
    }
  }

  return {
    authMode,
    targetsProvided: targetsIn.length,
    targetsUsable: usable.length,
    clustersTargeted: clusterIds.length,
    downCount: downRows.length,
    downRows,
    debug: {
      targetIpsByCluster: clusterIds.map(cid => ({
        ClusterId: cid,
        ClusterName: byCluster[cid].ClusterName,
        TargetIps: Object.keys(byCluster[cid].Ips)
      })),
      interfaceNodeIpSamples: debugNodeIpSamples
    }
  };
}
