import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity AHV (kAcropolis) Inventory Drift ‚Äî 7-day (ET) + Active Scope
 *
 * What management gets:
 * 1) Active Scope Today (per cluster): Active PGs, Total VMs, Failed VMs, Added(7d), Removed(7d), Net Drift(7d)
 * 2) PG Trend (7-day): per-day delta (0 vs No run) + VMs Today + Last Drift
 * 3) Failed VMs (today snapshot): VM + error message from failedAttempts (if present)
 *
 * Semantics (locked):
 * - "0"      = snapshot exists, no membership change vs previous available snapshot in window
 * - "No run" = no completed snapshot selected for that ET day
 * - No "PG NEW" labeling (removed entirely)
 * - Failures are NOT removals: failed VMs remain part of inventory membership
 *
 * Evidence:
 * - Uses only COMPLETED runs (Succeeded / SucceededWithWarning / Failed / Canceled)
 * - Inventory membership = VM objects present in the selected completed snapshot
 */
export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ======================
  // CONFIG (safe defaults)
  // ======================
  const TREND_DAYS = 7;                 // show last 7 ET days (incl today)
  const ACTIVE_SCOPE_HOURS = 48;        // active scope = latest completed run within last 48h
  const MAX_PGS_PER_CLUSTER = 2000;     // safety
  const MAX_FAILED_ROWS = 250;          // email size safety

  // ==============================
  // 1) Auth (vault name -> id -> manual)
  // ==============================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = all?.credentials || [];
    const found = creds.find((c) => c?.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return detail?.token || detail?.password || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (_) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = d2?.token || d2?.password || null;
      authMode = "vault-id";
    } catch (_) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");
  const commonHeaders = { accept: "application/json", apiKey };

  // ======================
  // 2) Helpers
  // ======================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const safeCell = (v) => (v === null || v === undefined ? "" : String(v).replace(/\|/g, " "));

  function nowEtString() {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    }).formatToParts(new Date());
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day} ${m.hour}:${m.minute}`;
  }

  function dateKeyET(d) {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).formatToParts(d);
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day}`; // YYYY-MM-DD
  }

  function dayLabelFromETKey(etKey) {
    const day = Number(etKey.slice(8, 10));
    const suffix =
      day % 100 >= 11 && day % 100 <= 13 ? "th" :
      day % 10 === 1 ? "st" :
      day % 10 === 2 ? "nd" :
      day % 10 === 3 ? "rd" : "th";
    return `${day}${suffix}`;
  }

  function usecsFromDate(d) {
    return String(Math.floor(d.getTime() * 1000));
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const err = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      err.httpStatus = resp.status;
      err.bodyText = txt;
      err.url = url;
      throw err;
    }
    return resp.json();
  }

  async function getJsonSafe(url, headers) {
    try {
      const data = await getJson(url, headers);
      return { ok: true, data, status: 200, bodyText: "", url };
    } catch (e) {
      return {
        ok: false,
        data: null,
        status: e?.httpStatus || 0,
        bodyText: e?.bodyText || String(e || ""),
        url: e?.url || url
      };
    }
  }

  // Run parsing (matches your PowerShell logic: localBackupInfo[0])
  function getLbi0(run) {
    const lbi = run?.localBackupInfo;
    if (!lbi) return null;
    const a = Array.isArray(lbi) ? lbi : [lbi];
    return a.length ? a[0] : null;
  }

  function pickRunId(run) {
    return (
      norm(run?.runId) ||
      norm(run?.id) ||
      norm(run?.protectionGroupRunId) ||
      norm(run?.instanceId) ||
      ""
    );
  }

  function pickRunEndUsecs(run) {
    const l0 = getLbi0(run);
    return (
      norm(l0?.endTimeUsecs) ||
      norm(run?.endTimeUsecs) ||
      norm(run?.endTimeUsec) ||
      ""
    );
  }

  function pickRunStatus(run) {
    const l0 = getLbi0(run);
    return (
      norm(l0?.status) ||
      norm(run?.status) ||
      norm(run?.runStatus) ||
      ""
    );
  }

  function isRunCompleted(run) {
    const s = pickRunStatus(run).toLowerCase();
    // Completed = done (success/warn/fail/cancel). We will still use it as a snapshot source.
    return (
      s === "succeeded" || s === "succeededwithwarning" || s === "warning" ||
      s === "failed" || s === "failure" ||
      s === "canceled" || s === "cancelled"
    );
  }

  // Object parsing (kAcropolis + kVirtualMachine)
  function isAhvVmObject(obj) {
    const env = norm(obj?.object?.environment);
    const typ = norm(obj?.object?.objectType);
    return env === "kAcropolis" && typ === "kVirtualMachine";
  }

  function vmName(obj) {
    return norm(obj?.object?.name) || norm(obj?.objectName) || norm(obj?.name) || "";
  }

  function failedAttempts(obj) {
    const fa = obj?.localSnapshotInfo?.failedAttempts;
    return toArray(fa);
  }

  function vmFailed(obj) {
    return failedAttempts(obj).length > 0;
  }

  function bestFailMessage(obj) {
    const fa = failedAttempts(obj);
    if (!fa.length) return "";
    // take first message (PowerShell iterates; we keep primary for management)
    const msg = norm(fa[0]?.message) || norm(fa[0]?.error) || "FailedAttempts present (no message)";
    return msg.replace(/[\r\n]+/g, " ").trim();
  }

  function vmSetFromObjects(objs) {
    const s = new Set();
    for (const o of objs) {
      if (!isAhvVmObject(o)) continue;
      const n = vmName(o);
      if (n) s.add(n);
    }
    return s;
  }

  function countFailedInObjects(objs) {
    let failed = 0;
    for (const o of objs) {
      if (!isAhvVmObject(o)) continue;
      if (vmFailed(o)) failed++;
    }
    return failed;
  }

  // Prefer embedded run.objects (like your PowerShell). Else fallback to /objects endpoint.
  function embeddedObjectsIfAny(run) {
    const objs = run?.objects;
    const a = toArray(objs);
    return a.length ? a : null;
  }

  async function fetchRunObjects(headers, pgId, runId) {
    const pg = encodeURIComponent(pgId);
    const run = encodeURIComponent(runId);
    const urls = [
      `${baseUrl}/v2/data-protect/protection-groups/${pg}/runs/${run}/objects`,
      `${baseUrl}/v2/data-protect/protection-groups/${pg}/runs/${run}/objects?includeDetails=true`
    ];
    for (const u of urls) {
      const r = await getJsonSafe(u, headers);
      if (!r.ok) continue;
      const d = r.data || {};
      const objs =
        toArray(d.objects).length ? toArray(d.objects) :
        toArray(d.runObjects).length ? toArray(d.runObjects) :
        toArray(d.objectRuns).length ? toArray(d.objectRuns) :
        toArray(d.protectedObjects).length ? toArray(d.protectedObjects) :
        [];
      return { ok: true, objects: objs, usedUrl: u };
    }
    const last = await getJsonSafe(urls[urls.length - 1], headers);
    return { ok: false, objects: [], err: last, usedUrl: urls[urls.length - 1] };
  }

  // ======================
  // 3) Window construction
  // ======================
  const asOfEt = nowEtString();
  const now = new Date();

  const etKeys = [];
  for (let i = TREND_DAYS - 1; i >= 0; i--) {
    etKeys.push(dateKeyET(new Date(now.getTime() - i * 24 * 60 * 60 * 1000)));
  }
  const dayLabels = etKeys.map(dayLabelFromETKey);

  const trendStart = new Date(now.getTime() - TREND_DAYS * 24 * 60 * 60 * 1000);
  const trendStartUsecs = usecsFromDate(trendStart);
  const trendEndUsecs = usecsFromDate(now);

  const activeScopeStart = new Date(now.getTime() - ACTIVE_SCOPE_HOURS * 60 * 60 * 1000);
  const activeScopeStartUsecs = usecsFromDate(activeScopeStart);

  // ======================
  // 4) Clusters
  // ======================
  const errors = [];

  const cluUrl = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const cluResp = await getJsonSafe(cluUrl, commonHeaders);
  const clusters = toArray(cluResp?.data?.cohesityClusters);

  if (!cluResp.ok || !clusters.length) {
    return {
      authMode,
      totalClusters: 0,
      markdownEmail: "‚ö†Ô∏è No clusters returned from Helios or API call failed.",
      errors: cluResp.ok ? [] : [{ scope: "clusters", httpStatus: cluResp.status, url: cluResp.url, body: cluResp.bodyText }]
    };
  }

  // ======================
  // 5) API: PGs + runs
  // ======================
  async function fetchAllAhvPGs(clusterId) {
    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };

    const pgs = [];
    let pageToken = "";
    let safety = 0;

    while (safety < 200) {
      safety++;
      let url = `${baseUrl}/v2/data-protect/protection-groups?environments=kAcropolis`;
      if (pageToken) url += `&pageToken=${encodeURIComponent(pageToken)}`;

      const resp = await getJsonSafe(url, headers);
      if (!resp.ok) return { ok: false, pgs: [], err: resp };

      const data = resp.data || {};
      const batch = toArray(data.protectionGroups);
      for (const pg of batch) pgs.push(pg);
      if (pgs.length >= MAX_PGS_PER_CLUSTER) break;

      const next =
        norm(data.nextPageToken) ||
        norm(data.pagination?.nextPageToken) ||
        norm(data.nextToken);

      if (!next || next === pageToken) break;
      pageToken = next;
    }
    return { ok: true, pgs, err: null };
  }

  async function fetchRuns(headers, pgId) {
    const id = encodeURIComponent(pgId);
    const urls = [
      `${baseUrl}/v2/data-protect/protection-groups/${id}/runs?filterByEndTime=${encodeURIComponent(trendStartUsecs + "," + trendEndUsecs)}&onlyReturnSuccessfulCopyRun=false`,
      `${baseUrl}/v2/data-protect/protection-groups/${id}/runs?filterByEndTime=${encodeURIComponent(trendStartUsecs + "," + trendEndUsecs)}`
    ];

    for (const u of urls) {
      const r = await getJsonSafe(u, headers);
      if (!r.ok) continue;
      const d = r.data || {};
      const runs =
        toArray(d.runs).length ? toArray(d.runs) :
        toArray(d.protectionGroupRuns).length ? toArray(d.protectionGroupRuns) :
        toArray(d.runInfo).length ? toArray(d.runInfo) :
        [];
      return { ok: true, runs, usedUrl: u };
    }

    const last = await getJsonSafe(urls[urls.length - 1], headers);
    return { ok: false, runs: [], err: last, usedUrl: urls[urls.length - 1] };
  }

  function getPGState(pg) {
    if (pg?.isDeleted) return "Deleted";
    if (pg?.isPaused) return "Paused";
    if (pg?.isActive) return "Active";
    return "Inactive";
  }

  // ======================
  // 6) Compute report
  // ======================
  const clusterSummary = {}; // section 1
  const pgRows = [];         // section 2
  const failedRows = [];     // section 3 (failed VMs today snapshot)

  let grandActivePGs = 0;
  let grandTotalVMs = 0;
  let grandFailedVMs = 0;
  let grandAdded = 0;
  let grandRemoved = 0;

  for (const cl of clusters) {
    const clusterName = norm(cl?.clusterName) || norm(cl?.name) || `Cluster-${norm(cl?.clusterId)}`;
    const clusterId = norm(cl?.clusterId);
    if (!clusterId) continue;

    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };

    const pgRes = await fetchAllAhvPGs(clusterId);
    if (!pgRes.ok) {
      errors.push({ scope: "protection-groups", clusterName, clusterId, httpStatus: pgRes.err.status, url: pgRes.err.url, body: pgRes.err.bodyText });
      continue;
    }

    const pgs = toArray(pgRes.pgs);
    clusterSummary[clusterName] = {
      Cluster: clusterName,
      Active_PGs: 0,
      TotalVMs: 0,
      FailedVMs: 0,
      Added_7d: 0,
      Removed_7d: 0,
      Net_Drift_7d: 0
    };

    for (const pg of pgs) {
      const pgName = norm(pg?.name);
      if (!pgName) continue;

      const pgState = getPGState(pg);
      if (pgState !== "Active") continue; // Active Scope = Active PGs only

      const pgId = norm(pg?.id) || norm(pg?.protectionGroupId) || norm(pg?.groupId);
      if (!pgId) continue;

      const runRes = await fetchRuns(headers, pgId);
      if (!runRes.ok) {
        errors.push({ scope: "pg-runs", clusterName, clusterId, protectionGroup: pgName, protectionGroupId: pgId, httpStatus: runRes.err.status, url: runRes.err.url || runRes.usedUrl, body: runRes.err.bodyText });
        continue;
      }

      const completedRuns = runRes.runs
        .map((r) => ({
          raw: r,
          runId: pickRunId(r),
          endUsecs: pickRunEndUsecs(r),
          status: pickRunStatus(r),
          completed: isRunCompleted(r)
        }))
        .filter((x) => x.runId && x.endUsecs && x.completed)
        .sort((a, b) => Number(b.endUsecs) - Number(a.endUsecs));

      if (!completedRuns.length) {
        // Still include PG row with "No run" across the week (management visibility)
        const emptyRow = { Cluster: clusterName, ProtectionGroup: pgName, VMsToday: "‚Äî", LastDrift: "‚Äî" };
        for (const lab of dayLabels) emptyRow[lab] = "No run";
        pgRows.push({ ...emptyRow, _sortCluster: clusterName, _sortPg: pgName });
        continue;
      }

      // Pick per-ET-day latest completed run (in window)
      const dayToRun = {};
      for (const r of completedRuns) {
        const endMs = Math.floor(Number(r.endUsecs) / 1000);
        if (!Number.isFinite(endMs)) continue;
        const key = dateKeyET(new Date(endMs));
        if (!dayToRun[key] || Number(r.endUsecs) > Number(dayToRun[key].endUsecs)) dayToRun[key] = r;
      }

      // Build snapshots: dayKey -> { set, failedCount } or null
      const snap = {};
      for (const k of etKeys) snap[k] = null;

      for (const k of etKeys) {
        const r = dayToRun[k];
        if (!r) continue;

        // objects
        let objs = embeddedObjectsIfAny(r.raw);
        if (!objs) {
          const oRes = await fetchRunObjects(headers, pgId, r.runId);
          if (!oRes.ok) {
            errors.push({ scope: "run-objects", clusterName, clusterId, protectionGroup: pgName, protectionGroupId: pgId, runId: r.runId, httpStatus: oRes.err.status, url: oRes.err.url || oRes.usedUrl, body: oRes.err.bodyText });
            continue;
          }
          objs = toArray(oRes.objects);
        }

        const vmSet = vmSetFromObjects(objs);
        const failedCnt = countFailedInObjects(objs);

        snap[k] = { set: vmSet, failed: failedCnt, objects: objs, runId: r.runId, endUsecs: r.endUsecs };
      }

      // -------------------------
      // Active Scope snapshot (latest completed within last 48h)
      // -------------------------
      let activeSnap = null;
      for (const r of completedRuns) {
        if (Number(r.endUsecs) < Number(activeScopeStartUsecs)) continue;

        // If we already loaded this run as one of the daily snapshots, reuse it where possible.
        const endMs = Math.floor(Number(r.endUsecs) / 1000);
        const k = Number.isFinite(endMs) ? dateKeyET(new Date(endMs)) : null;

        if (k && snap[k]?.runId === r.runId) {
          activeSnap = snap[k];
          break;
        }

        // else fetch objects for this run
        let objs = embeddedObjectsIfAny(r.raw);
        if (!objs) {
          const oRes = await fetchRunObjects(headers, pgId, r.runId);
          if (!oRes.ok) {
            errors.push({ scope: "active-scope-objects", clusterName, clusterId, protectionGroup: pgName, protectionGroupId: pgId, runId: r.runId, httpStatus: oRes.err.status, url: oRes.err.url || oRes.usedUrl, body: oRes.err.bodyText });
            continue;
          }
          objs = toArray(oRes.objects);
        }

        activeSnap = {
          set: vmSetFromObjects(objs),
          failed: countFailedInObjects(objs),
          objects: objs,
          runId: r.runId,
          endUsecs: r.endUsecs
        };
        break;
      }

      // If no active-scope run, still include PG row; but it won't count in cluster active scope totals.
      const vmsToday = activeSnap ? activeSnap.set.size : null;
      const failedToday = activeSnap ? activeSnap.failed : null;

      // Collect failed VMs with messages from ACTIVE SCOPE snapshot only (what management cares about ‚Äútoday‚Äù)
      if (activeSnap && activeSnap.objects?.length) {
        for (const o of activeSnap.objects) {
          if (!isAhvVmObject(o)) continue;
          if (!vmFailed(o)) continue;
          const name = vmName(o);
          if (!name) continue;
          failedRows.push({
            Cluster: clusterName,
            ProtectionGroup: pgName,
            VMName: name,
            Error: bestFailMessage(o) || "FailedAttempts present (no message)"
          });
          if (failedRows.length >= MAX_FAILED_ROWS) break;
        }
      }

      // -------------------------
      // Trend delta cells (7-day)
      // - compares to previous available snapshot in window
      // - "No run" when no snapshot
      // - "0" when snapshot exists and no membership change
      // -------------------------
      const cells = {};
      for (const k of etKeys) cells[k] = "No run";

      let prev = null; // { set }
      let lastDriftText = "‚Äî";

      for (const k of etKeys) {
        const cur = snap[k];
        if (!cur) {
          cells[k] = "No run";
          continue;
        }
        if (!prev) {
          // first snapshot has no baseline inside the visible window => show 0 (no claim)
          cells[k] = "0";
          prev = cur;
          continue;
        }

        let adds = 0, rems = 0;
        for (const x of cur.set) if (!prev.set.has(x)) adds++;
        for (const x of prev.set) if (!cur.set.has(x)) rems++;

        if (adds === 0 && rems === 0) cells[k] = "0";
        else if (adds > 0 && rems === 0) cells[k] = `üü¢ +${adds}`;
        else if (rems > 0 && adds === 0) cells[k] = `üî¥ -${rems}`;
        else cells[k] = `üü¢ +${adds} / üî¥ -${rems}`;

        lastDriftText = `${cells[k]} (${k})`;
        prev = cur;
      }

      // Net drift (7d) uses first available snapshot vs last available snapshot in window
      let first = null, last = null;
      for (const k of etKeys) { if (snap[k]) { first = snap[k]; break; } }
      for (let i = etKeys.length - 1; i >= 0; i--) { const k = etKeys[i]; if (snap[k]) { last = snap[k]; break; } }

      const net = first && last ? (last.set.size - first.set.size) : 0;

      // Added/Removed (7d) for Active Scope summary:
      // use sum of diffs across available snapshots (window), same as your management-friendly ‚Äúhow much churn happened‚Äù
      let added7 = 0, removed7 = 0;
      let p2 = null;
      for (const k of etKeys) {
        const cur = snap[k];
        if (!cur) continue;
        if (!p2) { p2 = cur; continue; }
        for (const x of cur.set) if (!p2.set.has(x)) added7++;
        for (const x of p2.set) if (!cur.set.has(x)) removed7++;
        p2 = cur;
      }

      // Cluster Active Scope aggregation ONLY when we have an Active Scope snapshot
      if (activeSnap) {
        clusterSummary[clusterName].Active_PGs += 1;
        clusterSummary[clusterName].TotalVMs += vmsToday;
        clusterSummary[clusterName].FailedVMs += failedToday;
        clusterSummary[clusterName].Added_7d += added7;
        clusterSummary[clusterName].Removed_7d += removed7;
        clusterSummary[clusterName].Net_Drift_7d += net;

        grandActivePGs += 1;
        grandTotalVMs += vmsToday;
        grandFailedVMs += failedToday;
        grandAdded += added7;
        grandRemoved += removed7;
      }

      // Section 2 row (PG trend)
      const row = {
        Cluster: clusterName,
        ProtectionGroup: pgName,
        VMsToday: activeSnap ? String(vmsToday) : "‚Äî",
        FailedToday: activeSnap ? String(failedToday) : "‚Äî",
        LastDrift: lastDriftText,
        PGState: pgState
      };
      for (let i = 0; i < etKeys.length; i++) row[dayLabels[i]] = cells[etKeys[i]];
      pgRows.push({ ...row, _sortCluster: clusterName, _sortPg: pgName });
    }
  }

  // ======================
  // 7) Markdown builder
  // ======================
  function mdTable(headers, rows) {
    const head = "| " + headers.join(" | ") + " |";
    const sep = "| " + headers.map(() => "---").join(" | ") + " |";
    const body = rows.map((r) => "| " + headers.map((h) => safeCell(r[h])).join(" | ") + " |");
    return [head, sep].concat(body).join("\n");
  }

  // Section 1 rows
  const s1Rows = Object.keys(clusterSummary)
    .sort()
    .map((cn) => {
      const s = clusterSummary[cn];
      const net = s.Net_Drift_7d;
      const netStr = net > 0 ? `üü¢ +${net}` : net < 0 ? `üî¥ ${net}` : "0";
      return {
        Cluster: cn,
        Active_PGs: String(s.Active_PGs),
        TotalVMs: String(s.TotalVMs),
        FailedVMs: String(s.FailedVMs),
        Added_7d: String(s.Added_7d),
        Removed_7d: String(s.Removed_7d),
        "Net Drift (7d)": netStr
      };
    });

  const grandNet = s1Rows.reduce((acc, r) => {
    const raw = r["Net Drift (7d)"];
    const m = raw.match(/-?\d+/);
    return acc + (m ? Number(m[0]) : 0);
  }, 0);
  const grandNetStr = grandNet > 0 ? `üü¢ +${grandNet}` : grandNet < 0 ? `üî¥ ${grandNet}` : "0";

  s1Rows.push({
    Cluster: "‚≠ê TOTAL",
    Active_PGs: String(grandActivePGs),
    TotalVMs: String(grandTotalVMs),
    FailedVMs: String(grandFailedVMs),
    Added_7d: String(grandAdded),
    Removed_7d: String(grandRemoved),
    "Net Drift (7d)": grandNetStr
  });

  // Section 2 headers/rows
  const s2Headers = ["Cluster", "ProtectionGroup", "VMsToday", "FailedToday"]
    .concat(dayLabels)
    .concat(["LastDrift", "PGState"]);

  const s2Rows = pgRows
    .sort((a, b) => a._sortCluster.localeCompare(b._sortCluster) || a._sortPg.localeCompare(b._sortPg))
    .map((r) => {
      const out = {
        Cluster: r.Cluster,
        ProtectionGroup: r.ProtectionGroup,
        VMsToday: r.VMsToday,
        FailedToday: r.FailedToday
      };
      for (const lab of dayLabels) out[lab] = r[lab];
      out.LastDrift = r.LastDrift;
      out.PGState = r.PGState;
      return out;
    });

  // Section 3 failed VMs table
  const s3Headers = ["Cluster", "ProtectionGroup", "VMName", "Error"];
  const s3Rows = failedRows.slice(0, MAX_FAILED_ROWS);

  const markdownEmail = [
    "### Cohesity AHV Inventory Drift ‚Äî 7-Day (Retention-Aware)",
    "",
    `**Inventory As Of (ET):** ${asOfEt}`,
    `**Drift Window:** Last ${TREND_DAYS} days (ET)`,
    `**Evidence Source:** Completed backup jobs only`,
    `**Active Scope:** Latest completed run per Active PG within last ${ACTIVE_SCOPE_HOURS} hours`,
    "",
    "## 1) Active Scope Today (Monitored)",
    mdTable(["Cluster", "Active_PGs", "TotalVMs", "FailedVMs", "Added_7d", "Removed_7d", "Net Drift (7d)"], s1Rows),
    "",
    "## 2) Protection Group Drift (7-Day) + Current State",
    "_Legend: 0 = no membership change vs previous snapshot | No run = no completed snapshot selected for that ET day_",
    mdTable(s2Headers, s2Rows),
    "",
    "## 3) Failed Virtual Machines (Today Snapshot Only)",
    s3Rows.length ? mdTable(s3Headers, s3Rows) : "No failed VMs detected in the Active Scope snapshots.",
    "",
    "_Audit note: Failures are not treated as removals. Added/Removed are computed only from VM membership changes between completed snapshots._"
  ].join("\n");

  return {
    authMode,
    totalClusters: clusters.length,
    inventoryAsOfET: asOfEt,
    trendWindowDays: TREND_DAYS,
    activeScopeHours: ACTIVE_SCOPE_HOURS,
    dayLabels,
    markdownEmail,
    rows: {
      section1_activeScope: s1Rows,
      section2_pgTrend: s2Rows,
      section3_failedVms: s3Rows
    },
    errors
  };
}
