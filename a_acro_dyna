import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alert Tiles (Markdown-only, Severity Symbols)
 * - GET-only
 * - ONLY clusters that currently have Active (kOpen) alerts are shown (short output)
 * - Sections: Hardware / Maintenance / Data Service
 * - Columns: EXACT alertCategory enums (alphabetical)
 * - Cell: ✅ if healthy, else ⛔<n> ⚠️<n> ℹ️<n>
 *
 * Return: { authMode, markdownEmail }
 * Email body: {{ result("run_javascript_1").markdownEmail }}
 */
export default async function () {
  const baseUrl = "https://helios.cohesity.com";
  const alertsPath = "/mcm/alerts";

  // ==============================
  // 1) Auth (AS-IS from your reference)
  // ==============================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = all?.credentials || [];
    const found = creds.find((c) => c?.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return detail?.token || detail?.password || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (_) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = d2?.token || d2?.password || null;
      authMode = "vault-id";
    } catch (_) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey || apiKey === "PASTE_YOUR_API_KEY_HERE") {
    throw new Error("No Helios API key available.");
  }

  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // 2) CATEGORY COLUMNS (EXACT ENUMS)
  // ==============================
  const HW_Cats = [
    "kCPU","kChassis","kCluster","kDisk","kFan","kFirmware","kMemory","kNIC",
    "kNode","kNodeHealth","kOperatingSystem","kPowerSupply","kStorageDevice",
    "kStoragePool","kTemperature"
  ].sort();

  const MAINT_Cats = [
    "kAuditLog","kClusterManagement","kConfiguration","kFaultTolerance",
    "kGeneralSoftwareFailure","kHelios","kLicense","kNetworking","kSecurity",
    "kStorageUsage","kSystemService","kUpgrade"
  ].sort();

  const DS_Cats = [
    "kAgent","kAppMarketPlace","kArchivalRestore","kBackupRestore","kCDP",
    "kDataPath","kDataSourceConnector","kDisasterRecovery","kIndexing","kMetadata",
    "kNetBackup","kQuota","kRemoteReplication","kViewFailover"
  ].sort();

  // ==============================
  // 3) SYMBOLS (as agreed)
  // ==============================
  const SYM_HEALTHY = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";

  function sevBucket(sev) {
    switch (sev) {
      case "kCritical": return "C";
      case "kWarning":  return "W";
      case "kInfo":     return "I";
      default:          return "I";
    }
  }

  function normalizeAlerts(resp) {
    if (Array.isArray(resp)) return resp;
    if (Array.isArray(resp?.alerts)) return resp.alerts;
    if (Array.isArray(resp?.items)) return resp.items;
    return [];
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const err = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      err.httpStatus = resp.status;
      err.bodyText = txt;
      err.url = url;
      throw err;
    }
    return resp.json();
  }

  async function getJsonSafe(url, headers) {
    try {
      const data = await getJson(url, headers);
      return { ok: true, data, status: 200, bodyText: "", url };
    } catch (e) {
      return {
        ok: false,
        data: null,
        status: e?.httpStatus || 0,
        bodyText: e?.bodyText || String(e || ""),
        url: e?.url || url
      };
    }
  }

  async function getActiveAlertsByBucket(bucketEnum) {
    // GET with query params (avoid GET body issues)
    const qs = new URLSearchParams({
      alertStateList: "kOpen",
      alertTypeBucketList: bucketEnum
    });

    const url = `${baseUrl}${alertsPath}?${qs.toString()}`;
    const r = await getJsonSafe(url, { ...commonHeaders, Accept: "application/json" });

    if (!r.ok) {
      throw new Error(`Helios alerts GET failed (${r.status}) ${r.url} ${r.bodyText || ""}`);
    }
    return normalizeAlerts(r.data);
  }

  function cellValue(C, W, I) {
    if (C === 0 && W === 0 && I === 0) return SYM_HEALTHY;
    return `${SYM_C}${C} ${SYM_W}${W} ${SYM_I}${I}`;
  }

  function buildMarkdownTable(rows, categories) {
    if (!rows?.length) return "No Active alerts (no clusters to display).";

    const header = ["ClusterName", ...categories];
    const sep = header.map(() => "---");

    const lines = [];
    lines.push(`| ${header.join(" | ")} |`);
    lines.push(`| ${sep.join(" | ")} |`);

    for (const row of rows) {
      const vals = [row.ClusterName, ...categories.map((c) => row[c] ?? SYM_HEALTHY)];
      lines.push(`| ${vals.join(" | ")} |`);
    }
    return lines.join("\n");
  }

  async function buildWideTileTableSeverityShort(bucketEnum, categories) {
    const alerts = await getActiveAlertsByBucket(bucketEnum);

    // Cluster list ONLY from alerts (short output)
    const clusters = Array.from(
      new Set(
        alerts
          .map((a) => String(a?.clusterName ?? "").trim())
          .filter((x) => x.length > 0)
      )
    ).sort((a, b) => a.localeCompare(b));

    if (!clusters.length) return { markdown: "" };

    // counts["cluster||category"] = {C:n, W:n, I:n}
    const counts = new Map();

    for (const a of alerts) {
      const cluster = String(a?.clusterName ?? "").trim();
      const cat = String(a?.alertCategory ?? "").trim();
      if (!cluster || !cat) continue;
      if (!categories.includes(cat)) continue;

      const key = `${cluster}||${cat}`;
      if (!counts.has(key)) counts.set(key, { C: 0, W: 0, I: 0 });

      const b = sevBucket(String(a?.severity ?? ""));
      counts.get(key)[b] += 1;
    }

    const rows = clusters.map((c) => {
      const row = { ClusterName: c };
      for (const cat of categories) {
        const key = `${c}||${cat}`;
        if (!counts.has(key)) row[cat] = SYM_HEALTHY;
        else {
          const { C, W, I } = counts.get(key);
          row[cat] = cellValue(C, W, I);
        }
      }
      return row;
    });

    return { markdown: buildMarkdownTable(rows, categories) };
  }

  // ==============================
  // 4) Build output
  // ==============================
  const note =
    `NOTE:\n` +
    `- This report shows ONLY clusters that currently have Active (kOpen) alerts in each section.\n` +
    `- Clusters not displayed have no Active alerts for that section (healthy for these tiles).\n` +
    `- Cells show "${SYM_HEALTHY}" or "${SYM_C}<n> ${SYM_W}<n> ${SYM_I}<n>".\n` +
    `- AuthMode: ${authMode}`;

  const hw  = await buildWideTileTableSeverityShort("kHardware", HW_Cats);
  const mnt = await buildWideTileTableSeverityShort("kMaintenance", MAINT_Cats);
  const ds  = await buildWideTileTableSeverityShort("kDataService", DS_Cats);

  const markdownEmail =
    `${note}\n\n` +
    `Hardware\n${hw.markdown || "No Active alerts (no clusters to display)."}\n\n` +
    `Maintenance\n${mnt.markdown || "No Active alerts (no clusters to display)."}\n\n` +
    `Data Service\n${ds.markdown || "No Active alerts (no clusters to display)."}`;

  return { authMode, markdownEmail };
}
