# =====================================================================
# Cohesity Helios â€” Oracle DB Inventory (Registration + PG/Policy/Host)
# STRICTLY READ-ONLY (GET-only)
#
# Menu:
# 1) Select Cluster: [0] ALL or [1..N] single
#
# Output:
# - Console table
# - ONE timestamped CSV (always if rows exist)
#
# Adds:
# - TDE_EncryptedTsCount  (tdeEncryptedTsCount)
# - TDE_Enabled           (Yes if count > 0 else No)
# - DataGuardRole         (dataGuardInfo.role => kPrimary / kStandby)
#
# Join:
# - By DBName (case-insensitive) (same style as your working script)
# =====================================================================

$ErrorActionPreference = "Stop"
$FormatEnumerationLimit = -1
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# -------------------------------
# Output folder
# -------------------------------
$outDir = "H:\Cohesity_API\Logs"
if (-not (Test-Path -Path $outDir -PathType Container)) {
    New-Item -Path $outDir -ItemType Directory | Out-Null
}

# -------------------------------
# API key
# -------------------------------
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()

$baseUrl = "https://helios.cohesity.com"
$commonHeaders = @{ "apiKey" = $apiKey; "accept"="application/json" }

# -------------------------------
# GET wrapper (PS 5.1 safe)
# -------------------------------
function Invoke-HeliosGetJson {
    param(
        [Parameter(Mandatory)][string]$Uri,
        [Parameter(Mandatory)][hashtable]$Headers
    )
    if ($PSVersionTable.PSVersion.Major -lt 6) {
        $resp = Invoke-WebRequest -Uri $Uri -Headers $Headers -Method Get -UseBasicParsing
    } else {
        $resp = Invoke-WebRequest -Uri $Uri -Headers $Headers -Method Get
    }
    if (-not $resp -or [string]::IsNullOrWhiteSpace($resp.Content)) { return $null }
    return ($resp.Content | ConvertFrom-Json)
}

# -------------------------------
# Helpers
# -------------------------------
function To-FlatString {
    param([object]$v)
    if ($null -eq $v) { return "" }
    if ($v -is [System.Array]) {
        return (($v | Where-Object { $_ -ne $null -and "$_".Trim() -ne "" }) -join ";")
    }
    return "$v"
}

function Resolve-HostName {
    param([string]$nameOrIp)
    if ([string]::IsNullOrWhiteSpace($nameOrIp)) { return "" }
    if ($nameOrIp -match '^\d{1,3}(\.\d{1,3}){3}$') {
        try { return ([System.Net.Dns]::GetHostEntry($nameOrIp).HostName) } catch { return $nameOrIp }
    }
    return $nameOrIp
}

function Get-TdeEncryptedTsCount {
    param([object]$node)
    try {
        if ($node.PSObject.Properties["tdeEncryptedTsCount"]) {
            $v = $node.tdeEncryptedTsCount
            if ($null -eq $v) { return 0 }
            return [int]$v
        }
    } catch {}
    return 0
}

function Get-DataGuardRole {
    param([object]$node)
    try {
        if (-not $node.PSObject.Properties["dataGuardInfo"]) { return "" }
        $dg = $node.dataGuardInfo
        if ($null -eq $dg) { return "" }
        if ($dg -is [System.Array]) {
            $roles = @($dg | ForEach-Object { $_.role }) | Where-Object { $_ -and "$_".Trim() -ne "" } | Select-Object -Unique
            return (To-FlatString $roles)
        } else {
            return (To-FlatString $dg.role)
        }
    } catch { return "" }
}

# =====================================================================
# 1) Cluster menu (your working pattern: cohesityClusters)
# =====================================================================
$cluJson = Invoke-HeliosGetJson -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders
$json_clu = @($cluJson.cohesityClusters)
if (-not $json_clu -or $json_clu.Count -eq 0) { throw "No clusters returned from Helios." }

$clusters = $json_clu | ForEach-Object {
    $name = ($_.name,$_.clusterName,$_.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
    $cid  = ($_.clusterId,$_.id | Where-Object { $_ } | Select-Object -First 1)
    if (-not $name) { $name = "Unknown-$cid" }
    [pscustomobject]@{ ClusterName=$name; ClusterId=$cid }
} | Sort-Object ClusterName

$clusterMenu = for ($i=0; $i -lt $clusters.Count; $i++) {
    [pscustomobject]@{ Index=$i+1; ClusterName=$clusters[$i].ClusterName; ClusterId=$clusters[$i].ClusterId }
}

Write-Host ""
Write-Host "Available Helios Clusters (sorted):" -ForegroundColor Cyan
$clusterMenu | Format-Table -AutoSize
Write-Host ""
Write-Host "[0] All clusters" -ForegroundColor Yellow
Write-Host "[X] Exit" -ForegroundColor Yellow

while ($true) {
    $in = Read-Host "Select cluster: 0 for ALL, 1-$($clusterMenu.Count) for single, or X"
    if ($in -match '^(x|X|q|Q)$') { return }

    $n = 0
    if (-not [int]::TryParse($in, [ref]$n)) { Write-Host "Enter 0, 1-$($clusterMenu.Count), or X." -ForegroundColor Red; continue }
    if ($n -lt 0 -or $n -gt $clusterMenu.Count) { Write-Host "Enter 0, 1-$($clusterMenu.Count), or X." -ForegroundColor Red; continue }

    if ($n -eq 0) { $SelectedClusters = @($clusterMenu) }
    else { $SelectedClusters = @($clusterMenu | Where-Object { $_.Index -eq $n }) }

    break
}

# Build clustersAvailable in your style, but safe if cluster name has spaces
$clustersAvailable = @()
foreach ($c in $SelectedClusters) {
    $clustersAvailable += ("{0}|{1}" -f $c.ClusterId, $c.ClusterName)
}

# =====================================================================
# 2) Collect rows (same 2 arrays like your script)
# =====================================================================
$regRows = @()   # Script 1 rows (registration / DB attributes)
$pgRows  = @()   # Script 2 rows (PG/policy/host info)

# caches
$policyCache = @{}  # key: clusterId|policyId -> policyName
$hostCache   = @{}  # key: clusterId|hostId   -> hostNameOut

foreach ($cluster in $clustersAvailable) {

    $cluster_id, $cluster_name = $cluster -split "\|", 2

    $headers = @{
        apiKey          = $apiKey
        accessClusterId = $cluster_id
        accept          = "application/json"
    }

    # ----------------------------- Script 1 (DB attributes) -----------------------------
    $uri1 = "$baseUrl/irisservices/api/v1/public/protectionSources/registrationInfo" +
            "?environments=kOracle&includeEmbeddedApplication=true&includeApplicationTreeInfo=true" +
            "&allUnderHierarchy=true&includeData=true"

    $json1 = Invoke-HeliosGetJson -Uri $uri1 -Headers $headers

    # Safely walk arrays to reach oracleProtectionSource nodes
    $db_nodes = @()
    foreach ($root in ($json1.rootNodes | Where-Object { $_ })) {
        foreach ($app in ($root.applications | Where-Object { $_ })) {
            foreach ($ati in ($app.applicationTreeInfo | Where-Object { $_ })) {
                $ora = $ati.protectionSource.oracleProtectionSource
                if ($ora) { $db_nodes += $ora }
            }
        }
    }

    foreach ($node in $db_nodes) {

        # CPU_Count: keep original path; display fallback so it never appears blank
        $cpu = (@($node.hosts.cpuCount) -join ';')
        if ([string]::IsNullOrWhiteSpace($cpu)) { $cpu = 'N/A' }

        # DBHome: collect like CPU_Count, join if multiple; fallback to N/A
        $dbHome = (@($node.hosts.sessions.location) -join ';')
        if ([string]::IsNullOrWhiteSpace($dbHome)) { $dbHome = 'N/A' }

        $tdeCount   = Get-TdeEncryptedTsCount -node $node
        $tdeEnabled = $(if ($tdeCount -gt 0) { "Yes" } else { "No" })
        $dgRole     = Get-DataGuardRole -node $node

        $regRows += [PSCustomObject]@{
            Cluster              = $cluster_name
            DBName               = $node.databaseUniqueName
            DBVersion            = $node.version
            ArchiveLog_Enabled   = $node.archivelogEnabled
            BCT_Enabled          = $node.bctEnabled
            TDE_Enabled          = $tdeEnabled
            TDE_EncryptedTsCount = $tdeCount
            DataGuardRole        = $dgRole
            DB_Type              = $node.dbType
            DB_Size_in_GB        = [math]::Round(((($node.size) | ForEach-Object { $_ }) / 1GB), 4)
            DB_Instances         = (@($node.hosts.sessions.systemIdentifier) -join ';')
            CPU_Count            = $cpu
            DB_Home              = $dbHome
            SharedPool_Size      = $node.sgaTargetSize
            Fragment_Size        = $node.sharedPoolSize
            FRA_Size_in_GB       = [math]::Round(((($node.frasize) | ForEach-Object { $_ }) / 1GB), 4)
        }
    }

    # ----------------------------- Script 2 (PG/Policy/Host) -----------------------------
    # IMPORTANT: keep this EXACT query style so oracleParams payload is present
    $uri2  = "$baseUrl/v2/data-protect/protection-groups?environments=kOracle&isDeleted=false&isActive=true&includeLastRunInfo=true"
    $json2 = Invoke-HeliosGetJson -Uri $uri2 -Headers $headers

    foreach ($dbd in ($json2.protectionGroups | Where-Object { $_ })) {
        foreach ($channels in ($dbd.oracleParams.objects | Where-Object { $_ })) {
            foreach ($channel in ($channels.dbParams.dbChannels.dbChannel | Where-Object { $_ })) {

                # PolicyName (cached)
                $policyName = ""
                if ($dbd.policyId) {
                    $pk = "$cluster_id|$($dbd.policyId)"
                    if ($policyCache.ContainsKey($pk)) {
                        $policyName = $policyCache[$pk]
                    } else {
                        try {
                            $pJson = Invoke-HeliosGetJson -Uri "$baseUrl/v2/data-protect/policies?ids=$($dbd.policyId)" -Headers $headers
                            $policyName = ($pJson.policies | Where-Object { $_._id -eq $dbd.policyId } | Select-Object -ExpandProperty name -First 1)
                        } catch { $policyName = "" }
                        $policyCache[$pk] = $policyName
                    }
                }

                # Hostname EXACT style (hostId -> objects/<id> -> .name -> PTR if IP)
                $hostName = ""
                try {
                    $hostId = $channel.databaseNodeList.hostId
                    if ($hostId) {
                        $hk = "$cluster_id|$hostId"
                        if ($hostCache.ContainsKey($hk)) {
                            $hostName = $hostCache[$hk]
                        } else {
                            $ipApiUrl  = "$baseUrl/v2/data-protect/objects/$hostId"
                            $ipResponse = Invoke-WebRequest -Method Get -Uri $ipApiUrl -Headers $headers -UseBasicParsing
                            $ipJson = $ipResponse.Content | ConvertFrom-Json
                            $ip = $ipJson.name
                            $hostName = Resolve-HostName -nameOrIp $ip
                            $hostCache[$hk] = $hostName
                        }
                    }
                } catch { $hostName = "" }

                $pgRows += [PSCustomObject]@{
                    Cluster               = $cluster_name
                    PGName                = $dbd.name
                    Replicated_To_Cluster = (To-FlatString $dbd.lastRun.replicationInfo.replicationTargetResults.ClusterName)
                    PolicyName            = $policyName
                    SourceName            = $channels.SourceName
                    DBName                = $channel.databaseUniqueName
                    PersistMountPoints    = (To-FlatString $dbd.oracleParams.persistMountPoints)
                    LogRetentionDays      = $channel.archiveVolRetentionDays
                    ChannelCount          = $channel.databaseNodeList.ChannelCount
                    Port                  = $channel.databaseNodeList.port
                    HostName              = $hostName
                }
            }
        }
    }

    Write-Host ("   Cluster done: {0} | regRows(add)={1} | pgRows(add)={2}" -f $cluster_name,
        (@($regRows | Where-Object { $_.Cluster -eq $cluster_name }).Count),
        (@($pgRows  | Where-Object { $_.Cluster -eq $cluster_name }).Count)
    ) -ForegroundColor DarkCyan
}

# =====================================================================
# 3) JOIN BOTH OUTPUTS BY DBName (case-insensitive) (your style)
# =====================================================================
$ix = New-Object System.Collections.Hashtable ([StringComparer]::OrdinalIgnoreCase)
foreach ($r in $pgRows) {
    $k = ($r.DBName -as [string]).Trim()
    if (-not [string]::IsNullOrWhiteSpace($k)) { $ix[$k] = $r }
}

$final = @()

# Left join: all DBs from Script 1, enrich with Script 2 when present
foreach ($a in $regRows) {
    $k  = ($a.DBName -as [string]).Trim()
    $sb = $null
    if (-not [string]::IsNullOrWhiteSpace($k)) { $sb = $ix[$k] }

    $final += [PSCustomObject]@{
        Cluster               = $a.Cluster
        DBName                = $a.DBName
        HostName              = if ($sb) { $sb.HostName } else { "" }
        PGName                = if ($sb) { $sb.PGName } else { "" }
        Replicated_To_Cluster = if ($sb) { $sb.Replicated_To_Cluster } else { "" }
        PolicyName            = if ($sb) { $sb.PolicyName } else { "" }
        SourceName            = if ($sb) { $sb.SourceName } else { "" }
        PersistMountPoints    = if ($sb) { $sb.PersistMountPoints } else { "" }
        LogRetentionDays      = if ($sb) { $sb.LogRetentionDays } else { "" }
        ChannelCount          = if ($sb) { $sb.ChannelCount } else { "" }
        Port                  = if ($sb) { $sb.Port } else { "" }

        DBVersion             = $a.DBVersion
        ArchiveLog_Enabled    = $a.ArchiveLog_Enabled
        BCT_Enabled           = $a.BCT_Enabled
        TDE_Enabled           = $a.TDE_Enabled
        TDE_EncryptedTsCount  = $a.TDE_EncryptedTsCount
        DataGuardRole         = $a.DataGuardRole
        DB_Type               = $a.DB_Type
        DB_Size_in_GB         = $a.DB_Size_in_GB
        DB_Instances          = ($a.DB_Instances -as [string])
        CPU_Count             = ($a.CPU_Count -as [string])
        DB_Home               = ($a.DB_Home -as [string])
        SharedPool_Size       = $a.SharedPool_Size
        Fragment_Size         = $a.Fragment_Size
        FRA_Size_in_GB        = $a.FRA_Size_in_GB
    }
}

# (Optional) include DBs that exist only in Script 2 but not in Script 1
# $onlyInPg = $pgRows | Where-Object { -not ($regRows.DBName -contains $_.DBName) }
# foreach ($sb in $onlyInPg) { ... }

# =====================================================================
# 4) ONE CLEAN TABLE + CSV
# =====================================================================
$final = $final | Sort-Object Cluster, DBName

$colsDef = @(
    @{Label='Cluster';               Expression = { $_.Cluster } },
    @{Label='Replicated_To_Cluster'; Expression = { $_.Replicated_To_Cluster } },
    @{Label='DBName';                Expression = { $_.DBName } },
    @{Label='HostName';              Expression = { $_.HostName } },
    @{Label='PGName';                Expression = { $_.PGName } },
    @{Label='PolicyName';            Expression = { $_.PolicyName } },
    @{Label='SourceName';            Expression = { $_.SourceName } },
    @{Label='PersistMountPoints';    Expression = { $_.PersistMountPoints } },
    @{Label='LogRetentionDays';      Expression = { $_.LogRetentionDays } },
    @{Label='ChannelCount';          Expression = { $_.ChannelCount } },
    @{Label='Port';                  Expression = { $_.Port } },

    @{Label='DataGuardRole';         Expression = { $_.DataGuardRole } },
    @{Label='TDE_Enabled';           Expression = { $_.TDE_Enabled } },
    @{Label='TDE_EncryptedTsCount';  Expression = { $_.TDE_EncryptedTsCount } },

    @{Label='DBVersion';             Expression = { $_.DBVersion } },
    @{Label='ArchiveLog_Enabled';    Expression = { $_.ArchiveLog_Enabled } },
    @{Label='BCT_Enabled';           Expression = { $_.BCT_Enabled } },
    @{Label='DB_Type';               Expression = { $_.DB_Type } },
    @{Label='DB_Size_in_GB';         Expression = { $_.DB_Size_in_GB } },
    @{Label='DB_Instances';          Expression = { $_.DB_Instances } },
    @{Label='CPU_Count';             Expression = { $_.CPU_Count } },
    @{Label='DB_Home';               Expression = { $_.DB_Home } },
    @{Label='SharedPool_Size';       Expression = { $_.SharedPool_Size } },
    @{Label='Fragment_Size';         Expression = { $_.Fragment_Size } },
    @{Label='FRA_Size_in_GB';        Expression = { $_.FRA_Size_in_GB } }
)

try {
    $raw = $Host.UI.RawUI
    $raw.BufferSize = New-Object Management.Automation.Host.Size (10000, $raw.BufferSize.Height)
} catch {}

$txt = $final | Format-Table -Property $colsDef -AutoSize | Out-String -Width 10000
$txt

$stamp   = Get-Date -Format "yyyy-MM-dd_HHmm"
$csvPath = Join-Path $outDir "oracle_DB_combined_$stamp.csv"

$final |
    Select-Object ($colsDef | ForEach-Object { $_.Label }) |
    Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8

Write-Host "CSV exported: $csvPath" -ForegroundColor Gray
