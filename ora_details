# =====================================================================
# Cohesity Helios — Oracle DB Inventory (Registration + PG/Policy/Host)
# STRICTLY READ-ONLY (GET-only)
#
# Menu:
# 1) Select Cluster: [0] ALL or [1..N] single
#
# Output:
# - Console table (explicit columns)
# - ONE timestamped CSV (always)
#
# Notes:
# - Joins Script1 + Script2 by DBName (case-insensitive)
# - Adds TDE_Enabled (best-effort from registrationInfo)
# =====================================================================

$ErrorActionPreference = "Stop"
$FormatEnumerationLimit = -1
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# -------------------------------
# Tunables
# -------------------------------
$outDir = "H:\Cohesity_API\Logs"

# -------------------------------
# Folder
# -------------------------------
if (-not (Test-Path -Path $outDir -PathType Container)) {
    New-Item -Path $outDir -ItemType Directory | Out-Null
}

# -------------------------------
# API key
# -------------------------------
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()

$baseUrl = "https://helios.cohesity.com"
$commonHeaders = @{ "apiKey" = $apiKey; "accept"="application/json" }

# -------------------------------
# GET wrapper (PS 5.1 safe)
# -------------------------------
function Invoke-HeliosGetJson {
    param(
        [Parameter(Mandatory)][string]$Uri,
        [Parameter(Mandatory)][hashtable]$Headers
    )
    if ($PSVersionTable.PSVersion.Major -lt 6) {
        $resp = Invoke-WebRequest -Uri $Uri -Headers $Headers -Method Get -UseBasicParsing
    } else {
        $resp = Invoke-WebRequest -Uri $Uri -Headers $Headers -Method Get
    }
    if (-not $resp -or [string]::IsNullOrWhiteSpace($resp.Content)) { return $null }
    return ($resp.Content | ConvertFrom-Json)
}

# -------------------------------
# Helpers
# -------------------------------
function To-FlatString {
    param([object]$v)
    if ($null -eq $v) { return "" }
    if ($v -is [System.Array]) {
        return (($v | Where-Object { $_ -ne $null -and "$_".Trim() -ne "" }) -join ";")
    }
    return "$v"
}

function Resolve-HostName {
    param([string]$nameOrIp)
    if ([string]::IsNullOrWhiteSpace($nameOrIp)) { return "" }
    if ($nameOrIp -match '^\d{1,3}(\.\d{1,3}){3}$') {
        try { return ([System.Net.Dns]::GetHostEntry($nameOrIp).HostName } catch { return $nameOrIp }
    }
    return $nameOrIp
}

function Get-TdeEnabled {
    param([object]$node)

    # Best-effort: property names vary by Cohesity version.
    $tryProps = @(
        "tdeEnabled","isTdeEnabled","isTDEEnabled","tde",
        "encryptionEnabled","isEncrypted",
        "tdeWalletLocation","walletLocation","tdeWalletPath","walletPath"
    )

    foreach ($p in $tryProps) {
        $prop = $node.PSObject.Properties[$p]
        if ($prop -and $null -ne $prop.Value) {
            $val = $prop.Value
            if ($val -is [bool]) { return ($(if ($val) { "Yes" } else { "No" })) }
            if ("$val".Trim() -ne "") { return "Yes" }
        }
    }
    return "N/A"
}

# =====================================================================
# 1) Clusters menu  (MATCHES YOUR REFERENCE STYLE)
# =====================================================================
$cluJson = Invoke-HeliosGetJson -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders

# Primary shape (your env): .cohesityClusters
$json_clu = @($cluJson.cohesityClusters)

# Fallbacks (just in case)
if (-not $json_clu -or $json_clu.Count -eq 0) {
    if ($cluJson.PSObject.Properties["clusters"])     { $json_clu = @($cluJson.clusters) }
    elseif ($cluJson.PSObject.Properties["clusterInfos"]) { $json_clu = @($cluJson.clusterInfos) }
}

if (-not $json_clu -or $json_clu.Count -eq 0) { throw "No clusters returned from Helios." }

$clusters = $json_clu | ForEach-Object {
    $name = ($_.name,$_.clusterName,$_.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
    $cid  = ($_.clusterId,$_.id | Where-Object { $_ } | Select-Object -First 1)
    if (-not $name) { $name = "Unknown-$cid" }
    [pscustomobject]@{ ClusterName=$name; ClusterId=$cid }
} | Sort-Object ClusterName

$clusterMenu = for ($i=0; $i -lt $clusters.Count; $i++) {
    [pscustomobject]@{ Index=$i+1; ClusterName=$clusters[$i].ClusterName; ClusterId=$clusters[$i].ClusterId }
}

Write-Host ""
Write-Host "Available Helios Clusters (sorted):" -ForegroundColor Cyan
$clusterMenu | Format-Table -AutoSize
Write-Host ""
Write-Host "[0] All clusters" -ForegroundColor Yellow
Write-Host "[X] Exit" -ForegroundColor Yellow

while ($true) {
    $in = Read-Host "Select cluster: 0 for ALL, 1-$($clusterMenu.Count) for single, or X"
    if ($in -match '^(x|X|q|Q)$') { return }

    $n = 0
    if (-not [int]::TryParse($in, [ref]$n)) { Write-Host "Enter 0, 1-$($clusterMenu.Count), or X." -ForegroundColor Red; continue }
    if ($n -lt 0 -or $n -gt $clusterMenu.Count) { Write-Host "Enter 0, 1-$($clusterMenu.Count), or X." -ForegroundColor Red; continue }

    if ($n -eq 0) { $SelectedClusters = @($clusterMenu) }
    else { $SelectedClusters = @($clusterMenu | Where-Object { $_.Index -eq $n }) }

    break
}

# =====================================================================
# 2) Collect data
# =====================================================================
$regRows = @()   # Script 1 rows (registration / DB attributes)
$pgRows  = @()   # Script 2 rows (PG/policy/host info)

# Caches (per run)
$policyNameCache = @{}  # key: ClusterId|PolicyId -> PolicyName
$hostNameCache   = @{}  # key: ClusterId|HostId   -> HostName

foreach ($c in $SelectedClusters) {

    $headers = @{ apiKey=$apiKey; accessClusterId=$c.ClusterId; accept="application/json" }

    # -------------------------------------------------------------
    # Script 1 (DB attributes) — registrationInfo (kOracle)
    # -------------------------------------------------------------
    $uri1 = "$baseUrl/irisservices/api/v1/public/protectionSources/registrationInfo" +
            "?environments=kOracle&includeEmbeddedApplication=true&includeApplicationTreeInfo=true" +
            "&allUnderHierarchy=true&includeData=true"

    $json1 = $null
    try { $json1 = Invoke-HeliosGetJson -Uri $uri1 -Headers $headers } catch {
        Write-Host "⚠️ registrationInfo failed for $($c.ClusterName): $($_.Exception.Message)" -ForegroundColor Yellow
        continue
    }

    $db_nodes = @()
    foreach ($root in @($json1.rootNodes) | Where-Object { $_ }) {
        foreach ($app in @($root.applications) | Where-Object { $_ }) {
            foreach ($ati in @($app.applicationTreeInfo) | Where-Object { $_ }) {
                $ora = $ati.protectionSource.oracleProtectionSource
                if ($ora) { $db_nodes += $ora }
            }
        }
    }

    foreach ($node in @($db_nodes) | Where-Object { $_ }) {

        $cpu = To-FlatString (@($node.hosts.cpuCount))
        if ([string]::IsNullOrWhiteSpace($cpu)) { $cpu = "N/A" }

        $dbhome = To-FlatString (@($node.hosts.sessions.location))
        if ([string]::IsNullOrWhiteSpace($dbhome)) { $dbhome = "N/A" }

        $tde = Get-TdeEnabled -node $node

        $regRows += [PSCustomObject]@{
            Cluster            = $c.ClusterName
            DBName             = $node.databaseUniqueName
            DBVersion          = $node.version
            ArchiveLog_Enabled = $node.archivelogEnabled
            BCT_Enabled        = $node.bctEnabled
            TDE_Enabled        = $tde
            DB_Type            = $node.dbType
            DB_Size_in_GB      = [math]::Round(((($node.size) | ForEach-Object { $_ }) / 1GB), 4)
            DB_Instances       = To-FlatString (@($node.hosts.sessions.systemIdentifier))
            CPU_Count          = $cpu
            DB_Home            = $dbhome
            SharedPool_Size    = $node.sgaTargetSize
            Fragment_Size      = $node.sharedPoolSize
            FRA_Size_in_GB     = [math]::Round(((($node.frasize) | ForEach-Object { $_ }) / 1GB), 4)
        }
    }

    # -------------------------------------------------------------
    # Script 2 (PG/Policy/Host) — protection-groups (kOracle)
    # -------------------------------------------------------------
    $uri2 = "$baseUrl/v2/data-protect/protection-groups?environments=kOracle&isDeleted=false&isActive=true&includeLastRunInfo=true"

    $json2 = $null
    try { $json2 = Invoke-HeliosGetJson -Uri $uri2 -Headers $headers } catch {
        Write-Host "⚠️ protection-groups failed for $($c.ClusterName): $($_.Exception.Message)" -ForegroundColor Yellow
        continue
    }

    foreach ($pg in @($json2.protectionGroups) | Where-Object { $_ }) {

        # Policy name (cached)
        $policyName = ""
        if ($pg.policyId) {
            $pkey = "$($c.ClusterId)|$($pg.policyId)"
            if ($policyNameCache.ContainsKey($pkey)) {
                $policyName = $policyNameCache[$pkey]
            } else {
                try {
                    $pJson = Invoke-HeliosGetJson -Uri "$baseUrl/v2/data-protect/policies?ids=$($pg.policyId)" -Headers $headers
                    $policyName = ($pJson.policies | Where-Object { $_._id -eq $pg.policyId } | Select-Object -ExpandProperty name -First 1)
                } catch { $policyName = "" }
                $policyNameCache[$pkey] = $policyName
            }
        }

        $repTo = ""
        try { $repTo = To-FlatString (@($pg.lastRun.replicationInfo.replicationTargetResults.ClusterName)) } catch { $repTo = "" }

        foreach ($obj in @($pg.oracleParams.objects) | Where-Object { $_ }) {
            foreach ($ch in @($obj.dbParams.dbChannels.dbChannel) | Where-Object { $_ }) {

                # Host name (cached): databaseNodeList.hostId -> /v2/data-protect/objects/<id> -> .name
                $hostName = ""
                $hostId = $null
                try { $hostId = $ch.databaseNodeList.hostId } catch { $hostId = $null }

                if ($hostId) {
                    $hkey = "$($c.ClusterId)|$hostId"
                    if ($hostNameCache.ContainsKey($hkey)) {
                        $hostName = $hostNameCache[$hkey]
                    } else {
                        try {
                            $oJson = Invoke-HeliosGetJson -Uri "$baseUrl/v2/data-protect/objects/$hostId" -Headers $headers
                            $hostName = Resolve-HostName -nameOrIp $oJson.name
                        } catch { $hostName = "" }
                        $hostNameCache[$hkey] = $hostName
                    }
                }

                $pgRows += [PSCustomObject]@{
                    Cluster               = $c.ClusterName
                    PGName                = $pg.name
                    Replicated_To_Cluster = $repTo
                    PolicyName            = $policyName
                    SourceName            = $obj.SourceName
                    DBName                = $ch.databaseUniqueName
                    PersistMountPoints    = To-FlatString $pg.oracleParams.persistMountPoints
                    LogRetentionDays      = $ch.archiveVolRetentionDays
                    ChannelCount          = $ch.databaseNodeList.ChannelCount
                    Port                  = $ch.databaseNodeList.port
                    HostName              = $hostName
                }
            }
        }
    }
}

# =====================================================================
# 3) JOIN BOTH OUTPUTS BY DBName (case-insensitive)
# =====================================================================
$ix = New-Object System.Collections.Hashtable ([StringComparer]::OrdinalIgnoreCase)
foreach ($sr in $pgRows) { if ($sr -and $sr.DBName) { $ix[$sr.DBName] = $sr } }

$final = @()

# Left join: all DBs from Script 1, enrich with Script 2 when present
foreach ($a in $regRows) {
    $b = $null
    if ($a.DBName -and $ix.ContainsKey($a.DBName)) { $b = $ix[$a.DBName] }

    $final += [PSCustomObject]@{
        Cluster               = $a.Cluster
        DBName                = $a.DBName
        HostName              = if ($b) { $b.HostName } else { "" }
        PGName                = if ($b) { $b.PGName } else { "" }
        Replicated_To_Cluster = if ($b) { $b.Replicated_To_Cluster } else { "" }
        PolicyName            = if ($b) { $b.PolicyName } else { "" }
        SourceName            = if ($b) { $b.SourceName } else { "" }
        PersistMountPoints    = if ($b) { $b.PersistMountPoints } else { "" }
        LogRetentionDays      = if ($b) { $b.LogRetentionDays } else { "" }
        ChannelCount          = if ($b) { $b.ChannelCount } else { "" }
        Port                  = if ($b) { $b.Port } else { "" }

        DBVersion             = $a.DBVersion
        ArchiveLog_Enabled    = $a.ArchiveLog_Enabled
        BCT_Enabled           = $a.BCT_Enabled
        TDE_Enabled           = $a.TDE_Enabled
        DB_Type               = $a.DB_Type
        DB_Size_in_GB         = $a.DB_Size_in_GB
        DB_Instances          = To-FlatString $a.DB_Instances
        CPU_Count             = $a.CPU_Count
        DB_Home               = $a.DB_Home
        SharedPool_Size       = $a.SharedPool_Size
        Fragment_Size         = $a.Fragment_Size
        FRA_Size_in_GB        = $a.FRA_Size_in_GB
    }
}

# Optional: include DBs only in Script 2 not in Script 1
$onlyInPg = $pgRows | Where-Object { $_ -and $_.DBName -and -not ($regRows.DBName -contains $_.DBName) }
foreach ($b in $onlyInPg) {
    $final += [PSCustomObject]@{
        Cluster               = $b.Cluster
        DBName                = $b.DBName
        HostName              = $b.HostName
        PGName                = $b.PGName
        Replicated_To_Cluster = $b.Replicated_To_Cluster
        PolicyName            = $b.PolicyName
        SourceName            = $b.SourceName
        PersistMountPoints    = $b.PersistMountPoints
        LogRetentionDays      = $b.LogRetentionDays
        ChannelCount          = $b.ChannelCount
        Port                  = $b.Port

        DBVersion             = ""
        ArchiveLog_Enabled    = ""
        BCT_Enabled           = ""
        TDE_Enabled           = "N/A"
        DB_Type               = ""
        DB_Size_in_GB         = ""
        DB_Instances          = ""
        CPU_Count             = ""
        DB_Home               = ""
        SharedPool_Size       = ""
        Fragment_Size         = ""
        FRA_Size_in_GB        = ""
    }
}

# =====================================================================
# 4) ONE CLEAN TABLE + CSV
# =====================================================================
$final = $final | Sort-Object Cluster, DBName

$colsDef = @(
    @{Label='Cluster';               Expression = { $_.Cluster } },
    @{Label='Replicated_To_Cluster'; Expression = { $_.Replicated_To_Cluster } },
    @{Label='DBName';                Expression = { $_.DBName } },
    @{Label='HostName';              Expression = { $_.HostName } },
    @{Label='PGName';                Expression = { $_.PGName } },
    @{Label='PolicyName';            Expression = { $_.PolicyName } },
    @{Label='SourceName';            Expression = { $_.SourceName } },
    @{Label='PersistMountPoints';    Expression = { $_.PersistMountPoints } },
    @{Label='LogRetentionDays';      Expression = { $_.LogRetentionDays } },
    @{Label='ChannelCount';          Expression = { $_.ChannelCount } },
    @{Label='Port';                  Expression = { $_.Port } },
    @{Label='DBVersion';             Expression = { $_.DBVersion } },
    @{Label='ArchiveLog_Enabled';    Expression = { $_.ArchiveLog_Enabled } },
    @{Label='BCT_Enabled';           Expression = { $_.BCT_Enabled } },
    @{Label='TDE_Enabled';           Expression = { $_.TDE_Enabled } },
    @{Label='DB_Type';               Expression = { $_.DB_Type } },
    @{Label='DB_Size_in_GB';         Expression = { $_.DB_Size_in_GB } },
    @{Label='DB_Instances';          Expression = { $_.DB_Instances } },
    @{Label='CPU_Count';             Expression = { $_.CPU_Count } },
    @{Label='DB_Home';               Expression = { $_.DB_Home } },
    @{Label='SharedPool_Size';       Expression = { $_.SharedPool_Size } },
    @{Label='Fragment_Size';         Expression = { $_.Fragment_Size } },
    @{Label='FRA_Size_in_GB';        Expression = { $_.FRA_Size_in_GB } }
)

try {
    $raw = $Host.UI.RawUI
    $raw.BufferSize = New-Object Management.Automation.Host.Size (10000, $raw.BufferSize.Height)
} catch {}

$txt = $final | Format-Table -Property $colsDef -AutoSize | Out-String -Width 10000
$txt

$stamp   = Get-Date -Format "yyyy-MM-dd_HHmm"
$csvPath = Join-Path $outDir "oracle_DB_combined_$stamp.csv"

# Export in the same visual order (use Labels)
$final |
    Select-Object ($colsDef | ForEach-Object { $_.Label }) |
    Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8

Write-Host "CSV exported: $csvPath" -ForegroundColor Gray
