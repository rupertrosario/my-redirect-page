# =====================================================================
# Cohesity Helios ‚Äî Oracle DB Inventory (Registration + PG/Policy/Host)
# STRICTLY READ-ONLY (GET-only)
#
# Menu:
# 1) Select Cluster: [0] ALL or [1..N] single
#
# Output:
# - Console table
# - ONE timestamped CSV (always, if rows exist)
#
# Adds:
# - TDE_EncryptedTsCount  (from registrationInfo)
# - TDE_Enabled           (Yes if TDE_EncryptedTsCount > 0 else No)
# - DataGuardRole         (dataGuardInfo.role => kPrimary / kStandby, etc.)
#
# Join:
# - By DBName (case-insensitive)
# - If multiple PG rows exist for same DB, outputs multiple rows
# =====================================================================

$ErrorActionPreference = "Stop"
$FormatEnumerationLimit = -1
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# -------------------------------
# Tunables
# -------------------------------
$outDir = "H:\Cohesity_API\Logs"
$MAX_FILES = 50
$MAX_AGE_DAYS = 30

# -------------------------------
# Folder hygiene
# -------------------------------
if (-not (Test-Path -Path $outDir -PathType Container)) {
    New-Item -Path $outDir -ItemType Directory | Out-Null
}
try {
    $files = Get-ChildItem -Path $outDir -File -ErrorAction Stop
    if ($files.Count -gt $MAX_FILES) {
        ($files | Sort-Object CreationTime | Select-Object -First ($files.Count - $MAX_FILES)) |
            Remove-Item -Force -ErrorAction SilentlyContinue
    }
} catch {}
try {
    $threshold = (Get-Date).AddDays(-$MAX_AGE_DAYS)
    Get-ChildItem -Path $outDir -File -ErrorAction SilentlyContinue |
        Where-Object { $_.LastWriteTime -lt $threshold } |
        Remove-Item -Force -ErrorAction SilentlyContinue
} catch {}

# -------------------------------
# API key
# -------------------------------
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()

$baseUrl = "https://helios.cohesity.com"
$commonHeaders = @{ "apiKey" = $apiKey; "accept"="application/json" }

# -------------------------------
# GET wrapper (PS 5.1 safe)
# -------------------------------
function Invoke-HeliosGetJson {
    param(
        [Parameter(Mandatory)][string]$Uri,
        [Parameter(Mandatory)][hashtable]$Headers
    )
    if ($PSVersionTable.PSVersion.Major -lt 6) {
        $resp = Invoke-WebRequest -Uri $Uri -Headers $Headers -Method Get -UseBasicParsing
    } else {
        $resp = Invoke-WebRequest -Uri $Uri -Headers $Headers -Method Get
    }
    if (-not $resp -or [string]::IsNullOrWhiteSpace($resp.Content)) { return $null }
    return ($resp.Content | ConvertFrom-Json)
}

# -------------------------------
# Helpers
# -------------------------------
function To-FlatString {
    param([object]$v)
    if ($null -eq $v) { return "" }
    if ($v -is [System.Array]) {
        return (($v | Where-Object { $_ -ne $null -and "$_".Trim() -ne "" }) -join ";")
    }
    return "$v"
}

function Resolve-HostName {
    param([string]$nameOrIp)
    if ([string]::IsNullOrWhiteSpace($nameOrIp)) { return "" }
    if ($nameOrIp -match '^\d{1,3}(\.\d{1,3}){3}$') {
        try { return ([System.Net.Dns]::GetHostEntry($nameOrIp).HostName) } catch { return $nameOrIp }
    }
    return $nameOrIp
}

function Get-DataGuardRole {
    param([object]$node)

    # dataGuardInfo can be object or array; role may be 'kPrimary' / 'kStandby'
    try {
        if (-not $node.PSObject.Properties["dataGuardInfo"]) { return "" }
        $dg = $node.dataGuardInfo
        if ($null -eq $dg) { return "" }

        if ($dg -is [System.Array]) {
            $roles = @($dg | ForEach-Object { $_.role }) | Where-Object { $_ -and "$_".Trim() -ne "" } | Select-Object -Unique
            return (To-FlatString $roles)
        } else {
            return (To-FlatString $dg.role)
        }
    } catch { return "" }
}

function Get-TdeCount {
    param([object]$node)
    # Cohesity field you saw: tdeEncryptedTsCount
    try {
        if ($node.PSObject.Properties["tdeEncryptedTsCount"]) {
            $v = $node.tdeEncryptedTsCount
            if ($null -eq $v) { return 0 }
            return [int]$v
        }
    } catch {}
    return 0
}

# caches across clusters
$script:policyNameCache = @{}  # key: ClusterId|PolicyId -> PolicyName
$script:hostNameCache   = @{}  # key: ClusterId|HostId   -> HostName

# =====================================================================
# 1) Clusters menu (your reference style)
# =====================================================================
$cluJson = Invoke-HeliosGetJson -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders

$json_clu = @($cluJson.cohesityClusters)
if (-not $json_clu -or $json_clu.Count -eq 0) {
    if ($cluJson.PSObject.Properties["clusters"])     { $json_clu = @($cluJson.clusters) }
    elseif ($cluJson.PSObject.Properties["clusterInfos"]) { $json_clu = @($cluJson.clusterInfos) }
}
if (-not $json_clu -or $json_clu.Count -eq 0) { throw "No clusters returned from Helios." }

$clusters = $json_clu | ForEach-Object {
    $name = ($_.name,$_.clusterName,$_.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
    $cid  = ($_.clusterId,$_.id | Where-Object { $_ } | Select-Object -First 1)
    if (-not $name) { $name = "Unknown-$cid" }
    [pscustomobject]@{ ClusterName=$name; ClusterId=$cid }
} | Sort-Object ClusterName

$clusterMenu = for ($i=0; $i -lt $clusters.Count; $i++) {
    [pscustomobject]@{ Index=$i+1; ClusterName=$clusters[$i].ClusterName; ClusterId=$clusters[$i].ClusterId }
}

Write-Host ""
Write-Host "Available Helios Clusters (sorted):" -ForegroundColor Cyan
$clusterMenu | Format-Table -AutoSize
Write-Host ""
Write-Host "[0] All clusters" -ForegroundColor Yellow
Write-Host "[X] Exit" -ForegroundColor Yellow

while ($true) {
    $in = Read-Host "Select cluster: 0 for ALL, 1-$($clusterMenu.Count) for single, or X"
    if ($in -match '^(x|X|q|Q)$') { return }

    $n = 0
    if (-not [int]::TryParse($in, [ref]$n)) { Write-Host "Enter 0, 1-$($clusterMenu.Count), or X." -ForegroundColor Red; continue }
    if ($n -lt 0 -or $n -gt $clusterMenu.Count) { Write-Host "Enter 0, 1-$($clusterMenu.Count), or X." -ForegroundColor Red; continue }

    if ($n -eq 0) { $SelectedClusters = @($clusterMenu) }
    else { $SelectedClusters = @($clusterMenu | Where-Object { $_.Index -eq $n }) }

    break
}

# =====================================================================
# 2) Collect data
# =====================================================================
$regRows = @()
$pgRows  = @()

foreach ($c in $SelectedClusters) {

    $cluster_id   = "$($c.ClusterId)"
    $cluster_name = "$($c.ClusterName)"
    $headers      = @{ apiKey=$apiKey; accessClusterId=$cluster_id; accept="application/json" }

    Write-Host ("`nüî∏ Cluster: {0}" -f $cluster_name) -ForegroundColor Yellow

    # -------------------------------------------------------------
    # Script 1 ‚Äî registrationInfo (kOracle)
    # -------------------------------------------------------------
    $uri1 = "$baseUrl/irisservices/api/v1/public/protectionSources/registrationInfo" +
            "?environments=kOracle&includeEmbeddedApplication=true&includeApplicationTreeInfo=true" +
            "&allUnderHierarchy=true&includeData=true"

    $json1 = $null
    try { $json1 = Invoke-HeliosGetJson -Uri $uri1 -Headers $headers } catch {
        Write-Host "‚ö†Ô∏è registrationInfo failed: $($_.Exception.Message)" -ForegroundColor Yellow
        continue
    }

    $db_nodes = @()
    foreach ($root in @($json1.rootNodes) | Where-Object { $_ }) {
        foreach ($app in @($root.applications) | Where-Object { $_ }) {
            foreach ($ati in @($app.applicationTreeInfo) | Where-Object { $_ }) {
                $ora = $ati.protectionSource.oracleProtectionSource
                if ($ora) { $db_nodes += $ora }
            }
        }
    }

    foreach ($node in @($db_nodes) | Where-Object { $_ }) {

        $cpu = To-FlatString (@($node.hosts.cpuCount))
        if ([string]::IsNullOrWhiteSpace($cpu)) { $cpu = "N/A" }

        $dbhome = To-FlatString (@($node.hosts.sessions.location))
        if ([string]::IsNullOrWhiteSpace($dbhome)) { $dbhome = "N/A" }

        $tdeCount = Get-TdeCount -node $node
        $tdeEnabled = $(if ($tdeCount -gt 0) { "Yes" } else { "No" })
        $dgRole = Get-DataGuardRole -node $node

        $regRows += [PSCustomObject]@{
            Cluster              = $cluster_name
            DBName               = $node.databaseUniqueName
            DBVersion            = $node.version
            ArchiveLog_Enabled   = $node.archivelogEnabled
            BCT_Enabled          = $node.bctEnabled
            TDE_Enabled          = $tdeEnabled
            TDE_EncryptedTsCount = $tdeCount
            DataGuardRole        = $dgRole
            DB_Type              = $node.dbType
            DB_Size_in_GB        = [math]::Round(((($node.size) | ForEach-Object { $_ }) / 1GB), 4)
            DB_Instances         = To-FlatString (@($node.hosts.sessions.systemIdentifier))
            CPU_Count            = $cpu
            DB_Home              = $dbhome
            SharedPool_Size      = $node.sgaTargetSize
            Fragment_Size        = $node.sharedPoolSize
            FRA_Size_in_GB       = [math]::Round(((($node.frasize) | ForEach-Object { $_ }) / 1GB), 4)
        }
    }

    # -------------------------------------------------------------
    # Script 2 ‚Äî protection-groups (Oracle-only filtered in code)
    # -------------------------------------------------------------
    $uri2 = "$baseUrl/v2/data-protect/protection-groups?isDeleted=false&isActive=true&includeLastRunInfo=true"

    $json2 = $null
    try { $json2 = Invoke-HeliosGetJson -Uri $uri2 -Headers $headers } catch {
        Write-Host "‚ö†Ô∏è protection-groups failed: $($_.Exception.Message)" -ForegroundColor Yellow
        continue
    }

    foreach ($pg in @($json2.protectionGroups) | Where-Object { $_ -and $_.oracleParams }) {

        # PolicyName (cached)
        $policyName = ""
        if ($pg.policyId) {
            $pkey = "$cluster_id|$($pg.policyId)"
            if ($script:policyNameCache.ContainsKey($pkey)) {
                $policyName = $script:policyNameCache[$pkey]
            } else {
                try {
                    $pJson = Invoke-HeliosGetJson -Uri "$baseUrl/v2/data-protect/policies?ids=$($pg.policyId)" -Headers $headers
                    $policyName = ($pJson.policies | Where-Object { $_._id -eq $pg.policyId } | Select-Object -ExpandProperty name -First 1)
                } catch { $policyName = "" }
                $script:policyNameCache[$pkey] = $policyName
            }
        }

        $repTo = ""
        try { $repTo = To-FlatString (@($pg.lastRun.replicationInfo.replicationTargetResults.ClusterName)) } catch { $repTo = "" }

        foreach ($obj in @($pg.oracleParams.objects) | Where-Object { $_ }) {

            # channels shape varies (array/object)
            $channels = @()
            try {
                if ($obj.dbParams -and $obj.dbParams.dbChannels) {
                    if ($obj.dbParams.dbChannels.dbChannel) { $channels = @($obj.dbParams.dbChannels.dbChannel) }
                    else { $channels = @($obj.dbParams.dbChannels) }
                }
            } catch { $channels = @() }

            foreach ($ch in @($channels) | Where-Object { $_ }) {

                # DBName = join key
                $dbName = ($ch.databaseUniqueName, $ch.databaseName, $ch.name | Where-Object { $_ -and "$_".Trim() } | Select-Object -First 1)
                if ([string]::IsNullOrWhiteSpace($dbName)) { continue }

                # SourceName fallback
                $sourceName = ($obj.SourceName, $obj.sourceName, $ch.SourceName, $ch.sourceName | Where-Object { $_ -and "$_".Trim() } | Select-Object -First 1)

                # PersistMountPoints
                $pmp = ""
                try { $pmp = To-FlatString (@($pg.oracleParams.persistMountPoints)) } catch { $pmp = "" }

                # LogRetentionDays
                $logRet = ($ch.archiveVolRetentionDays, $ch.logRetentionDays, $ch.logRetentionInDays | Where-Object { $_ -ne $null } | Select-Object -First 1)

                # databaseNodeList shape varies
                $nodeList = $ch.databaseNodeList
                $hostIds  = @()
                if ($nodeList -is [System.Array]) { $hostIds = @($nodeList | ForEach-Object { $_.hostId }) }
                else { $hostIds = @($nodeList.hostId) }
                $hostIds = $hostIds | Where-Object { $_ }

                $hostNames = @()
                foreach ($hid in $hostIds) {
                    $hkey = "$cluster_id|$hid"
                    if ($script:hostNameCache.ContainsKey($hkey)) {
                        if ($script:hostNameCache[$hkey]) { $hostNames += $script:hostNameCache[$hkey] }
                    } else {
                        $hn = ""
                        try {
                            $oJson = Invoke-HeliosGetJson -Uri "$baseUrl/v2/data-protect/objects/$hid" -Headers $headers
                            $hn = Resolve-HostName -nameOrIp $oJson.name
                        } catch { $hn = "" }
                        $script:hostNameCache[$hkey] = $hn
                        if ($hn) { $hostNames += $hn }
                    }
                }
                $hostNameOut = To-FlatString $hostNames

                # ChannelCount / Port
                $chanCount = ($nodeList.ChannelCount, $nodeList.channelCount, $ch.channelCount | Where-Object { $_ -ne $null } | Select-Object -First 1)
                $port      = ($nodeList.port, $ch.port | Where-Object { $_ -ne $null } | Select-Object -First 1)

                $pgRows += [PSCustomObject]@{
                    Cluster               = $cluster_name
                    DBName                = $dbName
                    HostName              = $hostNameOut
                    PGName                = $pg.name
                    Replicated_To_Cluster = $repTo
                    PolicyName            = $policyName
                    SourceName            = $sourceName
                    PersistMountPoints    = $pmp
                    LogRetentionDays      = $logRet
                    ChannelCount          = $chanCount
                    Port                  = $port
                }
            }
        }
    }

    Write-Host ("   regRows={0} | pgRows(add)={1}" -f (@($regRows | Where-Object { $_.Cluster -eq $cluster_name }).Count), (@($pgRows | Where-Object { $_.Cluster -eq $cluster_name }).Count)) -ForegroundColor DarkCyan
}

# =====================================================================
# 3) Join (DBName case-insensitive) ‚Äî allows multiple PG rows per DB
# =====================================================================
$lookup = New-Object System.Collections.Hashtable ([StringComparer]::OrdinalIgnoreCase)
foreach ($r in $pgRows) {
    if (-not $r -or [string]::IsNullOrWhiteSpace($r.DBName)) { continue }
    if (-not $lookup.ContainsKey($r.DBName)) { $lookup[$r.DBName] = @() }
    $lookup[$r.DBName] += $r
}

$final = @()

foreach ($a in $regRows) {

    $matches = @()
    if ($a.DBName -and $lookup.ContainsKey($a.DBName)) { $matches = @($lookup[$a.DBName]) }

    if ($matches.Count -gt 0) {
        foreach ($b in $matches) {
            $final += [PSCustomObject]@{
                Cluster               = $a.Cluster
                DBName                = $a.DBName
                HostName              = $b.HostName
                PGName                = $b.PGName
                Replicated_To_Cluster = $b.Replicated_To_Cluster
                PolicyName            = $b.PolicyName
                SourceName            = $b.SourceName
                PersistMountPoints    = $b.PersistMountPoints
                LogRetentionDays      = $b.LogRetentionDays
                ChannelCount          = $b.ChannelCount
                Port                  = $b.Port

                DBVersion             = $a.DBVersion
                ArchiveLog_Enabled    = $a.ArchiveLog_Enabled
                BCT_Enabled           = $a.BCT_Enabled
                TDE_Enabled           = $a.TDE_Enabled
                TDE_EncryptedTsCount  = $a.TDE_EncryptedTsCount
                DataGuardRole         = $a.DataGuardRole
                DB_Type               = $a.DB_Type
                DB_Size_in_GB         = $a.DB_Size_in_GB
                DB_Instances          = $a.DB_Instances
                CPU_Count             = $a.CPU_Count
                DB_Home               = $a.DB_Home
                SharedPool_Size       = $a.SharedPool_Size
                Fragment_Size         = $a.Fragment_Size
                FRA_Size_in_GB        = $a.FRA_Size_in_GB
            }
        }
    } else {
        $final += [PSCustomObject]@{
            Cluster               = $a.Cluster
            DBName                = $a.DBName
            HostName              = ""
            PGName                = ""
            Replicated_To_Cluster = ""
            PolicyName            = ""
            SourceName            = ""
            PersistMountPoints    = ""
            LogRetentionDays      = ""
            ChannelCount          = ""
            Port                  = ""

            DBVersion             = $a.DBVersion
            ArchiveLog_Enabled    = $a.ArchiveLog_Enabled
            BCT_Enabled           = $a.BCT_Enabled
            TDE_Enabled           = $a.TDE_Enabled
            TDE_EncryptedTsCount  = $a.TDE_EncryptedTsCount
            DataGuardRole         = $a.DataGuardRole
            DB_Type               = $a.DB_Type
            DB_Size_in_GB         = $a.DB_Size_in_GB
            DB_Instances          = $a.DB_Instances
            CPU_Count             = $a.CPU_Count
            DB_Home               = $a.DB_Home
            SharedPool_Size       = $a.SharedPool_Size
            Fragment_Size         = $a.Fragment_Size
            FRA_Size_in_GB        = $a.FRA_Size_in_GB
        }
    }
}

if (-not $final -or $final.Count -eq 0) {
    Write-Host "`n‚úÖ No Oracle DB rows returned. Nothing to export." -ForegroundColor Green
    return
}

# =====================================================================
# 4) Output (console + CSV)
# =====================================================================
$final = $final | Sort-Object Cluster, DBName, PGName

$colsDef = @(
    @{Label='Cluster';               Expression = { $_.Cluster } },
    @{Label='DBName';                Expression = { $_.DBName } },
    @{Label='HostName';              Expression = { $_.HostName } },
    @{Label='PGName';                Expression = { $_.PGName } },
    @{Label='Replicated_To_Cluster'; Expression = { $_.Replicated_To_Cluster } },
    @{Label='PolicyName';            Expression = { $_.PolicyName } },
    @{Label='SourceName';            Expression = { $_.SourceName } },
    @{Label='PersistMountPoints';    Expression = { $_.PersistMountPoints } },
    @{Label='LogRetentionDays';      Expression = { $_.LogRetentionDays } },
    @{Label='ChannelCount';          Expression = { $_.ChannelCount } },
    @{Label='Port';                  Expression = { $_.Port } },
    @{Label='DataGuardRole';         Expression = { $_.DataGuardRole } },
    @{Label='TDE_Enabled';           Expression = { $_.TDE_Enabled } },
    @{Label='TDE_EncryptedTsCount';  Expression = { $_.TDE_EncryptedTsCount } },
    @{Label='DBVersion';             Expression = { $_.DBVersion } },
    @{Label='ArchiveLog_Enabled';    Expression = { $_.ArchiveLog_Enabled } },
    @{Label='BCT_Enabled';           Expression = { $_.BCT_Enabled } },
    @{Label='DB_Type';               Expression = { $_.DB_Type } },
    @{Label='DB_Size_in_GB';         Expression = { $_.DB_Size_in_GB } },
    @{Label='DB_Instances';          Expression = { $_.DB_Instances } },
    @{Label='CPU_Count';             Expression = { $_.CPU_Count } },
    @{Label='DB_Home';               Expression = { $_.DB_Home } },
    @{Label='SharedPool_Size';       Expression = { $_.SharedPool_Size } },
    @{Label='Fragment_Size';         Expression = { $_.Fragment_Size } },
    @{Label='FRA_Size_in_GB';        Expression = { $_.FRA_Size_in_GB } }
)

try {
    $raw = $Host.UI.RawUI
    $raw.BufferSize = New-Object Management.Automation.Host.Size (10000, $raw.BufferSize.Height)
} catch {}

($final | Format-Table -Property $colsDef -AutoSize | Out-String -Width 10000)

$stamp   = Get-Date -Format "yyyy-MM-dd_HHmm"
$csvPath = Join-Path $outDir "oracle_DB_combined_$stamp.csv"

$final |
    Select-Object ($colsDef | ForEach-Object { $_.Label }) |
    Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8

Write-Host "CSV exported: $csvPath" -ForegroundColor Gray
