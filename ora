# 1) Get the DB names from your results (objects, not the formatted text)
$dbNames = $results | Where-Object { $_.DBName } | Select-Object -Expand DBName -Unique

# 2) Call your secondary API once per DB and cache the details
$detailByDb = @{}
foreach ($db in $dbNames) {
    $uri = "$baseUrl/your-endpoint?dbName=$([System.Web.HttpUtility]::UrlEncode($db))"
    $resp = Invoke-WebRequest -Uri $uri -Headers $headers -Method Get -UseBasicParsing
    $j    = $resp.Content | ConvertFrom-Json

    # adapt these fields to your API response
    $detailByDb[$db] = [pscustomobject]@{
        ObjectId   = $j.id
        ServerName = $j.serverName
        Status     = $j.status
    }
}

# 3) Join the details back onto your original rows
$augmented = $results | ForEach-Object {
    $d = $detailByDb[$_.DBName]
    [pscustomobject]@{
        Cluster   = $_.Cluster
        PGName    = $_.PGName
        Source    = $_.SourceName
        DBName    = $_.DBName
        ObjectId  = $d.ObjectId
        Server    = $d.ServerName
        DBStatus  = $d.Status
    }
}

# 4) NOW format for display (or export)
$augmented | Format-Table -AutoSize
# $augmented | Export-Csv .\db_with_details.csv -NoTypeInformation


$host.ipaddress | % { $_ -split '[\s,;{}]+' } | ? { $_ -and $_ -notmatch '^\d{1,3}(?:\.\d{1,3}){3}$' -and $_ -notlike '*:*' } | Select-Object -Unique



# $results : first API (has DBName column among others)
# $apiResults : second API (also has DBName with more details)

$idx = @{}; $apiResults | % { if($_.DBName){ $idx[$_.DBName.ToLower()] = $_ } }

$results | % {
  $k = $_.DBName; if(-not $k){ return }
  $rhs = $idx[$k.ToLower()]
  $h = [ordered]@{}
  $_.psobject.Properties | % { $h[$_.Name] = $_.Value }
  if($rhs){
    $rhs.psobject.Properties | % {
      if($h.Contains($_.Name)){ $h["api_$($_.Name)"] = $_.Value } else { $h[$_.Name] = $_.Value }
    }
  }
  [pscustomobject]$h
} | Format-Table -AutoSize
