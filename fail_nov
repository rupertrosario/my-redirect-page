# Cohesity Helios ‚Äì STRIKE Report (Single Cluster, v2 runs, no tasks dependency)
# ------------------------------------------------------------------------------
# - Reads API key from file
# - Single cluster (set cluster_id + cluster_name)
# - GET-only, no try/catch
# - Uses /v2/data-protect/protection-groups/{id}/runs with:
#     ?numRuns=15&excludeNonRestorableRuns=true&includeObjectDetails=true
# - Does NOT pass runTypes= in URL
# - Extracts per-object Status/Message even when 'latestFinishedTasks' is absent
# - Shows only failures with no later success (Strike logic)
# - Start/End times in EST, format dd/MM/yyyy HH:mm:ss

# =========================
# 0) API Key from your path
# =========================
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$ApiKey = (Get-Content -Path $apikeypath -Raw).Trim()

# Helios requires accessClusterId in the HEADER for on-prem cluster calls
$baseHeaders = @{
    "apiKey" = $ApiKey
    "accept" = "application/json"
}

Write-Host ""
Write-Host "============================================="
Write-Host "üö® Cohesity Helios STRIKE REPORT (Single Cluster)"
Write-Host "============================================="
Write-Host "READ-ONLY MODE ‚Äî GET requests only"
Write-Host ""

# =========================
# 1) Choose your Cluster
# =========================
# Get clusterId via: GET https://helios.cohesity.com/v2/mcm/cluster-mgmt/info
$cluster_id   = "<PASTE-YOUR-CLUSTER-ID-HERE>"
$cluster_name = "<YOUR-CLUSTER-NAME>"

if (-not $cluster_id -or $cluster_id -eq "<PASTE-YOUR-CLUSTER-ID-HERE>") {
    throw "‚ö†Ô∏è Please set your cluster_id before running."
}

$headers = $baseHeaders.Clone()
$headers["accessClusterId"] = $cluster_id

Write-Host "üîç Scanning cluster: $cluster_name ($cluster_id)..."
Write-Host ""

# =========================================================
# 2) Helpers
# =========================================================
function UsecsToEST([long]$usecs){
    if (-not $usecs) { return "-" }
    $estZone = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")
    $utcEpoch = [datetime]"1970-01-01"
    $utcTime = $utcEpoch.AddMilliseconds($usecs / 1000)
    return [System.TimeZoneInfo]::ConvertTimeFromUtc($utcTime, $estZone).ToString("dd/MM/yyyy HH:mm:ss")
}

# Normalize Cohesity status enums to Succeeded/Failed/Other
function Normalize-Status($val){
    if (-not $val) { return $null }
    switch -Regex ($val) {
        '^k?Success(ed)?(WithWarning)?$' { 'Succeeded'; break }
        '^k?Failure$'                    { 'Failed';    break }
        '^Succeeded$'                    { 'Succeeded'; break }
        '^Failed$'                       { 'Failed';    break }
        default                          { $val }
    }
}

# Extract per-object rows from a single protectionRun object,
# even if there is no 'latestFinishedTasks'. We try several common shapes.
function Get-ObjectRowsFromRun($run, $cluster_name, $pgName, $envType){
    $rows = @()

    # Timestamps & run type at the run level
    $startUs = $run.backupRun.base.startTimeUsecs
    $endUs   = $run.backupRun.base.endTimeUsecs
    $runType = ($run.backupRun.base.RunType -replace '^k','')

    # 1) Most common (when present)
    $candidate = $run.backupRun.latestFinishedTasks
    if ($candidate) {
        foreach($t in $candidate){
            $obj  = $t.base.sources[0].source.displayName
            $stat = Normalize-Status $t.base.publicStatus
            $msg  = $t.base.error.errorMsg
            $rows += [pscustomobject]@{
                Cluster         = $cluster_name
                ProtectionGroup = $pgName
                ObjectName      = $obj
                ObjectType      = $envType
                RunType         = $runType
                Status          = $stat
                Message         = $msg
                StartTimeUsecs  = $startUs
                EndTimeUsecs    = $endUs
            }
        }
        return $rows
    }

    # 2) Some payloads expose object details on .objects (when includeObjectDetails=true)
    $candidate = $run.objects
    if ($candidate) {
        foreach($o in $candidate){
            # Try common name fields
            $objName = $o.objectName
            if (-not $objName -and $o.source) { $objName = $o.source.displayName }
            if (-not $objName -and $o.entity) { $objName = $o.entity.displayName }

            # Try various status/error locations
            $stat = $o.status
            if (-not $stat -and $o.localBackupInfo) { $stat = $o.localBackupInfo.status }
            if (-not $stat -and $o.objectStatus)    { $stat = $o.objectStatus }

            $stat = Normalize-Status $stat

            $msg = $o.errorMessage
            if (-not $msg -and $o.error)                 { $msg = $o.error.errorMsg }
            if (-not $msg -and $o.localBackupInfo)       { $msg = $o.localBackupInfo.errorMessage }
            if (-not $msg -and $o.failureMessage)        { $msg = $o.failureMessage }

            $rows += [pscustomobject]@{
                Cluster         = $cluster_name
                ProtectionGroup = $pgName
                ObjectName      = $objName
                ObjectType      = $envType
                RunType         = $runType
                Status          = $stat
                Message         = $msg
                StartTimeUsecs  = $startUs
                EndTimeUsecs    = $endUs
            }
        }
        return $rows
    }

    # 3) Some payloads use different naming for object-level results
    $candidate = $run.objectRuns
    if ($candidate) {
        foreach($o in $candidate){
            $objName = $o.objectName
            if (-not $objName -and $o.entity) { $objName = $o.entity.displayName }

            $stat = Normalize-Status $o.status
            $msg  = $o.errorMessage
            if (-not $msg -and $o.error) { $msg = $o.error.errorMsg }

            $rows += [pscustomobject]@{
                Cluster         = $cluster_name
                ProtectionGroup = $pgName
                ObjectName      = $objName
                ObjectType      = $envType
                RunType         = $runType
                Status          = $stat
                Message         = $msg
                StartTimeUsecs  = $startUs
                EndTimeUsecs    = $endUs
            }
        }
        return $rows
    }

    # If nothing matched, return empty
    return $rows
}

# =========================================================
# 3) Collect strike data
# =========================================================
$AllRows = @()
$numRuns = 15  # few recent runs per PG; adjust as you like

# 3a) List Protection Groups on this cluster
$pgUrl  = "https://helios.cohesity.com/v2/data-protect/protection-groups"
$pgResp = Invoke-WebRequest -Uri $pgUrl -Headers $headers -Method Get -UseBasicParsing
$pgs    = ($pgResp.Content | ConvertFrom-Json).protectionGroups

foreach ($pg in $pgs) {
    $pgName  = $pg.name
    $envType = $pg.environment -replace '^k',''

    # 3b) Fetch runs for this PG (with includeObjectDetails)
    $runsUrl  = "https://helios.cohesity.com/v2/data-protect/protection-groups/$($pg.id)/runs?numRuns=$numRuns&excludeNonRestorableRuns=true&includeObjectDetails=true"
    $runsResp = Invoke-WebRequest -Uri $runsUrl -Headers $headers -Method Get -UseBasicParsing
    $runs     = ($runsResp.Content | ConvertFrom-Json).protectionRuns
    if (-not $runs) { continue }

    # 3c) Flatten per-object entries (robust to different shapes)
    $flat = @()
    foreach ($r in $runs) {
        $flat += Get-ObjectRowsFromRun -run $r -cluster_name $cluster_name -pgName $pgName -envType $envType
    }

    # Filter out entries where we couldn't resolve an object name
    $flat = $flat | Where-Object { $_.ObjectName }

    # 3d) Strike logic per (ObjectName + RunType)
    $keyed = $flat | Group-Object @{Expression = { $_.ObjectName + '||' + $_.RunType }}
    foreach ($k in $keyed) {
        $rowsForKey = $k.Group | Sort-Object EndTimeUsecs -Descending
        if (-not $rowsForKey) { continue }

        # Latest failed instance for this object+runType
        $latestFailed = $rowsForKey | Where-Object { $_.Status -eq 'Failed' } | Select-Object -First 1
        if (-not $latestFailed) { continue }

        # Any later success?
        $hasLaterSuccess = $rowsForKey | Where-Object {
            $_.Status -eq 'Succeeded' -and $_.StartTimeUsecs -gt $latestFailed.EndTimeUsecs
        }

        if (-not $hasLaterSuccess) {
            $AllRows += [pscustomobject]@{
                Cluster         = $latestFailed.Cluster
                ProtectionGroup = $latestFailed.ProtectionGroup
                ObjectName      = $latestFailed.ObjectName
                ObjectType      = $latestFailed.ObjectType
                RunType         = $latestFailed.RunType
                Status          = $latestFailed.Status
                Message         = $latestFailed.Message
                StartTime       = UsecsToEST $latestFailed.StartTimeUsecs
                EndTime         = UsecsToEST $latestFailed.EndTimeUsecs
            }
        }
    }
}

# ==============================
# 4) Print Full Table
# ==============================
if ($AllRows.Count -eq 0) {
    Write-Host "‚úÖ No unrecovered failures found on $cluster_name." -ForegroundColor Green
    return
}

$AllRows | Sort-Object ProtectionGroup,ObjectName,RunType | Format-Table -AutoSize

# =========================================================
# 5) Summary
# =========================================================
Write-Host "`nSummary for Cluster: $cluster_name" -ForegroundColor Green
Write-Host "=========================" -ForegroundColor Green
$pgCount  = ($AllRows.ProtectionGroup | Select-Object -Unique | Measure-Object).Count
$objCount = ($AllRows.ObjectName      | Select-Object -Unique | Measure-Object).Count
Write-Host "  Failed PGs     : $pgCount"
Write-Host "  Failed Objects : $objCount"
Write-Host "----------------------------------------"

# =========================================================
# 6) Export CSV
# =========================================================
$timestamp = (Get-Date).ToString("yyyy-MM-dd_HHmm")
$outfile   = "$PSScriptRoot\Helios_StrikeReport_${cluster_name}_$timestamp.csv"
$AllRows | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $outfile
Write-Host "`nüìÅ CSV saved to: $outfile" -ForegroundColor Yellow
Write-Host "`n‚úÖ Strike Report complete for $cluster_name ‚Äî GET-only, safe." -ForegroundColor Green
