# ---- Config -------------------------------------------------------------------
$apikeypath   = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
$cluster_id   = "<PASTE-YOUR-CLUSTER-ID-HERE>"     # same one you used
$cluster_name = "<YOUR-CLUSTER-NAME>"

if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$ApiKey = (Get-Content -Path $apikeypath -Raw).Trim()

$headers = @{
  "apiKey"          = $ApiKey
  "accessClusterId" = $cluster_id
  "accept"          = "application/json"
}

Write-Host ""
Write-Host "============================================="
Write-Host "üö® Cohesity Strike Report (v1 protectionRuns)"
Write-Host "============================================="
Write-Host "Cluster: $cluster_name"
Write-Host "Mode   : GET-only (no runTypes in URL)"
Write-Host ""

# ---- Helpers ------------------------------------------------------------------
function UsecsToEST([long]$usecs){
  if (-not $usecs) { return "-" }
  $estZone = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")
  $utcEpoch = [datetime]"1970-01-01"
  $utcTime = $utcEpoch.AddMilliseconds($usecs / 1000)
  [System.TimeZoneInfo]::ConvertTimeFromUtc($utcTime, $estZone).ToString("dd/MM/yyyy HH:mm:ss")
}

function Normalize-Status($val){
  if (-not $val) { return $null }
  switch -Regex ($val) {
    '^k?Success(ed)?(WithWarning)?$' { 'Succeeded'; break }
    '^k?Failure$'                    { 'Failed';    break }
    '^Succeeded$'                    { 'Succeeded'; break }
    '^Failed$'                       { 'Failed';    break }
    default                          { $val }
  }
}

# ---- Fetch runs (same call you used) ------------------------------------------
# Tip: you can add query params here if you want (e.g., ?numRuns=50&excludeTasks=true),
# but keeping it exactly like your working call:
$response  = Invoke-WebRequest -Method Get -Uri "https://helios.cohesity.com/irisservices/api/v1/public/protectionRuns" -Headers $headers
$json      = $response.Content | ConvertFrom-Json

# Some tenants wrap in .backupJobRuns; others return an array of runs.
# Your photo showed $json.backupRun in use, so we normalize to $runs list.
$runs = @()
if ($json -is [System.Collections.IEnumerable]) {
  $runs = $json
} elseif ($json.PSObject.Properties.Name -contains 'backupJobRuns') {
  $runs = $json.backupJobRuns
} else {
  $runs = ,$json   # single object
}

# ---- Flatten per-object rows from sourceBackupStatus --------------------------
$flatRuns = @()

foreach ($run in $runs) {
  # v1 payloads commonly expose these under .backupRun
  if (-not $run.backupRun) { continue }

  $runType = $run.backupRun.runType                 # e.g., kRegular / kIncremental / kLog / kFull
  $jobName = $run.jobName
  $srcList = $run.backupRun.sourceBackupStatus

  if (-not $srcList) { continue }

  foreach ($info in $srcList) {
    # Common fields seen in v1
    $status   = Normalize-Status $info.status
    $env      = $info.source.environment
    $objName  = $info.source.name
    $errMsg   = $info.error
    $startUs  = $info.stats.startTimeUsecs
    $endUs    = $info.stats.endTimeUsecs

    # Guard on object name
    if (-not $objName) { continue }

    $flatRuns += [pscustomobject]@{
      Cluster         = $cluster_name
      ProtectionGroup = $jobName
      ObjectName      = $objName
      ObjectType      = $env -replace '^k',''
      RunType         = $runType -replace '^k',''
      Status          = $status
      Message         = $errMsg
      StartTimeUsecs  = $startUs
      EndTimeUsecs    = $endUs
      StartTime       = UsecsToEST $startUs
      EndTime         = UsecsToEST $endUs
    }
  }
}

# ---- Strike logic: (PG + Object + RunType) -> latest Failed w/ no later Success
$strike = @()

# group key keeps failures distinct per PG/object/runType (important for DBs)
$groups = $flatRuns | Group-Object @{Expression = { "$($_.ProtectionGroup)||$($_.ObjectName)||$($_.RunType)" }}

foreach ($g in $groups) {
  $rows = $g.Group | Sort-Object EndTimeUsecs -Descending
  if (-not $rows) { continue }

  $latestFailed = $rows | Where-Object { $_.Status -eq 'Failed' } | Select-Object -First 1
  if (-not $latestFailed) { continue }

  $laterSuccess = $rows | Where-Object {
    $_.Status -eq 'Succeeded' -and $_.StartTimeUsecs -gt $latestFailed.EndTimeUsecs
  }

  if (-not $laterSuccess) {
    $strike += [pscustomobject]@{
      Cluster         = $latestFailed.Cluster
      ProtectionGroup = $latestFailed.ProtectionGroup
      ObjectName      = $latestFailed.ObjectName
      ObjectType      = $latestFailed.ObjectType
      RunType         = $latestFailed.RunType
      Status          = $latestFailed.Status
      StartTime       = $latestFailed.StartTime
      EndTime         = $latestFailed.EndTime
      Message         = $latestFailed.Message
    }
  }
}

# ---- Output -------------------------------------------------------------------
if ($strike.Count -eq 0) {
  Write-Host "‚úÖ No unrecovered failures found." -ForegroundColor Green
  return
}

# Console table
$strike | Sort-Object ProtectionGroup,ObjectName,RunType |
  Format-Table Cluster,ProtectionGroup,ObjectName,ObjectType,RunType,Status,StartTime,EndTime,Message -AutoSize

# Summary
Write-Host "`nSummary for Cluster: $cluster_name" -ForegroundColor Green
Write-Host "=========================" -ForegroundColor Green
$pgCount  = ($strike.ProtectionGroup | Select-Object -Unique | Measure-Object).Count
$objCount = ($strike.ObjectName      | Select-Object -Unique | Measure-Object).Count
Write-Host "  Failed PGs     : $pgCount"
Write-Host "  Failed Objects : $objCount"
Write-Host "----------------------------------------"

# CSV
$timestamp = (Get-Date).ToString("yyyy-MM-dd_HHmm")
$outfile   = "$PSScriptRoot\StrikeReport_${cluster_name}_$timestamp.csv"
$strike | Export-Csv -NoTypeInformation -Encoding UTF8 -Path $outfile
Write-Host "`nüìÅ CSV saved to: $outfile" -ForegroundColor Yellow
