import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alerts (ALL clusters, single API call)
 * 4 Emails Total (kHardware, kSoftware, kDataService, kMaintenance)
 *
 * Each email contains:
 *   - Summary
 *   - Details
 *
 * - NO accessClusterId
 * - NO clusterIdentifiers
 * - Uses alertDocument.alertDescription
 * - Dedupe key: clusterId|alertCode (per bucket)
 * - Date format: YYYY-MM-DD HH:mm:ss (Eastern Time)
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // =============================
  // AUTH
  // =============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available.");

  const headers = { accept: "application/json", apiKey };

  // =============================
  // SETTINGS
  // =============================
  const MAX_ALERTS = 10000;
  const ALERT_STATES = ["kOpen", "kNote"];
  const BUCKETS = ["kHardware", "kSoftware", "kDataService", "kMaintenance"];
  const MAX_TOTAL_DETAIL_ROWS_PER_BUCKET = 1500;

  const EMAIL_PREFIX = "Cohesity Helios — Active Alerts";

  // =============================
  // SYMBOLS
  // =============================
  const SYM_OK = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";
  const SYM_U = "❓";

  // =============================
  // HELPERS
  // =============================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const safeCell = (v) => (v === null || v === undefined ? "" : String(v).replace(/\|/g, " "));
  const cap = (s, n) => {
    const t = norm(s);
    return t.length > n ? t.slice(0, n - 1) + "…" : t;
  };

  function mdTable(headers, rows) {
    if (!rows.length) return "No data.";
    const head = `| ${headers.join(" | ")} |`;
    const sep = `| ${headers.map(() => "---").join(" | ")} |`;
    const body = rows.map((r) => `| ${headers.map((h) => safeCell(r[h] ?? "")).join(" | ")} |`);
    return [head, sep, ...body].join("\n");
  }

  function usecsToEasternDateTime(usecs) {
    if (!usecs) return "";
    const d = new Date(Math.floor(Number(usecs) / 1000));
    return new Intl.DateTimeFormat("en-CA", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    }).format(d).replace(",", "");
  }

  function severityBucket(sev) {
    const s = norm(sev).toLowerCase();
    if (s.includes("critical")) return "C";
    if (s.includes("warning")) return "W";
    if (s.includes("info")) return "I";
    return "U";
  }

  function severitySymbol(b) {
    if (b === "C") return SYM_C;
    if (b === "W") return SYM_W;
    if (b === "I") return SYM_I;
    return SYM_U;
  }

  function extractAlerts(payload) {
    return toArray(
      payload?.alerts ||
      payload?.alertsList?.alerts ||
      payload?.alertsList ||
      payload?.alertList ||
      payload
    ).filter((x) => x && typeof x === "object");
  }

  function bucketOf(a) { return norm(a?.alertTypeBucket); }
  function categoryOf(a) { return norm(a?.alertCategory) || "Unknown"; }
  function clusterIdOf(a) { return norm(a?.clusterId); }
  function clusterNameOf(a) { return norm(a?.clusterName) || "UnknownCluster"; }
  function alertCodeOf(a) { return norm(a?.alertCode); }
  function alertDescOf(a) { return norm(a?.alertDocument?.alertDescription); }

  function cellSymbols(C, W, I) {
    if (!C && !W && !I) return SYM_OK;
    const parts = [];
    if (C) parts.push(`${SYM_C}${C}`);
    if (W) parts.push(`${SYM_W}${W}`);
    if (I) parts.push(`${SYM_I}${I}`);
    return parts.join(" ");
  }

  function dedupeLatest(alerts) {
    const m = new Map();
    for (const a of alerts) {
      const key = `${clusterIdOf(a)}|${alertCodeOf(a)}`;
      const latest = Number(a?.latestTimestampUsecs || 0);
      const occ = Number(a?.dedupCount || 1);

      const prev = m.get(key);
      if (!prev) {
        m.set(key, { alert: a, latest, occ });
      } else {
        prev.occ += occ;
        if (latest >= prev.latest) {
          prev.latest = latest;
          prev.alert = a;
        }
      }
    }
    return Array.from(m.values()).sort((x, y) => y.latest - x.latest);
  }

  // =============================
  // FETCH ALL ALERTS
  // =============================
  const params = new URLSearchParams();
  params.set("maxAlerts", String(MAX_ALERTS));
  params.set("alertStateList", ALERT_STATES.join(","));

  const resp = await fetch(`${baseUrl}/v2/mcm/alerts?${params.toString()}`, { method: "GET", headers });
  if (!resp.ok) throw new Error(`Alerts fetch failed: ${resp.status}`);

  const payload = await resp.json();
  const allAlerts = extractAlerts(payload);
  const filtered = allAlerts.filter(a => BUCKETS.includes(bucketOf(a)));

  const clusterMap = new Map();
  for (const a of filtered) {
    const cid = clusterIdOf(a);
    const cn = clusterNameOf(a);
    if (cid) clusterMap.set(cid, cn);
  }

  const clusters = Array.from(clusterMap.entries())
    .map(([clusterId, clusterName]) => ({ clusterId, clusterName }))
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  const alertsByBucket = new Map();
  for (const b of BUCKETS) alertsByBucket.set(b, []);
  for (const a of filtered) alertsByBucket.get(bucketOf(a)).push(a);

  const utcDate = new Date().toISOString().slice(0, 10);

  function renderBucket(bucket) {
    const deduped = dedupeLatest(alertsByBucket.get(bucket));
    const categories = [...new Set(deduped.map(u => categoryOf(u.alert)))].sort();

    const header =
      `### Cohesity Helios — Active Alerts — ${bucket}\n\n` +
      `Unique: Latest per cluster and alertCode\n` +
      `Scope: Current active alerts (kOpen, kNote)\n`;

    // Summary
    const summaryRows = [];
    for (const cl of clusters) {
      const row = { Cluster: cl.clusterName };
      const counts = {};
      for (const cat of categories) counts[cat] = { C:0, W:0, I:0 };

      for (const u of deduped) {
        const a = u.alert;
        if (clusterIdOf(a) !== cl.clusterId) continue;
        const cat = categoryOf(a);
        const sev = severityBucket(a?.severity);
        if (counts[cat] && counts[cat][sev] !== undefined) counts[cat][sev]++;
      }

      for (const cat of categories) {
        const c = counts[cat] || { C:0, W:0, I:0 };
        row[cat] = cellSymbols(c.C, c.W, c.I);
      }

      summaryRows.push(row);
    }

    const summary =
      `**Summary**\n\n` +
      mdTable(["Cluster", ...categories], summaryRows);

    // Details (big consolidated table)
    const detailRows = [];
    let total = 0;

    for (const cl of clusters) {
      const clusterAlerts = deduped.filter(u => clusterIdOf(u.alert) === cl.clusterId);
      for (const u of clusterAlerts) {
        if (total >= MAX_TOTAL_DETAIL_ROWS_PER_BUCKET) break;
        const a = u.alert;
        const sevB = severityBucket(a?.severity);

        detailRows.push({
          Cluster: cl.clusterName,
          Sev: `${severitySymbol(sevB)} ${norm(a?.severity)}`,
          alertCategory: categoryOf(a),
          alertCode: alertCodeOf(a),
          alertState: norm(a?.alertState),
          latestSeen: usecsToEasternDateTime(a?.latestTimestampUsecs),
          occurrences: String(u.occ),
          alertDescription: cap(alertDescOf(a), 220)
        });

        total++;
      }
    }

    const details =
      `**Details**\n\n` +
      mdTable(
        ["Cluster","Sev","alertCategory","alertCode","alertState","latestSeen","occurrences","alertDescription"],
        detailRows
      );

    return [header, summary, "", details].join("\n\n");
  }

  return {
    kHardwareSubject: `${EMAIL_PREFIX} — kHardware — ${utcDate}`,
    kHardwareMarkdown: renderBucket("kHardware"),

    kSoftwareSubject: `${EMAIL_PREFIX} — kSoftware — ${utcDate}`,
    kSoftwareMarkdown: renderBucket("kSoftware"),

    kDataServiceSubject: `${EMAIL_PREFIX} — kDataService — ${utcDate}`,
    kDataServiceMarkdown: renderBucket("kDataService"),

    kMaintenanceSubject: `${EMAIL_PREFIX} — kMaintenance — ${utcDate}`,
    kMaintenanceMarkdown: renderBucket("kMaintenance"),
  };
}
