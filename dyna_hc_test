import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Cluster Health Tiles — Email-safe Markdown (GET-only)
 * Source: GET /v2/mcm/alerts (single call)
 *
 * Noise reduction (your requirement):
 * - DEDUPE per cluster per alertCode (key = clusterId|alertCode)
 * - Ignore id/dedupCount
 *
 * Notes:
 * - No /cluster-mgmt/info (clusters with no alerts won't appear => cannot show ✅ rows)
 * - No maxAlerts param (API default cap still applies)
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // AUTH (vault id)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // CATEGORY ENUMS (sorted)
  // ==============================
  const HW_Cats = [
    "kDisk","kNode","kCluster","kChassis","kPowerSupply","kCPU","kMemory","kTemperature",
    "kFan","kNIC","kFirmware","kNodeHealth","kOperatingSystem","kStorageDevice","kStoragePool"
  ].sort();

  const MAINT_Cats = [
    "kHelios","kAppMarketPlace","kSystemService","kLicense","kSecurity","kUpgrade",
    "kClusterManagement","kAuditLog","kNetworking","kConfiguration","kStorageUsage",
    "kFaultTolerance","kGeneralSoftwareFailure"
  ].sort();

  const DS_Cats = [
    "kDataPath","kDataSourceConnector","kMetadata","kIndexing","kBackupRestore","kArchivalRestore",
    "kRemoteReplication","kQuota","kCDP","kViewFailover","kDisasterRecovery","kAgent","kNetBackup"
  ].sort();

  // ==============================
  // SYMBOLS
  // ==============================
  const SYM_OK = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";

  // ==============================
  // HELPERS
  // ==============================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const safeCell = (v) => (v === null || v === undefined ? "" : String(v).replace(/\|/g, " "));

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`.trim());
    }
    return resp.json();
  }

  function mdTable(headers, rows) {
    if (!rows.length) return "No clusters returned.";
    const head = `| ${headers.join(" | ")} |`;
    const sep = `| ${headers.map(() => "---").join(" | ")} |`;
    const body = rows.map((r) => `| ${headers.map((h) => safeCell(r[h] ?? "")).join(" | ")} |`);
    return [head, sep, ...body].join("\n");
  }

  function cellFromCounts(c, w, i) {
    const cc = Number(c || 0);
    const ww = Number(w || 0);
    const ii = Number(i || 0);
    if (cc === 0 && ww === 0 && ii === 0) return SYM_OK;
    return `${SYM_C}${cc} ${SYM_W}${ww} ${SYM_I}${ii}`;
  }

  // bucket -> clusterName -> category -> {c,w,i}
  const store = new Map();
  function ensure(bucket, clusterName, category) {
    if (!store.has(bucket)) store.set(bucket, new Map());
    const b = store.get(bucket);
    if (!b.has(clusterName)) b.set(clusterName, new Map());
    const c = b.get(clusterName);
    if (!c.has(category)) c.set(category, { c: 0, w: 0, i: 0 });
    return c.get(category);
  }

  // ==============================
  // 1) Fetch alerts (single global call, no maxAlerts)
  // ==============================
  function buildAlertsUrl() {
    const u = new URL(`${baseUrl}/v2/mcm/alerts`);
    ["kOpen", "kNote"].forEach((s) => u.searchParams.append("alertStateList", s));
    ["kHardware", "kMaintenance", "kDataService"].forEach((b) => u.searchParams.append("alertTypeBucketList", b));
    return u.toString();
  }

  const payload = await getJson(buildAlertsUrl(), commonHeaders);
  const alerts = toArray(payload?.alertsList);

  // ==============================
  // 2) Dedupe per clusterId|alertCode (NOT alertCode-only)
  // ==============================
  const seen = new Set();

  for (const a of alerts) {
    const state = norm(a?.alertState);
    if (state !== "kOpen" && state !== "kNote") continue;

    const clusterId = String(a?.clusterId ?? "");
    const code = norm(a?.alertCode);
    if (!clusterId || !code) continue;

    const dedupeKey = `${clusterId}|${code}`;
    if (seen.has(dedupeKey)) continue;
    seen.add(dedupeKey);

    const bucket = norm(a?.alertTypeBucket);
    const category = norm(a?.alertCategory);
    const severity = norm(a?.severity);

    // clusterName is in payload; fallback to clusterId
    const clusterName = norm(a?.clusterName) || clusterId;

    if (!bucket || !category || !clusterName) continue;
    if (bucket !== "kHardware" && bucket !== "kMaintenance" && bucket !== "kDataService") continue;

    const cell = ensure(bucket, clusterName, category);
    if (severity === "kCritical") cell.c += 1;
    else if (severity === "kWarning") cell.w += 1;
    else if (severity === "kInfo") cell.i += 1;
  }

  // ==============================
  // 3) Build section tables (clusters with alerts only)
  // ==============================
  function buildSection(bucket, cats) {
    const b = store.get(bucket) || new Map();
    const clusterNames = Array.from(b.keys()).sort((x, y) => x.localeCompare(y));

    const rows = [];
    for (const name of clusterNames) {
      const row = { ClusterName: name };
      const catMap = b.get(name) || new Map();
      for (const cat of cats) {
        const v = catMap.get(cat) || { c: 0, w: 0, i: 0 };
        row[cat] = cellFromCounts(v.c, v.w, v.i);
      }
      rows.push(row);
    }
    return mdTable(["ClusterName", ...cats], rows);
  }

  // ==============================
  // 4) NOTE / HEADER (exact wording)
  // ==============================
  const note = [
    "### Cohesity Hardware Health Check",
    "This report mimics the System → Health → Components view for each Cohesity cluster.",
    "**Legend:** ✅ Healthy | ⛔<N> Critical | ⚠️<N> Warning | ℹ️<N> Info | ⚠️NO_DATA Unreachable",
  ].join("\n\n");

  // ==============================
  // 5) MARKDOWN SECTIONS
  // ==============================
  const markdownHardware = `\n**Hardware**\n${buildSection("kHardware", HW_Cats)}`;
  const markdownMaintenance = `\n**Maintenance**\n${buildSection("kMaintenance", MAINT_Cats)}`;
  const markdownDataService = `\n**Data Service**\n${buildSection("kDataService", DS_Cats)}`;

  const markdown = [note, markdownHardware, markdownMaintenance, markdownDataService].join("\n\n");

  return {
    note,
    markdownHardware,
    markdownMaintenance,
    markdownDataService,
    markdown,
    // Optional quick debug (remove later):
    debug_alertsReturned: alerts.length,
    debug_uniqueClusterAlertCodes: seen.size,
  };
}
