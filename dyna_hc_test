import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Health Tiles — Email-safe Markdown (GET-only)
 *
 * Source (single call):
 *   - GET https://helios.cohesity.com/v2/mcm/alerts
 *
 * Logic (your requirement):
 * - Fetch alerts once.
 * - For EACH cluster, for EACH bucket (Hardware/Maintenance/DataService), for EACH category+severity:
 *     count UNIQUE alertCode values (dedupe key = clusterId|bucket|category|severity|alertCode)
 * - Cell output:
 *     ✅ if no unique codes
 *     else ⛔<N> ⚠️<N> ℹ️<N> (N = unique alertCodes)
 *
 * IMPORTANT LIMITATION (because we do NOT call cluster-mgmt/info):
 * - Clusters with zero active alerts (kOpen/kNote) will not appear at all.
 * - “⚠️NO_DATA Unreachable” cannot be determined without a cluster baseline endpoint.
 *
 * Returns:
 *  - note
 *  - markdownHardware
 *  - markdownMaintenance
 *  - markdownDataService
 *  - markdown
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // AUTH (vault id)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // CATEGORY ENUMS (sorted)
  // ==============================
  const HW_Cats = [
    "kDisk","kNode","kCluster","kChassis","kPowerSupply","kCPU","kMemory","kTemperature",
    "kFan","kNIC","kFirmware","kNodeHealth","kOperatingSystem","kStorageDevice","kStoragePool"
  ].sort();

  const MAINT_Cats = [
    "kHelios","kAppMarketPlace","kSystemService","kLicense","kSecurity","kUpgrade",
    "kClusterManagement","kAuditLog","kNetworking","kConfiguration","kStorageUsage",
    "kFaultTolerance","kGeneralSoftwareFailure"
  ].sort();

  const DS_Cats = [
    "kDataPath","kDataSourceConnector","kMetadata","kIndexing","kBackupRestore","kArchivalRestore",
    "kRemoteReplication","kQuota","kCDP","kViewFailover","kDisasterRecovery","kAgent","kNetBackup"
  ].sort();

  const BUCKETS = [
    { key: "kHardware", label: "Hardware", cats: HW_Cats },
    { key: "kMaintenance", label: "Maintenance", cats: MAINT_Cats },
    { key: "kDataService", label: "Data Service", cats: DS_Cats }
  ];

  // ==============================
  // SYMBOLS
  // ==============================
  const SYM_OK = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";

  // ==============================
  // HELPERS
  // ==============================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const safeCell = (v) => (v === null || v === undefined ? "" : String(v).replace(/\|/g, " "));

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const e = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`.trim());
      e.status = resp.status;
      e.body = txt;
      throw e;
    }
    return resp.json();
  }

  function mdTable(headers, rows) {
    if (!rows.length) return "No clusters returned.";
    const head = `| ${headers.join(" | ")} |`;
    const sep = `| ${headers.map(() => "---").join(" | ")} |`;
    const body = rows.map((r) => `| ${headers.map((h) => safeCell(r[h] ?? "")).join(" | ")} |`);
    return [head, sep, ...body].join("\n");
  }

  function cellFromSets(setC, setW, setI) {
    const c = setC ? setC.size : 0;
    const w = setW ? setW.size : 0;
    const i = setI ? setI.size : 0;
    if (c === 0 && w === 0 && i === 0) return SYM_OK;
    return `${SYM_C}${c} ${SYM_W}${w} ${SYM_I}${i}`;
  }

  // store[bucketKey][clusterName][category] = { C:Set, W:Set, I:Set }
  const store = new Map();

  function ensureCell(bucketKey, clusterName, category) {
    if (!store.has(bucketKey)) store.set(bucketKey, new Map());
    const b = store.get(bucketKey);
    if (!b.has(clusterName)) b.set(clusterName, new Map());
    const c = b.get(clusterName);
    if (!c.has(category)) c.set(category, { C: new Set(), W: new Set(), I: new Set() });
    return c.get(category);
  }

  // ==============================
  // 1) Fetch alerts (single global call; no maxAlerts; no time window)
  // ==============================
  function buildAlertsUrl() {
    const u = new URL(`${baseUrl}/v2/mcm/alerts`);

    // array params => repeated params
    ["kOpen", "kNote"].forEach((s) => u.searchParams.append("alertStateList", s));
    ["kHardware", "kMaintenance", "kDataService"].forEach((b) => u.searchParams.append("alertTypeBucketList", b));

    return u.toString();
  }

  const payload = await getJson(buildAlertsUrl(), commonHeaders);
  const alerts = toArray(payload?.alertsList);

  // ==============================
  // 2) Per-cluster dedupe on alertCode (scoped properly)
  //    key = clusterId|bucket|category|severity|alertCode
  // ==============================
  const seen = new Set();

  // quick lookup for valid categories per bucket
  const catsByBucket = new Map(BUCKETS.map((b) => [b.key, new Set(b.cats)]));

  for (const a of alerts) {
    const state = norm(a?.alertState);
    if (state !== "kOpen" && state !== "kNote") continue;

    const clusterId = String(a?.clusterId ?? "");
    const clusterName = norm(a?.clusterName) || clusterId;

    const bucket = norm(a?.alertTypeBucket);
    const category = norm(a?.alertCategory);
    const severity = norm(a?.severity);
    const code = norm(a?.alertCode);

    if (!clusterId || !clusterName || !bucket || !category || !severity || !code) continue;
    if (!catsByBucket.has(bucket)) continue;
    if (!catsByBucket.get(bucket).has(category)) continue;
    if (severity !== "kCritical" && severity !== "kWarning" && severity !== "kInfo") continue;

    const dedupeKey = `${clusterId}|${bucket}|${category}|${severity}|${code}`;
    if (seen.has(dedupeKey)) continue;
    seen.add(dedupeKey);

    const cell = ensureCell(bucket, clusterName, category);
    if (severity === "kCritical") cell.C.add(code);
    else if (severity === "kWarning") cell.W.add(code);
    else cell.I.add(code);
  }

  // ==============================
  // 3) Build section tables
  // ==============================
  function buildSection(bucketKey, cats) {
    const b = store.get(bucketKey) || new Map();
    const clusterNames = Array.from(b.keys()).sort((x, y) => x.localeCompare(y));

    const rows = [];
    for (const name of clusterNames) {
      const row = { ClusterName: name };
      const catMap = b.get(name) || new Map();

      for (const cat of cats) {
        const v = catMap.get(cat) || { C: new Set(), W: new Set(), I: new Set() };
        row[cat] = cellFromSets(v.C, v.W, v.I);
      }
      rows.push(row);
    }

    return mdTable(["ClusterName", ...cats], rows);
  }

  // ==============================
  // 4) NOTE / HEADER (exact wording)
  // ==============================
  const note =
    `### Cohesity Hardware Health Check\n\n` +
    `This report mimics the System → Health → Components view for each Cohesity cluster.\n\n` +
    `**Legend:** ✅ Healthy | ⛔<N> Critical | ⚠️<N> Warning | ℹ️<N> Info | ⚠️NO_DATA Unreachable\n`;

  // ==============================
  // 5) MARKDOWN SECTIONS (independent)
  // ==============================
  const markdownHardware = `\n**Hardware**\n${buildSection("kHardware", HW_Cats)}`;
  const markdownMaintenance = `\n**Maintenance**\n${buildSection("kMaintenance", MAINT_Cats)}`;
  const markdownDataService = `\n**Data Service**\n${buildSection("kDataService", DS_Cats)}`;

  const markdown = [note, markdownHardware, markdownMaintenance, markdownDataService].join("\n\n");

  return {
    note,
    markdownHardware,
    markdownMaintenance,
    markdownDataService,
    markdown,
    // minimal debug to verify behavior
    debug_alertsReturned: alerts.length,
    debug_uniqueKeys: seen.size
  };
}
