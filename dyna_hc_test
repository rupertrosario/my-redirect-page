import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alerts (ALL clusters, single API call)
 * 4 Emails Total (kHardware, kSoftware, kDataService, kMaintenance)
 * Each email contains:
 *   1) Summary (Cluster × alertCategory)
 *   2) Details (latest per clusterId|alertCode)
 *
 * - NO accessClusterId
 * - NO clusterIdentifiers
 * - Uses alertDocument.alertDescription
 * - Dedupe key: clusterId|alertCode (per bucket)
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // =============================
  // AUTH
  // =============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available.");

  const headers = { accept: "application/json", apiKey };

  // =============================
  // SETTINGS
  // =============================
  const MAX_ALERTS = 10000;
  const ALERT_STATES = ["kOpen", "kNote"];
  const BUCKETS = ["kHardware", "kSoftware", "kDataService", "kMaintenance"];

  const MAX_DETAIL_ROWS_PER_CLUSTER = 50;
  const MAX_TOTAL_DETAIL_ROWS_PER_BUCKET = 1500;

  const EMAIL_PREFIX = "Cohesity Helios — Active Alerts (Unique)";

  // =============================
  // HELPERS
  // =============================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const safeCell = (v) => (v === null || v === undefined ? "" : String(v).replace(/\|/g, " "));
  const cap = (s, n) => {
    const t = norm(s);
    return t.length > n ? t.slice(0, n - 1) + "…" : t;
  };

  function mdTable(headers, rows) {
    if (!rows.length) return "No data.";
    const head = `| ${headers.join(" | ")} |`;
    const sep = `| ${headers.map(() => "---").join(" | ")} |`;
    const body = rows.map((r) => `| ${headers.map((h) => safeCell(r[h] ?? "")).join(" | ")} |`);
    return [head, sep, ...body].join("\n");
  }

  function usecsToUtc(usecs) {
    const u = Number(usecs || 0);
    if (!u) return "";
    const d = new Date(Math.floor(u / 1000));
    return d.toISOString().replace("T", " ").replace(".000Z", "Z");
  }

  function severityBucket(sev) {
    const s = norm(sev).toLowerCase();
    if (s.includes("critical")) return "C";
    if (s.includes("warning")) return "W";
    if (s.includes("info")) return "I";
    return "U";
  }

  function severitySymbol(b) {
    if (b === "C") return "⛔";
    if (b === "W") return "⚠️";
    if (b === "I") return "ℹ️";
    return "❓";
  }

  function extractAlerts(payload) {
    return toArray(
      payload?.alerts ||
      payload?.alertsList?.alerts ||
      payload?.alertsList ||
      payload?.alertList ||
      payload
    ).filter((x) => x && typeof x === "object");
  }

  function bucketOf(a) { return norm(a?.alertTypeBucket); }
  function categoryOf(a) { return norm(a?.alertCategory); }
  function clusterIdOf(a) { return norm(a?.clusterId); }
  function clusterNameOf(a) { return norm(a?.clusterName); }
  function alertCodeOf(a) { return norm(a?.alertCode); }
  function alertDescriptionOf(a) { return norm(a?.alertDocument?.alertDescription); }

  // =============================
  // FETCH ALL ALERTS (ONE CALL)
  // =============================
  const params = new URLSearchParams();
  params.set("maxAlerts", String(MAX_ALERTS));
  params.set("alertStateList", ALERT_STATES.join(","));

  const resp = await fetch(`${baseUrl}/v2/mcm/alerts?${params.toString()}`, { method: "GET", headers });
  if (!resp.ok) throw new Error(`Alerts fetch failed: ${resp.status}`);

  const payload = await resp.json();
  const allAlerts = extractAlerts(payload);
  const filtered = allAlerts.filter(a => BUCKETS.includes(bucketOf(a)));

  // =============================
  // BUILD CLUSTER LIST
  // =============================
  const clusterMap = new Map();
  for (const a of filtered) {
    const cid = clusterIdOf(a);
    const cn = clusterNameOf(a);
    if (cid) clusterMap.set(cid, cn);
  }

  const clusters = Array.from(clusterMap.entries())
    .map(([clusterId, clusterName]) => ({ clusterId, clusterName }))
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  // =============================
  // GROUP BY BUCKET + DEDUPE
  // =============================
  const bucketData = new Map();
  const categoriesByBucket = new Map();

  for (const b of BUCKETS) {
    bucketData.set(b, []);
    categoriesByBucket.set(b, new Set());
  }

  for (const a of filtered) {
    bucketData.get(bucketOf(a)).push(a);
  }

  function dedupeLatest(alerts) {
    const m = new Map();
    for (const a of alerts) {
      const key = `${clusterIdOf(a)}|${alertCodeOf(a)}`;
      const latest = Number(a?.latestTimestampUsecs || 0);
      const occ = Number(a?.dedupCount || 1);

      const prev = m.get(key);
      if (!prev) {
        m.set(key, { alert: a, latest, occ });
      } else {
        prev.occ += occ;
        if (latest >= prev.latest) {
          prev.latest = latest;
          prev.alert = a;
        }
      }
    }
    return Array.from(m.values())
      .sort((x, y) => y.latest - x.latest);
  }

  const dedupedByBucket = new Map();

  for (const b of BUCKETS) {
    const deduped = dedupeLatest(bucketData.get(b));
    dedupedByBucket.set(b, deduped);
    for (const u of deduped) {
      categoriesByBucket.get(b).add(categoryOf(u.alert));
    }
  }

  // =============================
  // RENDER BUCKET
  // =============================
  function renderBucket(bucket) {
    const deduped = dedupedByBucket.get(bucket);
    const categories = Array.from(categoriesByBucket.get(bucket)).sort();

    const header =
      `### Cohesity Helios — Active Alerts — ${bucket}\n\n` +
      `States: ${ALERT_STATES.join(", ")} | Unique per (clusterId|alertCode)\n`;

    // SUMMARY
    const summaryRows = [];
    for (const cl of clusters) {
      const row = { Cluster: cl.clusterName };
      const counts = {};

      for (const cat of categories) counts[cat] = { C: 0, W: 0, I: 0 };

      for (const u of deduped) {
        const a = u.alert;
        if (clusterIdOf(a) !== cl.clusterId) continue;
        const cat = categoryOf(a);
        const sev = severityBucket(a?.severity);
        if (counts[cat] && counts[cat][sev] !== undefined) counts[cat][sev]++;
      }

      for (const cat of categories) {
        const c = counts[cat] || { C: 0, W: 0, I: 0 };
        row[cat] = (!c.C && !c.W && !c.I) ? "✅" : `${c.C}C/${c.W}W/${c.I}I`;
      }

      summaryRows.push(row);
    }

    const summary =
      `**Summary (Cluster × alertCategory)**\n\n` +
      mdTable(["Cluster", ...categories], summaryRows);

    // DETAILS
    const detailParts = [];
    let totalRows = 0;

    for (let i = 0; i < clusters.length; i++) {
      const cl = clusters[i];
      const clusterAlerts = deduped.filter(u => clusterIdOf(u.alert) === cl.clusterId);

      if (!clusterAlerts.length) {
        detailParts.push(`**${i + 1}. ${cl.clusterName}**\n\n✅ No alerts.\n`);
        continue;
      }

      const rows = [];
      for (const u of clusterAlerts) {
        if (totalRows >= MAX_TOTAL_DETAIL_ROWS_PER_BUCKET) break;

        const a = u.alert;
        const sevB = severityBucket(a?.severity);

        rows.push({
          Sev: `${severitySymbol(sevB)} ${norm(a?.severity)}`,
          alertCategory: categoryOf(a),
          alertCode: alertCodeOf(a),
          alertState: norm(a?.alertState),
          latestSeenUtc: usecsToUtc(a?.latestTimestampUsecs),
          occurrences: String(u.occ),
          alertDescription: cap(alertDescriptionOf(a), 220)
        });

        totalRows++;
      }

      detailParts.push(
        `**${i + 1}. ${cl.clusterName}**\n\n` +
        mdTable(
          ["Sev","alertCategory","alertCode","alertState","latestSeenUtc","occurrences","alertDescription"],
          rows
        ) +
        "\n"
      );
    }

    const details = `**Details (latest per alertCode)**\n\n${detailParts.join("\n")}`;

    return [header, summary, details].join("\n\n");
  }

  // =============================
  // RETURN 4 EMAILS
  // =============================
  const utcDate = new Date().toISOString().slice(0, 10);

  return {
    kHardwareSubject: `${EMAIL_PREFIX} — kHardware — ${utcDate}`,
    kHardwareMarkdown: renderBucket("kHardware"),

    kSoftwareSubject: `${EMAIL_PREFIX} — kSoftware — ${utcDate}`,
    kSoftwareMarkdown: renderBucket("kSoftware"),

    kDataServiceSubject: `${EMAIL_PREFIX} — kDataService — ${utcDate}`,
    kDataServiceMarkdown: renderBucket("kDataService"),

    kMaintenanceSubject: `${EMAIL_PREFIX} — kMaintenance — ${utcDate}`,
    kMaintenanceMarkdown: renderBucket("kMaintenance")
  };
}
