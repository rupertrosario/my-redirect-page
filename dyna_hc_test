import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alerts (ALL clusters, single API call)
 * 4 Emails Total (kHardware, kSoftware, kDataService, kMaintenance)
 *
 * Each email contains:
 *   1) Summary (Cluster × alertCategory) with SYMBOL cells
 *   2) Details (ONE big table) with Cluster as first column (latest per clusterId|alertCode)
 *
 * - NO accessClusterId
 * - NO clusterIdentifiers
 * - Uses alertDocument.alertDescription
 * - Dedupe key: clusterId|alertCode (per bucket)
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // =============================
  // AUTH
  // =============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available.");

  const headers = { accept: "application/json", apiKey };

  // =============================
  // SETTINGS
  // =============================
  const MAX_ALERTS = 10000;
  const ALERT_STATES = ["kOpen", "kNote"];
  const BUCKETS = ["kHardware", "kSoftware", "kDataService", "kMaintenance"];

  // email safety
  const MAX_TOTAL_DETAIL_ROWS_PER_BUCKET = 1500;

  const EMAIL_PREFIX = "Cohesity Helios — Active Alerts (Unique)";

  // =============================
  // SYMBOLS
  // =============================
  const SYM_OK = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";
  const SYM_U = "❓";

  // =============================
  // HELPERS
  // =============================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const safeCell = (v) => (v === null || v === undefined ? "" : String(v).replace(/\|/g, " "));
  const cap = (s, n) => {
    const t = norm(s);
    return t.length > n ? t.slice(0, n - 1) + "…" : t;
  };

  function mdTable(headers, rows) {
    if (!rows.length) return "No data.";
    const head = `| ${headers.join(" | ")} |`;
    const sep = `| ${headers.map(() => "---").join(" | ")} |`;
    const body = rows.map((r) => `| ${headers.map((h) => safeCell(r[h] ?? "")).join(" | ")} |`);
    return [head, sep, ...body].join("\n");
  }

  function usecsToUtc(usecs) {
    const u = Number(usecs || 0);
    if (!u) return "";
    const d = new Date(Math.floor(u / 1000));
    return d.toISOString().replace("T", " ").replace(".000Z", "Z");
  }

  function severityBucket(sev) {
    const s = norm(sev).toLowerCase();
    if (s.includes("critical") || s === "kcritical") return "C";
    if (s.includes("warning") || s === "kwarning") return "W";
    if (s.includes("info") || s === "kinfo" || s.includes("informational")) return "I";
    return "U";
  }

  function symForSevBucket(b) {
    if (b === "C") return SYM_C;
    if (b === "W") return SYM_W;
    if (b === "I") return SYM_I;
    return SYM_U;
  }

  function extractAlerts(payload) {
    return toArray(
      payload?.alerts ||
        payload?.alertsList?.alerts ||
        payload?.alertsList ||
        payload?.alertList ||
        payload
    ).filter((x) => x && typeof x === "object");
  }

  function bucketOf(a) {
    return norm(a?.alertTypeBucket);
  }
  function categoryOf(a) {
    return norm(a?.alertCategory) || "Unknown";
  }
  function clusterIdOf(a) {
    return norm(a?.clusterId);
  }
  function clusterNameOf(a) {
    return norm(a?.clusterName) || "UnknownCluster";
  }
  function alertCodeOf(a) {
    return norm(a?.alertCode);
  }
  function alertDescOf(a) {
    return norm(a?.alertDocument?.alertDescription);
  }

  // SUMMARY cell: render symbols only
  // ✅ none, else "⛔x ⚠️y ℹ️z" (omit zero parts)
  function cellSymbols(C, W, I) {
    if (!C && !W && !I) return SYM_OK;
    const parts = [];
    if (C) parts.push(`${SYM_C}${C}`);
    if (W) parts.push(`${SYM_W}${W}`);
    if (I) parts.push(`${SYM_I}${I}`);
    return parts.join(" ");
  }

  // Dedupe: latest per (clusterId|alertCode) within a bucket; sum dedupCount
  function dedupeLatest(alerts) {
    const m = new Map();
    for (const a of alerts) {
      const cid = clusterIdOf(a);
      const code = alertCodeOf(a);
      if (!cid || !code) continue;

      const key = `${cid}|${code}`;
      const latest = Number(a?.latestTimestampUsecs || 0);
      const occ = Number(a?.dedupCount || 1);

      const prev = m.get(key);
      if (!prev) {
        m.set(key, { alert: a, latest, occ });
      } else {
        prev.occ += occ;
        if (latest >= prev.latest) {
          prev.latest = latest;
          prev.alert = a;
        }
      }
    }
    return Array.from(m.values()).sort((x, y) => y.latest - x.latest);
  }

  // =============================
  // FETCH ALL ALERTS (ONE CALL)
  // =============================
  const params = new URLSearchParams();
  params.set("maxAlerts", String(MAX_ALERTS));
  params.set("alertStateList", ALERT_STATES.join(","));

  const resp = await fetch(`${baseUrl}/v2/mcm/alerts?${params.toString()}`, { method: "GET", headers });
  if (!resp.ok) throw new Error(`Alerts fetch failed: ${resp.status}`);

  const payload = await resp.json();
  const allAlerts = extractAlerts(payload);
  const filtered = allAlerts.filter((a) => BUCKETS.includes(bucketOf(a)));

  // Build stable cluster list
  const clusterMap = new Map(); // clusterId -> clusterName
  for (const a of filtered) {
    const cid = clusterIdOf(a);
    const cn = clusterNameOf(a);
    if (cid) clusterMap.set(cid, cn);
  }
  const clusters = Array.from(clusterMap.entries())
    .map(([clusterId, clusterName]) => ({ clusterId, clusterName }))
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  // Group alerts by bucket
  const alertsByBucket = new Map();
  for (const b of BUCKETS) alertsByBucket.set(b, []);
  for (const a of filtered) alertsByBucket.get(bucketOf(a)).push(a);

  // Dedupe + category universe
  const dedupedByBucket = new Map();
  const categoriesByBucket = new Map();
  for (const b of BUCKETS) categoriesByBucket.set(b, new Set());

  for (const b of BUCKETS) {
    const deduped = dedupeLatest(alertsByBucket.get(b) || []);
    dedupedByBucket.set(b, deduped);
    for (const u of deduped) categoriesByBucket.get(b).add(categoryOf(u.alert));
  }

  // =============================
  // RENDER BUCKET (one email body)
  // =============================
  function renderBucket(bucket) {
    const deduped = dedupedByBucket.get(bucket) || [];
    const categories = Array.from(categoriesByBucket.get(bucket) || new Set()).sort((a, b) => a.localeCompare(b));

    const header =
      `### Cohesity Helios — Active Alerts — ${bucket}\n\n` +
      `**States:** ${ALERT_STATES.join(", ")} | **Unique:** latest per (clusterId|alertCode) | **Window:** not filtered\n` +
      `**Legend:** ${SYM_OK} none | ${SYM_C} Critical | ${SYM_W} Warning | ${SYM_I} Info\n`;

    // ---------- SUMMARY ----------
    const summaryRows = [];
    for (const cl of clusters) {
      const row = { Cluster: cl.clusterName };

      // init counts per category
      const counts = new Map();
      for (const cat of categories) counts.set(cat, { C: 0, W: 0, I: 0 });

      for (const u of deduped) {
        const a = u.alert;
        if (clusterIdOf(a) !== cl.clusterId) continue;

        const cat = categoryOf(a);
        if (!counts.has(cat)) counts.set(cat, { C: 0, W: 0, I: 0 });

        const sev = severityBucket(a?.severity);
        if (sev === "C" || sev === "W" || sev === "I") counts.get(cat)[sev] += 1;
      }

      for (const cat of categories) {
        const c = counts.get(cat) || { C: 0, W: 0, I: 0 };
        row[cat] = cellSymbols(c.C, c.W, c.I);
      }

      summaryRows.push(row);
    }

    const summary =
      `**Summary (Cluster × alertCategory)**\n\n` +
      mdTable(["Cluster", ...categories], summaryRows);

    // ---------- DETAILS (ONE BIG TABLE; Cluster is first column) ----------
    const detailRows = [];
    let total = 0;

    // Pre-sort: clusterName asc, severity desc, latest desc
    const sevRank = (b) => (b === "C" ? 3 : b === "W" ? 2 : b === "I" ? 1 : 0);

    const expanded = deduped.map((u) => {
      const a = u.alert;
      return {
        clusterName: clusterNameOf(a),
        clusterId: clusterIdOf(a),
        alert: a,
        occ: u.occ,
        latest: Number(a?.latestTimestampUsecs || u.latest || 0),
        sevB: severityBucket(a?.severity),
      };
    });

    expanded.sort((x, y) => {
      if (x.clusterName !== y.clusterName) return x.clusterName.localeCompare(y.clusterName);
      if (sevRank(y.sevB) !== sevRank(x.sevB)) return sevRank(y.sevB) - sevRank(x.sevB);
      return (y.latest || 0) - (x.latest || 0);
    });

    for (const x of expanded) {
      if (total >= MAX_TOTAL_DETAIL_ROWS_PER_BUCKET) break;
      const a = x.alert;

      detailRows.push({
        Cluster: x.clusterName,
        Sev: `${symForSevBucket(x.sevB)} ${norm(a?.severity) || "Unknown"}`,
        alertCategory: categoryOf(a),
        alertCode: alertCodeOf(a),
        alertState: norm(a?.alertState),
        latestSeenUtc: usecsToUtc(a?.latestTimestampUsecs || x.latest),
        occurrences: String(x.occ || 0),
        alertDescription: cap(alertDescOf(a), 220),
      });

      total++;
    }

    const detailsHeader = `**Details (latest per alertCode; consolidated table)**\n`;
    const details =
      detailsHeader +
      "\n" +
      mdTable(
        ["Cluster", "Sev", "alertCategory", "alertCode", "alertState", "latestSeenUtc", "occurrences", "alertDescription"],
        detailRows
      ) +
      (total >= MAX_TOTAL_DETAIL_ROWS_PER_BUCKET
        ? `\n\n${SYM_W} Detail rows capped at ${MAX_TOTAL_DETAIL_ROWS_PER_BUCKET} for ${bucket}.\n`
        : "");

    return [header, summary, details].join("\n\n");
  }

  // =============================
  // RETURN 4 EMAILS
  // =============================
  const utcDate = new Date().toISOString().slice(0, 10);

  return {
    kHardwareSubject: `${EMAIL_PREFIX} — kHardware — ${utcDate}`,
    kHardwareMarkdown: renderBucket("kHardware"),

    kSoftwareSubject: `${EMAIL_PREFIX} — kSoftware — ${utcDate}`,
    kSoftwareMarkdown: renderBucket("kSoftware"),

    kDataServiceSubject: `${EMAIL_PREFIX} — kDataService — ${utcDate}`,
    kDataServiceMarkdown: renderBucket("kDataService"),

    kMaintenanceSubject: `${EMAIL_PREFIX} — kMaintenance — ${utcDate}`,
    kMaintenanceMarkdown: renderBucket("kMaintenance"),
  };
}
