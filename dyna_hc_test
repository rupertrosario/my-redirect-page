import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alerts (Unique by alertCode, latest occurrence) — Split emails by alertTypeBucket
 * GET-only
 *
 * What you asked (same style as your working script):
 * - Email bodies use MARKDOWN PIPE TABLES (no code blocks, no HTML).
 * - “Unique alerts” = dedupe by alertCode, keep ONLY the latest occurrence per cluster.
 * - Per alertTypeBucket (kHardware/kSoftware/kDataService/kMaintenance):
 *    1) SUMMARY email: Cluster on Y, alertCategory on X, cells show counts by severity (C/W/I) for unique alertCodes.
 *    2) DETAILS email: per cluster table listing the latest alert per alertCode (for that bucket).
 *
 * Returns ONLY:
 *  - emails: [{ bucket, kind, subject, markdown }]
 *
 * Dynatrace Send email mappings (loop):
 * - Subject: {{ _.item.subject }}
 * - Message: {{ _.item.markdown }}
 */
export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // AUTH (vault id)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  // ==============================
  // SETTINGS
  // ==============================
  const CONCURRENCY = 8;
  const MAX_ALERTS = 5000; // no time filter; increase if needed
  const ALERT_STATES = ["kOpen", "kNote"];

  const TYPE_BUCKETS = ["kHardware", "kSoftware", "kDataService", "kMaintenance"];
  const EMAIL_PREFIX = "Cohesity Helios — Active Alerts (Unique)";

  // keep email safe
  const MAX_DETAIL_ROWS_PER_CLUSTER = 60;
  const MAX_TOTAL_DETAIL_ROWS_PER_BUCKET = 1600;

  // ==============================
  // SYMBOLS
  // ==============================
  const SYM_OK = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";

  // ==============================
  // HELPERS
  // ==============================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const safeCell = (v) => (v === null || v === undefined ? "" : String(v).replace(/\|/g, " "));
  const cap = (s, n) => {
    const t = norm(s);
    return t.length > n ? t.slice(0, n - 1) + "…" : t;
  };

  function mdTable(headers, rows) {
    if (!rows.length) return "No data.";
    const head = `| ${headers.join(" | ")} |`;
    const sep = `| ${headers.map(() => "---").join(" | ")} |`;
    const body = rows.map((r) => `| ${headers.map((h) => safeCell(r[h] ?? "")).join(" | ")} |`);
    return [head, sep, ...body].join("\n");
  }

  function usecsToUtc(usecs) {
    const u = Number(usecs || 0);
    if (!u) return "";
    const d = new Date(Math.floor(u / 1000)); // usecs -> ms
    const iso = d.toISOString(); // ...Z
    return iso.replace("T", " ").replace(".000Z", "Z");
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try {
        txt = await resp.text();
      } catch (_) {}
      const e = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      e.status = resp.status;
      e.body = txt;
      throw e;
    }
    return resp.json();
  }

  async function poolMap(items, worker, concurrency) {
    const results = new Array(items.length);
    let idx = 0;
    const runners = new Array(Math.min(concurrency, items.length)).fill(0).map(async () => {
      while (idx < items.length) {
        const cur = idx++;
        results[cur] = await worker(items[cur], cur);
      }
    });
    await Promise.all(runners);
    return results;
  }

  function extractAlerts(payload) {
    const a =
      payload?.alertsList?.alerts ||
      payload?.alertsList ||
      payload?.alerts ||
      payload?.alertList ||
      payload;
    return toArray(a).filter((x) => x && typeof x === "object");
  }

  function severityBucket(sev) {
    const s = norm(sev).toLowerCase();
    if (s.includes("critical") || s === "kcritical") return "C";
    if (s.includes("warning") || s === "kwarning") return "W";
    if (s.includes("info") || s === "kinfo" || s.includes("informational")) return "I";
    return "U";
  }

  function symForBucket(b) {
    if (b === "C") return SYM_C;
    if (b === "W") return SYM_W;
    if (b === "I") return SYM_I;
    return "❓";
  }

  function bucketOf(a) {
    return norm(a?.alertTypeBucket) || "Unknown";
  }
  function categoryOf(a) {
    return norm(a?.alertCategory) || "Unknown";
  }

  function summarizeProps(propertyList) {
    const arr = toArray(propertyList);
    if (!arr.length) return "";
    const pairs = [];
    for (const p of arr) {
      const k = norm(p?.key || p?.name);
      const v = norm(p?.value);
      if (!k) continue;
      pairs.push(`${k}=${cap(v, 60)}`);
      if (pairs.length >= 3) break;
    }
    return pairs.join("; ");
  }

  function cellCWI(C, W, I) {
    if (!C && !W && !I) return SYM_OK;
    return `${C}C/${W}W/${I}I`;
  }

  // ==============================
  // COMMON HEADERS
  // ==============================
  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // 1) CLUSTERS
  // ==============================
  const clu = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, commonHeaders);
  const clusters = toArray(clu?.cohesityClusters)
    .map((c) => ({ clusterName: norm(c?.clusterName), clusterId: norm(c?.clusterId) }))
    .filter((c) => c.clusterName && c.clusterId)
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  if (!clusters.length) throw new Error("No clusters returned from /v2/mcm/cluster-mgmt/info");

  // ==============================
  // 2) PER-CLUSTER /v2/mcm/alerts (NO time filter)
  // ==============================
  async function fetchAlertsForCluster(clusterId) {
    const headers = { ...commonHeaders, accessClusterId: String(clusterId) };
    const params = new URLSearchParams();
    params.set("maxAlerts", String(MAX_ALERTS));
    params.set("alertStateList", ALERT_STATES.join(","));
    const url = `${baseUrl}/v2/mcm/alerts?${params.toString()}`;
    const data = await getJson(url, headers);
    return extractAlerts(data);
  }

  const perCluster = await poolMap(
    clusters,
    async (cl) => {
      try {
        const alerts = await fetchAlertsForCluster(cl.clusterId);
        return { ok: true, clusterName: cl.clusterName, clusterId: cl.clusterId, alerts };
      } catch (e) {
        return { ok: false, clusterName: cl.clusterName, clusterId: cl.clusterId, alerts: [], error: norm(e?.message) };
      }
    },
    CONCURRENCY
  );

  // ==============================
  // 3) DEDUPE: latest per alertCode (per cluster, per bucket)
  // ==============================
  function dedupeLatestByAlertCode(alerts) {
    // returns array of { alertCode, alert, occurrences }
    const m = new Map(); // code -> { latestUsecs, occurrences, alert }
    for (const a of alerts) {
      const code = norm(a?.alertCode);
      if (!code) continue;
      const latest = Number(a?.latestTimestampUsecs || 0);
      const occ = Number(a?.dedupCount || 1);

      const prev = m.get(code);
      if (!prev) {
        m.set(code, { alertCode: code, latestUsecs: latest, occurrences: occ, alert: a });
      } else {
        prev.occurrences += occ;
        if (latest >= Number(prev.latestUsecs || 0)) {
          prev.latestUsecs = latest;
          prev.alert = a;
        }
      }
    }
    return Array.from(m.values()).sort((x, y) => Number(y.latestUsecs || 0) - Number(x.latestUsecs || 0));
  }

  // Build per cluster -> per bucket -> deduped list; also gather categories per bucket
  const perClusterBucketMap = new Map(); // clusterName -> { ok, error?, buckets: Map(bucket -> deduped[]) }
  const categoriesByBucket = new Map(); // bucket -> Set(category)
  for (const b of TYPE_BUCKETS) categoriesByBucket.set(b, new Set());

  for (const c of perCluster) {
    const buckets = new Map();
    for (const b of TYPE_BUCKETS) buckets.set(b, []);

    if (!c.ok) {
      perClusterBucketMap.set(c.clusterName, { ok: false, error: c.error, buckets });
      continue;
    }

    // group raw alerts by bucket
    const grouped = new Map();
    for (const a of c.alerts) {
      const b = bucketOf(a);
      if (!TYPE_BUCKETS.includes(b)) continue;
      if (!grouped.has(b)) grouped.set(b, []);
      grouped.get(b).push(a);
    }

    for (const b of TYPE_BUCKETS) {
      const deduped = dedupeLatestByAlertCode(grouped.get(b) || []);
      buckets.set(b, deduped);
      const catSet = categoriesByBucket.get(b);
      for (const u of deduped) catSet.add(categoryOf(u.alert));
    }

    perClusterBucketMap.set(c.clusterName, { ok: true, buckets });
  }

  // ==============================
  // 4) BUILD EMAILS (same style: markdown tables)
  // ==============================
  const utcDate = new Date().toISOString().slice(0, 10);
  const emails = [];

  for (const bucket of TYPE_BUCKETS) {
    const categories = Array.from(categoriesByBucket.get(bucket) || new Set()).sort((a, b) => a.localeCompare(b));

    // ---------- SUMMARY (matrix): X=category, Y=cluster ----------
    const summaryRows = [];
    for (const cl of clusters) {
      const entry = perClusterBucketMap.get(cl.clusterName);

      if (!entry || !entry.ok) {
        const r = { Cluster: cl.clusterName };
        for (const cat of categories) r[cat] = `${SYM_W}NO_DATA`;
        summaryRows.push(r);
        continue;
      }

      const deduped = entry.buckets.get(bucket) || [];
      const byCat = new Map(); // cat -> {C,W,I}
      for (const cat of categories) byCat.set(cat, { C: 0, W: 0, I: 0 });

      for (const u of deduped) {
        const a = u.alert;
        const cat = categoryOf(a);
        if (!byCat.has(cat)) byCat.set(cat, { C: 0, W: 0, I: 0 });
        const sev = severityBucket(a?.severity);
        if (sev === "C" || sev === "W" || sev === "I") byCat.get(cat)[sev] += 1;
      }

      const r = { Cluster: cl.clusterName };
      for (const cat of categories) {
        const cwc = byCat.get(cat) || { C: 0, W: 0, I: 0 };
        r[cat] = cellCWI(cwc.C, cwc.W, cwc.I);
      }
      summaryRows.push(r);
    }

    const summaryNote =
      `### ${EMAIL_PREFIX} — ${bucket}\n\n` +
      `**States:** ${ALERT_STATES.join(", ")} | **MaxAlerts/cluster:** ${MAX_ALERTS} | **Window:** not filtered\n` +
      `**Unique logic:** latest per **alertCode** (per cluster) | **Matrix:** X=alertCategory, Y=cluster | **Cell:** xC/yW/zI (unique alertCodes)\n\n` +
      `**Legend:** ✅ none | ⛔ Critical | ⚠️ Warning | ℹ️ Info | ⚠️NO_DATA unreachable\n`;

    const markdownSummary =
      `**Summary Matrix (Cluster × alertCategory) — ${bucket}**\n` +
      mdTable(["Cluster", ...categories], summaryRows);

    const summarySubject = `${EMAIL_PREFIX} — ${bucket} — SUMMARY — ${utcDate}`;
    const summaryMarkdown = [summaryNote, markdownSummary].join("\n\n");

    emails.push({ bucket, kind: "summary", subject: summarySubject, markdown: summaryMarkdown });

    // ---------- DETAILS: per cluster (latest per alertCode) ----------
    const detailParts = [];
    let totalDetailRows = 0;

    for (let i = 0; i < clusters.length; i++) {
      const cl = clusters[i];
      const n = i + 1;
      const entry = perClusterBucketMap.get(cl.clusterName);

      if (!entry || !entry.ok) {
        detailParts.push(
          `**${n}. ${cl.clusterName}**\n\n${SYM_W}NO_DATA — ${cap(norm(entry?.error) || "Unreachable/failed request", 220)}\n`
        );
        continue;
      }

      const deduped = entry.buckets.get(bucket) || [];
      if (!deduped.length) {
        detailParts.push(`**${n}. ${cl.clusterName}**\n\n${SYM_OK} No matching alerts.\n`);
        continue;
      }

      const take = Math.min(MAX_DETAIL_ROWS_PER_CLUSTER, deduped.length);
      const rows = [];
      for (let k = 0; k < take; k++) {
        if (totalDetailRows >= MAX_TOTAL_DETAIL_ROWS_PER_BUCKET) break;

        const u = deduped[k];
        const a = u.alert;
        const sevB = severityBucket(a?.severity);

        rows.push({
          Sev: `${symForBucket(sevB)} ${norm(a?.severity) || "Unknown"}`,
          alertCategory: categoryOf(a),
          alertCode: norm(a?.alertCode),
          alertState: norm(a?.alertState),
          latestSeenUtc: usecsToUtc(a?.latestTimestampUsecs),
          occurrences: String(u.occurrences || 0),
          props: cap(summarizeProps(a?.propertyList), 180),
        });

        totalDetailRows++;
      }

      detailParts.push(
        `**${n}. ${cl.clusterName}**\n\n` +
          mdTable(
            ["Sev", "alertCategory", "alertCode", "alertState", "latestSeenUtc", "occurrences", "props"],
            rows
          ) +
          "\n"
      );

      if (totalDetailRows >= MAX_TOTAL_DETAIL_ROWS_PER_BUCKET) {
        detailParts.push(`\n${SYM_W} Detail rows capped at ${MAX_TOTAL_DETAIL_ROWS_PER_BUCKET} for ${bucket}.\n`);
        break;
      }
    }

    const detailsNote =
      `### ${EMAIL_PREFIX} — ${bucket} (Details)\n\n` +
      `**States:** ${ALERT_STATES.join(", ")} | **MaxAlerts/cluster:** ${MAX_ALERTS} | **Window:** not filtered\n` +
      `**Unique logic:** latest per **alertCode** (per cluster)\n\n`;

    const detailsSubject = `${EMAIL_PREFIX} — ${bucket} — DETAILS — ${utcDate}`;
    const detailsMarkdown = [detailsNote, `**Latest alert per alertCode — ${bucket}**\n\n${detailParts.join("\n")}`].join("\n");

    emails.push({ bucket, kind: "details", subject: detailsSubject, markdown: detailsMarkdown });
  }

  return { emails };
}
