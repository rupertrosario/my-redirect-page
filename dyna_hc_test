import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Health Tiles (GET-only) — Alerts-only (NO cluster-mgmt baseline)
 * - GET /v2/mcm/alerts (single call)
 * - Filter: alertState in (kOpen, kNote)
 * - Hardware table ONLY counts UNIQUE alertCode per CLUSTER for kHardware
 * - Cell shows: ⛔<N> ⚠️<N> ℹ️<N> where N = unique alertCodes in that severity for that category on that cluster
 *
 * LIMITATION:
 * - Clusters with zero active alerts will not appear (no baseline endpoint).
 *
 * Returns:
 *  - note
 *  - markdownHardware
 *  - markdownMaintenance
 *  - markdownDataService
 *  - markdown
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // AUTH (vault id)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // CATEGORY ENUMS (sorted)
  // ==============================
  const HW_Cats = [
    "kDisk","kNode","kCluster","kChassis","kPowerSupply","kCPU","kMemory","kTemperature",
    "kFan","kNIC","kFirmware","kNodeHealth","kOperatingSystem","kStorageDevice","kStoragePool"
  ].sort();

  const MAINT_Cats = [
    "kHelios","kAppMarketPlace","kSystemService","kLicense","kSecurity","kUpgrade",
    "kClusterManagement","kAuditLog","kNetworking","kConfiguration","kStorageUsage",
    "kFaultTolerance","kGeneralSoftwareFailure"
  ].sort();

  const DS_Cats = [
    "kDataPath","kDataSourceConnector","kMetadata","kIndexing","kBackupRestore","kArchivalRestore",
    "kRemoteReplication","kQuota","kCDP","kViewFailover","kDisasterRecovery","kAgent","kNetBackup"
  ].sort();

  // ==============================
  // SYMBOLS
  // ==============================
  const SYM_OK = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";

  // ==============================
  // HELPERS
  // ==============================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const safeCell = (v) => (v === null || v === undefined ? "" : String(v).replace(/\|/g, " "));

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`.trim());
    }
    return resp.json();
  }

  function mdTable(headers, rows) {
    if (!rows.length) return "No clusters returned.";
    const head = `| ${headers.join(" | ")} |`;
    const sep = `| ${headers.map(() => "---").join(" | ")} |`;
    const body = rows.map((r) => `| ${headers.map((h) => safeCell(r[h] ?? "")).join(" | ")} |`);
    return [head, sep, ...body].join("\n");
  }

  function cellFromSets(setC, setW, setI) {
    const c = setC ? setC.size : 0;
    const w = setW ? setW.size : 0;
    const i = setI ? setI.size : 0;
    if (c === 0 && w === 0 && i === 0) return SYM_OK;
    return `${SYM_C}${c} ${SYM_W}${w} ${SYM_I}${i}`;
  }

  // ==============================
  // 1) Fetch alerts (single global call)
  // ==============================
  function buildAlertsUrl() {
    const u = new URL(`${baseUrl}/v2/mcm/alerts`);
    ["kOpen", "kNote"].forEach((s) => u.searchParams.append("alertStateList", s));
    ["kHardware", "kMaintenance", "kDataService"].forEach((b) => u.searchParams.append("alertTypeBucketList", b));
    return u.toString();
  }

  const payload = await getJson(buildAlertsUrl(), commonHeaders);
  const alerts = toArray(payload?.alertsList);

  // ==============================
  // 2) Build per-cluster unique alertCode sets (per bucket/category/severity)
  // store[bucket][clusterName][category] = { C:Set, W:Set, I:Set }
  // ==============================
  const store = new Map();

  function ensureCell(bucket, clusterName, category) {
    if (!store.has(bucket)) store.set(bucket, new Map());
    const b = store.get(bucket);
    if (!b.has(clusterName)) b.set(clusterName, new Map());
    const c = b.get(clusterName);
    if (!c.has(category)) c.set(category, { C: new Set(), W: new Set(), I: new Set() });
    return c.get(category);
  }

  for (const a of alerts) {
    const state = norm(a?.alertState);
    if (state !== "kOpen" && state !== "kNote") continue;

    const bucket = norm(a?.alertTypeBucket);
    const category = norm(a?.alertCategory);
    const severity = norm(a?.severity);
    const code = norm(a?.alertCode);

    // per your ask: “unique codes for hardware type”
    if (bucket !== "kHardware") continue;

    const clusterName = norm(a?.clusterName) || String(a?.clusterId ?? "");
    if (!clusterName || !category || !code) continue;
    if (!HW_Cats.includes(category)) continue;

    const cell = ensureCell(bucket, clusterName, category);
    if (severity === "kCritical") cell.C.add(code);
    else if (severity === "kWarning") cell.W.add(code);
    else if (severity === "kInfo") cell.I.add(code);
  }

  // ==============================
  // 3) Build Hardware table (clusters with at least one hardware alert)
  // ==============================
  function buildHardware() {
    const b = store.get("kHardware") || new Map();
    const clusterNames = Array.from(b.keys()).sort((x, y) => x.localeCompare(y));

    const rows = [];
    for (const name of clusterNames) {
      const row = { ClusterName: name };
      const catMap = b.get(name) || new Map();

      for (const cat of HW_Cats) {
        const v = catMap.get(cat) || { C: new Set(), W: new Set(), I: new Set() };
        row[cat] = cellFromSets(v.C, v.W, v.I);
      }
      rows.push(row);
    }
    return mdTable(["ClusterName", ...HW_Cats], rows);
  }

  const note = [
    "### Cohesity Hardware Health Check",
    "This report mimics the System → Health → Components view for each Cohesity cluster.",
    "**Legend:** ✅ Healthy | ⛔<N> Critical | ⚠️<N> Warning | ℹ️<N> Info | ⚠️NO_DATA Unreachable",
  ].join("\n\n");

  const markdownHardware = `\n**Hardware**\n${buildHardware()}`;

  // Placeholders (not populated in this version since you asked hardware only)
  const markdownMaintenance = `\n**Maintenance**\nNo data (hardware-only unique alertCode mode).`;
  const markdownDataService = `\n**Data Service**\nNo data (hardware-only unique alertCode mode).`;

  const markdown = [note, markdownHardware, markdownMaintenance, markdownDataService].join("\n\n");

  return {
    note,
    markdownHardware,
    markdownMaintenance,
    markdownDataService,
    markdown,
    debug_alertsReturned: alerts.length,
  };
}
