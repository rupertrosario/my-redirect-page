import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Health Tiles — Email-safe Markdown (GET-only)
 *
 * Source:
 *   - GET https://helios.cohesity.com/v2/mcm/alerts  (single call)
 *
 * Clean 3-phase logic (correctness first):
 *   Phase 1: Partition alerts by clusterId
 *   Phase 2: Within each clusterId, dedupe by alertCode (keep ONE representative)
 *   Phase 3: Classify each unique alertCode into (bucket, category, severity) and count tiles
 *
 * Cell meaning:
 *   ⛔<N> ⚠️<N> ℹ️<N> where N = number of UNIQUE alertCodes (per cluster) in that severity for that category
 *   ✅ when all 3 counts are zero
 *
 * Notes / limitations (because no cluster-mgmt baseline):
 * - Clusters with zero active alerts (kOpen/kNote) will not appear.
 * - No ⚠️NO_DATA unreachable handling (needs baseline list to detect missing clusters).
 * - No time window and no maxAlerts param (API default cap applies).
 *
 * Returns:
 *  - note
 *  - markdownHardware
 *  - markdownMaintenance
 *  - markdownDataService
 *  - markdown
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // AUTH (vault id)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // CATEGORY ENUMS (sorted)
  // ==============================
  const HW_Cats = [
    "kDisk","kNode","kCluster","kChassis","kPowerSupply","kCPU","kMemory","kTemperature",
    "kFan","kNIC","kFirmware","kNodeHealth","kOperatingSystem","kStorageDevice","kStoragePool"
  ].sort();

  const MAINT_Cats = [
    "kHelios","kAppMarketPlace","kSystemService","kLicense","kSecurity","kUpgrade",
    "kClusterManagement","kAuditLog","kNetworking","kConfiguration","kStorageUsage",
    "kFaultTolerance","kGeneralSoftwareFailure"
  ].sort();

  const DS_Cats = [
    "kDataPath","kDataSourceConnector","kMetadata","kIndexing","kBackupRestore","kArchivalRestore",
    "kRemoteReplication","kQuota","kCDP","kViewFailover","kDisasterRecovery","kAgent","kNetBackup"
  ].sort();

  const BUCKETS = [
    { key: "kHardware", label: "Hardware", cats: HW_Cats },
    { key: "kMaintenance", label: "Maintenance", cats: MAINT_Cats },
    { key: "kDataService", label: "Data Service", cats: DS_Cats }
  ];

  const catsByBucket = new Map(BUCKETS.map((b) => [b.key, new Set(b.cats)]));

  // ==============================
  // SYMBOLS
  // ==============================
  const SYM_OK = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";

  // ==============================
  // HELPERS
  // ==============================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const safeCell = (v) => (v === null || v === undefined ? "" : String(v).replace(/\|/g, " "));

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`.trim());
    }
    return resp.json();
  }

  function mdTable(headers, rows) {
    if (!rows.length) return "No clusters returned.";
    const head = `| ${headers.join(" | ")} |`;
    const sep = `| ${headers.map(() => "---").join(" | ")} |`;
    const body = rows.map((r) => `| ${headers.map((h) => safeCell(r[h] ?? "")).join(" | ")} |`);
    return [head, sep, ...body].join("\n");
  }

  function cellFromCounts(c, w, i) {
    const cc = Number(c || 0);
    const ww = Number(w || 0);
    const ii = Number(i || 0);
    if (cc === 0 && ww === 0 && ii === 0) return SYM_OK;
    return `${SYM_C}${cc} ${SYM_W}${ww} ${SYM_I}${ii}`;
  }

  // store[bucketKey][clusterName][category] = { c:int, w:int, i:int }
  const store = new Map();

  function ensureCounts(bucketKey, clusterName, category) {
    if (!store.has(bucketKey)) store.set(bucketKey, new Map());
    const b = store.get(bucketKey);
    if (!b.has(clusterName)) b.set(clusterName, new Map());
    const c = b.get(clusterName);
    if (!c.has(category)) c.set(category, { c: 0, w: 0, i: 0 });
    return c.get(category);
  }

  // ==============================
  // 1) Fetch alerts (single global call)
  // ==============================
  function buildAlertsUrl() {
    const u = new URL(`${baseUrl}/v2/mcm/alerts`);
    ["kOpen", "kNote"].forEach((s) => u.searchParams.append("alertStateList", s));
    ["kHardware", "kMaintenance", "kDataService"].forEach((b) =>
      u.searchParams.append("alertTypeBucketList", b)
    );
    return u.toString();
  }

  const payload = await getJson(buildAlertsUrl(), commonHeaders);
  const alerts = toArray(payload?.alertsList);

  // ==============================
  // PHASE 1: Partition by clusterId
  // clusterId -> { clusterName, alerts: [] }
  // ==============================
  const byCluster = new Map();

  for (const a of alerts) {
    const state = norm(a?.alertState);
    if (state !== "kOpen" && state !== "kNote") continue;

    const clusterId = String(a?.clusterId ?? "");
    if (!clusterId) continue;

    const clusterName = norm(a?.clusterName) || clusterId;

    if (!byCluster.has(clusterId)) byCluster.set(clusterId, { clusterName, alerts: [] });
    byCluster.get(clusterId).alerts.push(a);
  }

  // ==============================
  // PHASE 2: Dedupe per cluster by alertCode (keep ONE representative per code)
  // clusterId -> Map(alertCode -> representativeAlert)
  // ==============================
  const uniqByCluster = new Map();

  for (const [clusterId, obj] of byCluster.entries()) {
    const repByCode = new Map();

    for (const a of obj.alerts) {
      const code = norm(a?.alertCode);
      if (!code) continue;

      // keep first; (optional) you could prefer kCritical over others, but not requested
      if (!repByCode.has(code)) repByCode.set(code, a);
    }

    uniqByCluster.set(clusterId, { clusterName: obj.clusterName, repByCode });
  }

  // ==============================
  // PHASE 3: Classify each unique alertCode into tiles
  // ==============================
  for (const { clusterName, repByCode } of uniqByCluster.values()) {
    for (const a of repByCode.values()) {
      const bucket = norm(a?.alertTypeBucket);
      const category = norm(a?.alertCategory);
      const severity = norm(a?.severity);

      if (!bucket || !category || !severity) continue;
      if (!catsByBucket.has(bucket)) continue;
      if (!catsByBucket.get(bucket).has(category)) continue;
      if (severity !== "kCritical" && severity !== "kWarning" && severity !== "kInfo") continue;

      const cell = ensureCounts(bucket, clusterName, category);
      if (severity === "kCritical") cell.c += 1;
      else if (severity === "kWarning") cell.w += 1;
      else cell.i += 1;
    }
  }

  // ==============================
  // Build section tables
  // ==============================
  function buildSection(bucketKey, cats) {
    const b = store.get(bucketKey) || new Map();
    const clusterNames = Array.from(b.keys()).sort((x, y) => x.localeCompare(y));

    const rows = [];
    for (const name of clusterNames) {
      const row = { ClusterName: name };
      const catMap = b.get(name) || new Map();

      for (const cat of cats) {
        const v = catMap.get(cat) || { c: 0, w: 0, i: 0 };
        row[cat] = cellFromCounts(v.c, v.w, v.i);
      }
      rows.push(row);
    }

    return mdTable(["ClusterName", ...cats], rows);
  }

  // ==============================
  // NOTE / HEADER (exact wording)
  // ==============================
  const note =
    `### Cohesity Hardware Health Check\n\n` +
    `This report mimics the System → Health → Components view for each Cohesity cluster.\n\n` +
    `**Legend:** ✅ Healthy | ⛔<N> Critical | ⚠️<N> Warning | ℹ️<N> Info | ⚠️NO_DATA Unreachable\n`;

  // ==============================
  // MARKDOWN SECTIONS (independent)
  // ==============================
  const markdownHardware = `\n**Hardware**\n${buildSection("kHardware", HW_Cats)}`;
  const markdownMaintenance = `\n**Maintenance**\n${buildSection("kMaintenance", MAINT_Cats)}`;
  const markdownDataService = `\n**Data Service**\n${buildSection("kDataService", DS_Cats)}`;

  const markdown = [note, markdownHardware, markdownMaintenance, markdownDataService].join("\n\n");

  return {
    note,
    markdownHardware,
    markdownMaintenance,
    markdownDataService,
    markdown,
    // Debug (remove later)
    debug_alertsReturned: alerts.length,
    debug_clustersWithAlerts: byCluster.size,
    debug_uniqueCodesTotal: Array.from(uniqByCluster.values()).reduce((n, x) => n + x.repByCode.size, 0),
  };
}
