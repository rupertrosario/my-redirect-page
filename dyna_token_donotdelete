import { execution } from "@dynatrace-sdk/automation-utils";

export default async function ({ execution_id }) {
  const ex     = await execution(execution_id);
  const result = await ex.result(execute_dql_query_1);   // your DQL step ID
  const rows   = result.records ?? [];

  const BYTES_PER_TB = 1_000_000_000_000;

  function safeNum(x) {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  }

  function badge(p) {
    const n = Number(p);
    if (!Number.isFinite(n)) return "âšª";
    if (n < 70) return "ðŸŸ¢";
    if (n < 85) return "ðŸŸ¡";
    return "ðŸ”´";
  }

  // Normalize DQL rows
  const clusters = rows
    .map((r) => {
      const clusterName = r.clusterName ?? "Unknown";

      const usedTB  = safeNum(r.used_TB);
      const totalTB = safeNum(r.total_TB);

      const usedPctRaw =
        r.used_pct_rounded != null
          ? safeNum(r.used_pct_rounded)
          : (totalTB > 0 ? (usedTB / totalTB) * 100 : 0);

      const usedPctLabel =
        typeof r.used_pct_label === "string"
          ? r.used_pct_label
          : `${usedPctRaw.toFixed(1)} %`;

      const usedHddTB  = safeNum(r.used_hdd_bytes)  / BYTES_PER_TB;
      const totalHddTB = safeNum(r.total_hdd_bytes) / BYTES_PER_TB;
      const usedSddTB  = safeNum(r.used_sdd_bytes)  / BYTES_PER_TB;
      const totalSddTB = safeNum(r.total_sdd_bytes) / BYTES_PER_TB;

      const usedHddPct =
        totalHddTB > 0 ? (usedHddTB / totalHddTB) * 100 : 0;
      const usedSddPct =
        totalSddTB > 0 ? (usedSddTB / totalSddTB) * 100 : 0;

      return {
        clusterName,

        usedPct:      usedPctRaw.toFixed(1),
        usedPctLabel,

        usedHddTB:    usedHddTB.toFixed(1),
        totalHddTB:   totalHddTB.toFixed(1),
        usedHddPct:   usedHddPct.toFixed(1),

        usedSddTB:    usedSddTB.toFixed(1),
        totalSddTB:   totalSddTB.toFixed(1),
        usedSddPct:   usedSddPct.toFixed(1),

        usedTB:       usedTB.toFixed(1),
        totalTB:      totalTB.toFixed(1),

        status:       badge(usedPctRaw)
      };
    })
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  // ðŸ“Š Table â€“ same style as your Cohesity script, with Used/Total TB at the end
  const header = [
    "ðŸ“Š **Isilon Cluster Capacity Report**",
    "",
    "| Cluster | Used % | Status | HDD Used TB | HDD Total TB | HDD % | SSD Used TB | SSD Total TB | SSD % | Used TB | Total TB |",
    "|---------|-------:|:------:|------------:|-------------:|------:|------------:|-------------:|------:|--------:|---------:|"
  ].join("\n");

  const body = clusters
    .map((c) =>
      `| ${c.clusterName}` +
      ` | ${c.usedPct} %` +
      ` | ${c.status}` +
      ` | ${c.usedHddTB}` +
      ` | ${c.totalHddTB}` +
      ` | ${c.usedHddPct} %` +
      ` | ${c.usedSddTB}` +
      ` | ${c.totalSddTB}` +
      ` | ${c.usedSddPct} %` +
      ` | ${c.usedTB}` +
      ` | ${c.totalTB} |`
    )
    .join("\n");

  const footer = [
    "",
    `**_Total clusters in report: ${clusters.length}_**`,
    "",
    "ðŸŸ¢ = Healthy (â‰¤ 70%)",
    "ðŸŸ¡ = Warning (70â€“84.9%)",
    "ðŸ”´ = Critical (â‰¥ 85%)"
  ].join("\n");

  const report = [header, body, "", footer].join("\n");

  // For email: use `report` as body; `clusters` is there if you need JSON
  return { clusters, report };
}
