// ğŸš€ Cohesity Helios â€“ Read-only Capacity + Garbage (Vault by Name â†’ ID â†’ Manual Fallback)
import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";
  const oneTiB  = 1099511627776;
  const vaultId = "credentials_vault-312312";   // optional backup ID
  const vaultName = "Cohesity_API_Key";         // âœ… your working Vault credential name
  let apiKey = null;
  let authMode = "vault-name";

  // Helper to fetch credential by name
  async function tryGetByName(name) {
    try {
      const list = await credentialVaultClient.getCredentials();
      const found = list.credentials.find(c => c.name === name);
      if (!found) {
        console.log(`âŒ No credential found with name: ${name}`);
        return null;
      }
      const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
      console.log(`âœ… Loaded API key from vault (by name): ${found.name}`);
      return detail.token;
    } catch (err) {
      console.log(`âš ï¸ Vault name lookup failed (${err.message || "unknown error"})`);
      return null;
    }
  }

  // 1ï¸âƒ£ Try Vault by Name
  apiKey = await tryGetByName(vaultName);

  // 2ï¸âƒ£ If name fails, try Vault by ID
  if (!apiKey) {
    try {
      const vaultData = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = vaultData?.token;
      authMode = "vault-id";
      console.log(`âœ… Loaded API key from vault (by ID): ${vaultData?.name || vaultId}`);
    } catch (err) {
      console.log(`âš ï¸ Vault ID fetch failed (${err.message || "unknown error"})`);
    }
  }

  // 3ï¸âƒ£ Manual fallback for testing
  if (!apiKey) {
    apiKey = "PASTE_YOUR_API_KEY_HERE"; // ğŸ§ª manual fallback
    authMode = "manual";
    console.log("âš ï¸ Using manual API key fallback");
  }

  const headers = { accept: "application/json", apiKey };

  // 4ï¸âƒ£ Get cluster list
  const listResp = await fetch(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { method: "GET", headers });
  if (listResp.status !== 200)
    throw new Error(`âŒ Cluster list failed (${listResp.status})`);
  const clusters = (await listResp.json())?.cohesityClusters || [];
  if (!clusters.length) {
    const emptyReport = "ğŸ“Š **Cohesity Cluster Capacity Report**\n\n_No clusters returned._";
    return { clusters: [], report: emptyReport, authMode };
  }

  // 5ï¸âƒ£ Get capacity + garbage for each cluster
  const stats = await Promise.all(clusters.map(async ({ clusterName, clusterId }) => {
    const h = { ...headers, accessClusterId: String(clusterId) };
    const safeName = clusterName.replace(/\s+/g, '');
    const entityId = `${safeName}+(ID+${clusterId})`; // âœ… working format

    const tsUrl =
      `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
      `?schemaName=ApolloV2ClusterStats` +
      `&metricName=EstimatedGarbageBytes` +
      `&startTimeMsecs=2` +
      `&entityId=${entityId}` +
      `&rollupFunction=latest` +
      `&rollupIntervalSecs=30` +
      `&metricUnitType=0` +
      `&range=day`;

    const capUrl = `${baseUrl}/irisservices/api/v1/public/stats/storage`;

    const [tsResp, capResp] = await Promise.all([
      fetch(tsUrl,  { method: "GET", headers: h }),
      fetch(capUrl, { method: "GET", headers: h })
    ]);

    // Garbage
    let garbageGB = 0, garbageTB = 0;
    if (tsResp.status === 200) {
      const tsJson = await tsResp.json();
      const vec = tsJson?.dataPointVec || [];
      const latest = vec.length ? vec[vec.length - 1] : undefined;
      const bytes = latest?.data?.int64Value ?? 0;
      garbageGB = +(bytes / (1024 ** 3)).toFixed(2);
      garbageTB = +(bytes / (1024 ** 4)).toFixed(3);
    }

    // Capacity
    if (capResp.status !== 200) return null;
    const s = await capResp.json();
    const totalTiB = +(s.totalCapacityBytes  / oneTiB).toFixed(2);
    const usedTiB  = +(s.localUsageBytes     / oneTiB).toFixed(2);
    const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
    const consumedPercent = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

    return { clusterName, clusterId, totalTiB, usedTiB, availTiB, consumedPercent, garbageGB, garbageTB };
  }));

  // 6ï¸âƒ£ Sort alphabetically and build color-coded table
  const rows = stats.filter(Boolean).sort((a, b) => a.clusterName.localeCompare(b.clusterName));
  const badge = (p) => (p >= 80 ? "ğŸ”´" : (p > 70 ? "ğŸŸ¡" : "ğŸŸ¢"));

  const header = [
    "ğŸ“Š **Cohesity Cluster Capacity Report**",
    "",
    "| Cluster | Used TiB | Avail TiB | % Used | Status | Garbage GB | Garbage TB |",
    "|----------|----------:|----------:|--------:|:------:|-----------:|-----------:|"
  ].join("\n");

  const body = rows.map(c =>
    `| ${c.clusterName} | ${c.usedTiB} | ${c.availTiB} | ${c.consumedPercent}% | ${badge(c.consumedPercent)} | ${c.garbageGB} | ${c.garbageTB} |`
  ).join("\n");

  const footer = [
    "",
    `**_Total clusters in report: ${rows.length}_**`,
    "",
    "ğŸŸ¢ = Healthy (â‰¤ 70%)",
    "ğŸŸ¡ = Warning (70â€“79%)",
    "ğŸ”´ = Critical (â‰¥ 80%)",
    "",
    `ğŸ”‘ Auth mode used: **${authMode}**`
  ].join("\n");

  const report = [header, body, "", footer].join("\n");

  // 7ï¸âƒ£ Return clean data for email or table output
  return { clusters: rows, report, authMode };
}
