# -------------------------------------------------------------
# Cohesity File System Backup Failures ‚Äì Multi-Cluster (Helios)
# Environment: kPhysical | ObjectType: kHost
# Latest-run-per-runType; include ONLY object-level failedAttempts[]
# -------------------------------------------------------------

$logDirectory = "X:\PowerShell\Data\Cohesity\BackupFailures"
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory | Out-Null
}

# --- Load API key ---
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found: $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()
$commonHeaders = @{ "apiKey" = $apiKey }

# --- Get all clusters from Helios ---
$baseUrl = "https://helios.cohesity.com"
$url     = "$baseUrl/v2/mcm/cluster-mgmt/info"
$response = Invoke-WebRequest -Uri $url -Headers $commonHeaders -Method Get
$json_clu = ($response.Content | ConvertFrom-Json).cohesityClusters
if (-not $json_clu) { throw "No clusters returned from Helios." }

# --- Helper: ¬µs -> local time (safe) ---
function Convert-ToLocalFromUsecs {
    param($usecs, $tz)
    if(-not $usecs -or $usecs -eq 0){ return $null }
    try{
        $utc=[DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$usecs/1000)).UtcDateTime
        if($tz){ [System.TimeZoneInfo]::ConvertTimeFromUtc($utc,$tz) } else { $utc.ToLocalTime() }
    }catch{ return $null }
}
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")

$globalFailures = @()

# -------------------------------------------------------------
# Iterate clusters
# -------------------------------------------------------------
foreach($cluster in $json_clu){

    # Resolve cluster name (robust)
    $cluster_name = @($cluster.name, $cluster.clusterName, $cluster.displayName) |
                    Where-Object { $_ -and $_.Trim() } | Select-Object -First 1
    if(-not $cluster_name){ $cluster_name = "Unknown-$($cluster.clusterId)" }

    $cluster_id = $cluster.clusterId
    Write-Host "`nüîπ Processing cluster: $cluster_name" -ForegroundColor Cyan
    $headers = @{ apiKey = $apiKey; accessClusterId = $cluster_id }

    # --- Get File System PGs (kPhysical) ---
    try{
        $pgResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups" `
                                    -Headers $headers -Method Get -Body @{
                                        environments="kPhysical"
                                        isDeleted="False"
                                        isPaused="False"
                                        isActive="True"
                                    }
        $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
    }catch{
        Write-Host "‚ö†Ô∏è Unable to list PGs on $cluster_name: $($_.Exception.Message)" -ForegroundColor Yellow
        continue
    }
    if(-not $pgs){ Write-Host "‚ö†Ô∏è No File System PGs found on $cluster_name." -ForegroundColor Yellow; continue }

    foreach($pg in $pgs){
        $pgId   = $pg.id
        $pgName = $pg.name
        Write-Host "`nüì¶ Checking PG: $pgName" -ForegroundColor Yellow

        # --- Fetch runs (include object details) ---
        try{
            $runResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" `
                                         -Headers $headers -Method Get -Body @{
                                             environments="kPhysical"
                                             numRuns="10"
                                             excludeNonRestorableRuns="False"
                                             includeObjectDetails="True"
                                         }
            $jsonRuns = $runResp | ConvertFrom-Json
        }catch{
            Write-Host "‚ö†Ô∏è Skipping PG $pgName on $cluster_name due to API error: $($_.Exception.Message)" -ForegroundColor Yellow
            continue
        }
        if(-not $jsonRuns.runs){ continue }

        $runs = $jsonRuns.runs

        # --- Work per runType: pick latest by endTimeUsecs ---
        $runTypes = $runs.localBackupInfo.runType | Select-Object -Unique
        foreach($rType in $runTypes){
            $latestRun = $runs |
                Where-Object { $_.localBackupInfo[0].runType -eq $rType } |
                Sort-Object  { $_.localBackupInfo[0].endTimeUsecs } -Descending |
                Select-Object -First 1
            if(-not $latestRun){ continue }

            $info       = $latestRun.localBackupInfo[0]
            $status     = $info.status
            $runType    = $info.runType
            $startLocal = Convert-ToLocalFromUsecs $info.startTimeUsecs $tz
            $endLocal   = Convert-ToLocalFromUsecs $info.endTimeUsecs   $tz

            if($endLocal){
                Write-Host ("   üïì Latest Run Date: {0}" -f $endLocal.ToString('dd-MMM-yyyy HH:mm:ss')) -ForegroundColor DarkGray
            }

            # If latest succeeded ‚Üí just print a success line and move on
            if($status -eq "Succeeded" -or $status -eq "SucceededWithWarning"){
                Write-Host "‚úÖ $cluster_name ‚Üí $pgName [$rType] ‚Äì Latest run succeeded" -ForegroundColor Green
                continue
            }

            Write-Host "‚ùå $cluster_name ‚Üí $pgName [$rType] ‚Äì Latest run failed, collecting host failures..." -ForegroundColor Red
            if(-not $latestRun.objects){ continue }

            # Only kHost in kPhysical with actual failedAttempts[]
            $fsObjs = $latestRun.objects | Where-Object {
                $_.object.objectType -eq 'kHost' -and $_.object.environment -eq 'kPhysical'
            }

            foreach($fs in $fsObjs){
                $attempts = $fs.localSnapshotInfo.failedAttempts
                if(-not $attempts -or $attempts.Count -eq 0){ continue }  # strictly object-level failures only

                foreach($fa in $attempts){
                    $msgClean = ($fa.message -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                    $globalFailures += [pscustomobject]@{
                        Cluster       = $cluster_name
                        ProtectionGroup = $pgName
                        RunType       = $runType
                        HostName      = $fs.object.name
                        StartTime     = $startLocal
                        EndTime       = $endLocal
                        FailedMessage = $msgClean
                    }
                }
            }
        }
    }
}

# -------------------------------------------------------------
# De-dup (cluster|PG|runType|Host|Message|EndTime) and Output
# -------------------------------------------------------------
if ($globalFailures.Count -gt 0) {
    $dedup = $globalFailures |
        Group-Object {
            $end = if ($_.EndTime) { $_.EndTime.ToString('yyyy-MM-dd HH:mm') } else { 'N/A' }
            "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.HostName)|$($_.FailedMessage)|$end"
        } |
        ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 }

    $sorted = $dedup | Sort-Object Cluster,ProtectionGroup,EndTime -Descending

    Write-Host "`nüî• Latest Failed File System Runs (All Clusters):`n" -ForegroundColor Cyan
    $sorted | Format-Table Cluster,ProtectionGroup,RunType,HostName,StartTime,EndTime,FailedMessage -AutoSize
}
else{
    Write-Host "`n‚úÖ All latest File System runs succeeded across all clusters." -ForegroundColor Green
}

# -------------------------------------------------------------
# CSV Reference Path (no export yet)
# -------------------------------------------------------------
$timestamp = Get-Date -Format "yyyyMMdd_HHmm"
$csvPath   = "X:\PowerShell\Data\Cohesity\BackupFailures\BackupFailures_FileSystem_AllClusters_$timestamp.csv"
Write-Host "`nüìÇ (CSV path ready if needed later): $csvPath" -ForegroundColor Gray
