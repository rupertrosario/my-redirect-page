# =====================================================================
# Cohesity Long-Running Jobs ‚Äì Multi-Cluster (Helios)
# API key | All clusters | GET-only (read-only)
#
# What it does:
#   - Uses Helios + apiKey (same style as your Backup Failures script)
#   - Enumerates ALL Helios-managed clusters (v2/mcm/cluster-mgmt/info)
#   - For each cluster:
#       * Lists all protectionJobs (v1, public/protectionJobs)
#       * Lists protectionRuns per job (v1, public/protectionRuns)
#       * Finds runs where:
#           - backupRun.status = kRunning
#           - runtime > thresholdHours (default: 24)
#           - AND copyRun.status not in (kCanceled, kSuccess, kFailure)
#       * Classifies each copyRun.target.type:
#           - kLocal   ‚Üí Backup (Local)
#           - kRemote  ‚Üí Replication (Remote)
#           - kArchival‚Üí Archival (part of Replication table)
#
# Output:
#   - Table 1: BACKUP (Local)
#   - Table 2: REPLICATION / ARCHIVAL (Remote/Archival)
#   - Duration: "Xd Yh ZZm" (e.g. 1d 0h 05m)
#
# CSVs (UTF-8):
#   X:\PowerShell\Data\Cohesity\LongRunningJobs\LongRunningJobs_Backup_Over24h_yyyyMMdd_HHmm.csv
#   X:\PowerShell\Data\Cohesity\LongRunningJobs\LongRunningJobs_Replication_Over24h_yyyyMMdd_HHmm.csv
#
# All HTTP calls are GET only (no writes, deletes, or updates).
# =====================================================================

# -------------------------------
# Settings
# -------------------------------
$thresholdHours = 24.0

# -------------------------------
# Folder + API key (reused pattern)
# -------------------------------
$logDirectory = "X:\PowerShell\Data\Cohesity\LongRunningJobs"
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory | Out-Null
}

# Hygiene 1: keep at most 50 newest files
try {
    $files = Get-ChildItem -Path $logDirectory -File -ErrorAction Stop
    if ($files.Count -gt 50) {
        $toDelete = $files | Sort-Object CreationTime | Select-Object -First ($files.Count - 50)
        $count = ($toDelete | Measure-Object).Count
        if ($count -gt 0) { $toDelete | Remove-Item -Force -ErrorAction SilentlyContinue }
        Write-Host "üßπ Removed $count old files to keep last 50."
    }
} catch {}

# Hygiene 2: delete anything older than 30 days
try {
    $thresholdDate = (Get-Date).AddDays(-30)
    $older = Get-ChildItem -Path $logDirectory -File -ErrorAction SilentlyContinue |
             Where-Object { $_.LastWriteTime -lt $thresholdDate }
    $oldCount = ($older | Measure-Object).Count
    if ($oldCount -gt 0) {
        $older | Remove-Item -Force -ErrorAction SilentlyContinue
        Write-Host "üßΩ Deleted $oldCount files older than 30 days."
    }
} catch {}

$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()

$baseUrl       = "https://helios.cohesity.com"
$commonHeaders = @{ "apiKey" = $apiKey }

# -------------------------------
# Helpers (from your failures script + duration)
# -------------------------------
function Convert-ToUtcFromEpoch($v){
    if ($null -eq $v -or $v -eq 0) { return $null }
    try { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$v/1000)).UtcDateTime }
    catch { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$v).UtcDateTime }
}

function Convert-ToLocalFromUsecs($usecs, $tz){
    $utc = Convert-ToUtcFromEpoch $usecs
    if ($null -eq $utc) { return $null }
    if ($tz) { [System.TimeZoneInfo]::ConvertTimeFromUtc($utc,$tz) } else { $utc.ToLocalTime() }
}

function CleanMsg([string]$s){
    if([string]::IsNullOrWhiteSpace($s)){ return $null }
    return ($s -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
}

# EST like your main script; fallback to local if missing
try {
    $tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")
} catch {
    $tz = [System.TimeZoneInfo]::Local
}

function Write-Log($msg,$color="Gray"){ Write-Host $msg -ForegroundColor $color }

function Format-Duration {
    param([double]$Hours)

    $span  = [TimeSpan]::FromHours($Hours)
    $days  = [int][math]::Floor($span.TotalDays)
    $hrs   = $span.Hours
    $mins  = $span.Minutes
    # Example: "1d 0h 05m"
    return ("{0}d {1}h {2:00}m" -f $days, $hrs, $mins)
}

# -------------------------------
# Get clusters (Helios)
# -------------------------------
try {
    $resp     = Invoke-WebRequest -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders -Method Get
    $json_clu = ($resp.Content | ConvertFrom-Json).cohesityClusters
} catch {
    throw "Failed to query Helios clusters: $($_.Exception.Message)"
}

if (-not $json_clu) { throw "No clusters returned from Helios." }

Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "  COHESITY LONG-RUNNING JOBS ‚Äì ALL CLUSTERS" -ForegroundColor White
Write-Host "=============================================" -ForegroundColor Cyan
Write-Host ("Threshold: {0} hours" -f $thresholdHours) -ForegroundColor Yellow

# -------------------------------
# Main collection ‚Äì long-running jobs
# -------------------------------
$finishedStates = @('kCanceled', 'kSuccess', 'kFailure')
$results        = New-Object System.Collections.Generic.List[object]

foreach($cluster in $json_clu){

    $cluster_name = ($cluster.name,$cluster.clusterName,$cluster.displayName |
                     Where-Object {$_ -and $_.Trim()} | Select-Object -First 1)
    if(-not $cluster_name){$cluster_name="Unknown-$($cluster.clusterId)"}

    $headers = @{ apiKey=$apiKey; accessClusterId=$cluster.clusterId }

    Write-Log ("`n==============================") "DarkCyan"
    Write-Log ("Cluster: {0}" -f $cluster_name) "Cyan"
    Write-Log ("==============================") "DarkCyan"

    # v1 protectionJobs (GET-only)
    try{
        $jobsResp = Invoke-WebRequest -Uri "$baseUrl/irisservices/api/v1/public/protectionJobs?isDeleted=false" `
                                      -Headers $headers -Method Get
        $jobs = $jobsResp.Content | ConvertFrom-Json
    }catch{
        Write-Log ("‚ö†Ô∏è Failed to list protectionJobs on {0}: {1}" -f $cluster_name,$_.Exception.Message) "Yellow"
        continue
    }

    if(-not $jobs){
        Write-Log "No protectionJobs on this cluster." "Gray"
        continue
    }

    foreach($job in $jobs | Sort-Object -Property name){
        $jobName = $job.name
        $jobId   = $job.id
        if(-not $jobId -or -not $jobName){ continue }

        # v1 protectionRuns (GET-only)
        try{
            $runResp = Invoke-WebRequest -Uri "$baseUrl/irisservices/api/v1/public/protectionRuns?jobId=$jobId&excludeTasks=true" `
                                         -Headers $headers -Method Get
            $runs = $runResp.Content | ConvertFrom-Json
        }catch{
            Write-Log ("  ‚ö†Ô∏è Failed to get runs for job {0}: {1}" -f $jobName,$_.Exception.Message) "Yellow"
            continue
        }

        if(-not $runs){ continue }

        foreach($run in $runs){
            if(-not $run.backupRun){ continue }

            $backupRun = $run.backupRun

            # Only job-level running runs
            if($backupRun.status -ne 'kRunning'){ continue }

            $startUsecs = $backupRun.stats.startTimeUsecs
            $startUtc   = Convert-ToUtcFromEpoch $startUsecs
            if($null -eq $startUtc){ continue }

            $hoursRunning = ([DateTime]::UtcNow - $startUtc).TotalHours
            if($hoursRunning -lt $thresholdHours){ continue }

            $startLocal = Convert-ToLocalFromUsecs $startUsecs $tz
            $startText  = if($startLocal){ $startLocal.ToString("dd-MM-yyyy HH:mm:ss") } else { "<unknown>" }

            $runTypeRaw = $backupRun.runType
            $runType    = if($runTypeRaw -and $runTypeRaw.StartsWith('k')){ $runTypeRaw.Substring(1) } else { $runTypeRaw }

            $envRaw = $job.environment
            $env    = if($envRaw){ $envRaw } else { "Unknown" }

            if(-not $run.copyRun){ continue }

            $durationStr = Format-Duration -Hours $hoursRunning
            $hoursRounded = [math]::Round($hoursRunning,2)

            foreach($copyRun in $run.copyRun){
                if(-not $copyRun){ continue }
                if($copyRun.status -in $finishedStates){ continue }

                $targetTypeRaw = $copyRun.target.type
                if(-not $targetTypeRaw){ $targetTypeRaw = 'kLocal' }

                $targetType = if($targetTypeRaw.StartsWith('k')){ $targetTypeRaw.Substring(1) } else { $targetTypeRaw }

                $statusRaw = $copyRun.status
                $status    = if($statusRaw -and $statusRaw.StartsWith('k')){ $statusRaw.Substring(1) } else { $statusRaw }

                $results.Add([pscustomobject]@{
                    Cluster         = $cluster_name
                    ProtectionGroup = $jobName
                    Environment     = $env          # kSQL, kOracle, kGenericNas, etc.
                    TargetType      = $targetType   # Local / Remote / Archival / ...
                    RunType         = $runType      # RegularBackup / Full / ...
                    StartTime       = $startText
                    HoursRunning    = $hoursRounded
                    Duration        = $durationStr
                    Status          = $status
                }) | Out-Null
            }
        }
    }
}

# -------------------------------
# Split Backup vs Replication/Archival
# -------------------------------
if($results.Count -eq 0){
    Write-Host ("`n‚úÖ No jobs running longer than {0} hours were found on any cluster." -f $thresholdHours) -ForegroundColor Green
    return
}

$sorted = $results | Sort-Object Cluster,ProtectionGroup,StartTime -Descending

$backupRows = $sorted | Where-Object { $_.TargetType -eq 'Local' }
$replRows   = $sorted | Where-Object { $_.TargetType -ne 'Local' }

$timestamp     = Get-Date -Format "yyyyMMdd_HHmm"
$backupCsvPath = Join-Path $logDirectory ("LongRunningJobs_Backup_Over{0}h_{1}.csv" -f [int]$thresholdHours,$timestamp)
$replCsvPath   = Join-Path $logDirectory ("LongRunningJobs_Replication_Over{0}h_{1}.csv" -f [int]$thresholdHours,$timestamp)

# -------------------------------
# BACKUP (Local) table + CSV
# -------------------------------
if($backupRows.Count -gt 0){
    $backupRows |
        Select-Object Cluster,ProtectionGroup,Environment,RunType,StartTime,Duration,HoursRunning,Status |
        Export-Csv -Path $backupCsvPath -NoTypeInformation -Encoding utf8

    Write-Host ("`nJobs running longer than {0} hours ‚Äì BACKUP (Local):`n" -f $thresholdHours) -ForegroundColor Cyan
    $backupRows |
        Select-Object Cluster,ProtectionGroup,Environment,RunType,StartTime,Duration |
        Format-Table -AutoSize

    Write-Host ("`nüìÇ Backup CSV saved: {0}" -f $backupCsvPath) -ForegroundColor Gray
}else{
    Write-Host ("`nNo backup jobs running longer than {0} hours." -f $thresholdHours) -ForegroundColor Green
}

# -------------------------------
# REPLICATION / ARCHIVAL table + CSV
# -------------------------------
if($replRows.Count -gt 0){
    $replRows |
        Select-Object Cluster,ProtectionGroup,Environment,TargetType,RunType,StartTime,Duration,HoursRunning,Status |
        Export-Csv -Path $replCsvPath -NoTypeInformation -Encoding utf8

    Write-Host ("`nJobs running longer than {0} hours ‚Äì REPLICATION / ARCHIVAL (Remote/Archival):`n" -f $thresholdHours) -ForegroundColor Cyan
    $replRows |
        Select-Object Cluster,ProtectionGroup,Environment,TargetType,RunType,StartTime,Duration |
        Format-Table -AutoSize

    Write-Host ("`nüìÇ Replication CSV saved: {0}" -f $replCsvPath) -ForegroundColor Gray
}else{
    Write-Host ("`nNo replication/archival jobs running longer than {0} hours." -f $thresholdHours) -ForegroundColor Green
}

Write-Host "`n‚úÖ Long-running job check complete!" -ForegroundColor Green
