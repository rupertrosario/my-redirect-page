# =====================================================================
# Cohesity Backup Failures ‚Äì Multi-Cluster (Helios)
# Menu-driven | Verbose/Silent | CSV only when failures exist (UTF-8)
#
# Environments handled:
#   2 Oracle (kOracle, kDatabase)     ‚Üí Columns: Hosts, DatabaseName ("DB Host" for host-only)
#   3 SQL    (kSQL, kDatabase)        ‚Üí Columns: Hosts, DatabaseName ("DB Host" for host-only)
#   4 Physical (kPhysical, kHost)     ‚Üí Fallback to run-level messages when no failedAttempts
#   5 NAS (kGenericNas,kIsilon,kHost) ‚Üí Fallback to run-level messages when no failedAttempts
#   6 HyperV (kHyperV, kVirtualMachine)
#   7 Acropolis (kAcropolis, kVirtualMachine)
#   8 RemoteAdapter (kRemoteAdapter)  ‚Üí latest Failed WITHOUT later Success
#
# Unified rule (all but RemoteAdapter):
#   - For each PG and RunType ‚Üí take latest run
#   - Skip if latest run status ‚àà {Succeeded, SucceededWithWarning}
#   - Prefer object.localSnapshotInfo.failedAttempts[]; for Physical/NAS
#     fall back to run-level messages if none found.
# =====================================================================

# ---------- Setup ----------
$logDirectory = "X:\PowerShell\Data\Cohesity\BackupFailures"
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory | Out-Null
}
# keep max 50 logs
$fileCount = (Get-ChildItem -Path $logDirectory -File).Count
if ($fileCount -gt 50) {
    Get-ChildItem -Path $logDirectory -File |
        Sort-Object CreationTime |
        Select-Object -First ($fileCount - 50) |
        Remove-Item -Force
}

# API key
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found: $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()
$commonHeaders = @{ "apiKey" = $apiKey }
$baseUrl = "https://helios.cohesity.com"

# ---------- Helpers ----------
function Convert-ToUtcFromEpoch($v){
    if ($null -eq $v -or $v -eq 0) { return $null }
    try { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$v/1000)).UtcDateTime }
    catch { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$v).UtcDateTime }
}
function Convert-ToLocalFromUsecs($usecs, $tz){
    $utc = Convert-ToUtcFromEpoch $usecs
    if ($null -eq $utc) { return $null }
    if ($tz) { [System.TimeZoneInfo]::ConvertTimeFromUtc($utc,$tz) } else { $utc.ToLocalTime() }
}
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")
function Write-IfVerbose($msg,$color="Gray"){ if($script:VerboseMode){ Write-Host $msg -ForegroundColor $color } }
function Print-Line($msg,$color="Gray"){ Write-Host $msg -ForegroundColor $color }

# ---------- Get clusters ----------
$response = Invoke-WebRequest -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders -Method Get
$json_clu = ($response.Content | ConvertFrom-Json).cohesityClusters
if (-not $json_clu) { throw "No clusters returned from Helios." }

# ---------- Menu ----------
Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "   COHESITY BACKUP FAILURES ‚Äì MAIN MENU" -ForegroundColor White
Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "1.  All Environments"
Write-Host "2.  Oracle"
Write-Host "3.  SQL"
Write-Host "4.  Physical (File System)"
Write-Host "5.  NAS (GenericNas/Isilon)"
Write-Host "6.  Hyper-V"
Write-Host "7.  Acropolis (AHV)"
Write-Host "8.  Remote Adapter"
Write-Host "---------------------------------------------"
$choice = Read-Host "Enter your choice(s) (e.g. 2,3,4)"

Write-Host "`nSelect Mode:" -ForegroundColor Yellow
Write-Host "1. Verbose (progress, successes, no-failure lines)"
Write-Host "2. Silent  (only failure tables + CSV lines)"
$modeChoice = Read-Host "Enter mode [1 or 2]"
$script:VerboseMode = $modeChoice -eq "1"

# ---------- Environment map ----------
$envMap = @{
    2 = @{ Label="Oracle";        Filter="kOracle";                 Object="kDatabase";       NameField="name"; ParentHostNeeded=$true;  AllowRunFallback=$false }
    3 = @{ Label="SQL";           Filter="kSQL";                    Object="kDatabase";       NameField="name"; ParentHostNeeded=$true;  AllowRunFallback=$false }
    4 = @{ Label="Physical";      Filter="kPhysical";               Object="kHost";           NameField="name"; ParentHostNeeded=$false; AllowRunFallback=$true  }  # Fallback ON
    5 = @{ Label="NAS";           Filter="kGenericNas,kIsilon";     Object="kHost";           NameField="name"; ParentHostNeeded=$false; AllowRunFallback=$true  }  # Fallback ON
    6 = @{ Label="HyperV";        Filter="kHyperV";                 Object="kVirtualMachine"; NameField="name"; ParentHostNeeded=$false; AllowRunFallback=$false }
    7 = @{ Label="Acropolis";     Filter="kAcropolis";              Object="kVirtualMachine"; NameField="name"; ParentHostNeeded=$false; AllowRunFallback=$false }
    8 = @{ Label="RemoteAdapter"; Filter="kRemoteAdapter";          Object="kRemoteAdapter";  NameField="name"; ParentHostNeeded=$false; AllowRunFallback=$false }
}

# =====================================================================
# Collectors
# =====================================================================

# --- Unified collector (ALL except RemoteAdapter) ---
function Collect-EnvLatestFailedWithObjectAttempts {
    param(
        [string]$Label,
        [string]$Filter,          # comma-separated envs
        [string]$ObjectType,      # object.objectType to pick
        [string]$NameField,       # property on object to display
        [bool]  $ParentHostNeeded,# Oracle/SQL parent host mapping via sourceId
        [bool]  $AllowRunFallback # Physical/NAS: allow run-level message fallback
    )

    $globalFailures = @()
    $filterSet = $Filter.Split(',') | ForEach-Object { $_.Trim() }

    foreach($cluster in $json_clu){
        $cluster_name = ($cluster.name,$cluster.clusterName,$cluster.displayName | Where-Object {$_ -and $_.Trim()} | Select-Object -First 1)
        if(-not $cluster_name){$cluster_name="Unknown-$($cluster.clusterId)"}
        $headers=@{apiKey=$apiKey;accessClusterId=$cluster.clusterId}
        Write-IfVerbose ("`nüîπ Processing cluster: {0}" -f $cluster_name) "Cyan"

        # PG list for this environment
        try{
            $pgResp=Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups" -Headers $headers -Body @{
                environments=$Filter;isDeleted="False";isPaused="False";isActive="True"} -Method Get
            $pgs=($pgResp.Content|ConvertFrom-Json).protectionGroups
        }catch{ continue }
        if(-not $pgs){ continue }

        foreach($pg in $pgs){
            $pgId=$pg.id;$pgName=$pg.name
            Write-IfVerbose ("üì¶ Checking PG: {0}" -f $pgName) "Yellow"

            # Get last 10 runs with object details
            try{
                $runResp=Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" -Headers $headers -Body @{
                    environments=$Filter;numRuns="10";excludeNonRestorableRuns="False";includeObjectDetails="True"} -Method Get
                $jsonRuns=$runResp|ConvertFrom-Json
            }catch{ continue }
            if(-not $jsonRuns.runs){ continue }

            $runs = $jsonRuns.runs
            $runTypes = $runs.localBackupInfo.runType | Select-Object -Unique

            foreach($rType in $runTypes){
                $latestRun = $runs |
                    Where-Object { $_.localBackupInfo[0].runType -eq $rType } |
                    Sort-Object { $_.localBackupInfo[0].endTimeUsecs } -Descending |
                    Select-Object -First 1
                if(-not $latestRun){ continue }

                $info       = $latestRun.localBackupInfo[0]
                $status     = $info.status
                $runType    = $info.runType
                $startLocal = Convert-ToLocalFromUsecs $info.startTimeUsecs $tz
                $endLocal   = Convert-ToLocalFromUsecs $info.endTimeUsecs   $tz

                if($endLocal){ Write-IfVerbose ("   üïì Latest Run Date: {0}" -f $endLocal.ToString('dd-MMM-yyyy HH:mm:ss')) "DarkGray" }

                # Skip if latest run succeeded
                if ($status -eq "Succeeded" -or $status -eq "SucceededWithWarning") {
                    Write-IfVerbose ("‚úÖ {0} ‚Üí {1} [{2}] ‚Äì Latest run succeeded" -f $cluster_name,$pgName,$rType) "Green"
                    continue
                }

                if(-not $latestRun.objects){ continue }

                # Build id->name map for ParentHost resolving (Oracle/SQL)
                $idToName = @{}
                if($ParentHostNeeded){
                    foreach($ob in $latestRun.objects){
                        if($ob.object -and $ob.object.id){
                            $idToName[[string]$ob.object.id] = $ob.object.name
                        }
                    }
                }

                # Filter only the object type we care about and env in filterSet
                $objs = $latestRun.objects | Where-Object {
                    $_.object.objectType -eq $ObjectType -and $_.object.environment -in $filterSet
                }

                $addedAnyObject = $false

                if($ParentHostNeeded){
                    # ----- Oracle/SQL: Hosts + DatabaseName -----
                    foreach($o in $objs){
                        $attempts = $o.localSnapshotInfo.failedAttempts
                        if(-not $attempts -or $attempts.Count -eq 0){ continue }

                        $parent = $null
                        if($o.object -and $o.object.sourceId){
                            $key = [string]$o.object.sourceId
                            if($idToName.ContainsKey($key)){ $parent = $idToName[$key] }
                        }

                        foreach($fa in $attempts){
                            $msgClean = ($fa.message -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                            $globalFailures += [pscustomobject]@{
                                Cluster         = $cluster_name
                                ProtectionGroup = $pgName
                                Environment     = $Label
                                RunType         = $runType
                                Hosts           = $parent
                                DatabaseName    = $o.object.$NameField
                                StartTime       = $startLocal
                                EndTime         = $endLocal
                                FailedMessage   = $msgClean
                            }
                            $addedAnyObject = $true
                        }
                    }

                    # Host-only failures (no DBs discovered)
                    $hostObjs = $latestRun.objects | Where-Object { $_.object.objectType -eq 'kHost' }
                    foreach($h in $hostObjs){
                        $hattempts = $h.localSnapshotInfo.failedAttempts
                        if(-not $hattempts -or $hattempts.Count -eq 0){ continue }
                        foreach($fa in $hattempts){
                            $msgClean = ($fa.message -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                            $globalFailures += [pscustomobject]@{
                                Cluster         = $cluster_name
                                ProtectionGroup = $pgName
                                Environment     = $Label
                                RunType         = $runType
                                Hosts           = $h.object.name
                                DatabaseName    = "DB Host"
                                StartTime       = $startLocal
                                EndTime         = $endLocal
                                FailedMessage   = $msgClean
                            }
                            $addedAnyObject = $true
                        }
                    }
                }
                else{
                    # ----- Physical/NAS/HyperV/AHV: Name (+ optional ParentHost=null) -----
                    foreach($o in $objs){
                        $attempts = $o.localSnapshotInfo.failedAttempts
                        if(-not $attempts -or $attempts.Count -eq 0){ continue }
                        foreach($fa in $attempts){
                            $msgClean = ($fa.message -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                            $globalFailures += [pscustomobject]@{
                                Cluster         = $cluster_name
                                ProtectionGroup = $pgName
                                Environment     = $Label
                                RunType         = $runType
                                Name            = $o.object.$NameField
                                ParentHost      = $null
                                StartTime       = $startLocal
                                EndTime         = $endLocal
                                FailedMessage   = $msgClean
                            }
                            $addedAnyObject = $true
                        }
                    }
                }

                # ---- Run-level fallback (ONLY for Physical/NAS) ----
                if(-not $addedAnyObject -and $AllowRunFallback){
                    $runMsg = $null
                    if($info.messages){
                        if($info.messages -is [System.Array]){ $runMsg = ($info.messages -join ' | ') } else { $runMsg = [string]$info.messages }
                    } else { $runMsg = "Run failed (no per-object failedAttempts[] present)" }

                    # Emit one line per host object (visible in the run) to show where it failed
                    $hostLike = $latestRun.objects | Where-Object { $_.object.objectType -eq 'kHost' -and $_.object.environment -in $filterSet }
                    if(-not $hostLike){ $hostLike = @(@{ object = @{ name = "(run-level)" } }) }

                    foreach($h in $hostLike){
                        $globalFailures += [pscustomobject]@{
                            Cluster         = $cluster_name
                            ProtectionGroup = $pgName
                            Environment     = $Label
                            RunType         = $runType
                            Name            = $h.object.name
                            ParentHost      = $null
                            StartTime       = $startLocal
                            EndTime         = $endLocal
                            FailedMessage   = ($runMsg -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                        }
                    }
                }
            }
        }
    }

    # De-dup and return
    if($globalFailures.Count -gt 0){
        $globalFailures = $globalFailures |
            Group-Object {
                if($_.PSObject.Properties.Name -contains 'Hosts'){
                    "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.Hosts)|$($_.DatabaseName)|$($_.FailedMessage)|$($_.EndTime)"
                } else {
                    "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.Name)|$($_.ParentHost)|$($_.FailedMessage)|$($_.EndTime)"
                }
            } |
            ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 }

        $sorted    = $globalFailures | Sort-Object Cluster,ProtectionGroup,EndTime -Descending
        $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
        $csvPath   = "$logDirectory\BackupFailures_${Label}_AllClusters_$timestamp.csv"
        $sorted    | Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8
        return [pscustomobject]@{ Rows = $sorted; Csv = $csvPath }
    } else {
        return [pscustomobject]@{ Rows = @(); Csv = $null }
    }
}

# --- RemoteAdapter: latest Failed WITHOUT later Success ---
function Collect-RemoteAdapter {
    $Label = "RemoteAdapter"
    $globalFailures = @()

    foreach ($clus in $json_clu) {
        $cluster_name = ($clus.name, $clus.clusterName, $clus.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
        if (-not $cluster_name) { $cluster_name = "Unknown-$($clus.clusterId)" }
        $headers = @{ apiKey=$apiKey; accessClusterId=$clus.clusterId }

        try {
            $pgResp = Invoke-WebRequest -Method Get -Uri "$baseUrl/v2/data-protect/protection-groups" -Headers $headers -Body @{
                environments = "kRemoteAdapter"; isDeleted = "False"; isPaused = "False"; isActive = "True"
            }
            $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
        } catch { continue }
        if (-not $pgs) { continue }

        foreach ($pg in $pgs) {
            $pgId = $pg.id; $pgName = $pg.name

            $HostName = $null; $DB_name = $null
            try {
                $HostName = $pg.remoteAdapterParams.hosts.hostname
                if ($HostName -is [System.Array]) { $HostName = ($HostName -join ',') }
                $args = $pg.remoteAdapterParams.hosts.incrementalBackupScript.params
                if ($args -is [System.Array]) { $args = ($args -join ' ') }
                if ($args -match "-o\s+(\S+)") { $DB_name = $matches[1] }
            } catch { }

            try {
                $runResp = Invoke-WebRequest -Method Get -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" -Headers $headers -Body @{
                    environments             = "kRemoteAdapter"
                    isDeleted                = "False"
                    isPaused                 = "False"
                    isActive                 = "True"
                    numRuns                  = "10"
                    excludeNonRestorableRuns = "False"
                    includeObjectDetails     = "True"
                }
                $json = $runResp | ConvertFrom-Json
            } catch { continue }

            $runs = if ($json -and $json.runs) { $json.runs } else { @() }
            if (-not $runs) { continue }

            $flatRuns = @()
            foreach ($run in $runs) {
                if ($run.localBackupInfo) {
                    foreach ($info in $run.localBackupInfo) {
                        $flatRuns += [pscustomobject]@{
                            RunType         = $info.runType
                            Status          = $info.status
                            Message         = $info.messages
                            StartTimeUsecs  = $info.startTimeUsecs
                            EndTimeUsecs    = $info.endTimeUsecs
                            Cluster         = $cluster_name
                            ProtectionGroup = $pgName
                            HostName        = $HostName
                            DB_name         = $DB_name
                        }
                    }
                }
            }
            if (-not $flatRuns) { continue }

            $grouped = $flatRuns | Group-Object RunType
            foreach ($g in $grouped) {
                $latestFailed = $g.Group |
                    Where-Object { $_.Status -eq 'Failed' } |
                    Sort-Object EndTimeUsecs -Descending |
                    Select-Object -First 1
                if ($null -eq $latestFailed) { continue }

                $hasLaterSuccess = $g.Group | Where-Object {
                    $_.Status -in @('Succeeded','SucceededWithWarning') -and
                    $_.StartTimeUsecs -gt $latestFailed.EndTimeUsecs
                }
                if ($hasLaterSuccess) { continue }

                $startLocal = Convert-ToLocalFromUsecs $latestFailed.StartTimeUsecs $tz
                $endLocal   = Convert-ToLocalFromUsecs $latestFailed.EndTimeUsecs   $tz
                $msg = $latestFailed.Message
                if ($msg -is [System.Array]) { $msg = ($msg -join ' | ') }

                $globalFailures += [pscustomobject]@{
                    Cluster         = $latestFailed.Cluster
                    ProtectionGroup = $latestFailed.ProtectionGroup
                    Environment     = $Label
                    RunType         = $latestFailed.RunType
                    Name            = if ($latestFailed.DB_name) { $latestFailed.DB_name } else { $latestFailed.HostName }
                    ParentHost      = $null
                    StartTime       = $startLocal
                    EndTime         = $endLocal
                    FailedMessage   = $msg
                }
            }
        }
    }

    if ($globalFailures.Count -gt 0) {
        $dedup = $globalFailures |
            Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.Name)|$($_.FailedMessage)|$($_.EndTime)" } |
            ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 }

        $rows = $dedup | Sort-Object Cluster,ProtectionGroup,EndTime -Descending
        $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
        $csvPath   = Join-Path $logDirectory "BackupFailures_RemoteAdapter_AllClusters_$timestamp.csv"
        $rows | Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8

        return [pscustomobject]@{ Rows = $rows; Csv = $csvPath }
    } else {
        return [pscustomobject]@{ Rows = @(); Csv = $null }
    }
}

# =====================================================================
# Run menu selection
# =====================================================================
$summary   = New-Object System.Collections.ArrayList
$allTables = New-Object System.Collections.ArrayList

function Add-SummaryLine($label,$csv){
    $csvText = if ($csv -and -not ([string]::IsNullOrWhiteSpace($csv))) { [string]$csv } else { "No failures (no CSV)" }
    $null = $summary.Add(("{0}: {1}" -f $label, $csvText))
}

function Show-Table {
    param($label,$rows,$csvPath)
    if($rows.Count -gt 0){
        Print-Line ("`nüî• Latest Failed {0} Runs (All Clusters):`n" -f $label) "Cyan"
        # Auto-pick Oracle/SQL column set if present
        $hasOracleShape = ($rows[0].PSObject.Properties.Name -contains 'Hosts' -and $rows[0].PSObject.Properties.Name -contains 'DatabaseName')
        if($hasOracleShape){
            $rows | Select-Object Cluster,ProtectionGroup,RunType,Hosts,DatabaseName,StartTime,EndTime,FailedMessage |
                    Format-Table -AutoSize
        } else {
            $rows | Select-Object Cluster,ProtectionGroup,Environment,RunType,Name,ParentHost,StartTime,EndTime,FailedMessage |
                    Format-Table -AutoSize
        }
        if($csvPath){ Print-Line ("`nüìÇ CSV saved: {0}" -f $csvPath) "Gray" }
        Add-SummaryLine $label $csvPath
    } else {
        if($script:VerboseMode){
            Print-Line ("‚úÖ No failures found for {0} (All Clusters)" -f $label) "Green"
        }
        Add-SummaryLine $label $null
    }
}

if($choice -eq "1"){
    Print-Line "`n‚ñ∂ Running ALL environments..." "Cyan"
    foreach($key in ($envMap.Keys|Sort-Object)){
        $env=$envMap[$key]
        Print-Line "`n==============================" "DarkCyan"
        Print-Line ("‚ñ∂ Environment: {0}" -f $env.Label) "Cyan"
        Print-Line "==============================" "DarkCyan"

        $res = if     ($env.Label -eq "RemoteAdapter") { Collect-RemoteAdapter }
               else { Collect-EnvLatestFailedWithObjectAttempts -Label $env.Label -Filter $env.Filter -ObjectType $env.Object -NameField $env.NameField -ParentHostNeeded:$env.ParentHostNeeded -AllowRunFallback:$env.AllowRunFallback }

        Show-Table -label $env.Label -rows $res.Rows -csvPath $res.Csv
        if($res.Rows.Count -gt 0){ $allTables.AddRange($res.Rows) | Out-Null }
    }

    if($allTables.Count -gt 0){
        Print-Line "`nüî• Combined Failures ‚Äì All Environments" "Magenta"
        $sortedAll=$allTables|Sort-Object Cluster,ProtectionGroup,Environment,EndTime -Descending
        $timestamp=Get-Date -Format "yyyyMMdd_HHmm"
        $combinedPath="$logDirectory\BackupFailures_AllEnvironments_$timestamp.csv"
        $sortedAll|Export-Csv -Path $combinedPath -NoTypeInformation -Encoding utf8
        Print-Line ("üìÇ Combined CSV saved: {0}" -f $combinedPath) "Gray"
        $null=$summary.Add(("All Environments: {0}" -f $combinedPath))
    } else {
        if($script:VerboseMode){
            Print-Line "`n‚úÖ All environments succeeded ‚Äî no combined CSV created." "Green"
        }
        $null=$summary.Add("All Environments: No failures (no CSV)")
    }
}
else{
    $selected=$choice.Split(',')|ForEach-Object{$_.Trim()}|Where-Object{$_ -match '^\d+$'}
    foreach($sel in $selected){
        if($envMap.ContainsKey([int]$sel)){
            $env=$envMap[[int]$sel]
            Print-Line ("`n‚ñ∂ Running environment: {0}" -f $env.Label) "Cyan"
            $res = if     ($env.Label -eq "RemoteAdapter") { Collect-RemoteAdapter }
                   else { Collect-EnvLatestFailedWithObjectAttempts -Label $env.Label -Filter $env.Filter -ObjectType $env.Object -NameField $env.NameField -ParentHostNeeded:$env.ParentHostNeeded -AllowRunFallback:$env.AllowRunFallback }
            Show-Table -label $env.Label -rows $res.Rows -csvPath $res.Csv
        } else {
            Print-Line ("‚ö†Ô∏è Invalid selection: {0}" -f $sel) "Yellow"
        }
    }
}

# ---------- Final summary ----------
Write-Host "`n==============================" -ForegroundColor Cyan
Write-Host "          SUMMARY" -ForegroundColor White
Write-Host "==============================" -ForegroundColor Cyan
foreach($line in $summary){ Write-Host $line }
Write-Host "=============================="
Write-Host "‚úÖ Processing complete!" -ForegroundColor Green
