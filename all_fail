# =====================================================================
# Cohesity Backup Failures ‚Äì Multi-Cluster (Helios)
# Menu-driven | Verbose/Silent | CSV only when failures exist (UTF-8)
# Environments: Oracle, SQL, Physical, NAS, HyperV, Acropolis, RemoteAdapter
# Speed-ups:
#   - Menu & mode FIRST, network AFTER
#   - HTTP timeouts
#   - Throttle runs per PG
#   - Optional "Fast (Silent)" mode in one keystroke
# =====================================================================

# ---------- Tunables ----------
$logDirectory   = "X:\PowerShell\Data\Cohesity\BackupFailures"
$apikeypath     = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
$baseUrl        = "https://helios.cohesity.com"
$HttpTimeoutSec = 20              # per HTTP call
$MaxRunsPerPG   = 6               # lower = faster; raise if needed (was 10)
$tz             = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")

# ---------- Ensure folder + housekeeping ----------
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory | Out-Null
}
# keep at most 50 newest files
$files = Get-ChildItem -Path $logDirectory -File -ErrorAction SilentlyContinue |
         Sort-Object LastWriteTime -Descending
if ($files -and ($files.Count -gt 50)) {
    $toDelete = $files | Select-Object -Last ($files.Count - 50)
    if ($toDelete) { $toDelete | Remove-Item -Force -ErrorAction SilentlyContinue }
}
# delete anything older than 30 days
Get-ChildItem -Path $logDirectory -File -ErrorAction SilentlyContinue |
    Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-30) } |
    Remove-Item -Force -ErrorAction SilentlyContinue

# ---------- API key (no network yet) ----------
if (-not (Test-Path $apikeypath)) { throw "API key file not found: $apikeypath" }
$apiKey        = (Get-Content -Path $apikeypath -Raw).Trim()
$commonHeaders = @{ "apiKey" = $apiKey }

# ---------- Helpers ----------
function Convert-ToUtcFromEpoch($v){
    if ($null -eq $v -or $v -eq 0) { return $null }
    try { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$v/1000)).UtcDateTime }
    catch { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$v).UtcDateTime }
}
function Usecs-ToLocal($usecs){
    $utc = Convert-ToUtcFromEpoch $usecs
    if ($null -eq $utc) { return $null }
    [System.TimeZoneInfo]::ConvertTimeFromUtc($utc, $tz)
}
function Write-Log($msg,$color="Gray"){ if($script:VerboseMode){ Write-Host $msg -ForegroundColor $color } }

# ---------- HTTP wrappers with timeout ----------
function GET-Web($uri, $headers, $body = $null){
    if ($body) {
        return Invoke-WebRequest -Uri $uri -Headers $headers -Body $body -Method Get -TimeoutSec $HttpTimeoutSec
    } else {
        return Invoke-WebRequest -Uri $uri -Headers $headers -Method Get -TimeoutSec $HttpTimeoutSec
    }
}

# ---------- Common fetchers (lazy; called after menu) ----------
function Get-Clusters {
    $resp = GET-Web "$baseUrl/v2/mcm/cluster-mgmt/info" $commonHeaders
    $data = ($resp.Content | ConvertFrom-Json).cohesityClusters
    if (-not $data) { throw "No clusters returned from Helios." }
    return $data
}
function Get-EnvPGs($headers, [string]$envCsv){
    $resp = GET-Web "$baseUrl/v2/data-protect/protection-groups" $headers @{
        environments=$envCsv; isDeleted="False"; isPaused="False"; isActive="True"
    }
    return ($resp.Content | ConvertFrom-Json).protectionGroups
}
function Get-PGRuns($headers, $pgId, [string]$envCsv){
    $resp = GET-Web "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" $headers @{
        environments             = $envCsv
        isDeleted                = "False"
        isPaused                 = "False"
        isActive                 = "True"
        numRuns                  = [string]$MaxRunsPerPG
        excludeNonRestorableRuns = "False"
        includeObjectDetails     = "True"
    }
    return ($resp | ConvertFrom-Json)
}

# =====================================================================
# Collectors (unchanged logic; just using timeout + throttled runs)
# =====================================================================

# ---- Oracle / SQL (Hosts + DatabaseName, host-level discovery rows when no DBs) ----
function Collect-OracleSql {
    param([string]$Label, [string]$EnvFilter, $Clusters)  # EnvFilter = kOracle / kSQL
    $rows = @()

    foreach($clus in $Clusters){
        $clusterName = ($clus.name, $clus.clusterName, $clus.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
        if (-not $clusterName) { $clusterName = "Unknown-$($clus.clusterId)" }
        $headers = @{ apiKey=$apiKey; accessClusterId=$clus.clusterId }
        Write-Log ("`nüîπ Cluster: {0}" -f $clusterName) "Cyan"

        try { $pgs = Get-EnvPGs $headers $EnvFilter } catch { continue }
        if (-not $pgs) { continue }

        foreach($pg in $pgs){
            $pgId=$pg.id; $pgName=$pg.name
            Write-Log ("üì¶ PG: {0}" -f $pgName) "DarkYellow"
            try { $jsonRuns = Get-PGRuns $headers $pgId $EnvFilter } catch { continue }
            if (-not $jsonRuns.runs) { continue }

            $runs    = $jsonRuns.runs
            $rTypes  = $runs.localBackupInfo.runType | Select-Object -Unique
            foreach($r in $rTypes){
                $latest = $runs | Where-Object { $_.localBackupInfo[0].runType -eq $r } |
                                  Sort-Object { $_.localBackupInfo[0].endTimeUsecs } -Descending |
                                  Select-Object -First 1
                if (-not $latest) { continue }

                $info = $latest.localBackupInfo[0]
                $status = $info.status
                $runType = $info.runType
                $startLocal = Usecs-ToLocal $info.startTimeUsecs
                $endLocal   = Usecs-ToLocal $info.endTimeUsecs

                if ($status -eq "Succeeded" -or $status -eq "SucceededWithWarning") { continue }
                if (-not $latest.objects) { continue }

                $dbObjs   = $latest.objects | Where-Object { $_.object.objectType -eq 'kDatabase' }
                $hostObjs = $latest.objects | Where-Object { $_.object.objectType -eq 'kHost' -and $_.object.environment -eq 'kPhysical' }

                # Build map sourceId->hostName
                $idToName = @{}
                foreach($h in $hostObjs){
                    if($h.object -and $h.object.id){
                        $idToName[[string]$h.object.id] = $h.object.name
                    }
                }

                # DB-level failures
                foreach($db in $dbObjs){
                    $attempts = $db.localSnapshotInfo.failedAttempts
                    if (-not $attempts) { continue }

                    $hostName = $null
                    if ($db.object -and $db.object.sourceId) {
                        $key = [string]$db.object.sourceId
                        if($idToName.ContainsKey($key)){ $hostName = $idToName[$key] }
                    }

                    foreach($fa in $attempts){
                        $msg = ($fa.message -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                        $rows += [pscustomobject]@{
                            Cluster         = $clusterName
                            ProtectionGroup = $pgName
                            RunType         = $runType
                            Hosts           = $hostName
                            DatabaseName    = $db.object.name
                            StartTime       = $startLocal
                            EndTime         = $endLocal
                            FailedMessage   = $msg
                        }
                    }
                }

                # Host-level (discovery/pre-DB) failures
                foreach($h in $hostObjs){
                    $attempts = $h.localSnapshotInfo.failedAttempts
                    if (-not $attempts) { continue }
                    $alreadyHostRow = $rows | Where-Object {
                        $_.Cluster -eq $clusterName -and $_.ProtectionGroup -eq $pgName -and
                        $_.RunType -eq $runType -and $_.Hosts -eq $h.object.name -and $_.EndTime -eq $endLocal
                    }
                    foreach($fa in $attempts){
                        if ($alreadyHostRow) { break }
                        $msg = ($fa.message -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                        $rows += [pscustomobject]@{
                            Cluster         = $clusterName
                            ProtectionGroup = $pgName
                            RunType         = $runType
                            Hosts           = $h.object.name
                            DatabaseName    = "No DBs Found (Host-Level Failure)"
                            StartTime       = $startLocal
                            EndTime         = $endLocal
                            FailedMessage   = $msg
                        }
                    }
                }
            }
        }
    }

    if ($rows.Count -gt 0) {
        $rows = $rows |
            Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.Hosts)|$($_.DatabaseName)|$($_.FailedMessage)|$($_.EndTime)" } |
            ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 } |
            Sort-Object Cluster,ProtectionGroup,EndTime -Descending
        $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
        $csv       = Join-Path $logDirectory "BackupFailures_${Label}_AllClusters_$timestamp.csv"
        $rows | Export-Csv -Path $csv -NoTypeInformation -Encoding utf8
        return [pscustomobject]@{ Rows=$rows; Csv=$csv }
    } else {
        return [pscustomobject]@{ Rows=@(); Csv=$null }
    }
}

# ---- Physical (kPhysical, kHost) ‚Äì ONLY object-level failedAttempts ----
function Collect-Physical { param($Clusters)
    $rows  = @()
    foreach($clus in $Clusters){
        $clusterName = ($clus.name, $clus.clusterName, $clus.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
        if (-not $clusterName) { $clusterName = "Unknown-$($clus.clusterId)" }
        $headers = @{ apiKey=$apiKey; accessClusterId=$clus.clusterId }

        try { $pgs = Get-EnvPGs $headers "kPhysical" } catch { continue }
        if (-not $pgs) { continue }

        foreach($pg in $pgs){
            try { $jsonRuns = Get-PGRuns $headers $pg.id "kPhysical" } catch { continue }
            if (-not $jsonRuns.runs) { continue }

            $runs   = $jsonRuns.runs
            $rTypes = $runs.localBackupInfo.runType | Select-Object -Unique
            foreach($r in $rTypes){
                $latest = $runs | Where-Object { $_.localBackupInfo[0].runType -eq $r } |
                                  Sort-Object { $_.localBackupInfo[0].endTimeUsecs } -Descending |
                                  Select-Object -First 1
                if (-not $latest) { continue }
                $info = $latest.localBackupInfo[0]
                if ($info.status -eq "Succeeded" -or $info.status -eq "SucceededWithWarning") { continue }
                $startLocal = Usecs-ToLocal $info.startTimeUsecs
                $endLocal   = Usecs-ToLocal $info.endTimeUsecs

                $objs = $latest.objects | Where-Object { $_.object.objectType -eq 'kHost' -and $_.object.environment -eq 'kPhysical' }
                foreach($o in $objs){
                    $attempts = $o.localSnapshotInfo.failedAttempts
                    if (-not $attempts) { continue }
                    foreach($fa in $attempts){
                        $msg = ($fa.message -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                        $rows += [pscustomobject]@{
                            Cluster         = $clusterName
                            ProtectionGroup = $pg.name
                            RunType         = $info.runType
                            Name            = $o.object.name
                            StartTime       = $startLocal
                            EndTime         = $endLocal
                            FailedMessage   = $msg
                        }
                    }
                }
            }
        }
    }
    if ($rows.Count -gt 0) {
        $rows = $rows |
            Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.Name)|$($_.FailedMessage)|$($_.EndTime)" } |
            ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 } |
            Sort-Object Cluster,ProtectionGroup,EndTime -Descending
        $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
        $csv       = Join-Path $logDirectory "BackupFailures_Physical_AllClusters_$timestamp.csv"
        $rows | Export-Csv -Path $csv -NoTypeInformation -Encoding utf8
        return [pscustomobject]@{ Rows=$rows; Csv=$csv }
    } else { return [pscustomobject]@{ Rows=@(); Csv=$null } }
}

# ---- NAS (kGenericNas, kIsilon) ----
function Collect-NAS { param($Clusters)
    $rows  = @()
    foreach($clus in $Clusters){
        $clusterName = ($clus.name, $clus.clusterName, $clus.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
        if (-not $clusterName) { $clusterName = "Unknown-$($clus.clusterId)" }
        $headers = @{ apiKey=$apiKey; accessClusterId=$clus.clusterId }

        try { $pgs = Get-EnvPGs $headers "kGenericNas,kIsilon" } catch { continue }
        if (-not $pgs) { continue }

        foreach($pg in $pgs){
            try { $jsonRuns = Get-PGRuns $headers $pg.id "kGenericNas,kIsilon" } catch { continue }
            if (-not $jsonRuns.runs) { continue }

            $runs   = $jsonRuns.runs
            $rTypes = $runs.localBackupInfo.runType | Select-Object -Unique
            foreach($r in $rTypes){
                $latest = $runs | Where-Object { $_.localBackupInfo[0].runType -eq $r } |
                                  Sort-Object { $_.localBackupInfo[0].endTimeUsecs } -Descending |
                                  Select-Object -First 1
                if (-not $latest) { continue }
                $info = $latest.localBackupInfo[0]
                if ($info.status -eq "Succeeded" -or $info.status -eq "SucceededWithWarning") { continue }
                $startLocal = Usecs-ToLocal $info.startTimeUsecs
                $endLocal   = Usecs-ToLocal $info.endTimeUsecs

                $objs = $latest.objects | Where-Object { $_.object.objectType -eq 'kHost' }
                foreach($o in $objs){
                    $attempts = $o.localSnapshotInfo.failedAttempts
                    if (-not $attempts) { continue }
                    foreach($fa in $attempts){
                        $msg = ($fa.message -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                        $rows += [pscustomobject]@{
                            Cluster         = $clusterName
                            ProtectionGroup = $pg.name
                            RunType         = $info.runType
                            Name            = $o.object.name
                            StartTime       = $startLocal
                            EndTime         = $endLocal
                            FailedMessage   = $msg
                        }
                    }
                }
            }
        }
    }
    if ($rows.Count -gt 0) {
        $rows = $rows |
            Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.Name)|$($_.FailedMessage)|$($_.EndTime)" } |
            ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 } |
            Sort-Object Cluster,ProtectionGroup,EndTime -Descending
        $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
        $csv       = Join-Path $logDirectory "BackupFailures_NAS_AllClusters_$timestamp.csv"
        $rows | Export-Csv -Path $csv -NoTypeInformation -Encoding utf8
        return [pscustomobject]@{ Rows=$rows; Csv=$csv }
    } else { return [pscustomobject]@{ Rows=@(); Csv=$null } }
}

# ---- Hyper-V (kVirtualMachine) ----
function Collect-HyperV { param($Clusters)
    $rows  = @()
    foreach($clus in $Clusters){
        $clusterName = ($clus.name, $clus.clusterName, $clus.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
        if (-not $clusterName) { $clusterName = "Unknown-$($clus.clusterId)" }
        $headers = @{ apiKey=$apiKey; accessClusterId=$clus.clusterId }

        try { $pgs = Get-EnvPGs $headers "kHyperV" } catch { continue }
        if (-not $pgs) { continue }

        foreach($pg in $pgs){
            try { $jsonRuns = Get-PGRuns $headers $pg.id "kHyperV" } catch { continue }
            if (-not $jsonRuns.runs) { continue }

            $runs   = $jsonRuns.runs
            $rTypes = $runs.localBackupInfo.runType | Select-Object -Unique
            foreach($r in $rTypes){
                $latest = $runs | Where-Object { $_.localBackupInfo[0].runType -eq $r } |
                                  Sort-Object { $_.localBackupInfo[0].endTimeUsecs } -Descending |
                                  Select-Object -First 1
                if (-not $latest) { continue }
                $info = $latest.localBackupInfo[0]
                if ($info.status -eq "Succeeded" -or $info.status -eq "SucceededWithWarning") { continue }
                $startLocal = Usecs-ToLocal $info.startTimeUsecs
                $endLocal   = Usecs-ToLocal $info.endTimeUsecs

                $vms = $latest.objects | Where-Object { $_.object.objectType -eq 'kVirtualMachine' }
                foreach($vm in $vms){
                    $attempts = $vm.localSnapshotInfo.failedAttempts
                    if (-not $attempts) { continue }
                    foreach($fa in $attempts){
                        $msg = ($fa.message -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                        $rows += [pscustomobject]@{
                            Cluster         = $clusterName
                            ProtectionGroup = $pg.name
                            RunType         = $info.runType
                            Name            = $vm.object.name
                            StartTime       = $startLocal
                            EndTime         = $endLocal
                            FailedMessage   = $msg
                        }
                    }
                }
            }
        }
    }
    if ($rows.Count -gt 0) {
        $rows = $rows |
            Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.Name)|$($_.FailedMessage)|$($_.EndTime)" } |
            ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 } |
            Sort-Object Cluster,ProtectionGroup,EndTime -Descending
        $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
        $csv       = Join-Path $logDirectory "BackupFailures_HyperV_AllClusters_$timestamp.csv"
        $rows | Export-Csv -Path $csv -NoTypeInformation -Encoding utf8
        return [pscustomobject]@{ Rows=$rows; Csv=$csv }
    } else { return [pscustomobject]@{ Rows=@(); Csv=$null } }
}

# ---- Acropolis (kVirtualMachine) ----
function Collect-Acropolis { param($Clusters)
    $rows  = @()
    foreach($clus in $Clusters){
        $clusterName = ($clus.name, $clus.clusterName, $clus.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
        if (-not $clusterName) { $clusterName = "Unknown-$($clus.clusterId)" }
        $headers = @{ apiKey=$apiKey; accessClusterId=$clus.clusterId }

        try { $pgs = Get-EnvPGs $headers "kAcropolis" } catch { continue }
        if (-not $pgs) { continue }

        foreach($pg in $pgs){
            try { $jsonRuns = Get-PGRuns $headers $pg.id "kAcropolis" } catch { continue }
            if (-not $jsonRuns.runs) { continue }

            $runs   = $jsonRuns.runs
            $rTypes = $runs.localBackupInfo.runType | Select-Object -Unique
            foreach($r in $rTypes){
                $latest = $runs | Where-Object { $_.localBackupInfo[0].runType -eq $r } |
                                  Sort-Object { $_.localBackupInfo[0].endTimeUsecs } -Descending |
                                  Select-Object -First 1
                if (-not $latest) { continue }
                $info = $latest.localBackupInfo[0]
                if ($info.status -eq "Succeeded" -or $info.status -eq "SucceededWithWarning") { continue }
                $startLocal = Usecs-ToLocal $info.startTimeUsecs
                $endLocal   = Usecs-ToLocal $info.endTimeUsecs

                $vms = $latest.objects | Where-Object { $_.object.objectType -eq 'kVirtualMachine' }
                foreach($vm in $vms){
                    $attempts = $vm.localSnapshotInfo.failedAttempts
                    if (-not $attempts) { continue }
                    foreach($fa in $attempts){
                        $msg = ($fa.message -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                        $rows += [pscustomobject]@{
                            Cluster         = $clusterName
                            ProtectionGroup = $pg.name
                            RunType         = $info.runType
                            Name            = $vm.object.name
                            StartTime       = $startLocal
                            EndTime         = $endLocal
                            FailedMessage   = $msg
                        }
                    }
                }
            }
        }
    }
    if ($rows.Count -gt 0) {
        $rows = $rows |
            Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.Name)|$($_.FailedMessage)|$($_.EndTime)" } |
            ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 } |
            Sort-Object Cluster,ProtectionGroup,EndTime -Descending
        $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
        $csv       = Join-Path $logDirectory "BackupFailures_Acropolis_AllClusters_$timestamp.csv"
        $rows | Export-Csv -Path $csv -NoTypeInformation -Encoding utf8
        return [pscustomobject]@{ Rows=$rows; Csv=$csv }
    } else { return [pscustomobject]@{ Rows=@(); Csv=$null } }
}

# ---- RemoteAdapter ‚Äì failed WITHOUT later success (runType-wise) ----
function Collect-RemoteAdapter { param($Clusters)
    $rows  = @()
    foreach ($clus in $Clusters) {
        $clusterName = ($clus.name, $clus.clusterName, $clus.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
        if (-not $clusterName) { $clusterName = "Unknown-$($clus.clusterId)" }
        $headers = @{ apiKey=$apiKey; accessClusterId=$clus.clusterId }

        try { $pgs = Get-EnvPGs $headers "kRemoteAdapter" } catch { continue }
        if (-not $pgs) { continue }

        foreach ($pg in $pgs) {
            try { $json = Get-PGRuns $headers $pg.id "kRemoteAdapter" } catch { continue }
            $runs = if ($json -and $json.runs) { $json.runs } else { @() }
            if (-not $runs) { continue }

            # hints from params
            $HostName = $null; $DB_name = $null
            try {
                $HostName = $pg.remoteAdapterParams.hosts.hostname
                if ($HostName -is [System.Array]) { $HostName = ($HostName -join ',') }
                $args = $pg.remoteAdapterParams.hosts.incrementalBackupScript.params
                if ($args -is [System.Array]) { $args = ($args -join ' ') }
                if ($args -match "-o\s+(\S+)") { $DB_name = $matches[1] }
            } catch {}

            $flat = @()
            foreach($run in $runs){
                if ($run.localBackupInfo) {
                    foreach($li in $run.localBackupInfo){
                        $flat += [pscustomobject]@{
                            RunType         = $li.runType
                            Status          = $li.status
                            Message         = $li.messages
                            StartTimeUsecs  = $li.startTimeUsecs
                            EndTimeUsecs    = $li.endTimeUsecs
                            Cluster         = $clusterName
                            ProtectionGroup = $pg.name
                            HostName        = $HostName
                            DB_name         = $DB_name
                        }
                    }
                }
            }
            if (-not $flat) { continue }

            $byType = $flat | Group-Object RunType
            foreach($g in $byType){
                $latestFailed = $g.Group |
                    Where-Object { $_.Status -eq 'Failed' } |
                    Sort-Object EndTimeUsecs -Descending |
                    Select-Object -First 1
                if (-not $latestFailed) { continue }

                $hasLaterSuccess = $g.Group | Where-Object {
                    $_.Status -in @('Succeeded','SucceededWithWarning') -and
                    $_.StartTimeUsecs -gt $latestFailed.EndTimeUsecs
                }
                if ($hasLaterSuccess) { continue }

                $startLocal = Usecs-ToLocal $latestFailed.StartTimeUsecs
                $endLocal   = Usecs-ToLocal $latestFailed.EndTimeUsecs
                $msg = $latestFailed.Message
                if ($msg -is [System.Array]) { $msg = ($msg -join ' | ') }

                $rows += [pscustomobject]@{
                    Cluster         = $latestFailed.Cluster
                    ProtectionGroup = $latestFailed.ProtectionGroup
                    RunType         = $latestFailed.RunType
                    Name            = (if ($latestFailed.DB_name) { $latestFailed.DB_name } else { $latestFailed.HostName })
                    StartTime       = $startLocal
                    EndTime         = $endLocal
                    FailedMessage   = $msg
                }
            }
        }
    }
    if ($rows.Count -gt 0) {
        $rows = $rows |
            Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.Name)|$($_.FailedMessage)|$($_.EndTime)" } |
            ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 } |
            Sort-Object Cluster,ProtectionGroup,EndTime -Descending
        $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
        $csv       = Join-Path $logDirectory "BackupFailures_RemoteAdapter_AllClusters_$timestamp.csv"
        $rows | Export-Csv -Path $csv -NoTypeInformation -Encoding utf8
        return [pscustomobject]@{ Rows=$rows; Csv=$csv }
    } else { return [pscustomobject]@{ Rows=@(); Csv=$null } }
}

# =====================================================================
# Output helpers
# =====================================================================
function Show-Table {
    param(
        [string]$label,
        [object[]]$rows,
        [string]$csvPath,
        [switch]$DbStyle # If set, expect columns Hosts + DatabaseName; else Name
    )
    if($rows -and $rows.Count -gt 0){
        Write-Host ("`nüî• Latest Failed {0} Runs (All Clusters):`n" -f $label) -ForegroundColor Cyan
        if($DbStyle){
            $rows | Select-Object Cluster,ProtectionGroup,RunType,Hosts,DatabaseName,
                                  @{n='StartTime';e={$_.StartTime}},
                                  @{n='EndTime';e={$_.EndTime}},
                                  FailedMessage | Format-Table -AutoSize
        }else{
            $rows | Select-Object Cluster,ProtectionGroup,RunType,Name,
                                  @{n='StartTime';e={$_.StartTime}},
                                  @{n='EndTime';e={$_.EndTime}},
                                  FailedMessage | Format-Table -AutoSize
        }
        if($csvPath){ Write-Host ("`nüìÇ CSV saved: {0}" -f $csvPath) -ForegroundColor Gray }
    } else {
        Write-Host ("‚úÖ No failures found for {0} (All Clusters)" -f $label) -ForegroundColor Green
    }
}

# =====================================================================
# MENU (now BEFORE any network calls)
# =====================================================================
Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "   COHESITY BACKUP FAILURES ‚Äì MAIN MENU" -ForegroundColor White
Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "0.  Exit"
Write-Host "1.  All Environments"
Write-Host "2.  Oracle"
Write-Host "3.  SQL"
Write-Host "4.  Physical (File System)"
Write-Host "5.  NAS (GenericNas/Isilon)"
Write-Host "6.  Hyper-V"
Write-Host "7.  Acropolis (AHV)"
Write-Host "8.  Remote Adapter"
Write-Host "9.  Report-only (All envs, silent, combined CSVs)"
Write-Host "---------------------------------------------"
$choice = Read-Host "Enter your choice(s) (e.g. 2,3,4) or press 'F' for Fast (silent) ALL"

# Fast key: F = run ALL in silent mode
$FastAllSilent = $false
if ($choice -match '^[Ff]$') { $FastAllSilent = $true; $choice = "1" }

# Ask for mode only if not report-only and not fast
if ($choice -eq "1" -and -not $FastAllSilent) {
    Write-Host "`nSelect Mode:" -ForegroundColor Yellow
    Write-Host "1. Verbose (detailed, color output)"
    Write-Host "2. Silent (compact output; prints tables only for failures)"
    $modeChoice = Read-Host "Enter mode [1 or 2]"
    $script:VerboseMode = $modeChoice -eq "1"
} else {
    $script:VerboseMode = $false  # Silent by default for everything else
}

if ($choice -match '(^|\D)0(\D|$)') { return } # clean exit

# From here on, we finally do network calls
$stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
$clusters  = Get-Clusters
Write-Log ("Resolved {0} clusters in {1} ms" -f $clusters.Count, $stopwatch.ElapsedMilliseconds) "DarkGray"

# ---------- Run selection ----------
$reportOnly   = ($choice -eq "9")
$doAll        = ($choice -eq "1")
$targets = @()
if ($doAll -or $reportOnly) {
    $targets = @(2,3,4,5,6,7,8)
} else {
    $targets = $choice.Split(',') | ForEach-Object { $_.Trim() } |
               Where-Object { $_ -match '^\d+$' -and [int]$_ -in 2..8 } |
               ForEach-Object { [int]$_ }
    if (-not $targets -or $targets.Count -eq 0) {
        Write-Host "‚ö†Ô∏è No valid selection. Exiting." -ForegroundColor Yellow
        return
    }
}

$combined = @()

foreach($sel in $targets){
    switch ($sel) {
        2 {
            $res = Collect-OracleSql -Label "Oracle" -EnvFilter "kOracle" -Clusters $clusters
            if (-not $reportOnly) { Show-Table -label "Oracle" -rows $res.Rows -csvPath $res.Csv -DbStyle }
            if ($res.Rows) { $combined += ($res.Rows | Select-Object *, @{n='Environment';e={'Oracle'}}) }
        }
        3 {
            $res = Collect-OracleSql -Label "SQL" -EnvFilter "kSQL" -Clusters $clusters
            if (-not $reportOnly) { Show-Table -label "SQL" -rows $res.Rows -csvPath $res.Csv -DbStyle }
            if ($res.Rows) { $combined += ($res.Rows | Select-Object *, @{n='Environment';e={'SQL'}}) }
        }
        4 {
            $res = Collect-Physical -Clusters $clusters
            if (-not $reportOnly) { Show-Table -label "Physical" -rows $res.Rows -csvPath $res.Csv }
            if ($res.Rows) { $combined += ($res.Rows | Select-Object *, @{n='Environment';e={'Physical'}}) }
        }
        5 {
            $res = Collect-NAS -Clusters $clusters
            if (-not $reportOnly) { Show-Table -label "NAS" -rows $res.Rows -csvPath $res.Csv }
            if ($res.Rows) { $combined += ($res.Rows | Select-Object *, @{n='Environment';e={'NAS'}}) }
        }
        6 {
            $res = Collect-HyperV -Clusters $clusters
            if (-not $reportOnly) { Show-Table -label "HyperV" -rows $res.Rows -csvPath $res.Csv }
            if ($res.Rows) { $combined += ($res.Rows | Select-Object *, @{n='Environment';e={'HyperV'}}) }
        }
        7 {
            $res = Collect-Acropolis -Clusters $clusters
            if (-not $reportOnly) { Show-Table -label "Acropolis" -rows $res.Rows -csvPath $res.Csv }
            if ($res.Rows) { $combined += ($res.Rows | Select-Object *, @{n='Environment';e={'Acropolis'}}) }
        }
        8 {
            $res = Collect-RemoteAdapter -Clusters $clusters
            if (-not $reportOnly) { Show-Table -label "RemoteAdapter" -rows $res.Rows -csvPath $res.Csv }
            if ($res.Rows) { $combined += ($res.Rows | Select-Object *, @{n='Environment';e={'RemoteAdapter'}}) }
        }
    }
}

# ---------- Combined ----------
if ($combined -and $combined.Count -gt 0) {
    # Normalize to common columns for combined output
    $display = $combined | ForEach-Object {
        if ($_ | Get-Member -Name Hosts -MemberType NoteProperty) {
            $_
        } else {
            [pscustomobject]@{
                Cluster         = $_.Cluster
                ProtectionGroup = $_.ProtectionGroup
                Environment     = $_.Environment
                RunType         = $_.RunType
                Hosts           = $_.Name
                DatabaseName    = if ($_ | Get-Member -Name DatabaseName -ErrorAction SilentlyContinue) { $_.DatabaseName } else { $null }
                StartTime       = $_.StartTime
                EndTime         = $_.EndTime
                FailedMessage   = $_.FailedMessage
            }
        }
    }

    $sortedAll = $display | Sort-Object Cluster,ProtectionGroup,Environment,EndTime -Descending
    if (-not $reportOnly) {
        Write-Host "`nüî• Combined Failures ‚Äì Selected Environments" -ForegroundColor Magenta
        $sortedAll | Select-Object Cluster,ProtectionGroup,Environment,RunType,Hosts,DatabaseName,StartTime,EndTime,FailedMessage |
            Format-Table -AutoSize
    }
    $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
    $combinedPath = Join-Path $logDirectory "BackupFailures_SelectedEnvironments_$timestamp.csv"
    $sortedAll | Export-Csv -Path $combinedPath -NoTypeInformation -Encoding utf8
    if (-not $reportOnly) {
        Write-Host ("`nüìÇ Combined CSV saved: {0}" -f $combinedPath) -ForegroundColor Gray
    }
} else {
    Write-Host "`n‚úÖ No failures found in the selected scope." -ForegroundColor Green
}

Write-Log ("Done in {0} sec" -f ([math]::Round($stopwatch.Elapsed.TotalSeconds,2))) "DarkGray"
