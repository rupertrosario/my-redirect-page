# Cohesity Backup Failure Report (unresolved failures with no later success)
# - Scans only a tight history window (default: last 30 runs per job/runType)
# - Reports an object only when the newest streak is failed and has not been followed by a success
# - Compatible with Helios/MCM or direct cluster auth via cohesity-api.ps1
# - CSV is UTF-8 (no BOM)

# ============================
# process commandline arguments
# ============================
[CmdletBinding()]
param (
    [Parameter()][string]$vip = 'helios.cohesity.com',
    [Parameter()][string]$username = 'helios',
    [Parameter()][string]$domain = 'local',
    [Parameter()][string]$tenant = $null,
    [Parameter()][switch]$useApiKey,
    [Parameter()][string]$password = $null,
    [Parameter()][switch]$noPrompt,
    [Parameter()][switch]$mcm,
    [Parameter()][string]$mfaCode = $null,
    [Parameter()][string]$clusterName = $null,

    [Parameter()][int]$numRuns = 30,           # only scan last 30 runs per job
    [Parameter()][int]$days = 7,               # look back 7 days
    [Parameter()][int]$failureCount = 1,       # min consecutive failures to report

    [Parameter()][string]$smtpServer,
    [Parameter()][string]$smtpPort = '25',
    [Parameter()][array]$sendTo,
    [Parameter()][string]$sendFrom
)

# ============================
# load cohesity-api helper
# ============================
. $(Join-Path -Path $PSScriptRoot -ChildPath cohesity-api.ps1)

# ============================
# authenticate
# ============================
apiauth -vip $vip `
        -username $username `
        -domain $domain `
        -passwd $password `
        -apiKeyAuthentication $useApiKey `
        -mfaCode $mfaCode `
        -heliosAuthentication $mcm `
        -tenant $tenant `
        -noPromptForPassword $noPrompt

# select helios/mcm managed cluster
if ($USING_HELIOS) {
    if ($clusterName) {
        $thisCluster = heliosCluster $clusterName
    } else {
        Write-Host "Please provide -clusterName when connecting through Helios/MCM" -ForegroundColor Yellow
        exit 1
    }
}

if (-not $cohesity_api.authorized) {
    Write-Host "Not authenticated" -ForegroundColor Yellow
    exit 1
}

# ============================
# helper function
# ============================
function Add-UnresolvedFailuresForRunTypes {
    param(
        [Parameter(Mandatory)]$job,
        [Parameter(Mandatory)][string]$runTypeLabel,
        [Parameter(Mandatory)][string[]]$runTypes,
        [Parameter(Mandatory)]$rootNodes,
        [Parameter(Mandatory)][hashtable]$reportFailures, # key -> firstFailMessage (sanitized)
        [Parameter(Mandatory)][hashtable]$failureTime,    # key -> firstFailStartTime
        [Parameter(Mandatory)][int]$numRuns,
        [Parameter(Mandatory)]$startUsecs,
        [Parameter(Mandatory)][int]$failureCount
    )

    # pull last N runs for only these runTypes, with object details
    $query = "data-protect/protection-groups/$($job.id)/runs?numRuns=$numRuns&startTimeUsecs=$startUsecs&includeTenants=true&includeObjectDetails=true&runTypes=$([string]::Join(',', $runTypes))"
    $runs = api get -v2 $query
    if (!$runs.runs) { return }

    # newest first (we want to find the most recent streak)
    # localBackupInfo is an array; using .startTimeUsecs against it yields a collection – take [0] explicitly
    $ordered = $runs.runs | Sort-Object { $_.localBackupInfo[0].startTimeUsecs } -Descending

    foreach ($run in $ordered) {

        # Best-effort guard
        if (-not $run.objects -or -not $run.localBackupInfo) { continue }

        # filter only objects that match the job environment (keeps signal tight)
        $theseObjects = $run.objects | Where-Object { $_.object.environment -eq $job.environment }
        if (-not $theseObjects) { continue }

        foreach ($obj in $theseObjects) {

            # object & (optional) parent source mapping (e.g., DB → host)
            $objectName = $obj.object.name
            $sourceName = $objectName
            if ($obj.object.PSObject.Properties['sourceId']) {
                $src = $rootNodes.rootNodes | Where-Object { $_.rootNode.id -eq $obj.object.sourceId }
                if ($src -and $src.rootNode -and $src.rootNode.name) {
                    $sourceName = $src.rootNode.name
                }
            }

            # build a per-object/runType key; use a stable hash to scope "decision" and "streak" vars
            $key = "$($job.name);;$objectName;;$sourceName;;$runTypeLabel"
            $hash = $key.GetHashCode()
            $decidedVar = "__decided_$hash"
            if (Get-Variable -Name $decidedVar -Scope Local -ErrorAction SilentlyContinue) {
                continue
            }

            # object-level status (snapshotInfo.status) – we only care when object actually failed
            $objSnap = $obj.localSnapshotInfo.snapshotInfo
            $status  = $objSnap.status

            # normalize start time
            $runStartTime = usecsToDate $run.localBackupInfo[0].startTimeUsecs

            # per-key streak tracking
            $streakVar    = "__streak_$hash"
            $firstMsgVar  = "__firstFailMsg_$hash"
            $firstTimeVar = "__firstFailTime_$hash"

            if (-not (Get-Variable -Name $streakVar -Scope Local -ErrorAction SilentlyContinue)) {
                Set-Variable -Name $streakVar -Value 0     -Scope Local
                Set-Variable -Name $firstMsgVar -Value $null -Scope Local
                Set-Variable -Name $firstTimeVar -Value $null -Scope Local
            }

            $streak    = (Get-Variable -Name $streakVar -Scope Local).Value
            $firstMsg  = (Get-Variable -Name $firstMsgVar -Scope Local).Value
            $firstTime = (Get-Variable -Name $firstTimeVar -Scope Local).Value

            if ($status -eq 'kFailed') {
                # increment the newest-failure streak
                $streak++

                # capture the first failure message & time for this current streak
                if (-not $firstMsg) {
                    $msg = $null
                    if ($obj.localSnapshotInfo.failedAttempts -and $obj.localSnapshotInfo.failedAttempts.Count -gt 0) {
                        $msg = [string]$obj.localSnapshotInfo.failedAttempts[0].message
                    }
                    # sanitize for CSV safety
                    if ($msg) {
                        $msg = $msg.Replace("`r"," ").Replace("`n"," ").Replace(",",";")
                        if ($msg.Length -gt 300) { $msg = $msg.Substring(0,300) }
                    }
                    $firstMsg  = $msg
                    $firstTime = $runStartTime
                }

                # if we’ve reached the report threshold, store in hashtables
                if ($streak -ge $failureCount) {
                    $reportFailures[$key] = $firstMsg
                    $failureTime[$key]    = $firstTime
                }

                # update locals
                Set-Variable -Name $streakVar -Value $streak    -Scope Local
                Set-Variable -Name $firstMsgVar -Value $firstMsg -Scope Local
                Set-Variable -Name $firstTimeVar -Value $firstTime -Scope Local
            }
            else {
                # any success (or not-failed) after a streak resolves it – do not report
                if ($reportFailures.ContainsKey($key)) { $reportFailures.Remove($key) }
                if ($failureTime.ContainsKey($key))    { $failureTime.Remove($key)    }
                Set-Variable -Name $decidedVar -Value $true -Scope Local
            }
        }
    }
}

# ============================
# collect job and failure data
# ============================
$cluster      = api get cluster
$dateString   = (Get-Date).ToString('yyyy-MM-dd')
$outfileName  = "backupFailureReport-$($cluster.name)-$dateString.csv"

# CSV header (UTF-8, no BOM)
"Job Name,Latest Backup,Backup Type,Source Name,Object Name,Message" | Out-File -FilePath $outfileName -Encoding utf8

$jobs       = api get -v2 "data-protect/protection-groups?isDeleted=false&isActive=true&includeTenants=true"
$rootNodes  = api get "protectionSources/registrationInfo"
$startUsecs = timeAgo $days 'days'

$totalFailures = 0

foreach ($job in $jobs.protectionGroups | Sort-Object -Property name) {
    $reportFailures = @{}
    $failureTime    = @{}

    # Backup-type runs (Full/Incremental/System)
    Add-UnresolvedFailuresForRunTypes -job $job -runTypeLabel 'Backup' `
        -runTypes @('kSystem','kFull','kIncremental') `
        -rootNodes $rootNodes `
        -reportFailures $reportFailures `
        -failureTime $failureTime `
        -numRuns $numRuns `
        -startUsecs $startUsecs `
        -failureCount $failureCount

    # Log-type runs
    Add-UnresolvedFailuresForRunTypes -job $job -runTypeLabel 'Log Backup' `
        -runTypes @('kLog') `
        -rootNodes $rootNodes `
        -reportFailures $reportFailures `
        -failureTime $failureTime `
        -numRuns $numRuns `
        -startUsecs $startUsecs `
        -failureCount $failureCount

    # Emit for this job
    foreach ($failureKey in $reportFailures.Keys | Sort-Object) {
        $totalFailures += 1

        # Key form: "$jobName;;$objectName;;$sourceName;;$runTypeLabel"
        $parts = $failureKey -split ';;'
        $jobName    = $parts[0]
        $objectName = $parts[1]
        $sourceName = $parts[2]
        $runType    = $parts[3]

        $message = [string]$reportFailures[$failureKey]
        if ($message) {
            $message = $message.Replace("`n",' ').Replace("`r",' ')
            if ($message.Length -gt 300) { $message = $message.Substring(0,300) }
        }

        $runStartTime = $failureTime[$failureKey]

        if ($sourceName -eq $objectName) {
            Write-Host ("    {0} ({1}) [{2}] {3}" -f $jobName, $runStartTime, $runType, $objectName)
        } else {
            Write-Host ("    {0} ({1}) [{2}] {3}/{4}" -f $jobName, $runStartTime, $runType, $sourceName, $objectName)
        }

        "{0},{1},{2},{3},{4},{5}" -f $jobName, $runStartTime, $runType, $sourceName, $objectName, $message |
            Out-File -FilePath $outfileName -Append -Encoding utf8
    }
}

if ($totalFailures -gt 0) {
    Write-Host "`nTotal Unresolved Failures: $totalFailures" -ForegroundColor Cyan
    Write-Host "Output saved to $outfileName`n" -ForegroundColor Cyan
} else {
    Write-Host "`n✅ No unresolved failures (within the lookback window). Output file still created with header: $outfileName`n" -ForegroundColor Green
}

# ============================
# optional email
# ============================
if ($smtpServer -and $sendFrom -and $sendTo) {
    Write-Host "Sending report to $([string]::Join(', ', $sendTo))" -ForegroundColor Cyan
    foreach ($toaddr in $sendTo) {
        try {
            Send-MailMessage -From $sendFrom -To $toaddr -SmtpServer $smtpServer -Port $smtpPort `
                -Subject "${clusterName} Backup Failure Report ($totalFailures)" `
                -Body "Total Unresolved Failures: $totalFailures`nReport: $outfileName`n" `
                -Attachments $outfileName -WarningAction SilentlyContinue
        } catch {
            Write-Warning "Failed to send mail to $toaddr: $($_.Exception.Message)"
        }
    }
}
