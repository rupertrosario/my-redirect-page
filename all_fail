# =====================================================================
# Cohesity Backup Failures ‚Äì Multi-Cluster (Helios)
# Menu-driven | Silent/Verbose | CSV only when failures exist (UTF-8)
# Environments: Oracle, SQL, Physical, NAS, HyperV, Acropolis, RemoteAdapter
#
# - Oracle/SQL: DB object failures + DB‚ÜíHost mapping (sourceId‚Üíhost id).
#   For host-only failures (no DBs discovered): Name="DB Host", ParentHost=<host>
# - Hyper-V/AHV/NAS: report only when latest run failed AND object has failedAttempts[]
#   (no generic rows)
# - Physical: uses your working logic:
#     - latest run failed -> include row (even if no per-object failedAttempts[])
#     - also includes object-level failedAttempts[] when present
# - RemoteAdapter: "failed WITHOUT later success" logic (as approved)
# - CSV is written only when failures exist, UTF-8 (no BOM)
# =====================================================================

# ---------- Setup ----------
$logDirectory = "X:\PowerShell\Data\Cohesity\BackupFailures"
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory | Out-Null
}
# keep max 50 logs
$fileCount = (Get-ChildItem -Path $logDirectory -File).Count
if ($fileCount -gt 50) {
    Get-ChildItem -Path $logDirectory -File |
        Sort-Object CreationTime |
        Select-Object -First ($fileCount - 50) |
        Remove-Item -Force
}

# API key
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found: $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()
$baseUrl = "https://helios.cohesity.com"
$commonHeaders = @{ "apiKey" = $apiKey }

# ---------- Helpers ----------
function Convert-ToUtcFromUsecs([Nullable[Int64]]$usecs){
    if ($null -eq $usecs -or $usecs -eq 0) { return $null }
    try { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$usecs/1000)).UtcDateTime }
    catch { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$usecs).UtcDateTime }
}
function Convert-ToLocalFromUsecs([Nullable[Int64]]$usecs, [System.TimeZoneInfo]$tz){
    $utc = Convert-ToUtcFromUsecs $usecs
    if ($null -eq $utc) { return $null }
    if ($tz) { [System.TimeZoneInfo]::ConvertTimeFromUtc($utc,$tz) } else { $utc.ToLocalTime() }
}
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")
function Clean-Msg($s){ if($null -eq $s){return $null}; return ($s -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim() }
function Write-Log($msg,$color="Gray"){ if($script:VerboseMode){ Write-Host $msg -ForegroundColor $color } }

# ---------- Get clusters (no body on GET) ----------
$cluUrl   = "$baseUrl/v2/mcm/cluster-mgmt/info"
$json_clu = ((Invoke-WebRequest -Method Get -Uri $cluUrl -Headers $commonHeaders).Content | ConvertFrom-Json).cohesityClusters
if (-not $json_clu) { throw "No clusters returned from Helios." }

# ---------- Menu ----------
Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "   COHESITY BACKUP FAILURES ‚Äì MAIN MENU" -ForegroundColor White
Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "1.  All Environments"
Write-Host "2.  Oracle"
Write-Host "3.  SQL"
Write-Host "4.  Physical (File System)"
Write-Host "5.  NAS (GenericNas/Isilon)"
Write-Host "6.  Hyper-V"
Write-Host "7.  Acropolis (AHV)"
Write-Host "8.  Remote Adapter"
Write-Host "---------------------------------------------"
$choice = Read-Host "Enter your choice(s) (e.g. 2,3,4)"

Write-Host "`nSelect Mode:" -ForegroundColor Yellow
Write-Host "1. Verbose (detailed, color output)"
Write-Host "2. Silent (tables only for failures + summary)"
$modeChoice = Read-Host "Enter mode [1 or 2]"
$script:VerboseMode = $modeChoice -eq "1"

# ---------- Environment map ----------
$envMap = @{
  2 = @{ Label="Oracle";        Filter="kOracle";                 Object="kDatabase";       NameField="name"; ParentHostNeeded=$true }
  3 = @{ Label="SQL";           Filter="kSQL";                    Object="kDatabase";       NameField="name"; ParentHostNeeded=$true }
  4 = @{ Label="Physical";      Filter="kPhysical";               Object="kHost";           NameField="name"; ParentHostNeeded=$false }
  5 = @{ Label="NAS";           Filter="kGenericNas,kIsilon";     Object="kHost";           NameField="name"; ParentHostNeeded=$false }
  6 = @{ Label="HyperV";        Filter="kHyperV";                 Object="kVirtualMachine"; NameField="name"; ParentHostNeeded=$false }
  7 = @{ Label="Acropolis";     Filter="kAcropolis";              Object="kVirtualMachine"; NameField="name"; ParentHostNeeded=$false }
  8 = @{ Label="RemoteAdapter"; Filter="kRemoteAdapter";          Object="kRemoteAdapter";  NameField="name"; ParentHostNeeded=$false }
}

# =====================================================================
# Collectors
# =====================================================================

# --- Oracle / SQL / NAS / HyperV / Acropolis ---
# Latest run per runType must be FAILED; include only objects that have failedAttempts[]
function Collect-EnvStrictFailedAttempts {
  param(
    [string]$Label,
    [string]$FilterCSV,     # e.g. "kGenericNas,kIsilon"
    [string]$ObjectType,    # object.objectType to pick
    [string]$NameField,     # property under object to display
    [bool]  $ParentHostNeeded
  )
  $global = @()
  $filterSet = $FilterCSV.Split(',') | ForEach-Object { $_.Trim() }

  foreach($cluster in $json_clu){
    $cluster_name = ($cluster.name,$cluster.clusterName,$cluster.displayName | Where-Object {$_ -and $_.Trim()} | Select-Object -First 1)
    if(-not $cluster_name){ $cluster_name="Unknown-$($cluster.clusterId)" }
    $headers=@{apiKey=$apiKey;accessClusterId=$cluster.clusterId}
    Write-Log ("`nüîπ Processing cluster: {0}" -f $cluster_name) "Cyan"

    # PGs
    $pgUrl = "$baseUrl/v2/data-protect/protection-groups?environments=$FilterCSV&isDeleted=false&isPaused=false&isActive=true"
    try {
      $pgs = ((Invoke-WebRequest -Method Get -Uri $pgUrl -Headers $headers).Content | ConvertFrom-Json).protectionGroups
    } catch { continue }
    if(-not $pgs){ continue }

    foreach($pg in $pgs){
      $pgId=$pg.id; $pgName=$pg.name
      Write-Log ("üì¶ Checking PG: {0}" -f $pgName) "Yellow"

      $runUrl = "$baseUrl/v2/data-protect/protection-groups/$pgId/runs?environments=$FilterCSV&numRuns=10&excludeNonRestorableRuns=false&includeObjectDetails=true"
      try {
        $jsonRuns = (Invoke-WebRequest -Method Get -Uri $runUrl -Headers $headers | ConvertFrom-Json)
      } catch { continue }
      if(-not $jsonRuns.runs){ continue }

      # Expand all entries in localBackupInfo[] to choose correct latest per runType
      $exp = foreach($r in $jsonRuns.runs){
        if($r.localBackupInfo){
          foreach($li in $r.localBackupInfo){
            [pscustomobject]@{
              runType        = $li.runType
              status         = $li.status
              startTimeUsecs = $li.startTimeUsecs
              endTimeUsecs   = $li.endTimeUsecs
              objects        = $r.objects
            }
          }
        }
      }
      if(-not $exp){ continue }

      $byType = $exp | Group-Object runType
      foreach($g in $byType){
        $latest = $g.Group | Sort-Object endTimeUsecs -Descending | Select-Object -First 1
        if(-not $latest){ continue }

        $status     = $latest.status
        $runType    = $latest.runType
        $startLocal = Convert-ToLocalFromUsecs $latest.startTimeUsecs $tz
        $endLocal   = Convert-ToLocalFromUsecs $latest.endTimeUsecs   $tz

        if($status -in @("Succeeded","SucceededWithWarning")){
          Write-Log ("‚úÖ {0} ‚Üí {1} [{2}] ‚Äì Latest run succeeded" -f $cluster_name,$pgName,$runType) "Green"
          continue
        } else {
          Write-Log ("‚ùå {0} ‚Üí {1} [{2}] ‚Äì Latest run failed, scanning objects..." -f $cluster_name,$pgName,$runType) "Red"
        }

        if(-not $latest.objects){ continue }

        # id‚Üíname map for ParentHost (DBs)
        $idToName = @{}
        if($ParentHostNeeded){
          foreach($ob in $latest.objects){ if($ob.object -and $ob.object.id){ $idToName[[string]$ob.object.id]=$ob.object.name } }
        }

        $objs = $latest.objects | Where-Object {
          $_.object.objectType -eq $ObjectType -and $_.object.environment -in $filterSet
        }

        foreach($o in $objs){
          $attempts = $o.localSnapshotInfo.failedAttempts
          if(-not $attempts -or $attempts.Count -eq 0){ continue }

          # Oracle/SQL: ParentHost from sourceId
          $parent = $null
          if($ParentHostNeeded -and $o.object -and $o.object.sourceId){
            $key=[string]$o.object.sourceId
            if($idToName.ContainsKey($key)){ $parent=$idToName[$key] }
          }

          foreach($fa in $attempts){
            $msg = Clean-Msg $fa.message
            $global += [pscustomobject]@{
              Cluster         = $cluster_name
              ProtectionGroup = $pgName
              Environment     = $Label
              RunType         = $runType
              Name            = $o.object.$NameField
              ParentHost      = $parent
              StartTime       = $startLocal
              EndTime         = $endLocal
              FailedMessage   = $msg
            }
          }
        }

        # For Oracle/SQL: host-only failures (no DBs discovered). We expose as Name="DB Host".
        if($ParentHostNeeded){
          $hostObjs = $latest.objects | Where-Object { $_.object.objectType -eq 'kHost' -and $_.object.environment -eq 'kPhysical' }
          foreach($h in $hostObjs){
            $hattempts = $h.localSnapshotInfo.failedAttempts
            if($hattempts -and $hattempts.Count -gt 0){
              foreach($fa in $hattempts){
                $msg = Clean-Msg $fa.message
                $global += [pscustomobject]@{
                  Cluster         = $cluster_name
                  ProtectionGroup = $pgName
                  Environment     = $Label
                  RunType         = $runType
                  Name            = "DB Host"
                  ParentHost      = $h.object.name
                  StartTime       = $startLocal
                  EndTime         = $endLocal
                  FailedMessage   = $msg
                }
              }
            }
          }
        }
      }
    }
  }

  if($global.Count -gt 0){
    $rows = $global |
      Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.Environment)|$($_.RunType)|$($_.Name)|$($_.ParentHost)|$($_.FailedMessage)|$($_.EndTime)" } |
      ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 } |
      Sort-Object Cluster,ProtectionGroup,EndTime -Descending

    $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
    $csvPath   = Join-Path $logDirectory ("BackupFailures_{0}_AllClusters_{1}.csv" -f $Label,$timestamp)
    $rows | Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8
    return [pscustomobject]@{ Rows = $rows; Csv = $csvPath }
  } else {
    return [pscustomobject]@{ Rows = @(); Csv = $null }
  }
}

# --- Physical: your working logic (include run-level failure rows when no failedAttempts[]) ---
function Collect-PhysicalWorking {
  $Label  = "Physical"
  $global = @()

  foreach($cluster in $json_clu){
    $cluster_name = ($cluster.name,$cluster.clusterName,$cluster.displayName | Where-Object {$_ -and $_.Trim()} | Select-Object -First 1)
    if(-not $cluster_name){ $cluster_name="Unknown-$($cluster.clusterId)" }
    $headers=@{apiKey=$apiKey;accessClusterId=$cluster.clusterId}
    Write-Log ("`nüîπ Processing cluster: {0}" -f $cluster_name) "Cyan"

    $pgUrl = "$baseUrl/v2/data-protect/protection-groups?environments=kPhysical&isDeleted=false&isPaused=false&isActive=true"
    try { $pgs = ((Invoke-WebRequest -Method Get -Uri $pgUrl -Headers $headers).Content | ConvertFrom-Json).protectionGroups }
    catch { continue }
    if(-not $pgs){ continue }

    foreach($pg in $pgs){
      $pgId=$pg.id; $pgName=$pg.name
      Write-Log ("üì¶ Checking PG: {0}" -f $pgName) "Yellow"

      $runUrl = "$baseUrl/v2/data-protect/protection-groups/$pgId/runs?environments=kPhysical&numRuns=10&excludeNonRestorableRuns=false&includeObjectDetails=true"
      try { $jsonRuns = (Invoke-WebRequest -Method Get -Uri $runUrl -Headers $headers | ConvertFrom-Json) }
      catch { continue }
      if(-not $jsonRuns.runs){ continue }

      # Expand to choose correct latest per runType
      $exp = foreach($r in $jsonRuns.runs){
        if($r.localBackupInfo){
          foreach($li in $r.localBackupInfo){
            [pscustomobject]@{
              runType        = $li.runType
              status         = $li.status
              startTimeUsecs = $li.startTimeUsecs
              endTimeUsecs   = $li.endTimeUsecs
              objects        = $r.objects
            }
          }
        }
      }
      if(-not $exp){ continue }

      $byType = $exp | Group-Object runType
      foreach($g in $byType){
        $latest = $g.Group | Sort-Object endTimeUsecs -Descending | Select-Object -First 1
        if(-not $latest){ continue }

        $status     = $latest.status
        $runType    = $latest.runType
        $startLocal = Convert-ToLocalFromUsecs $latest.startTimeUsecs $tz
        $endLocal   = Convert-ToLocalFromUsecs $latest.endTimeUsecs   $tz

        if($status -in @("Succeeded","SucceededWithWarning")){
          Write-Log ("‚úÖ {0} ‚Üí {1} [{2}] ‚Äì Latest run succeeded" -f $cluster_name,$pgName,$runType) "Green"
          continue
        } else {
          Write-Log ("‚ùå {0} ‚Üí {1} [{2}] ‚Äì Latest run failed, checking hosts..." -f $cluster_name,$pgName,$runType) "Red"
        }

        if($latest.objects){
          $hosts = $latest.objects | Where-Object { $_.object.objectType -eq 'kHost' -and $_.object.environment -eq 'kPhysical' }
          foreach($h in $hosts){
            $attempts = $h.localSnapshotInfo.failedAttempts
            if($attempts -and $attempts.Count -gt 0){
              foreach($fa in $attempts){
                $msg = Clean-Msg $fa.message
                $global += [pscustomobject]@{
                  Cluster         = $cluster_name
                  ProtectionGroup = $pgName
                  Environment     = $Label
                  RunType         = $runType
                  Name            = $h.object.name
                  ParentHost      = $null
                  StartTime       = $startLocal
                  EndTime         = $endLocal
                  FailedMessage   = $msg
                }
              }
            } else {
              # keep your generic row so failures are visible even without per-object details
              $global += [pscustomobject]@{
                Cluster         = $cluster_name
                ProtectionGroup = $pgName
                Environment     = $Label
                RunType         = $runType
                Name            = $h.object.name
                ParentHost      = $null
                StartTime       = $startLocal
                EndTime         = $endLocal
                FailedMessage   = "Run failed (no per-object failedAttempts details)"
              }
            }
          }
        } else {
          # no objects returned at all
          $global += [pscustomobject]@{
            Cluster         = $cluster_name
            ProtectionGroup = $pgName
            Environment     = $Label
            RunType         = $runType
            Name            = "(no object details)"
            ParentHost      = $null
            StartTime       = $startLocal
            EndTime         = $endLocal
            FailedMessage   = "Run failed (objects[] unavailable ‚Äì check includeObjectDetails)"
          }
        }
      }
    }
  }

  if($global.Count -gt 0){
    $rows = $global |
      Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.Environment)|$($_.RunType)|$($_.Name)|$($_.FailedMessage)|$($_.EndTime)" } |
      ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 } |
      Sort-Object Cluster,ProtectionGroup,EndTime -Descending

    $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
    $csvPath   = Join-Path $logDirectory "BackupFailures_Physical_AllClusters_$timestamp.csv"
    $rows | Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8
    return [pscustomobject]@{ Rows = $rows; Csv = $csvPath }
  } else {
    return [pscustomobject]@{ Rows = @(); Csv = $null }
  }
}

# --- RemoteAdapter: failed WITHOUT later success ---
function Collect-RemoteAdapter {
  $Label="RemoteAdapter"; $global=@()

  foreach ($clus in $json_clu) {
    $cluster_name = ($clus.name, $clus.clusterName, $clus.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
    if (-not $cluster_name) { $cluster_name = "Unknown-$($clus.clusterId)" }
    $headers = @{ apiKey=$apiKey; accessClusterId=$clus.clusterId }

    $pgUrl = "$baseUrl/v2/data-protect/protection-groups?environments=kRemoteAdapter&isDeleted=false&isPaused=false&isActive=true"
    try { $pgs = ((Invoke-WebRequest -Method Get -Uri $pgUrl -Headers $headers).Content | ConvertFrom-Json).protectionGroups }
    catch { continue }
    if (-not $pgs) { continue }

    foreach ($pg in $pgs) {
      $pgId=$pg.id; $pgName=$pg.name

      $HostName = $null; $DB_name  = $null
      try {
        $HostName = $pg.remoteAdapterParams.hosts.hostname
        if ($HostName -is [System.Array]) { $HostName = ($HostName -join ',') }
        $args = $pg.remoteAdapterParams.hosts.incrementalBackupScript.params
        if ($args -is [System.Array]) { $args = ($args -join ' ') }
        if ($args -match "-o\s+(\S+)") { $DB_name = $matches[1] }
      } catch { }

      $runUrl = "$baseUrl/v2/data-protect/protection-groups/$pgId/runs?environments=kRemoteAdapter&numRuns=10&excludeNonRestorableRuns=false&includeObjectDetails=true"
      try { $json = (Invoke-WebRequest -Method Get -Uri $runUrl -Headers $headers | ConvertFrom-Json) }
      catch { continue }
      $runs = if ($json -and $json.runs) { $json.runs } else { @() }
      if (-not $runs) { continue }

      # Flatten localBackupInfo[]
      $flat = @()
      foreach ($run in $runs) {
        if ($run.localBackupInfo) {
          foreach ($info in $run.localBackupInfo) {
            $flat += [pscustomobject]@{
              RunType         = $info.runType
              Status          = $info.status
              Message         = $info.messages
              StartTimeUsecs  = $info.startTimeUsecs
              EndTimeUsecs    = $info.endTimeUsecs
              Cluster         = $cluster_name
              ProtectionGroup = $pgName
              HostName        = $HostName
              DB_name         = $DB_name
            }
          }
        }
      }
      if (-not $flat) { continue }

      $groups = $flat | Group-Object RunType
      foreach ($g in $groups) {
        $latestFailed = $g.Group | Where-Object { $_.Status -eq 'Failed' } | Sort-Object EndTimeUsecs -Descending | Select-Object -First 1
        if ($null -eq $latestFailed) { continue }

        $hasLaterSuccess = $g.Group | Where-Object { $_.Status -in @('Succeeded','SucceededWithWarning') -and $_.StartTimeUsecs -gt $latestFailed.EndTimeUsecs }
        if ($hasLaterSuccess) { continue }

        $startLocal = Convert-ToLocalFromUsecs $latestFailed.StartTimeUsecs $tz
        $endLocal   = Convert-ToLocalFromUsecs $latestFailed.EndTimeUsecs   $tz
        $msg = $latestFailed.Message; if ($msg -is [System.Array]) { $msg = ($msg -join ' | ') }

        $global += [pscustomobject]@{
          Cluster         = $latestFailed.Cluster
          ProtectionGroup = $latestFailed.ProtectionGroup
          Environment     = $Label
          RunType         = $latestFailed.RunType
          Name            = (if ($latestFailed.DB_name) { $latestFailed.DB_name } else { $latestFailed.HostName })
          ParentHost      = $null
          StartTime       = $startLocal
          EndTime         = $endLocal
          FailedMessage   = $msg
        }
      }
    }
  }

  if ($global.Count -gt 0) {
    $rows = $global |
      Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.Environment)|$($_.RunType)|$($_.Name)|$($_.FailedMessage)|$($_.EndTime)" } |
      ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 } |
      Sort-Object Cluster,ProtectionGroup,EndTime -Descending

    $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
    $csvPath   = Join-Path $logDirectory "BackupFailures_RemoteAdapter_AllClusters_$timestamp.csv"
    $rows | Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8
    return [pscustomobject]@{ Rows = $rows; Csv = $csvPath }
  } else {
    return [pscustomobject]@{ Rows = @(); Csv = $null }
  }
}

# =====================================================================
# Run menu selection
# =====================================================================
$summary   = New-Object System.Collections.ArrayList
$allTables = New-Object System.Collections.ArrayList
function Add-SummaryLine($label,$csv){
  $csvText = if ($csv -and -not ([string]::IsNullOrWhiteSpace($csv))) { [string]$csv } else { "No failures (no CSV)" }
  $null = $summary.Add(("{0}: {1}" -f $label, $csvText))
}
function Show-Table {
  param($label,$rows,$csvPath)
  if($rows.Count -gt 0){
    Write-Host ("`nüî• Latest Failed {0} Runs (All Clusters):`n" -f $label) -ForegroundColor Cyan
    $rows | Select-Object Cluster,ProtectionGroup,Environment,RunType,Name,ParentHost,StartTime,EndTime,FailedMessage |
            Format-Table -AutoSize
    if($csvPath){ Write-Host ("`nüìÇ CSV saved: {0}" -f $csvPath) -ForegroundColor Gray }
    Add-SummaryLine $label $csvPath
  } else {
    if($script:VerboseMode){
      Write-Host ("‚úÖ No failures found for {0} (All Clusters)" -f $label) -ForegroundColor Green
    }
    Add-SummaryLine $label $null
  }
}

if($choice -eq "1"){
  Write-Host "`n‚ñ∂ Running ALL environments..." -ForegroundColor Cyan
  foreach($key in ($envMap.Keys|Sort-Object)){
    $env=$envMap[$key]
    Write-Host "`n==============================" -ForegroundColor DarkCyan
    Write-Host ("‚ñ∂ Environment: {0}" -f $env.Label) -ForegroundColor Cyan
    Write-Host "==============================" -ForegroundColor DarkCyan

    $res = switch ($env.Label) {
      "Physical"      { Collect-PhysicalWorking }
      "RemoteAdapter" { Collect-RemoteAdapter }
      default         { Collect-EnvStrictFailedAttempts -Label $env.Label -FilterCSV $env.Filter -ObjectType $env.Object -NameField $env.NameField -ParentHostNeeded:$env.ParentHostNeeded }
    }

    Show-Table -label $env.Label -rows $res.Rows -csvPath $res.Csv
    if($res.Rows.Count -gt 0){ $allTables.AddRange($res.Rows) | Out-Null }
  }

  if($allTables.Count -gt 0){
    Write-Host "`nüî• Combined Failures ‚Äì All Environments" -ForegroundColor Magenta
    $sortedAll=$allTables|Sort-Object Cluster,ProtectionGroup,Environment,EndTime -Descending
    $timestamp=Get-Date -Format "yyyyMMdd_HHmm"
    $combinedPath="$logDirectory\BackupFailures_AllEnvironments_$timestamp.csv"
    $sortedAll|Export-Csv -Path $combinedPath -NoTypeInformation -Encoding utf8
    Write-Host ("üìÇ Combined CSV saved: {0}" -f $combinedPath) -ForegroundColor Gray
    $null=$summary.Add(("All Environments: {0}" -f $combinedPath))
  } else {
    Write-Host "`n‚úÖ All environments succeeded ‚Äî no combined CSV created." -ForegroundColor Green
  }
}
else{
  $selected=$choice.Split(',')|ForEach-Object{$_.Trim()}|Where-Object{$_ -match '^\d+$'}
  foreach($sel in $selected){
    if($envMap.ContainsKey([int]$sel)){
      $env=$envMap[[int]$sel]
      Write-Host ("`n‚ñ∂ Running environment: {0}" -f $env.Label) -ForegroundColor Cyan

      $res = switch ($env.Label) {
        "Physical"      { Collect-PhysicalWorking }
        "RemoteAdapter" { Collect-RemoteAdapter }
        default         { Collect-EnvStrictFailedAttempts -Label $env.Label -FilterCSV $env.Filter -ObjectType $env.Object -NameField $env.NameField -ParentHostNeeded:$env.ParentHostNeeded }
      }

      Show-Table -label $env.Label -rows $res.Rows -csvPath $res.Csv
    } else {
      Write-Host ("‚ö†Ô∏è Invalid selection: {0}" -f $sel) -ForegroundColor Yellow
    }
  }
}

# ---------- Final summary ----------
Write-Host "`n==============================" -ForegroundColor Cyan
Write-Host "          SUMMARY" -ForegroundColor White
Write-Host "==============================" -ForegroundColor Cyan
foreach($line in $summary){ Write-Host $line }
Write-Host "=============================="
Write-Host "‚úÖ Processing complete!" -ForegroundColor Green
