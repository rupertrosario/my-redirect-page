# =====================================================================
# Cohesity Backup Failures ‚Äì Multi-Cluster (Helios)
# Menu-driven | Verbose / Silent | Per-Env & Combined CSV
# Environments: Oracle, SQL, Physical, NAS, HyperV, Acropolis, RemoteAdapter
# =====================================================================

$logDirectory = "X:\PowerShell\Data\Cohesity\BackupFailures"
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory | Out-Null
}

# keep logs tidy (optional; mirrors your template)
$fileCount = (Get-ChildItem -Path $logDirectory -File).Count
if ($fileCount -gt 50) {
    Get-ChildItem -Path $logDirectory -File |
        Sort-Object CreationTime |
        Select-Object -First ($fileCount - 50) |
        Remove-Item -Force
}

# --- Load API key ---
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found: $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()
$commonHeaders = @{ "apiKey" = $apiKey }
$baseUrl = "https://helios.cohesity.com"

# --- Helpers ---
function Convert-ToUtcFromEpoch($v){
    if ($null -eq $v -or $v -eq 0) { return $null }
    try { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$v/1000)).UtcDateTime }
    catch { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$v).UtcDateTime }
}
function Convert-ToLocalFromUsecs($usecs, $tz){
    $utc = Convert-ToUtcFromEpoch $usecs
    if ($null -eq $utc) { return $null }
    if ($tz) { [System.TimeZoneInfo]::ConvertTimeFromUtc($utc,$tz) } else { $utc.ToLocalTime() }
}
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")

function Write-Log($msg,$color="Gray"){ if($script:VerboseMode){ Write-Host $msg -ForegroundColor $color } }
function Get-LatestRun($runs){ $runs | Sort-Object { $_.localBackupInfo[0].endTimeUsecs } -Descending | Select-Object -First 1 }

# --- Get clusters ---
$response = Invoke-WebRequest -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders -Method Get
$json_clu = ($response.Content | ConvertFrom-Json).cohesityClusters
if (-not $json_clu) { throw "No clusters returned from Helios." }

# --- Menu ---
Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "   COHESITY BACKUP FAILURES ‚Äì MAIN MENU" -ForegroundColor White
Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "1.  All Environments"
Write-Host "2.  Oracle"
Write-Host "3.  SQL"
Write-Host "4.  Physical (File System)"
Write-Host "5.  NAS (GenericNas/Isilon)"
Write-Host "6.  Hyper-V"
Write-Host "7.  Acropolis (AHV)"
Write-Host "8.  Remote Adapter"
Write-Host "---------------------------------------------"
$choice = Read-Host "Enter your choice(s) (e.g. 2,3,4)"

Write-Host "`nSelect Mode:" -ForegroundColor Yellow
Write-Host "1. Verbose (detailed, color output)"
Write-Host "2. Silent (compact output; prints tables only for failures)"
$modeChoice = Read-Host "Enter mode [1 or 2]"
$script:VerboseMode = $modeChoice -eq "1"

# --- Environment Map ---
$envMap = @{
    2 = @{ Type="kOracle";        Label="Oracle";        Filter="kOracle";                 Object="kDatabase";       NameField="name" }
    3 = @{ Type="kSQL";           Label="SQL";           Filter="kSQL";                    Object="kDatabase";       NameField="name" }
    4 = @{ Type="kPhysical";      Label="Physical";      Filter="kPhysical";               Object="kHost";           NameField="name" }
    5 = @{ Type="kGenericNas";    Label="NAS";           Filter="kGenericNas,kIsilon";     Object="kHost";           NameField="name" }
    6 = @{ Type="kHyperV";        Label="HyperV";        Filter="kHyperV";                 Object="kVirtualMachine"; NameField="name" }
    7 = @{ Type="kAcropolis";     Label="Acropolis";     Filter="kAcropolis";              Object="kVirtualMachine"; NameField="name" }
    8 = @{ Type="kRemoteAdapter"; Label="RemoteAdapter"; Filter="kRemoteAdapter";          Object="kRemoteAdapter";  NameField="name" }
}

# ==============================================================
# Standard environments collector (Oracle/SQL/Physical/NAS/HyperV/Acropolis)
# ‚Üí Use includeObjectDetails + failedAttempts[] messages
# ‚Üí Show latest run; if failed OR failedAttempts exist, collect rows
# ==============================================================
function Collect-StandardEnv {
    param($Label,$Filter,$ObjectType,$NameField)

    $globalFailures = @()

    foreach($cluster in $json_clu){
        $cluster_name = ($cluster.name, $cluster.clusterName, $cluster.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
        if(-not $cluster_name){ $cluster_name = "Unknown-$($cluster.clusterId)" }
        $cluster_id = $cluster.clusterId
        $headers = @{ apiKey=$apiKey; accessClusterId=$cluster_id }

        Write-Log ("`nüîπ Processing cluster: {0}" -f $cluster_name) "Cyan"

        try {
            $pgResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups" -Headers $headers -Body @{
                environments = $Filter
                isDeleted = "False"
                isPaused = "False"
                isActive = "True"
            } -Method Get
            $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
        } catch {
            Write-Log ("‚ö†Ô∏è Error retrieving PGs on {0}" -f $cluster_name) "Yellow"
            continue
        }
        if(-not $pgs){ Write-Log ("‚ö†Ô∏è No {0} PGs on {1}" -f $Label, $cluster_name) "Yellow"; continue }

        foreach($pg in $pgs){
            $pgId = $pg.id; $pgName = $pg.name

            $runResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" -Headers $headers -Body @{
                environments = $Filter
                numRuns = "10"
                excludeNonRestorableRuns = "False"
                includeObjectDetails = "True"
            } -Method Get
            $runs = ( $runResp.Content | ConvertFrom-Json ).runs
            if(-not $runs){ continue }

            $latestRun = Get-LatestRun $runs
            if(-not $latestRun){ continue }

            $info = $latestRun.localBackupInfo[0]
            $status = $info.status
            $runType = $info.runType
            $startLocal = Convert-ToLocalFromUsecs $info.startTimeUsecs $tz
            $endLocal   = Convert-ToLocalFromUsecs $info.endTimeUsecs   $tz
            $isFailed = ($status -ne "Succeeded" -and $status -ne "SucceededWithWarning")

            Write-Log ("`nüì¶ Checking PG: {0}" -f $pgName) "Yellow"
            if($endLocal){ Write-Log ("   üïì Latest Run Date: {0}" -f $endLocal.ToString('dd-MMM-yyyy HH:mm:ss')) "DarkGray" }
            if($isFailed){ Write-Log ("‚ùå {0} ‚Üí {1} [{2}] ‚Äì Latest run failed" -f $cluster_name,$pgName,$runType) "Red" } else { Write-Log ("‚úÖ {0} ‚Üí {1} [{2}] ‚Äì Latest run succeeded" -f $cluster_name,$pgName,$runType) "Green" }

            if(-not $latestRun.objects){ continue }

            $filterSet = $Filter.Split(',')
            $objs = $latestRun.objects | Where-Object {
                $_.object.objectType -eq $ObjectType -and $_.object.environment -in $filterSet
            }

            foreach($o in $objs){
                $attempts = $o.localSnapshotInfo.failedAttempts
                if($isFailed -or $attempts){
                    if($attempts){
                        foreach($fa in $attempts){
                            $msgClean = ($fa.message -replace '[\r\n]+',' ' -replace ',',' ' -replace '"','''').Trim()
                            $globalFailures += [pscustomobject]@{
                                Cluster         = $cluster_name
                                ProtectionGroup = $pgName
                                Environment     = $Label
                                RunType         = $runType
                                Name            = $o.object.$NameField
                                StartTime       = $startLocal
                                EndTime         = $endLocal
                                FailedMessage   = $msgClean
                            }
                        }
                    } elseif ($isFailed) {
                        $globalFailures += [pscustomobject]@{
                            Cluster         = $cluster_name
                            ProtectionGroup = $pgName
                            Environment     = $Label
                            RunType         = $runType
                            Name            = $o.object.$NameField
                            StartTime       = $startLocal
                            EndTime         = $endLocal
                            FailedMessage   = "No failedAttempts[] details found ‚Äî Run marked Failed"
                        }
                    }
                }
            }
        }
    }

    # Dedup + Output
    if ($globalFailures.Count -gt 0) {
        $globalFailures = $globalFailures |
            Group-Object {
                $end = if ($_.EndTime) { $_.EndTime.ToString('yyyy-MM-dd HH:mm') } else { 'N/A' }
                "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.Name)|$($_.FailedMessage)|$end"
            } |
            ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 }

        Write-Host ("`nüî• Latest Failed {0} Runs (All Clusters):`n" -f $Label) -ForegroundColor Cyan
        $sorted = $globalFailures | Sort-Object Cluster,ProtectionGroup,EndTime -Descending
        $sorted | Format-Table Cluster,ProtectionGroup,RunType,Name,StartTime,EndTime,FailedMessage -AutoSize

        $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
        $csvPath = "$logDirectory\BackupFailures_${Label}_AllClusters_$timestamp.csv"
        $sorted | Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8
        Write-Host ("üìÇ CSV saved: {0}" -f $csvPath) -ForegroundColor Gray
        return ,$sorted, $csvPath
    }
    else {
        Write-Host ("`n‚úÖ No failures found for {0} (All Clusters)" -f $Label) -ForegroundColor Green
        return ,@(), $null
    }
}

# ==============================================================
# RemoteAdapter collector (screenshot-faithful)
# ‚Üí Pull PG host/args; flatten localBackupInfo into rows
# ‚Üí Group by RunType; take latest Failed without a later Success
# ==============================================================
function Collect-RemoteAdapter {
    $Label = "RemoteAdapter"
    $Filter = "kRemoteAdapter"

    $globalFailures = @()

    foreach ($clus in $json_clu) {
        $cluster_name = ($clus.name, $clus.clusterName, $clus.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
        if (-not $cluster_name) { $cluster_name = "Unknown-$($clus.clusterId)" }
        $cluster_id = $clus.clusterId
        $headers = @{ apiKey=$apiKey; accessClusterId=$cluster_id }

        Write-Log ("`nüîπ Processing cluster: {0}" -f $cluster_name) "Cyan"

        # List RemoteAdapter PGs
        try {
            $pgResponse = Invoke-WebRequest -Method Get -Uri "$baseUrl/v2/data-protect/protection-groups" -Headers $headers -Body @{
                environments = $Filter
                isDeleted    = "False"
                isPaused     = "False"
                isActive     = "True"
            }
            $pgs = ($pgResponse.Content | ConvertFrom-Json).protectionGroups
        } catch {
            Write-Log ("‚ö†Ô∏è Failed to list RemoteAdapter PGs on {0}" -f $cluster_name) "Yellow"
            continue
        }
        if (-not $pgs) { Write-Log ("‚ö†Ô∏è No RemoteAdapter PGs on {0}" -f $cluster_name) "Yellow"; continue }

        foreach ($pg in $pgs) {
            $pgId = $pg.id; $pgName = $pg.name

            # Extract host and DB from PG params (as in your photos)
            $HostName = $null; $DB_name = $null
            try {
                $HostName = $pg.remoteAdapterParams.hosts.hostname
                if ($HostName -is [System.Array]) { $HostName = ($HostName -join ',') }

                $args = $pg.remoteAdapterParams.hosts.incrementalBackupScript.params
                if ($args -is [System.Array]) { $args = ($args -join ' ') }
                if ($args -match "-o\s+(\S+)") { $DB_name = $matches[1] }
            } catch { }

            # Fetch recent runs (with details)
            $runResp = Invoke-WebRequest -Method Get -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" -Headers $headers -Body @{
                environments             = $Filter
                isDeleted                = "False"
                isPaused                 = "False"
                isActive                 = "True"
                numRuns                  = "10"
                excludeNonRestorableRuns = "False"
                includeObjectDetails     = "True"
            }
            $json = $runResp | ConvertFrom-Json
            $runs = if ($json -and $json.runs) { $json.runs } else { @() }
            if (-not $runs) { continue }

            # Flatten localBackupInfo (screenshot flow)
            $flatRuns = @()
            foreach ($run in $runs) {
                if ($run.localBackupInfo) {
                    foreach ($info in $run.localBackupInfo) {
                        $flatRuns += [pscustomobject]@{
                            RunType         = $info.runType
                            Status          = $info.status
                            Message         = $info.messages
                            StartTimeUsecs  = $info.startTimeUsecs
                            EndTimeUsecs    = $info.endTimeUsecs
                            Cluster         = $cluster_name
                            ProtectionGroup = $pgName
                            HostName        = $HostName
                            DB_name         = $DB_name
                        }
                    }
                }
            }
            if (-not $flatRuns) { continue }

            # Group by RunType ‚Üí pick latest Failed, and ensure NO later success
            $grouped = $flatRuns | Group-Object RunType
            foreach ($g in $grouped) {
                $latestFailed = $g.Group | Where-Object { $_.Status -eq 'Failed' } |
                                Sort-Object EndTimeUsecs -Descending | Select-Object -First 1
                if (-not $latestFailed) { continue }

                $hasLaterSuccess = $g.Group | Where-Object {
                    $_.Status -in @('Succeeded','SucceededWithWarning') -and
                    $_.StartTimeUsecs -gt $latestFailed.EndTimeUsecs
                }
                if ($hasLaterSuccess) { continue }

                $startLocal = Convert-ToLocalFromUsecs $latestFailed.StartTimeUsecs $tz
                $endLocal   = Convert-ToLocalFromUsecs $latestFailed.EndTimeUsecs   $tz
                $msg = $latestFailed.Message
                if ($msg -is [System.Array]) { $msg = ($msg -join ' | ') }

                $globalFailures += [pscustomobject]@{
                    Cluster         = $latestFailed.Cluster
                    ProtectionGroup = $latestFailed.ProtectionGroup
                    Environment     = $Label
                    RunType         = $latestFailed.RunType
                    Name            = if ($latestFailed.DB_name) { $latestFailed.DB_name } else { $latestFailed.HostName }
                    StartTime       = $startLocal
                    EndTime         = $endLocal
                    FailedMessage   = $msg
                }
            }
        }
    }

    if ($globalFailures.Count -gt 0) {
        $globalFailures = $globalFailures |
            Group-Object {
                $end = if ($_.EndTime) { $_.EndTime.ToString('yyyy-MM-dd HH:mm') } else { 'N/A' }
                "$($_.Cluster)|$($_.ProtectionGroup)|$($_.RunType)|$($_.Name)|$($_.FailedMessage)|$end"
            } |
            ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 }

        Write-Host ("`nüî• Latest Failed {0} Runs (All Clusters):`n" -f $Label) -ForegroundColor Cyan
        $sorted = $globalFailures | Sort-Object Cluster,ProtectionGroup,EndTime -Descending
        $sorted | Format-Table Cluster,ProtectionGroup,RunType,Name,StartTime,EndTime,FailedMessage -AutoSize

        $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
        $csvPath = "$logDirectory\BackupFailures_${Label}_AllClusters_$timestamp.csv"
        $sorted | Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8
        Write-Host ("üìÇ CSV saved: {0}" -f $csvPath) -ForegroundColor Gray
        return ,$sorted, $csvPath
    } else {
        Write-Host ("`n‚úÖ No failures found for {0} (All Clusters)" -f $Label) -ForegroundColor Green
        return ,@(), $null
    }
}

# --- Run selection ---
$summary   = New-Object System.Collections.ArrayList
$allTables = New-Object System.Collections.ArrayList

if($choice -eq "1"){
    Write-Host "`n‚ñ∂ Running ALL environments..." -ForegroundColor Cyan
    foreach($key in ($envMap.Keys | Sort-Object)){
        $env = $envMap[$key]
        Write-Host "`n==============================" -ForegroundColor DarkCyan
        Write-Host ("‚ñ∂ Environment: {0}" -f $env.Label) -ForegroundColor Cyan
        Write-Host "==============================" -ForegroundColor DarkCyan

        if ($env.Label -eq "RemoteAdapter") {
            $rows,$csv = Collect-RemoteAdapter
        } else {
            $rows,$csv = Collect-StandardEnv -Label $env.Label -Filter $env.Filter -ObjectType $env.Object -NameField $env.NameField
        }

        if($rows.Count -gt 0){
            $summary.Add(("üìÇ {0}: Failures found ‚Üí {1}" -f $env.Label,$csv)) | Out-Null
            $allTables.AddRange($rows) | Out-Null
        } else {
            $summary.Add(("‚úÖ {0}: No failures found (no CSV created)" -f $env.Label)) | Out-Null
        }
        Start-Sleep -Seconds 1
    }

    if($allTables.Count -gt 0){
        Write-Host "`nüî• Combined Failures ‚Äì All Environments" -ForegroundColor Magenta
        $sortedAll = $allTables | Sort-Object Cluster,ProtectionGroup,Environment,EndTime -Descending
        if($script:VerboseMode){ $sortedAll | Format-Table Cluster,ProtectionGroup,Environment,RunType,Name,StartTime,EndTime,FailedMessage -AutoSize }

        $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
        $combinedPath = "$logDirectory\BackupFailures_AllEnvironments_$timestamp.csv"
        $sortedAll | Export-Csv -Path $combinedPath -NoTypeInformation -Encoding utf8
        Write-Host ("üìÇ Combined CSV saved: {0}" -f $combinedPath) -ForegroundColor Gray
        $summary.Add(("üìÇ All Environments: Combined failures ‚Üí {0}" -f $combinedPath)) | Out-Null
    } else {
        Write-Host "`n‚úÖ All environments succeeded ‚Äî no combined CSV created." -ForegroundColor Green
    }
}
else{
    $selected = $choice.Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ -match '^\d+$' }
    foreach($sel in $selected){
        if($envMap.ContainsKey([int]$sel)){
            $env = $envMap[[int]$sel]
            Write-Host ("`n‚ñ∂ Running environment: {0}" -f $env.Label) -ForegroundColor Cyan

            if ($env.Label -eq "RemoteAdapter") {
                $rows,$csv = Collect-RemoteAdapter
            } else {
                $rows,$csv = Collect-StandardEnv -Label $env.Label -Filter $env.Filter -ObjectType $env.Object -NameField $env.NameField
            }

            if($rows.Count -gt 0){
                $summary.Add(("üìÇ {0}: Failures found ‚Üí {1}" -f $env.Label,$csv)) | Out-Null
            } else {
                $summary.Add(("‚úÖ {0}: No failures found (no CSV created)" -f $env.Label)) | Out-Null
            }
        } else {
            Write-Host ("‚ö†Ô∏è Invalid selection: {0}" -f $sel) -ForegroundColor Yellow
        }
    }
}

# --- Final summary (always show) ---
Write-Host "`n==============================" -ForegroundColor Cyan
Write-Host "          SUMMARY" -ForegroundColor White
Write-Host "==============================" -ForegroundColor Cyan
foreach($line in $summary){ Write-Host $line }
Write-Host "=============================="
Write-Host "All environments processed."

Write-Host "`n‚úÖ Processing complete!" -ForegroundColor Green
