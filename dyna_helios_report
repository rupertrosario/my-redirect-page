import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alert Tiles (Markdown-only, Severity Symbols)
 * - GET-only
 * - ONLY clusters that currently have Active (kOpen) alerts are shown (short output)
 * - Sections: Hardware / Maintenance / Data Service
 * - Columns: EXACT alertCategory enums (alphabetical)
 * - Cell:
 *     - ✅ if no active alerts for that category on that cluster
 *     - else ⛔<n> ⚠️<n> ℹ️<n>
 *
 * Return: { markdownEmail }
 * Email body: {{ result("run_javascript_1").markdownEmail }}
 */
export default async function () {
  const baseUrl = "https://helios.cohesity.com";
  const alertsPath = "/mcm/alerts";

  // ==============================
  // 1) Auth (ID-only; proven working in your probe)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const sec = await credentialVaultClient.getCredentialById({ id: vaultId });
  const apiKey = (sec?.token ?? sec?.password ?? sec?.value ?? "").trim();
  if (!apiKey) throw new Error(`Vault secret empty for id=${vaultId}`);

  const headers = {
    apiKey,
    Accept: "application/json",
    "Content-Type": "application/json"
  };

  // ==============================
  // 2) CATEGORY COLUMNS (EXACT ENUMS)
  // ==============================
  const HW_Cats = [
    "kCPU","kChassis","kCluster","kDisk","kFan","kFirmware","kMemory","kNIC",
    "kNode","kNodeHealth","kOperatingSystem","kPowerSupply","kStorageDevice",
    "kStoragePool","kTemperature"
  ].sort();

  const MAINT_Cats = [
    "kAuditLog","kClusterManagement","kConfiguration","kFaultTolerance",
    "kGeneralSoftwareFailure","kHelios","kLicense","kNetworking","kSecurity",
    "kStorageUsage","kSystemService","kUpgrade"
  ].sort();

  const DS_Cats = [
    "kAgent","kAppMarketPlace","kArchivalRestore","kBackupRestore","kCDP",
    "kDataPath","kDataSourceConnector","kDisasterRecovery","kIndexing","kMetadata",
    "kNetBackup","kQuota","kRemoteReplication","kViewFailover"
  ].sort();

  // ==============================
  // 3) SYMBOLS
  // ==============================
  const SYM_HEALTHY = "✅";
  const SYM_C = "⛔";
  const SYM_W = "⚠️";
  const SYM_I = "ℹ️";

  // ==============================
  // 4) HELPERS
  // ==============================
  function sevBucket(sev) {
    switch (sev) {
      case "kCritical": return "C";
      case "kWarning":  return "W";
      case "kInfo":     return "I";
      default:          return "I";
    }
  }

  function normalizeAlerts(resp) {
    if (Array.isArray(resp)) return resp;
    if (Array.isArray(resp?.alerts)) return resp.alerts;
    if (Array.isArray(resp?.items)) return resp.items;
    return [];
  }

  async function getJson(url, method = "GET", bodyObj = null) {
    const init = { method, headers };
    if (bodyObj) init.body = JSON.stringify(bodyObj);

    const resp = await fetch(url, init);
    if (!resp.ok) {
      const txt = await resp.text().catch(() => "");
      throw new Error(`${method} ${url} -> HTTP ${resp.status} ${txt || resp.statusText}`);
    }
    return resp.json().catch(() => ({}));
  }

  // --- IMPORTANT ---
  // Many tenants expect filter payload for /mcm/alerts.
  // Use POST with JSON body to avoid filter param mismatch.
  async function getActiveAlertsByBucket(bucketEnum) {
    const url = `${baseUrl}${alertsPath}`;
    const body = {
      alertStateList: ["kOpen"],
      alertTypeBucketList: [bucketEnum]
    };
    const j = await getJson(url, "POST", body);
    return normalizeAlerts(j);
  }

  function cellValue(C, W, I) {
    if (C === 0 && W === 0 && I === 0) return SYM_HEALTHY;
    return `${SYM_C}${C} ${SYM_W}${W} ${SYM_I}${I}`;
  }

  function buildMarkdownTable(rows, categories) {
    if (!rows?.length) return "No Active alerts (no clusters to display).";

    const header = ["ClusterName", ...categories];
    const sep = header.map(() => "---");

    const lines = [];
    lines.push(`| ${header.join(" | ")} |`);
    lines.push(`| ${sep.join(" | ")} |`);

    for (const row of rows) {
      const vals = [row.ClusterName, ...categories.map((c) => row[c] ?? SYM_HEALTHY)];
      lines.push(`| ${vals.join(" | ")} |`);
    }
    return lines.join("\n");
  }

  async function buildWideTileTableSeverityShort(bucketEnum, categories) {
    const alerts = await getActiveAlertsByBucket(bucketEnum);

    // Cluster list ONLY from alerts (short output)
    const clusters = Array.from(
      new Set(
        alerts
          .map((a) => String(a?.clusterName ?? "").trim())
          .filter((x) => x.length > 0)
      )
    ).sort((a, b) => a.localeCompare(b));

    if (!clusters.length) return { markdown: "" };

    const counts = new Map(); // key "cluster||cat" -> {C,W,I}

    for (const a of alerts) {
      const cluster = String(a?.clusterName ?? "").trim();
      const cat = String(a?.alertCategory ?? "").trim();
      if (!cluster || !cat) continue;
      if (!categories.includes(cat)) continue;

      const key = `${cluster}||${cat}`;
      if (!counts.has(key)) counts.set(key, { C: 0, W: 0, I: 0 });

      const b = sevBucket(String(a?.severity ?? ""));
      counts.get(key)[b] += 1;
    }

    const rows = clusters.map((c) => {
      const row = { ClusterName: c };
      for (const cat of categories) {
        const key = `${c}||${cat}`;
        if (!counts.has(key)) row[cat] = SYM_HEALTHY;
        else {
          const { C, W, I } = counts.get(key);
          row[cat] = cellValue(C, W, I);
        }
      }
      return row;
    });

    return { markdown: buildMarkdownTable(rows, categories) };
  }

  // ==============================
  // 5) BUILD OUTPUT
  // ==============================
  const note =
    `NOTE:\n` +
    `- This report shows ONLY clusters that currently have Active (kOpen) alerts in each section.\n` +
    `- Clusters not displayed have no Active alerts for that section (healthy for these tiles).\n` +
    `- Cells show "${SYM_HEALTHY}" or "${SYM_C}<n> ${SYM_W}<n> ${SYM_I}<n>".`;

  const hw  = await buildWideTileTableSeverityShort("kHardware", HW_Cats);
  const mnt = await buildWideTileTableSeverityShort("kMaintenance", MAINT_Cats);
  const ds  = await buildWideTileTableSeverityShort("kDataService", DS_Cats);

  const markdownEmail =
    `${note}\n\n` +
    `Hardware\n${hw.markdown || "No Active alerts (no clusters to display)."}\n\n` +
    `Maintenance\n${mnt.markdown || "No Active alerts (no clusters to display)."}\n\n` +
    `Data Service\n${ds.markdown || "No Active alerts (no clusters to display)."}`;

  return { markdownEmail };
}
