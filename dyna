// Dynatrace Workflow: Run JavaScript (no Credential Vault)
// Scopes needed for the workflow runner: environment-api:metrics:ingest
import { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';

export default async function () {
  console.log("ğŸš€ Cohesity Helios â†’ Dynatrace metrics (READ-ONLY, manual API key)");

  // ğŸ”“ Paste your Helios API key here (temporary; remove before prod)
  const apiKey  = "PASTE_YOUR_HELIOS_API_KEY_HERE";
  if (!apiKey || apiKey.includes("PASTE_YOUR_HELIOS_API_KEY_HERE")) {
    throw new Error("âŒ Please paste a valid Cohesity Helios API key.");
  }

  const baseUrl = "https://helios.cohesity.com";
  const oneTiB  = 1099511627776;
  const headers = { accept: "application/json", apiKey };

  // 1) Inventory: all clusters visible to this key
  const listUrl  = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const listResp = await fetch(listUrl, { method: "GET", headers });
  if (listResp.status !== 200) throw new Error(`Cluster list failed (HTTP ${listResp.status})`);
  const data     = await listResp.json();
  const clusters = data?.cohesityClusters || [];
  if (clusters.length === 0) {
    console.log("âš ï¸ No clusters returned from Helios.");
    return { clusters: [] };
  }

  const results = [];
  const lines   = [];  // Dynatrace Metrics v2 payload (one metric per line)

  for (const { clusterName, clusterId } of clusters) {
    const h = { ...headers, accessClusterId: String(clusterId) };

    // Canonical entityId for timeSeriesStats
    const safeName = clusterName.replace(/\s+/g, '');
    const entityId = `${safeName}+(ID+${clusterId})`;

    // 2) Garbage bytes (latest)
    const tsUrl =
      `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
      `?schemaName=ApolloV2ClusterStats` +
      `&metricName=EstimatedGarbageBytes` +
      `&startTimeMsecs=2` +
      `&entityId=${encodeURIComponent(entityId)}` +
      `&rollupFunction=latest` +
      `&rollupIntervalSecs=30` +
      `&metricUnitType=0` +
      `&range=day`;

    const tsResp = await fetch(tsUrl, { method: "GET", headers: h });
    if (tsResp.status !== 200) {
      console.log(`âš ï¸ Garbage stats GET failed for ${clusterName} (HTTP ${tsResp.status})`);
      continue;
    }
    const tsJson = await tsResp.json();
    const latest = Array.isArray(tsJson?.dataPointVec)
      ? tsJson.dataPointVec[tsJson.dataPointVec.length - 1]
      : undefined;
    const garbageBytes = latest?.data?.int64Value ?? 0;
    const garbageGB    = +(garbageBytes / (1024 ** 3)).toFixed(2);
    const garbageTB    = +(garbageBytes / (1024 ** 4)).toFixed(3);

    // 3) Capacity (total/used/available)
    const capUrl  = `${baseUrl}/irisservices/api/v1/public/stats/storage`;
    const capResp = await fetch(capUrl, { method: "GET", headers: h });
    if (capResp.status !== 200) {
      console.log(`âš ï¸ Capacity stats GET failed for ${clusterName} (HTTP ${capResp.status})`);
      continue;
    }
    const s = await capResp.json();
    const totalTiB = +(s.totalCapacityBytes   / oneTiB).toFixed(2);
    const usedTiB  = +(s.localUsageBytes      / oneTiB).toFixed(2);
    const availTiB = +(s.localAvailableBytes  / oneTiB).toFixed(2);
    const consumed = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

    results.push({
      clusterName, clusterId, totalTiB, usedTiB, availTiB,
      consumedPercent: consumed, garbageGB, garbageTB
    });

    // 4) Build metrics lines (dimensions = clusterName, clusterId)
    const dims = `clusterName="${clusterName.replace(/"/g, '\\"')}",clusterId="${clusterId}"`;
    lines.push(
      `cohesity.capacity.total.tib,${dims} ${totalTiB}`,
      `cohesity.capacity.used.tib,${dims} ${usedTiB}`,
      `cohesity.capacity.avail.tib,${dims} ${availTiB}`,
      `cohesity.capacity.consumed.percent,${dims} ${consumed}`,
      `cohesity.garbage.gb,${dims} ${garbageGB}`,
      `cohesity.garbage.tb,${dims} ${garbageTB}`
    );

    console.log(`âœ… ${clusterName}: ${consumed}% used (${usedTiB}/${totalTiB} TiB) | Garbage ${garbageGB} GB`);
  }

  // 5) Ingest to Dynatrace Metrics v2
  if (lines.length > 0) {
    await metricsClient.ingest({ body: lines.join('\n') });
    console.log(`ğŸ“¥ Ingested ${lines.length} metric lines.`);
  } else {
    console.log("â„¹ï¸ No metric lines to ingest.");
  }

  // Visible summary in the run output
  return { clusters: results };
}
