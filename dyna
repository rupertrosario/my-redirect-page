// Dynatrace Workflow: Cohesity Capacity Stats via Helios API
// Author: Rupert Rosario

const apiKey = Deno.env.get("COHESITY_API_KEY"); // Add as secure variable in step 5
const heliosUrl = "https://helios.cohesity.com";
const clusterInfoUrl = `${heliosUrl}/v2/mcm/cluster-mgmt/info`;
const storageUrl = `${heliosUrl}/irisservices/api/v1/public/stats/storage`;

console.log("üîπ Starting Cohesity Capacity Workflow...");

// ---- Step 1: Get Cluster List ----
const clusterResponse = await fetch(clusterInfoUrl, {
  method: "GET",
  headers: { "apiKey": apiKey },
});

if (!clusterResponse.ok) throw new Error(`‚ùå Failed to fetch clusters: ${clusterResponse.statusText}`);

const clusterData = await clusterResponse.json();
const clusters = clusterData.cohesityClusters;

for (const cluster of clusters) {
  const clusterId = cluster.clusterId;
  const clusterName = cluster.clusterName;

  console.log(`\n‚ñ∂ Checking Cluster: ${clusterName}`);

  // ---- Step 2: Get Storage Stats ----
  const storageResponse = await fetch(storageUrl, {
    method: "GET",
    headers: {
      "apiKey": apiKey,
      "accessClusterId": clusterId
    },
  });

  if (!storageResponse.ok) {
    console.error(`Failed to get stats for ${clusterName}`);
    continue;
  }

  const stats = await storageResponse.json();

  const totalTiB = (stats.totalCapacityBytes / (1024 ** 4)).toFixed(2);
  const usedTiB = (stats.localUsageBytes / (1024 ** 4)).toFixed(2);
  const freeTiB = (stats.localAvailableBytes / (1024 ** 4)).toFixed(2);
  const usedPct = ((stats.localUsageBytes / stats.totalCapacityBytes) * 100).toFixed(1);

  console.log(`‚úÖ ${clusterName} | Total: ${totalTiB} TiB | Used: ${usedTiB} TiB | Free: ${freeTiB} TiB | Used%: ${usedPct}`);
}

return { status: "‚úÖ Completed successfully" };
