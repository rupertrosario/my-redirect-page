/**
 * Cohesity Helios Capacity & Garbage Report (read-only)
 * Works in Dynatrace Simple Workflow runtime (no credentials injection)
 * ------------------------------------------------------------
 * ‚úÖ Uses API key inline (replace with credential later)
 * ‚úÖ Outputs JSON table usable for visualization
 * ‚úÖ Safe GET-only calls
 */

export default async function () {
  // üîê TEMPORARY ‚Äî Replace this with credential vault later
  const apiKey  = "PASTE_YOUR_API_KEY_HERE";
  const baseUrl = "https://helios.cohesity.com";
  const oneTiB  = 1099511627776;
  const headers = { accept: "application/json", apiKey };

  const results = [];

  try {
    // 1Ô∏è‚É£ Get cluster list
    const listUrl = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
    const listResp = await fetch(listUrl, { method: "GET", headers });

    if (listResp.status !== 200) {
      throw new Error(`Cluster list failed (HTTP ${listResp.status})`);
    }

    const listJson = await listResp.json();
    const clusters = listJson?.cohesityClusters || [];

    if (clusters.length === 0) {
      console.log("‚ö†Ô∏è No clusters returned");
      return { clusters: [] };
    }

    // 2Ô∏è‚É£ Loop through clusters
    for (const { clusterName, clusterId } of clusters) {
      const h = { ...headers, accessClusterId: String(clusterId) };
      const safeName = clusterName.replace(/\s+/g, "");
      const entityId = `${safeName}+(ID+${clusterId})`;

      // --- Garbage metric
      const tsUrl =
        `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
        `?schemaName=ApolloV2ClusterStats` +
        `&metricName=EstimatedGarbageBytes` +
        `&startTimeMsecs=2` +
        `&entityId=${entityId}` +
        `&rollupFunction=latest` +
        `&rollupIntervalSecs=30` +
        `&metricUnitType=0` +
        `&range=day`;

      const tsResp = await fetch(tsUrl, { method: "GET", headers: h });
      const tsJson = tsResp.status === 200 ? await tsResp.json() : {};
      const latest = Array.isArray(tsJson?.dataPointVec)
        ? tsJson.dataPointVec.at(-1)
        : undefined;
      const garbageBytes = latest?.data?.int64Value ?? 0;
      const garbageGB = +(garbageBytes / (1024 ** 3)).toFixed(2);
      const garbageTB = +(garbageBytes / (1024 ** 4)).toFixed(3);

      // --- Capacity metric
      const capUrl = `${baseUrl}/irisservices/api/v1/public/stats/storage`;
      const capResp = await fetch(capUrl, { method: "GET", headers: h });
      if (capResp.status !== 200) {
        console.log(`‚ö†Ô∏è Capacity stats failed for ${clusterName}`);
        continue;
      }

      const s = await capResp.json();
      const totalTiB = +(s.totalCapacityBytes / oneTiB).toFixed(2);
      const usedTiB  = +(s.localUsageBytes / oneTiB).toFixed(2);
      const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
      const consumed = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

      results.push({
        clusterName,
        clusterId,
        totalTiB,
        usedTiB,
        availTiB,
        consumedPercent: consumed,
        garbageGB,
        garbageTB,
      });
    }

    // ‚úÖ Final output for visualization
    return { clusters: results };

  } catch (err) {
    return {
      error: err.message,
      hint: "Check API key or endpoint access. Works with Simple Workflow mode."
    };
  }
}
