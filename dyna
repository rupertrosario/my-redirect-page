export default async function () {
  console.log("üöÄ Cohesity Helios ‚Äì Strict READ-ONLY (GET-only, no write/delete/post)");

  // üîê 1Ô∏è‚É£  Try to read the key from the Dynatrace Credential Vault
  //   Add a credential under Inputs ‚Üí Credentials named ‚Äúcohesity-helios-api-key‚Äù.
  //   If that alias exists, Dynatrace injects it at runtime as credentials.cohesity_helios_api_key.token
  let apiKey;
  try {
    if (typeof credentials !== "undefined" && credentials.cohesity_helios_api_key?.token) {
      apiKey = credentials.cohesity_helios_api_key.token;
      console.log("‚úÖ Using Cohesity Helios API key from Credential Vault");
    } else {
      // 2Ô∏è‚É£  No vault credential attached ‚Üí ask for / paste manually
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("‚ö†Ô∏è No credential vault entry found ‚Äì using inline key (for testing only)");
    }
  } catch (e) {
    apiKey = "PASTE_YOUR_API_KEY_HERE";
    console.log("‚ö†Ô∏è credentials object unavailable ‚Äì using inline key");
  }

  const baseUrl = "https://helios.cohesity.com";
  const oneTiB  = 1099511627776;
  const headers = { accept: "application/json", apiKey };

  // 3Ô∏è‚É£  Get cluster inventory
  const listUrl = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const listResp = await fetch(listUrl, { method: "GET", headers });
  if (listResp.status !== 200)
    throw new Error(`‚ùå Cluster list failed (HTTP ${listResp.status})`);

  const data = await listResp.json();
  const clusters = data?.cohesityClusters || [];

  if (clusters.length === 0) {
    console.log("‚ö†Ô∏è No clusters returned.");
    return { clusters: [] };
  }

  const results = [];

  // 4Ô∏è‚É£  For each cluster, read-only GETs for garbage + capacity
  for (const { clusterName, clusterId } of clusters) {
    const h = { ...headers, accessClusterId: String(clusterId) };
    console.log(`üìä Reading ${clusterName} (ID ${clusterId})`);

    const safeName = clusterName.replace(/\s+/g, "");
    const entityId = `${safeName}+(ID+${clusterId})`;

    // --- Garbage metric
    const tsUrl =
      `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
      `?schemaName=ApolloV2ClusterStats` +
      `&metricName=EstimatedGarbageBytes` +
      `&startTimeMsecs=2` +
      `&entityId=${entityId}` +
      `&rollupFunction=latest` +
      `&rollupIntervalSecs=30` +
      `&metricUnitType=0` +
      `&range=day`;

    console.log(`üîó GET ‚Üí ${tsUrl}`);
    const tsResp = await fetch(tsUrl, { method: "GET", headers: h });
    if (tsResp.status !== 200) {
      console.log(`‚ö†Ô∏è Garbage stats GET failed for ${clusterName} (HTTP ${tsResp.status})`);
      continue;
    }

    const tsJson = await tsResp.json();
    const latest = Array.isArray(tsJson?.dataPointVec)
      ? tsJson.dataPointVec.at(-1)
      : undefined;
    const garbageBytes = latest?.data?.int64Value ?? 0;
    const garbageGB = +(garbageBytes / (1024 ** 3)).toFixed(2);
    const garbageTB = +(garbageBytes / (1024 ** 4)).toFixed(3);

    // --- Capacity metric
    const capUrl = `${baseUrl}/irisservices/api/v1/public/stats/storage`;
    const capResp = await fetch(capUrl, { method: "GET", headers: h });
    if (capResp.status !== 200) {
      console.log(`‚ö†Ô∏è Capacity stats GET failed for ${clusterName} (HTTP ${capResp.status})`);
      continue;
    }

    const s = await capResp.json();
    const totalTiB = +(s.totalCapacityBytes / oneTiB).toFixed(2);
    const usedTiB  = +(s.localUsageBytes / oneTiB).toFixed(2);
    const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
    const consumed = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

    results.push({
      clusterName,
      clusterId,
      totalTiB,
      usedTiB,
      availTiB,
      consumedPercent: consumed,
      garbageGB,
      garbageTB
    });

    console.log(
      `‚úÖ ${clusterName}: ${consumed}% used (${usedTiB}/${totalTiB} TiB) | Garbage ${garbageGB} GB (${garbageTB} TB)`
    );
  }

  console.log("üìÑ Final summary (read-only):");
  console.log(JSON.stringify(results, null, 2));

  return { clusters: results };
}
