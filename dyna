export default async function () {
  // --- Config ---
  const apiKey  = credentials.Cohesity_API_Key.token;   // from Dynatrace vault
  const baseUrl = "https://helios.cohesity.com";
  const oneTiB  = 1099511627776;
  const headers = { accept: "application/json", apiKey };

  // --- Step 1: Get cluster list ---
  const listUrl = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const listResp = await fetch(listUrl, { method: "GET", headers });
  if (listResp.status !== 200) throw new Error(`Cluster list failed: ${listResp.status}`);

  const data = await listResp.json();
  const clusters = data?.cohesityClusters || [];
  if (clusters.length === 0) return { clusters: [] };

  const results = [];

  // --- Step 2: Loop through clusters ---
  for (const { clusterName, clusterId } of clusters) {
    const h = { ...headers, accessClusterId: String(clusterId) };
    const safeName = clusterName.replace(/\s+/g, '');
    const entityId = `${safeName}+(ID+${clusterId})`;

    // --- Garbage metric ---
    const tsUrl =
      `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
      `?schemaName=ApolloV2ClusterStats&metricName=EstimatedGarbageBytes` +
      `&startTimeMsecs=2&entityId=${entityId}&rollupFunction=latest` +
      `&rollupIntervalSecs=30&metricUnitType=0&range=day`;

    const tsResp = await fetch(tsUrl, { method: "GET", headers: h });
    const tsJson = tsResp.status === 200 ? await tsResp.json() : {};
    const latest = Array.isArray(tsJson?.dataPointVec)
      ? tsJson.dataPointVec.at(-1)
      : undefined;
    const garbageBytes = latest?.data?.int64Value ?? 0;
    const garbageGB = +(garbageBytes / (1024 ** 3)).toFixed(2);
    const garbageTB = +(garbageBytes / (1024 ** 4)).toFixed(3);

    // --- Capacity metric ---
    const capUrl = `${baseUrl}/irisservices/api/v1/public/stats/storage`;
    const capResp = await fetch(capUrl, { method: "GET", headers: h });
    if (capResp.status !== 200) continue;
    const s = await capResp.json();

    const totalTiB = +(s.totalCapacityBytes / oneTiB).toFixed(2);
    const usedTiB  = +(s.localUsageBytes / oneTiB).toFixed(2);
    const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
    const consumed = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

    results.push({
      clusterName,
      totalTiB,
      usedTiB,
      availTiB,
      consumedPercent: consumed,
      garbageGB,
      garbageTB
    });
  }

  // --- Final Output to Dynatrace ---
  return { clusters: results };
}
