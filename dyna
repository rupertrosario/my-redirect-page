import React, { useEffect, useState } from "react";
import { Card } from "@dynatrace-sdk/ui-card";
import { Table } from "@dynatrace-sdk/ui-table";
import { Spinner } from "@dynatrace-sdk/ui-spinner";

export default function CohesityHeliosTile() {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // --- Config ---
  const apiKey = "PASTE_YOUR_API_KEY_HERE"; // ⚠️ Replace with a temporary token
  const baseUrl = "https://helios.cohesity.com";
  const headers = { accept: "application/json", apiKey };
  const oneTiB = 1099511627776;

  useEffect(() => {
    async function fetchData() {
      try {
        // Step 1️⃣ Get cluster list
        const listResp = await fetch(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { headers });
        if (!listResp.ok) throw new Error(`Cluster list failed (${listResp.status})`);
        const listJson = await listResp.json();
        const clusters = listJson?.cohesityClusters || [];

        const results = [];

        // Step 2️⃣ Get capacity + garbage stats for each cluster
        for (const { clusterName, clusterId } of clusters) {
          const h = { ...headers, accessClusterId: String(clusterId) };
          const safeName = clusterName.replace(/\s+/g, "");
          const entityId = `${safeName}+(ID+${clusterId})`;

          // --- Garbage metric
          const tsUrl =
            `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
            `?schemaName=ApolloV2ClusterStats` +
            `&metricName=EstimatedGarbageBytes` +
            `&startTimeMsecs=2&entityId=${entityId}` +
            `&rollupFunction=latest&rollupIntervalSecs=30` +
            `&metricUnitType=0&range=day`;
          const tsResp = await fetch(tsUrl, { headers: h });
          const tsJson = tsResp.ok ? await tsResp.json() : {};
          const latest = Array.isArray(tsJson?.dataPointVec)
            ? tsJson.dataPointVec.at(-1)
            : undefined;
          const garbageBytes = latest?.data?.int64Value ?? 0;
          const garbageGB = +(garbageBytes / (1024 ** 3)).toFixed(2);
          const garbageTB = +(garbageBytes / (1024 ** 4)).toFixed(3);

          // --- Capacity metric
          const capUrl = `${baseUrl}/irisservices/api/v1/public/stats/storage`;
          const capResp = await fetch(capUrl, { headers: h });
          const s = capResp.ok ? await capResp.json() : null;
          if (!s) continue;

          const totalTiB = +(s.totalCapacityBytes / oneTiB).toFixed(2);
          const usedTiB = +(s.localUsageBytes / oneTiB).toFixed(2);
          const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
          const consumed = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

          results.push({
            clusterName,
            totalTiB,
            usedTiB,
            availTiB,
            consumedPercent: consumed,
            garbageGB,
            garbageTB
          });
        }

        setData(results);
      } catch (err) {
        console.error(err);
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }

    fetchData();
  }, []);

  if (loading) return <Spinner label="Fetching Cohesity data..." />;
  if (error) return <Card title="Error" subtitle={error} />;

  return (
    <Card title="Cohesity Helios – Cluster Capacity Summary">
      <Table
        columns={[
          { header: "Cluster", accessor: "clusterName" },
          { header: "Used (TiB)", accessor: "usedTiB" },
          { header: "Available (TiB)", accessor: "availTiB" },
          { header: "Total (TiB)", accessor: "totalTiB" },
          { header: "Consumed (%)", accessor: "consumedPercent" },
          { header: "Garbage (GB)", accessor: "garbageGB" },
        ]}
        data={data}
      />
    </Card>
  );
}
