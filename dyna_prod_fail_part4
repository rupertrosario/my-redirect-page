import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";
import { result } from "@dynatrace-sdk/automation-utils";

/**
 * cohesity_backup_failures (Part 4 / FINAL)
 */
export default async function () {
  const PART3 = "cohesity_backup_failures_p3";
  const p3 = await result(PART3);
  if (!p3 || !Array.isArray(p3.failures)) {
    throw new Error(`Part 4: missing Part 3 output. Check step name: ${PART3}`);
  }

  // Vault auth (kept per requirement; not used further)
  const vaultId = "credentials_vault-312312";
  const vaultCred = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (vaultCred?.token || vaultCred?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  function cleanMsg(s) {
    if (!s) return "";
    return String(s).replace(/[\r\n]+/g, " ").replace(/\|/g, " ").replace(/"/g, "'").trim();
  }

  function etDateYYYYMMDD() {
    const now = new Date();
    const parts = new Intl.DateTimeFormat("en-CA", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    })
      .formatToParts(now)
      .reduce((a, p) => ((a[p.type] = p.value), a), {});
    return `${parts.year}-${parts.month}-${parts.day}`;
  }

  // Dedup: 1 row per identity (same as PS final group)
  const dedup = new Map();
  for (const r of p3.failures) {
    const key = `${r.Environment}|${r.Cluster}|${r.ProtectionGroup}|${r.RunType}|${r.Host}|${r.ObjectType}|${r.ObjectName}`;
    const prev = dedup.get(key);
    if (!prev || String(r.EndTimeET) > String(prev.EndTimeET)) dedup.set(key, r);
  }

  const failures = Array.from(dedup.values()).sort((a, b) => {
    const c = String(a.Cluster).localeCompare(String(b.Cluster));
    if (c) return c;
    const p = String(a.ProtectionGroup).localeCompare(String(b.ProtectionGroup));
    if (p) return p;
    return String(b.EndTimeET).localeCompare(String(a.EndTimeET));
  });

  function toMarkdownTable(rows) {
    if (!rows.length) return "✅ No backup failures found across all clusters.";
    const cols = ["Environment","Cluster","ProtectionGroup","Host","ObjectType","ObjectName","RunType","EndTimeET","FailedMessage"];
    const lines = [];
    lines.push("### Cohesity Backup Failures — All Clusters");
    lines.push(`Total failures: **${rows.length}**`);
    lines.push("");
    lines.push(`| ${cols.join(" | ")} |`);
    lines.push(`| ${cols.map(() => "---").join(" | ")} |`);
    for (const r of rows) {
      const row = [
        r.Environment, r.Cluster, r.ProtectionGroup, r.Host || "",
        r.ObjectType, r.ObjectName, r.RunType, r.EndTimeET, r.FailedMessage
      ].map(cleanMsg);
      lines.push(`| ${row.join(" | ")} |`);
    }
    return lines.join("\n");
  }

  const markdownTable = toMarkdownTable(failures);
  const dateStr = etDateYYYYMMDD();
  const correlationId = `Cohesity_Backup_Failures_${dateStr}`;
  const snow_query = `correlation_id=${correlationId}`;

  const incidentText_create =
    failures.length === 0
      ? `Cohesity Backup Failures (${dateStr})\n\nNo failures detected.`
      : `Cohesity Backup Failures (${dateStr})\n\n${markdownTable}`;

  const incidentText_update =
    failures.length === 0
      ? `Cohesity Backup Failures (${dateStr})\n\nUpdate: No failures detected.`
      : `Cohesity Backup Failures (${dateStr}) — Update\n\n${markdownTable}`;

  return {
    authMode: "vault",

    count: failures.length,
    failures,

    markdownTable,
    markdownEmail: markdownTable,

    incidentText_create,
    incidentText_update,

    snow_query,
    snow_short_description: `Cohesity Backup Failures (${dateStr})`,
    snow_description_create: incidentText_create,
    snow_description_update: incidentText_update,

    pgIndexCount: Number(p3.pgIndexCount ?? 0),
    pgErrorsCount: Number(p3.pgErrorsCount ?? 0),
    failuresRawCount: Number(p3.failuresCount ?? 0),
  };
}
