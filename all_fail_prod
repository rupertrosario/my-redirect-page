# -------------------------------------------------------------
# Cohesity Helios â€” PG + Policy Details (DaysToKeep >= 35)
# -------------------------------------------------------------
# âœ… READ-ONLY (GET-only)
# âœ… Menu: [0] All clusters OR [1..N] single cluster
# âœ… Uses your picture-style approach (GET + Body) for filtering
# âœ… Outputs: Cluster | Environment | ProtectionGroup | PolicyName | DaysToKeep | PolicyId | PgId
# -------------------------------------------------------------

$ErrorActionPreference = "Stop"

# ==============================
# 0) API key from your path
# ==============================
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }

$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()
$commonHeaders = @{ "apiKey" = $apiKey }
$baseUrl = "https://helios.cohesity.com"

# ==========================================
# 1) Get Clusters (ClusterName + ClusterId)
# ==========================================
$url      = "$baseUrl/v2/mcm/cluster-mgmt/info"
$response = Invoke-WebRequest -Method Get -Uri $url -Headers $commonHeaders
$json     = $response.Content | ConvertFrom-Json
$json_clu = $json.cohesityClusters

if (-not $json_clu -or $json_clu.Count -eq 0) {
    throw "No clusters returned from Helios."
}

# ==========================================
# 2) Build menu + pick ALL or SINGLE
#    (same style as your reference)
# ==========================================
# name fallback logic for sorting + display
$normalized = foreach ($c in $json_clu) {
    $name = $c.clusterName
    if ([string]::IsNullOrWhiteSpace($name)) { $name = $c.name }
    if ([string]::IsNullOrWhiteSpace($name)) { $name = $c.displayName }
    if ([string]::IsNullOrWhiteSpace($name)) { $name = "Unknown-$($c.clusterId)" }

    [pscustomobject]@{
        clusterName = $name
        clusterId   = $c.clusterId
    }
}

$sorted = $normalized | Sort-Object -Property clusterName

$clusters = for ($i = 0; $i -lt $sorted.Count; $i++) {
    [pscustomobject]@{
        Index       = $i + 1
        ClusterName = $sorted[$i].clusterName
        ClusterId   = $sorted[$i].clusterId
    }
}

Write-Host ""
Write-Host "Available Helios Clusters (sorted by name):" -ForegroundColor Cyan
$clusters | Format-Table -AutoSize

Write-Host ""
Write-Host "[0] All clusters" -ForegroundColor Yellow
Write-Host "[X] Exit without selecting" -ForegroundColor Yellow
Write-Host ""

while ($true) {
    $inputVal = Read-Host "Enter 0 for ALL, 1-$($clusters.Count) for single, or X to exit"

    if ($inputVal -match '^(x|X|q|Q)$') {
        Write-Host "Exit selected. No clusters chosen." -ForegroundColor Cyan
        return
    }

    [int]$num = 0
    if (-not [int]::TryParse($inputVal, [ref]$num)) {
        Write-Host "Please enter a valid number or X to exit." -ForegroundColor Red
        continue
    }

    if ($num -lt 0 -or $num -gt $clusters.Count) {
        Write-Host "Please enter 0, 1-$($clusters.Count), or X to exit." -ForegroundColor Red
        continue
    }

    $selection = $num
    break
}

if ($selection -eq 0) {
    $SelectedClusters   = $clusters
    $SelectedClusterIds = $clusters.ClusterId

    Write-Host ""
    Write-Host "You selected: ALL clusters" -ForegroundColor Green
}
else {
    $selectedCluster    = $clusters | Where-Object { $_.Index -eq $selection }
    $SelectedClusters   = @($selectedCluster)
    $SelectedClusterIds = @($selectedCluster.ClusterId)

    Write-Host ""
    Write-Host "You selected cluster:" -ForegroundColor Green
    Write-Host "  Name: $($selectedCluster.ClusterName)"
    Write-Host "  Id:   $($selectedCluster.ClusterId)"
    Write-Host ""
}

# ==========================================
# 3) Policy cache (avoid repeated calls)
# ==========================================
$PolicyCache = @{}  # policyId -> @{ PolicyName=...; DaysToKeep=... }

function Get-PolicyDetails {
    param(
        [Parameter(Mandatory=$true)][string]$PolicyId,
        [Parameter(Mandatory=$true)][hashtable]$Headers
    )

    if ([string]::IsNullOrWhiteSpace($PolicyId)) { return $null }
    if ($PolicyCache.ContainsKey($PolicyId)) { return $PolicyCache[$PolicyId] }

    # policyId may contain ":" so URL-encode
    $enc = [uri]::EscapeDataString($PolicyId)
    $polUrl = "$baseUrl/irisservices/api/v1/public/protectionPolicies/$enc"

    try {
        $polResp = Invoke-WebRequest -Method Get -Uri $polUrl -Headers $Headers
        $polJson = $polResp.Content | ConvertFrom-Json

        $val = @{
            PolicyName = $polJson.name
            DaysToKeep = $polJson.daysToKeep
        }
    }
    catch {
        $val = @{
            PolicyName = "PolicyLookupFailed"
            DaysToKeep = $null
        }
    }

    $PolicyCache[$PolicyId] = $val
    return $val
}

# ==========================================
# 4) For each selected cluster:
#    - GET protection-groups (ALL environments)
#    - Join policy
#    - Filter DaysToKeep >= 35
# ==========================================
$AllRows = @()

foreach ($cid in $SelectedClusterIds) {

    $clus = $SelectedClusters | Where-Object { $_.ClusterId -eq $cid } | Select-Object -First 1
    $cluster_name = $clus.ClusterName
    $cluster_id   = $clus.ClusterId

    Write-Host "`nðŸ”¹ Processing cluster: $cluster_name" -ForegroundColor Cyan

    $headers = @{ "apiKey" = $apiKey; "accessClusterId" = $cluster_id }

    $pgUrl = "$baseUrl/v2/data-protect/protection-groups"

    # Keep your picture-style filtering (GET + Body)
    $pgBody = @{
        isDeleted = "False"
        isPaused  = "False"
        isActive  = "True"
        # No environments filter => ALL environments
    }

    try {
        $pgResp = Invoke-WebRequest -Method Get -Uri $pgUrl -Headers $headers -Body $pgBody
        $pgJson = $pgResp.Content | ConvertFrom-Json
        $pgs = $pgJson.protectionGroups
    }
    catch {
        Write-Host "Failed to get PGs for cluster '$cluster_name' (Id: $cluster_id): $_" -ForegroundColor Red
        continue
    }

    if (-not $pgs -or $pgs.Count -eq 0) {
        Write-Host "âš ï¸ No active protection groups returned for $cluster_name." -ForegroundColor Yellow
        continue
    }

    foreach ($pg in $pgs) {
        $policyId = $pg.policyId
        if ([string]::IsNullOrWhiteSpace($policyId)) { continue }

        $pol = Get-PolicyDetails -PolicyId $policyId -Headers $headers
        if (-not $pol) { continue }

        $days = $pol.DaysToKeep
        if ($null -eq $days) { continue }
        if ([int]$days -lt 35) { continue }

        # Environment field varies; try common options
        $env = $pg.environment
        if ([string]::IsNullOrWhiteSpace($env) -and $pg.environments -and $pg.environments.Count -gt 0) {
            $env = $pg.environments[0]
        }
        if ([string]::IsNullOrWhiteSpace($env)) { $env = "Unknown" }

        $AllRows += [pscustomobject]@{
            Cluster         = $cluster_name
            Environment     = $env
            ProtectionGroup = $pg.name
            PolicyName      = $pol.PolicyName
            DaysToKeep      = $days
            PolicyId        = $policyId
            PgId            = $pg.id
        }
    }
}

# ==========================================
# 5) Output (console)
# ==========================================
if (-not $AllRows -or $AllRows.Count -eq 0) {
    Write-Host "`nNo protection groups found with Policy DaysToKeep >= 35 (selected clusters)." -ForegroundColor Yellow
    return
}

Write-Host ""
Write-Host "=== Protection Groups with Policy DaysToKeep >= 35 (Selected Clusters) ===" -ForegroundColor Cyan
Write-Host ""

$AllRows |
    Sort-Object Cluster, Environment, ProtectionGroup |
    Format-Table Cluster, Environment, ProtectionGroup, PolicyName, DaysToKeep, PolicyId, PgId -AutoSize
