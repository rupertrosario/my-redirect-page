import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";
import { result } from "@dynatrace-sdk/automation-utils";

/**
 * PART 3 (UPDATED): Policy filter (daysToKeep>=35) + HEAVY runs + failure rule + ONE markdown table
 * READ-ONLY (GET-only)
 *
 * Reads Part 2 output via: await result("run_javascript_2")
 * Expects Part 2 to return: { baseUrl, numRuns, pgCandidates:[...], apiKey?, commonHeaders? }
 *
 * IMPORTANT FIXES:
 * - localBackupInfo can be OBJECT or ARRAY (handled)
 * - Do NOT "clear" failures using in-progress runs:
 *     only clear when runStatus is Succeeded (terminal success) AND object has no failure signal
 * - Object failure signal is broader than failedAttempts-only:
 *     failedAttempts OR localSnapshotInfo.status indicates failure
 */

export default async function () {
  const PART2_STEP = "run_javascript_2";
  const DAYS_TO_KEEP_MIN = 35;
  const vaultId = "credentials_vault-312312";

  // ---------- Pull Part 2 output ----------
  const p2 = await result(PART2_STEP);
  const baseUrl = p2?.baseUrl || "https://helios.cohesity.com";
  const NUM_RUNS = Number(p2?.numRuns ?? 10);
  const pgCandidates = Array.isArray(p2?.pgCandidates) ? p2.pgCandidates : [];

  if (!pgCandidates.length) {
    return {
      markdownTable: `✅ No candidate PGs from Part 2 (nothing to scan).`,
      count: 0,
      failures: [],
    };
  }

  // ---------- API key: prefer pass-through, fallback to vault ----------
  let apiKey = String(p2?.apiKey || p2?.commonHeaders?.apiKey || "").trim();
  if (!apiKey) {
    const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
    apiKey = (d2?.token || d2?.password || "").trim();
  }
  if (!apiKey) throw new Error("Part 3: No Helios API key available.");

  const commonHeaders = { accept: "application/json", apiKey };

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // ---------- Helpers ----------
  function cleanMsg(s) {
    if (!s) return "";
    return String(s).replace(/[\r\n]+/g, " ").replace(/,/g, " ").replace(/"/g, "'").trim();
  }

  function fmtETFromUsecs(usecs) {
    if (!usecs) return "";
    const ms = Math.floor(Number(usecs) / 1000);
    const d = new Date(ms);
    try {
      return new Intl.DateTimeFormat("en-US", {
        timeZone: "America/New_York",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        hour12: false,
      }).format(d);
    } catch {
      return d.toISOString();
    }
  }

  // localBackupInfo can be OBJECT or ARRAY
  function infoOf(run) {
    const lbi = run?.localBackupInfo;
    if (Array.isArray(lbi)) return lbi[0] || {};
    if (lbi && typeof lbi === "object") return lbi;
    return {};
  }
  function runTypeOf(run) { return String(infoOf(run)?.runType || "").trim(); }
  function statusOf(run) { return String(infoOf(run)?.status || "").trim(); }
  function endUsecsOf(run) { return Number(infoOf(run)?.endTimeUsecs || 0); }

  const RUN_SUCCEEDED = new Set(["Succeeded", "kSucceeded"]);
  const IN_PROGRESS = new Set(["Running", "Accepted", "Queued", "kRunning", "kAccepted", "kQueued"]);

  function isRunTerminalSuccess(run) {
    const st = statusOf(run);
    if (!RUN_SUCCEEDED.has(st)) return false;
    // endTimeUsecs present is a strong "terminal" indicator
    return endUsecsOf(run) > 0;
  }

  function getObjKey(ob) {
    const o = ob?.object;
    if (!o) return "";
    if (o.id) return String(o.id);
    const sid = o.sourceId ? String(o.sourceId) : "";
    return `${o.environment || ""}|${o.objectType || ""}|${o.name || ""}|${sid}`;
  }

  function hasFailedAttempts(ob) {
    const fa = ob?.localSnapshotInfo?.failedAttempts;
    return Array.isArray(fa) && fa.length > 0;
  }

  // Broader "object failed" signal (fail-open to avoid missing failures)
  function objectFailureSignal(ob) {
    const ls = ob?.localSnapshotInfo || {};
    const st = String(ls?.status || ls?.snapshotStatus || "").trim();

    if (hasFailedAttempts(ob)) return true;

    // If status is explicitly present and doesn't look like success, treat as failure.
    // (Common variants: Failed / Error / Warning / Partial)
    if (st) {
      const up = st.toUpperCase();
      if (up.includes("FAIL") || up.includes("ERROR") || up.includes("WARN") || up.includes("PART")) return true;
      if (up === "SUCCEEDED" || up === "KSUCCESS" || up === "SUCCESS" || up === "KSUCCEEDED") return false;
      // unknown explicit status -> treat as failure to avoid missing
      return true;
    }

    // No failedAttempts and no explicit status -> not a failure signal
    return false;
  }

  // Conservative "object success" used only for clearing:
  // only clear on terminal-success run and when NO failure signal exists.
  function isObjectExplicitSuccessForClear(ob) {
    return !objectFailureSignal(ob);
  }

  function combineFailureMessage(ob) {
    const ls = ob?.localSnapshotInfo || {};
    const fa = ls?.failedAttempts;

    if (Array.isArray(fa) && fa.length) {
      const msgs = fa.map((a) => cleanMsg(a?.message)).filter(Boolean);
      if (msgs.length) return msgs.join(" | ");
    }

    // fallback fields (best-effort)
    const fallback =
      ls?.message ||
      ls?.errorMessage ||
      ls?.error ||
      (Array.isArray(ls?.errors) ? ls.errors.map((e) => cleanMsg(e?.message || e)).join(" | ") : "") ||
      ls?.status ||
      ls?.snapshotStatus;

    return cleanMsg(fallback) || "Object indicates failure but no message returned.";
  }

  async function mapLimit(arr, limit, fn) {
    const out = [];
    let i = 0;
    const workers = Array.from({ length: Math.min(limit, arr.length) }, async () => {
      while (i < arr.length) {
        const idx = i++;
        try { out[idx] = await fn(arr[idx], idx); }
        catch (e) { out[idx] = { __error: e }; }
      }
    });
    await Promise.all(workers);
    return out;
  }

  // ---------- Group candidates by cluster ----------
  const byCluster = new Map(); // clusterId -> { clusterName, items: [...] }
  for (const it of pgCandidates) {
    const cid = String(it?.clusterId || "");
    if (!cid) continue;
    if (!byCluster.has(cid)) byCluster.set(cid, { clusterName: it?.clusterName || `Unknown-${cid}`, items: [] });
    byCluster.get(cid).items.push(it);
  }

  const allFailures = [];
  const CONCURRENCY_PER_CLUSTER = 3;

  for (const [clusterId, group] of byCluster.entries()) {
    const headers = { ...commonHeaders, Accept: "application/json", accessClusterId: String(clusterId) };

    // Policy cache per cluster (only for candidate PGs)
    const policyCache = new Map(); // policyId -> { daysToKeep, name }
    async function getPolicy(policyId) {
      const pid = String(policyId || "");
      if (!pid) return null;
      if (policyCache.has(pid)) return policyCache.get(pid);

      const url = `${baseUrl}/irisservices/api/v1/public/protectionPolicies/${encodeURIComponent(pid)}`;
      try {
        const p = await getJson(url, headers);
        const obj = { daysToKeep: p?.daysToKeep ?? null, name: p?.name ?? "" };
        policyCache.set(pid, obj);
        return obj;
      } catch {
        const obj = { daysToKeep: null, name: "PolicyLookupFailed" };
        policyCache.set(pid, obj);
        return obj;
      }
    }

    async function processPgCandidate(pg) {
      const pgId = String(pg?.pgId || "");
      const pgName = pg?.pgName || "";
      const pgEnv = pg?.pgEnv || "UnknownEnv";
      const clusterName = pg?.clusterName || group.clusterName;
      const policyId = String(pg?.policyId || "");

      if (!pgId) return;

      // 1) Policy filter (daysToKeep >= 35) — done here so Part 2 never hides failing PGs
      const pol = await getPolicy(policyId);
      const days = pol?.daysToKeep;
      if (days === null || Number(days) < DAYS_TO_KEEP_MIN) return;

      // 2) HEAVY runs for this PG
      let runsHeavy;
      try {
        runsHeavy = await getJson(
          `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs?numRuns=${NUM_RUNS}&excludeNonRestorableRuns=false&includeObjectDetails=true`,
          headers
        );
      } catch {
        return;
      }

      const runs = Array.isArray(runsHeavy?.runs) ? runsHeavy.runs : [];
      if (!runs.length) return;

      // Determine runTypes safely (object/array localBackupInfo)
      const heavyRunTypes = Array.from(new Set(runs.map(runTypeOf).filter(Boolean)));
      const typesToProcess = heavyRunTypes.length ? heavyRunTypes : ["__UNKNOWN__"];

      for (const rType of typesToProcess) {
        const runsForType =
          rType === "__UNKNOWN__"
            ? runs.slice().sort((a, b) => endUsecsOf(b) - endUsecsOf(a))
            : runs
                .filter((r) => runTypeOf(r) === rType)
                .sort((a, b) => endUsecsOf(b) - endUsecsOf(a));

        if (!runsForType.length) continue;

        // Best-effort DB host map (sourceId -> name)
        const idToName = new Map();
        for (const rr of runsForType) {
          const objs = Array.isArray(rr?.objects) ? rr.objects : [];
          for (const ob of objs) {
            const o = ob?.object;
            if (o?.id && o?.name && !idToName.has(String(o.id))) idToName.set(String(o.id), String(o.name));
          }
        }

        const cleared = new Set();          // objectKey with later terminal-success
        const latestFailByKey = new Map();  // objectKey -> row (latest failure not cleared)

        for (const run of runsForType) {
          const rInfo = infoOf(run);
          const rStatus = statusOf(run);
          const endTimeET = fmtETFromUsecs(endUsecsOf(run));

          const objsAll = (Array.isArray(run?.objects) ? run.objects : []).filter(
            (x) => x?.object && x?.localSnapshotInfo
          );

          // If objects missing, only record run-level if run is clearly failed (best-effort)
          if (!objsAll.length) {
            if (rStatus && !RUN_SUCCEEDED.has(rStatus) && !IN_PROGRESS.has(rStatus)) {
              const rk = `RUNLEVEL|${pgId}|${rType}`;
              if (!latestFailByKey.has(rk)) {
                const msg = Array.isArray(rInfo?.messages) ? rInfo.messages.join(" | ") : rInfo?.messages;
                latestFailByKey.set(rk, {
                  Environment: pgEnv,
                  Cluster: clusterName,
                  ProtectionGroup: pgName,
                  PolicyDaysToKeep: Number(days),
                  Host: "",
                  ObjectType: "RunLevel",
                  ObjectName: "(Run-level)",
                  RunType: rType === "__UNKNOWN__" ? (runTypeOf(run) || "UnknownRunType") : rType,
                  EndTimeET: endTimeET,
                  FailedMessage: cleanMsg(msg) || `Run status=${rStatus} (no object list returned).`,
                });
              }
            }
            continue;
          }

          // PASS 1 (CLEAR): only on terminal-success run
          if (isRunTerminalSuccess(run)) {
            for (const ob of objsAll) {
              const k = getObjKey(ob);
              if (!k) continue;
              if (isObjectExplicitSuccessForClear(ob)) cleared.add(k);
            }
          }

          // PASS 2 (CAPTURE failures): capture latest failure that has not been cleared by a later terminal success
          for (const ob of objsAll) {
            const k = getObjKey(ob);
            if (!k) continue;
            if (cleared.has(k)) continue;          // later terminal success exists
            if (latestFailByKey.has(k)) continue;  // already captured newer failure

            if (!objectFailureSignal(ob)) continue;

            const o = ob.object || {};
            let hostName = "";
            if (o.sourceId && idToName.has(String(o.sourceId))) hostName = idToName.get(String(o.sourceId));

            latestFailByKey.set(k, {
              Environment: o.environment ? String(o.environment) : pgEnv,
              Cluster: clusterName,
              ProtectionGroup: pgName,
              PolicyDaysToKeep: Number(days),
              Host: hostName,
              ObjectType: o.objectType ? String(o.objectType) : "UnknownType",
              ObjectName: o.name ? String(o.name) : "",
              RunType: rType === "__UNKNOWN__" ? (runTypeOf(run) || "UnknownRunType") : rType,
              EndTimeET: endTimeET,
              FailedMessage: combineFailureMessage(ob),
            });
          }
        }

        for (const v of latestFailByKey.values()) allFailures.push(v);
      }
    }

    await mapLimit(group.items, CONCURRENCY_PER_CLUSTER, processPgCandidate);
  }

  // ---------- Output: markdown table only ----------
  if (!allFailures.length) {
    return {
      markdownTable: `✅ No failures found for Policy DaysToKeep >= ${DAYS_TO_KEEP_MIN} across all clusters (window: last ${NUM_RUNS} runs).`,
      count: 0,
      failures: [],
    };
  }

  // Dedup safety (identity)
  const dedup = new Map();
  for (const r of allFailures) {
    const key = `${r.Environment}|${r.Cluster}|${r.ProtectionGroup}|${r.RunType}|${r.Host}|${r.ObjectType}|${r.ObjectName}`;
    const prev = dedup.get(key);
    if (!prev || String(r.EndTimeET) > String(prev.EndTimeET)) dedup.set(key, r);
  }

  const final = Array.from(dedup.values()).sort((a, b) => {
    const c = String(a.Cluster).localeCompare(String(b.Cluster));
    if (c) return c;
    const p = String(a.ProtectionGroup).localeCompare(String(b.ProtectionGroup));
    if (p) return p;
    const e = String(a.Environment).localeCompare(String(b.Environment));
    if (e) return e;
    const rt = String(a.RunType).localeCompare(String(b.RunType));
    if (rt) return rt;
    return String(b.EndTimeET).localeCompare(String(a.EndTimeET));
  });

  const cols = [
    "Environment",
    "Cluster",
    "ProtectionGroup",
    "PolicyDaysToKeep",
    "Host",
    "ObjectType",
    "ObjectName",
    "RunType",
    "EndTimeET",
    "FailedMessage",
  ];

  const lines = [];
  lines.push(`### Cohesity PROD Failures (DaysToKeep >= ${DAYS_TO_KEEP_MIN}) — All Clusters`);
  lines.push(`Window: last **${NUM_RUNS}** runs`);
  lines.push(`Total failures: **${final.length}**`);
  lines.push("");
  lines.push(`| ${cols.join(" | ")} |`);
  lines.push(`| ${cols.map(() => "---").join(" | ")} |`);

  for (const r of final) {
    const row = [
      r.Environment,
      r.Cluster,
      r.ProtectionGroup,
      String(r.PolicyDaysToKeep ?? ""),
      r.Host || "",
      r.ObjectType,
      r.ObjectName,
      r.RunType,
      r.EndTimeET,
      r.FailedMessage,
    ].map(cleanMsg);
    lines.push(`| ${row.join(" | ")} |`);
  }

  return {
    markdownTable: lines.join("\n"),
    count: final.length,
    failures: final,
  };
}
