import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";
import { result } from "@dynatrace-sdk/automation-utils";

/**
 * cohesity_backup_failures (FINAL / Part 3)
 * - GET-only
 * - Vault auth inside Part 3
 * - Reads Part 2 via result("cohesity_backup_failures_p2")
 * - Two-stage:
 *    LIGHT (includeObjectDetails=false) for 5 runs
 *    HEAVY (includeObjectDetails=true) ONLY when needed
 * - Safety: if LIGHT says "all succeeded" but we still want to catch hidden object failures,
 *          set CHECK_SUCCEEDED_RUN_OBJECT_FAILURES=true to probe latest run with HEAVY numRuns=1.
 */
export default async function () {
  const PART2_TASK = "cohesity_backup_failures_p2";
  const p2 = await result(PART2_TASK);
  if (!p2 || !Array.isArray(p2.pgIndex)) {
    throw new Error(`Part 3: missing Part 2 output. Check task name: ${PART2_TASK}`);
  }

  const baseUrl = p2.baseUrl || "https://helios.cohesity.com";
  const numRuns = Number(p2.numRuns ?? 5);
  const pgIndex = p2.pgIndex;

  // ---- toggle for correctness vs speed ----
  const CHECK_SUCCEEDED_RUN_OBJECT_FAILURES = true; // set false if too slow

  // Vault (same pattern)
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

  async function getJsonWithRetry(url, headers, retries = 2) {
    for (let i = 0; i <= retries; i++) {
      const resp = await fetch(url, { method: "GET", headers });
      if (resp.ok) return resp.json();

      const st = resp.status;
      if ((st === 429 || st >= 500) && i < retries) {
        await sleep(500 * (i + 1));
        continue;
      }

      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${st} ${txt}`);
    }
    return null;
  }

  function cleanMsg(s) {
    if (!s) return "";
    return String(s).replace(/[\r\n]+/g, " ").replace(/\|/g, " ").replace(/"/g, "'").trim();
  }

  function fmtETFromUsecs(usecs) {
    if (!usecs) return "";
    const ms = Math.floor(Number(usecs) / 1000);
    const d = new Date(ms);
    try {
      return new Intl.DateTimeFormat("en-US", {
        timeZone: "America/New_York",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        hour12: false,
      }).format(d);
    } catch {
      return d.toISOString();
    }
  }

  function etDateYYYYMMDD() {
    const now = new Date();
    const parts = new Intl.DateTimeFormat("en-CA", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    }).formatToParts(now).reduce((a, p) => ((a[p.type] = p.value), a), {});
    return `${parts.year}-${parts.month}-${parts.day}`;
  }

  function getObjKey(ob) {
    const o = ob?.object;
    if (!o) return "";
    if (o.id) return String(o.id);
    const sid = o.sourceId ? String(o.sourceId) : "";
    return `${o.environment || ""}|${o.objectType || ""}|${o.name || ""}|${sid}`;
  }

  function hasFailedAttempts(ob) {
    const fa = ob?.localSnapshotInfo?.failedAttempts;
    return Array.isArray(fa) && fa.length > 0;
  }

  function isSuccessForClear(ob) {
    return ob?.localSnapshotInfo && !hasFailedAttempts(ob);
  }

  function combineFailedAttempts(attempts) {
    if (!Array.isArray(attempts) || attempts.length === 0) return "";
    return attempts.map((a) => cleanMsg(a?.message)).filter(Boolean).join(" | ");
  }

  function runHasFailureHints(info) {
    // catch common hints even when status looks "Succeeded"
    const st = String(info?.status || "");
    if (st && st !== "Succeeded") return true;

    const stats = info?.stats || {};
    const candidates = [
      info?.numFailedObjects,
      info?.failedObjects,
      stats?.numFailedObjects,
      stats?.failedObjects,
      stats?.numErrors,
      stats?.numFailures,
      stats?.failed,
      stats?.errors,
    ].map((x) => Number(x || 0));

    const maxHint = Math.max(0, ...candidates);
    return maxHint > 0;
  }

  function lightNeedsHeavy(runsLight) {
    // if ANY of last runs has hints, we go heavy
    for (const r of runsLight) {
      const info = r?.localBackupInfo?.[0];
      if (runHasFailureHints(info)) return true;
    }
    return false;
  }

  async function mapLimit(items, limit, fn) {
    const out = [];
    let i = 0;
    const workers = Array.from({ length: Math.min(limit, items.length) }, async () => {
      while (true) {
        const idx = i++;
        if (idx >= items.length) break;
        const vals = await fn(items[idx], idx);
        if (Array.isArray(vals) && vals.length) out.push(...vals);
      }
    });
    await Promise.all(workers);
    return out;
  }

  const CONCURRENCY = 4;

  async function processPg(wi) {
    const headers = { ...commonHeaders, Accept: "application/json", accessClusterId: String(wi.clusterId) };

    // LIGHT (numRuns=5)
    const lightUrl =
      `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(String(wi.pgId))}` +
      `/runs?numRuns=${numRuns}&excludeNonRestorableRuns=false&includeObjectDetails=false`;

    let light;
    try {
      light = await getJsonWithRetry(lightUrl, headers, 2);
    } catch (_) {
      return [];
    }

    const runsLight = Array.isArray(light?.runs) ? light.runs : [];
    if (!runsLight.length) return [];

    let doHeavy = lightNeedsHeavy(runsLight);

    // Safety probe: if LIGHT says clean, optionally probe latest run with HEAVY numRuns=1
    if (!doHeavy && CHECK_SUCCEEDED_RUN_OBJECT_FAILURES) {
      const probeUrl =
        `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(String(wi.pgId))}` +
        `/runs?numRuns=1&excludeNonRestorableRuns=false&includeObjectDetails=true`;
      try {
        const probe = await getJsonWithRetry(probeUrl, headers, 1);
        const pr = Array.isArray(probe?.runs) ? probe.runs : [];
        const objs = pr[0]?.objects || [];
        const anyObjFail = Array.isArray(objs) && objs.some((o) => hasFailedAttempts(o));
        if (anyObjFail) doHeavy = true;
      } catch (_) {}
    }

    if (!doHeavy) return [];

    // HEAVY (numRuns=5)
    const heavyUrl =
      `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(String(wi.pgId))}` +
      `/runs?numRuns=${numRuns}&excludeNonRestorableRuns=false&includeObjectDetails=true`;

    let heavy;
    try {
      heavy = await getJsonWithRetry(heavyUrl, headers, 2);
    } catch (_) {
      return [];
    }

    const runs = Array.isArray(heavy?.runs) ? heavy.runs : [];
    if (!runs.length) return [];

    const runTypes = Array.from(
      new Set(runs.map((r) => r?.localBackupInfo?.[0]?.runType).filter(Boolean).map(String))
    );

    const failuresOut = [];

    for (const rType of runTypes) {
      const runsForType = runs
        .filter((r) => String(r?.localBackupInfo?.[0]?.runType || "") === rType)
        .sort(
          (a, b) =>
            Number(b?.localBackupInfo?.[0]?.endTimeUsecs || 0) - Number(a?.localBackupInfo?.[0]?.endTimeUsecs || 0)
        );
      if (!runsForType.length) continue;

      // best-effort host map (newest run only)
      const idToName = new Map();
      const newestObjs = Array.isArray(runsForType[0]?.objects) ? runsForType[0].objects : [];
      for (const ob of newestObjs) {
        const o = ob?.object;
        if (o?.id && o?.name && !idToName.has(String(o.id))) idToName.set(String(o.id), String(o.name));
      }

      const cleared = new Set();
      const latestFailByKey = new Map();

      for (const run of runsForType) {
        const info = run?.localBackupInfo?.[0] || {};
        const endTimeET = fmtETFromUsecs(info.endTimeUsecs);

        const objsAll = (Array.isArray(run?.objects) ? run.objects : []).filter(
          (x) => x?.object && x?.localSnapshotInfo
        );

        if (!objsAll.length) {
          if (String(info.status || "") === "Failed") {
            const rk = `RUNLEVEL|${wi.pgId}|${rType}`;
            if (!latestFailByKey.has(rk)) {
              const msg = Array.isArray(info.messages) ? info.messages.join(" | ") : info.messages;
              latestFailByKey.set(rk, {
                Environment: wi.pgEnv,
                Cluster: wi.clusterName,
                ProtectionGroup: wi.pgName,
                Host: "",
                ObjectType: "RunLevel",
                ObjectName: "(Run-level)",
                RunType: rType,
                EndTimeET: endTimeET,
                FailedMessage: cleanMsg(msg),
              });
            }
          }
          continue;
        }

        // mark successes (newer clears older failures)
        for (const ob of objsAll) {
          if (isSuccessForClear(ob)) {
            const k = getObjKey(ob);
            if (k) cleared.add(k);
          }
        }

        // capture latest uncleared failures
        for (const ob of objsAll) {
          const k = getObjKey(ob);
          if (!k) continue;
          if (cleared.has(k)) continue;
          if (latestFailByKey.has(k)) continue;
          if (!hasFailedAttempts(ob)) continue;

          const msg = combineFailedAttempts(ob?.localSnapshotInfo?.failedAttempts);
          if (!msg) continue;

          const o = ob.object || {};
          let hostName = "";
          if (o.sourceId && idToName.has(String(o.sourceId))) hostName = idToName.get(String(o.sourceId));

          latestFailByKey.set(k, {
            Environment: o.environment ? String(o.environment) : wi.pgEnv,
            Cluster: wi.clusterName,
            ProtectionGroup: wi.pgName,
            Host: hostName,
            ObjectType: o.objectType ? String(o.objectType) : "UnknownType",
            ObjectName: o.name ? String(o.name) : "",
            RunType: rType,
            EndTimeET: endTimeET,
            FailedMessage: msg,
          });
        }
      }

      for (const v of latestFailByKey.values()) failuresOut.push(v);
    }

    return failuresOut;
  }

  const all = await mapLimit(pgIndex, CONCURRENCY, processPg);

  // final dedup
  const dedup = new Map();
  for (const r of all) {
    const key = `${r.Environment}|${r.Cluster}|${r.ProtectionGroup}|${r.RunType}|${r.Host}|${r.ObjectType}|${r.ObjectName}`;
    const prev = dedup.get(key);
    if (!prev || String(r.EndTimeET) > String(prev.EndTimeET)) dedup.set(key, r);
  }

  const failures = Array.from(dedup.values()).sort((a, b) => {
    const c = String(a.Cluster).localeCompare(String(b.Cluster));
    if (c) return c;
    const p = String(a.ProtectionGroup).localeCompare(String(b.ProtectionGroup));
    if (p) return p;
    return String(b.EndTimeET).localeCompare(String(a.EndTimeET));
  });

  function toMarkdownTable(rows) {
    if (!rows.length) return "✅ No backup failures found across all clusters.";
    const cols = ["Environment","Cluster","ProtectionGroup","Host","ObjectType","ObjectName","RunType","EndTimeET","FailedMessage"];
    const lines = [];
    lines.push("### Cohesity Backup Failures — All Clusters");
    lines.push(`Total failures: **${rows.length}**`);
    lines.push("");
    lines.push(`| ${cols.join(" | ")} |`);
    lines.push(`| ${cols.map(() => "---").join(" | ")} |`);
    for (const r of rows) {
      const row = [
        r.Environment, r.Cluster, r.ProtectionGroup, r.Host || "",
        r.ObjectType, r.ObjectName, r.RunType, r.EndTimeET, r.FailedMessage
      ].map(cleanMsg);
      lines.push(`| ${row.join(" | ")} |`);
    }
    return lines.join("\n");
  }

  function toIncidentTextCreate(rows, md) {
    const d = etDateYYYYMMDD();
    if (!rows.length) return `Cohesity Backup Failures (${d})\n\nNo failures detected.`;
    return `Cohesity Backup Failures (${d})\n\n${md}`;
  }

  function toIncidentTextUpdate(rows, md) {
    const d = etDateYYYYMMDD();
    if (!rows.length) return `Cohesity Backup Failures (${d})\n\nUpdate: No failures detected.`;
    return `Cohesity Backup Failures (${d}) — Update\n\n${md}`;
  }

  const markdownTable = toMarkdownTable(failures);
  const d = etDateYYYYMMDD();
  const correlationId = `Cohesity_Backup_Failures_${d}`;
  const snow_query = `correlation_id=${correlationId}`;

  return {
    authMode: "vault",
    // debug-safe
    pgIndexCount: pgIndex.length,

    count: failures.length,
    failures,

    incidentText_create: toIncidentTextCreate(failures, markdownTable),
    incidentText_update: toIncidentTextUpdate(failures, markdownTable),

    markdownTable,
    markdownEmail: markdownTable,

    snow_query,
    snow_short_description: `Cohesity Backup Failures (${d})`,
    snow_description_create: toIncidentTextCreate(failures, markdownTable),
    snow_description_update: toIncidentTextUpdate(failures, markdownTable),
  };
}
