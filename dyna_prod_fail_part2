import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";
import { result } from "@dynatrace-sdk/automation-utils";

/**
 * PART 2: Policy filter only (daysToKeep >= 35)
 * - Reads Part 1 output via: await result("run_javascript_1")
 * - READ-ONLY (GET-only)
 *
 * Output -> Part 3:
 * {
 *   baseUrl, daysToKeepMin, numRuns,
 *   pgWorkItems: [{ clusterId, clusterName, pgId, pgName, pgEnv, policyId, policyName, daysToKeep }]
 * }
 *
 * NOTE: Dynatrace recommends NOT returning secrets in task results. :contentReference[oaicite:1]{index=1}
 */
export default async function () {
  // ---------- pull Part 1 output (NO workflow input mapping required) ----------
  const p1 = await result("run_javascript_1"); // must match the task name exactly
  if (!p1 || !Array.isArray(p1.pgIndex)) {
    throw new Error("Part 2: could not read Part 1 output (missing pgIndex). Check task name run_javascript_1.");
  }

  const baseUrl = p1.baseUrl || "https://helios.cohesity.com";
  const daysToKeepMin = Number(p1.daysToKeepMin ?? 35);
  const numRuns = Number(p1.numRuns ?? 5);
  const pgIndex = p1.pgIndex;

  // ---------- AUTH (vault) ----------
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // Group PGs by cluster so accessClusterId is correct and policy cache is per cluster
  const byCluster = new Map(); // clusterId -> { clusterName, items: [...] }
  for (const it of pgIndex) {
    const cid = String(it?.clusterId || "");
    if (!cid) continue;
    if (!byCluster.has(cid)) {
      byCluster.set(cid, { clusterName: it?.clusterName || `Unknown-${cid}`, items: [] });
    }
    byCluster.get(cid).items.push(it);
  }

  const pgWorkItems = [];

  for (const [clusterId, group] of byCluster.entries()) {
    const headers = {
      ...commonHeaders,
      Accept: "application/json",
      accessClusterId: String(clusterId),
    };

    // policyId -> { daysToKeep, name }
    const policyCache = new Map();

    async function getPolicy(policyId) {
      if (!policyId) return null;
      const pid = String(policyId);
      if (policyCache.has(pid)) return policyCache.get(pid);

      const url = `${baseUrl}/irisservices/api/v1/public/protectionPolicies/${encodeURIComponent(pid)}`;
      try {
        const p = await getJson(url, headers);
        const obj = { daysToKeep: p?.daysToKeep ?? null, name: p?.name ?? "" };
        policyCache.set(pid, obj);
        return obj;
      } catch (_) {
        const obj = { daysToKeep: null, name: "PolicyLookupFailed" };
        policyCache.set(pid, obj);
        return obj;
      }
    }

    for (const it of group.items) {
      const pol = await getPolicy(it.policyId);
      const days = pol?.daysToKeep;

      if (days !== null && Number(days) >= daysToKeepMin) {
        pgWorkItems.push({
          clusterId: String(it.clusterId),
          clusterName: it.clusterName || group.clusterName,
          pgId: String(it.pgId),
          pgName: it.pgName || "",
          pgEnv: it.pgEnv || "UnknownEnv",
          policyId: String(it.policyId),
          policyName: pol?.name || "",
          daysToKeep: Number(days),
        });
      }
    }
  }

  return { baseUrl, daysToKeepMin, numRuns, pgWorkItems };
}
