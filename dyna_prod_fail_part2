import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";
import { result } from "@dynatrace-sdk/automation-utils";

/**
 * PART 2 (LIGHT TRIAGE â€” FAIL-OPEN): send the "right" PGs to Part 3
 * READ-ONLY (GET-only)
 *
 * - Reads Part 1 output internally: await result("run_javascript_1")
 * - Uses LIGHT runs: includeObjectDetails=false
 * - FAIL-OPEN: if LIGHT is ambiguous (errors / no runs / no runType / running), PG is INCLUDED as candidate
 * - Candidate rule (broad on purpose to avoid missing failures):
 *     Include PG if ANY run in last numRuns has:
 *       - status != "Succeeded"  OR
 *       - failedObjectsCount/failedAppObjectsCount/cancelled* > 0  OR
 *       - status in Running/Queued/Accepted (in-progress)
 *
 * Output to Part 3:
 * {
 *   baseUrl, numRuns,
 *   apiKey, commonHeaders,
 *   pgCandidates: [{
 *     clusterId, clusterName, pgId, pgName, pgEnv, policyId,
 *     lightIssues: [{ runType, status, failedCount, endTimeUsecs, reason }]
 *   }],
 *   candidateCount
 * }
 */

export default async function () {
  const PART1_STEP = "run_javascript_1";
  const DEFAULT_NUM_RUNS = 10;

  // ---- pull Part 1 output ----
  const p1 = await result(PART1_STEP);
  if (!p1 || !Array.isArray(p1.pgIndex)) {
    throw new Error(`Part 2: missing pgIndex from ${PART1_STEP} output.`);
  }

  const baseUrl = p1.baseUrl || "https://helios.cohesity.com";
  const numRuns = Number(p1.numRuns ?? DEFAULT_NUM_RUNS);
  const pgIndex = p1.pgIndex;

  // ---- apiKey pass-through preferred; fallback to vault ----
  let apiKey = String(p1.apiKey || p1.commonHeaders?.apiKey || "").trim();
  if (!apiKey) {
    const vaultId = "credentials_vault-312312";
    const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
    apiKey = (d2?.token || d2?.password || "").trim();
  }
  if (!apiKey) throw new Error("Part 2: No Helios API key available.");

  const commonHeaders = { accept: "application/json", apiKey };

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // localBackupInfo can be OBJECT or ARRAY
  function infoOf(run) {
    const lbi = run?.localBackupInfo;
    if (Array.isArray(lbi)) return lbi[0] || {};
    if (lbi && typeof lbi === "object") return lbi;
    return {};
  }
  function runTypeOf(run) { return String(infoOf(run)?.runType || "").trim(); }
  function statusOf(run) { return String(infoOf(run)?.status || "").trim(); }
  function endUsecsOf(run) { return Number(infoOf(run)?.endTimeUsecs || 0); }
  function failedCountOf(run) {
    const i = infoOf(run);
    return (
      Number(i?.failedObjectsCount || 0) +
      Number(i?.failedAppObjectsCount || 0) +
      Number(i?.cancelledObjectsCount || 0) +
      Number(i?.cancelledAppObjectsCount || 0)
    );
  }

  const IN_PROGRESS = new Set(["Running", "Accepted", "Queued", "kRunning", "kAccepted", "kQueued"]);

  async function mapLimit(arr, limit, fn) {
    const out = [];
    let i = 0;
    const workers = Array.from({ length: Math.min(limit, arr.length) }, async () => {
      while (i < arr.length) {
        const idx = i++;
        try { out[idx] = await fn(arr[idx], idx); }
        catch (e) { out[idx] = { __error: e }; }
      }
    });
    await Promise.all(workers);
    return out;
  }

  // ---- group PGs by cluster ----
  const byCluster = new Map();
  for (const it of pgIndex) {
    const cid = String(it?.clusterId || "");
    if (!cid) continue;
    if (!byCluster.has(cid)) {
      byCluster.set(cid, { clusterName: it?.clusterName || `Unknown-${cid}`, items: [] });
    }
    byCluster.get(cid).items.push(it);
  }

  const pgCandidates = [];
  const CONCURRENCY_PER_CLUSTER = 4;

  for (const [clusterId, group] of byCluster.entries()) {
    const headers = { ...commonHeaders, Accept: "application/json", accessClusterId: String(clusterId) };

    async function triagePg(pg) {
      const pgId = String(pg?.pgId || "");
      if (!pgId) return;

      const candidateBase = {
        clusterId: String(pg.clusterId),
        clusterName: pg.clusterName || group.clusterName,
        pgId: String(pg.pgId),
        pgName: pg.pgName || "",
        pgEnv: pg.pgEnv || "UnknownEnv",
        policyId: String(pg.policyId || ""),
      };

      // LIGHT runs
      let light;
      try {
        light = await getJson(
          `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs?numRuns=${numRuns}&excludeNonRestorableRuns=false&includeObjectDetails=false`,
          headers
        );
      } catch {
        // FAIL-OPEN: include PG for Part 3
        pgCandidates.push({
          ...candidateBase,
          lightIssues: [{ runType: "", status: "", failedCount: 0, endTimeUsecs: 0, reason: "LIGHT_FETCH_ERROR" }],
        });
        return;
      }

      const runsArr = Array.isArray(light?.runs) ? light.runs : [];
      if (!runsArr.length) {
        // FAIL-OPEN
        pgCandidates.push({
          ...candidateBase,
          lightIssues: [{ runType: "", status: "", failedCount: 0, endTimeUsecs: 0, reason: "NO_RUNS_RETURNED" }],
        });
        return;
      }

      // Candidate rule: ANY run in window indicates possible failure or in-progress
      const lightIssues = [];
      let sawRunType = false;

      for (const r of runsArr) {
        const rt = runTypeOf(r);
        const st = statusOf(r);
        const fc = failedCountOf(r);
        const end = endUsecsOf(r);

        if (rt) sawRunType = true;

        const isInProgress = IN_PROGRESS.has(st);
        const notSucceeded = st && st !== "Succeeded";

        if (fc > 0 || isInProgress || notSucceeded) {
          lightIssues.push({
            runType: rt || "UnknownRunType",
            status: st || "Unknown",
            failedCount: fc,
            endTimeUsecs: end,
            reason: fc > 0 ? "FAILED_COUNT_GT0" : (isInProgress ? "IN_PROGRESS" : "STATUS_NOT_SUCCEEDED"),
          });
        }
      }

      // If runType is missing/ambiguous, FAIL-OPEN
      if (!sawRunType) {
        pgCandidates.push({
          ...candidateBase,
          lightIssues: [{ runType: "UnknownRunType", status: "Unknown", failedCount: 0, endTimeUsecs: 0, reason: "NO_RUNTYPES" }],
        });
        return;
      }

      // Healthy by LIGHT signals -> skip (Part 3 not needed)
      if (lightIssues.length === 0) return;

      // Include candidate
      pgCandidates.push({ ...candidateBase, lightIssues });
    }

    await mapLimit(group.items, CONCURRENCY_PER_CLUSTER, triagePg);
  }

  return {
    baseUrl,
    numRuns,
    apiKey,
    commonHeaders,
    pgCandidates,
    candidateCount: pgCandidates.length,
  };
}
