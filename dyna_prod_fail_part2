import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";
import { result } from "@dynatrace-sdk/automation-utils";

/**
 * Part 2: Build PG index across all clusters (no policy filter)
 * - GET-only
 * - Output consumed by Part 3 via result("cohesity_backup_failures_p2")
 */
export default async function () {
  const PART1 = "cohesity_backup_failures_p1";
  const p1 = await result(PART1);
  if (!p1?.baseUrl || !Array.isArray(p1.clusterIndex)) {
    throw new Error(`Part 2: missing Part 1 output. Check step name: ${PART1}`);
  }

  const baseUrl = p1.baseUrl;
  const numRuns = Number(p1.numRuns ?? 20);
  const clusterIndex = p1.clusterIndex;

  // Vault auth (required per your requirement)
  const vaultId = "credentials_vault-312312";
  const d = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d?.token || d?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  const pgIndex = [];
  const clusterErrors = [];

  for (const cl of clusterIndex) {
    const headers = { ...commonHeaders, Accept: "application/json", accessClusterId: String(cl.clusterId) };

    try {
      const pgJson = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups?isDeleted=false&isPaused=false&isActive=true`,
        headers
      );

      const pgs = Array.isArray(pgJson?.protectionGroups) ? pgJson.protectionGroups : [];
      for (const pg of pgs) {
        const pgId = pg?.id ? String(pg.id) : "";
        if (!pgId) continue;

        const pgEnv =
          (pg.environment && String(pg.environment)) ||
          (pg.environments && String(pg.environments)) ||
          (Array.isArray(pg.environmentTypes) ? pg.environmentTypes.join(",") : "") ||
          "UnknownEnv";

        pgIndex.push({
          clusterId: String(cl.clusterId),
          clusterName: cl.clusterName,
          pgId,
          pgName: pg?.name || "",
          pgEnv,
        });
      }
    } catch (e) {
      clusterErrors.push({ cluster: cl.clusterName, error: String(e?.message || e) });
    }
  }

  return {
    authMode: "vault",
    baseUrl,
    numRuns,
    pgIndex,
    pgIndexCount: pgIndex.length,
    clusterErrors,
    clusterErrorsCount: clusterErrors.length,
  };
}
