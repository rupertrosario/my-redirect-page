import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";
import { result } from "@dynatrace-sdk/automation-utils";

/**
 * cohesity_backup_failures_p2
 * READ-ONLY (GET-only)
 * - Vault auth inside Part 2
 * - Reads Part 1 via result("cohesity_backup_failures_p1")
 * - LIGHT runs only (includeObjectDetails=false) with concurrency
 * - Outputs ONLY PGs that need HEAVY (any runType latest != Succeeded)
 *
 * Output -> Part 3 reads via result("cohesity_backup_failures_p2")
 */
export default async function () {
  const PART1_TASK = "cohesity_backup_failures_p1";

  const p1 = await result(PART1_TASK);
  if (!p1 || !Array.isArray(p1.pgIndex)) {
    throw new Error(`Part 2: missing Part 1 output. Check task name: ${PART1_TASK}`);
  }

  const baseUrl = p1.baseUrl || "https://helios.cohesity.com";
  const numRuns = Number(p1.numRuns ?? 5);
  const pgIndex = p1.pgIndex;

  // Vault auth (same pattern)
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

  async function getJsonWithRetry(url, headers, retries = 3) {
    for (let i = 0; i <= retries; i++) {
      const resp = await fetch(url, { method: "GET", headers });
      if (resp.ok) return resp.json();

      const status = resp.status;
      if ((status === 429 || status >= 500) && i < retries) {
        await sleep(400 * (i + 1));
        continue;
      }

      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${status} ${txt}`);
    }
    return null;
  }

  // latest-per-runType check without sorting
  function lightNeedsHeavy(runsLight) {
    const latest = new Map(); // runType -> { endUsecs, status }
    for (const r of runsLight) {
      const info = r?.localBackupInfo?.[0];
      const rt = info?.runType ? String(info.runType) : "";
      const end = Number(info?.endTimeUsecs || 0);
      const st = info?.status ? String(info.status) : "";
      if (!rt || !end) continue;

      const prev = latest.get(rt);
      if (!prev || end > prev.endUsecs) latest.set(rt, { endUsecs: end, status: st });
    }
    for (const v of latest.values()) if (v.status !== "Succeeded") return true;
    return false;
  }

  async function mapLimit(items, limit, fn) {
    const out = [];
    let idx = 0;
    const workers = Array.from({ length: Math.min(limit, items.length) }, async () => {
      while (idx < items.length) {
        const my = idx++;
        const val = await fn(items[my], my);
        if (val) out.push(val);
      }
    });
    await Promise.all(workers);
    return out;
  }

  const CONCURRENCY = 5;

  async function checkPgLight(it) {
    const clusterId = it?.clusterId;
    const pgId = it?.pgId;
    if (!clusterId || !pgId) return null;

    const headers = { ...commonHeaders, Accept: "application/json", accessClusterId: String(clusterId) };
    const url =
      `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(String(pgId))}` +
      `/runs?numRuns=${numRuns}&excludeNonRestorableRuns=false&includeObjectDetails=false`;

    try {
      const data = await getJsonWithRetry(url, headers, 2);
      const runsLight = Array.isArray(data?.runs) ? data.runs : [];
      if (!runsLight.length) return null;
      if (!lightNeedsHeavy(runsLight)) return null;

      return {
        clusterId: String(it.clusterId),
        clusterName: it.clusterName || "",
        pgId: String(it.pgId),
        pgName: it.pgName || "",
        pgEnv: it.pgEnv || "UnknownEnv",
      };
    } catch (_) {
      return null; // fail-open per PG
    }
  }

  const pgCandidates = await mapLimit(pgIndex, CONCURRENCY, checkPgLight);

  return {
    baseUrl,
    numRuns,
    pgCandidates,
    pgCandidatesCount: pgCandidates.length,
    pgIndexCount: pgIndex.length,
  };
}
