/**
 * PART 2 (MODERATE): Policy filter only (daysToKeep >= 35)
 * READ-ONLY (GET-only)
 *
 * INPUT (from Part 1 via payload):
 * {
 *   baseUrl, apiKey, commonHeaders,
 *   daysToKeepMin, numRuns,
 *   pgIndex: [{ clusterId, clusterName, pgId, pgName, pgEnv, policyId }]
 * }
 *
 * OUTPUT (to Part 3):
 * {
 *   baseUrl, apiKey, commonHeaders,
 *   daysToKeepMin, numRuns,
 *   pgWorkItems: [{ clusterId, clusterName, pgId, pgName, pgEnv, policyId, policyName, daysToKeep }]
 * }
 */

export default async function ({ payload } = {}) {
  const baseUrl = payload?.baseUrl || "https://helios.cohesity.com";

  const apiKey = String(payload?.apiKey || payload?.commonHeaders?.apiKey || "").trim();
  if (!apiKey) throw new Error("Part 2 missing apiKey in payload (from Part 1).");

  const commonHeaders = {
    accept: "application/json",
    ...(payload?.commonHeaders || {}),
    apiKey,
  };

  const daysToKeepMin = Number(payload?.daysToKeepMin ?? 35);
  const numRuns = Number(payload?.numRuns ?? 5);

  const pgIndex = Array.isArray(payload?.pgIndex) ? payload.pgIndex : [];
  if (!pgIndex.length) {
    return { baseUrl, apiKey, commonHeaders, daysToKeepMin, numRuns, pgWorkItems: [] };
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // group by cluster to ensure correct accessClusterId and per-cluster policy cache
  const byCluster = new Map();
  for (const it of pgIndex) {
    const cid = String(it?.clusterId || "");
    if (!cid) continue;
    if (!byCluster.has(cid)) byCluster.set(cid, { clusterName: it?.clusterName || `Unknown-${cid}`, items: [] });
    byCluster.get(cid).items.push(it);
  }

  const pgWorkItems = [];

  for (const [clusterId, group] of byCluster.entries()) {
    const headers = {
      ...commonHeaders,
      Accept: "application/json",
      accessClusterId: String(clusterId),
    };

    const policyCache = new Map(); // policyId -> { daysToKeep, name }

    async function getPolicy(policyId) {
      if (!policyId) return null;
      const pid = String(policyId);
      if (policyCache.has(pid)) return policyCache.get(pid);

      const url = `${baseUrl}/irisservices/api/v1/public/protectionPolicies/${encodeURIComponent(pid)}`;
      try {
        const p = await getJson(url, headers);
        const obj = { daysToKeep: p?.daysToKeep ?? null, name: p?.name ?? "" };
        policyCache.set(pid, obj);
        return obj;
      } catch (_) {
        const obj = { daysToKeep: null, name: "PolicyLookupFailed" };
        policyCache.set(pid, obj);
        return obj;
      }
    }

    for (const it of group.items) {
      const pol = await getPolicy(it.policyId);
      const days = pol?.daysToKeep;

      if (days !== null && Number(days) >= daysToKeepMin) {
        pgWorkItems.push({
          clusterId: String(it.clusterId),
          clusterName: it.clusterName || group.clusterName,
          pgId: String(it.pgId),
          pgName: it.pgName || "",
          pgEnv: it.pgEnv || "UnknownEnv",
          policyId: String(it.policyId),
          policyName: pol?.name || "",
          daysToKeep: Number(days),
        });
      }
    }
  }

  return { baseUrl, apiKey, commonHeaders, daysToKeepMin, numRuns, pgWorkItems };
}
