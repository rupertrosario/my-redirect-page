import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";
import { result } from "@dynatrace-sdk/automation-utils";

/**
 * cohesity_backup_failures_p2
 * READ-ONLY (GET-only)
 * - Vault auth inside Part 2  ✅
 * - Reads Part 1 output via result("cohesity_backup_failures_p1")
 * - LIGHT runs only (includeObjectDetails=false)
 * - Outputs ONLY PGs that need HEAVY (any runType latest != Succeeded)
 *
 * Output -> Part 3 reads via result("cohesity_backup_failures_p2")
 */
export default async function () {
  const PART1_TASK = "cohesity_backup_failures_p1";
  const p1 = await result(PART1_TASK);
  if (!p1 || !Array.isArray(p1.pgIndex)) {
    throw new Error(`Part 2: missing Part 1 output. Check task name: ${PART1_TASK}`);
  }

  const baseUrl = p1.baseUrl || "https://helios.cohesity.com";
  const numRuns = Number(p1.numRuns ?? 5);
  const pgIndex = p1.pgIndex;

  // ==============================
  // AUTH (vault id)  ✅ (same style)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // single-pass: latest status per runType (no sort)
  function needsHeavy(runsLight) {
    const latest = new Map(); // runType -> { endUsecs, status }
    for (const r of runsLight) {
      const info = r?.localBackupInfo?.[0];
      const rt = info?.runType ? String(info.runType) : "";
      const end = Number(info?.endTimeUsecs || 0);
      const st = info?.status ? String(info.status) : "";
      if (!rt || !end) continue;

      const prev = latest.get(rt);
      if (!prev || end > prev.endUsecs) latest.set(rt, { endUsecs: end, status: st });
    }
    for (const v of latest.values()) {
      if (v.status !== "Succeeded") return true;
    }
    return false;
  }

  const pgWorkItems = [];

  for (const it of pgIndex) {
    const clusterId = it?.clusterId;
    const clusterName = it?.clusterName;
    const pgId = it?.pgId;
    if (!clusterId || !clusterName || !pgId) continue;

    const headers = { ...commonHeaders, Accept: "application/json", accessClusterId: String(clusterId) };

    let runsLightJson;
    try {
      runsLightJson = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(String(pgId))}/runs?numRuns=${numRuns}&excludeNonRestorableRuns=false&includeObjectDetails=false`,
        headers
      );
    } catch (_) {
      continue; // fail-open per PG
    }

    const runsLight = Array.isArray(runsLightJson?.runs) ? runsLightJson.runs : [];
    if (!runsLight.length) continue;

    if (!needsHeavy(runsLight)) continue;

    pgWorkItems.push({
      clusterId: String(clusterId),
      clusterName,
      pgId: String(pgId),
      pgName: it.pgName || "",
      pgEnv: it.pgEnv || "UnknownEnv",
    });
  }

  return {
    authMode: "vault",
    baseUrl,
    numRuns,
    pgWorkItems,
  };
}
