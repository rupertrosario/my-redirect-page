$logDirectory = "X:\PowerShell\Data\Cohesity\BackupFailures"

$fileCount = (Get-ChildItem -Path $logDirectory -File).Count

if ($fileCount -gt 50) {
    $filesToDelete = Get-ChildItem -Path $logDirectory -File | Sort-Object CreationTime | Select-Object -First ($fileCount - 50)
    if ($filesToDelete) { Remove-Item $filesToDelete -Force
        Write-Host "$($filesToDelete.Count) files Deleted." }
    else { Write-Host "No Files to delete." }
}
elseif (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory
}

# 0) API key from your path

$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$ApiKey = (Get-Content -Path $apikeypath -Raw).Trim()
$commonHeaders = @{ "apikey" = $ApiKey }

# 1) Get Clusters (ClusterName + ClusterId)

$url = "https://helios.cohesity.com/v2/mcm/cluster-mgmt/info"
$response = Invoke-WebRequest -Method Get -Uri $url -Headers $commonHeaders
$json_clu = $response.Content | ConvertFrom-Json
$json_clu = $json_clu.cohesityClusters

# Store all final results across clusters

$globalFailures = @()

# Collect all Protection Groups from clusters and process one cluster at a time
foreach ($clus in $json_clu) {
    $cluster_name = $clus.ClusterName
    $cluster_id = $clus.ClusterId

    $headers = @{ 
        "apikey" = $ApiKey
        "accessClusterId" = "$cluster_id" 
    }

    $body = @{ 
        environments = "kPhysical"
        isDeleted = "False"
        isPaused = "False"
        isActive = "True"
    }

    $pgurl = "https://helios.cohesity.com/v2/data-protect/protection-groups"

    $response = Invoke-WebRequest -Method Get -Uri $pgurl -Headers $headers -Body $body
    $pgs = $response.Content | ConvertFrom-Json
    $pgs = $pgsResponse

    foreach ($pg in $pgs.protectionGroups) {
        $pgId = $pg.id
        $pgName = $pg.name
        $hn.name
        $headers = @{ 
            "apikey" = "$ApiKey"
            "accessClusterId" = "$cluster_id" 
        }

        $body = @{ 
            environments = "kPhysical"
            isDeleted = "False"
            isPaused = "False"
            isActive = "True"
            numRuns = "10"
            excludeNonRestorableRuns= "false"
            includeObjectDetails = "true" 
        }

        $runurl = "https://helios.cohesity.com/v2/data-protect/protection-groups/$pgId/runs"

        $response = Invoke-WebRequest -Method Get -Uri $runurl -Headers $headers -Body $body
        $json = $response | ConvertFrom-Json
        $runs = if ($json -and $json.runs) { $json.runs } else { @() }

        $runs = if ($response -and $response.runs) { $response.runs } else { @() }
        #Write-Host " → PG: $pgName - Runs fetched: $($runs.Count)"

        if (-not $runs) {
            Write-Host " ⚠️ No runs found for PG: $pgName in Cluster: $cluster_name"
            continue
        }

        $flatRuns = @()
        foreach ($run in $runs) {
            if ($run.localBackupInfo) {
                foreach ($info in $run.localBackupInfo) {
                    $flatRuns += [pscustomobject]@{
                        RunType       = $run.runType
                        Status        = $info.status
                        Message       = $info.messages
                        StartTimeUsecs= $info.startTimeUsecs
                        EndTimeUsecs  = $info.endTimeUsecs
                        Cluster       = $cluster_name
                        ProtectionGroup = $pgName
                    }
                }
            }
        }

        function Convert-ToUTCFromEpoch($v) {
            if ($null -eq $v -or $v -eq 0) { return $null }
            try { 
                return [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$v).UtcDateTime
            } catch { 
                return [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$v / 1000)).UtcDateTime 
            }
        }

        $grouped = $flatRuns | Group-Object RunType
        foreach ($g in $grouped) {
            $latestFailed = $g.Group | Where-Object { $_.Status -eq "Failed" } | Sort-Object EndTimeUsecs -Descending | Select-Object -First 1
            if ($null -ne $latestFailed) {
                $hasLaterSuccess = $g.Group | Where-Object { $_.Status -eq "Succeeded" -and $_.StartTimeUsecs -gt $latestFailed.EndTimeUsecs }
                if (-not $hasLaterSuccess) {
                    $tzZone = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")
                    $startUtc = Convert-ToUTCFromEpoch $latestFailed.StartTimeUsecs
                    $endUtc = Convert-ToUTCFromEpoch $latestFailed.EndTimeUsecs

                    $globalFailures += [pscustomobject]@{
                        Cluster        = $latestFailed.Cluster
                        ProtectionGroup= $latestFailed.ProtectionGroup
                        RunType        = $latestFailed.RunType
                        Status         = $latestFailed.Status
                        Message        = $latestFailed.Message -join '; '
                        StartTime      = if ($startUtc) { [System.TimeZoneInfo]::ConvertTimeFromUtc($startUtc, $tzZone) } else { $null }
                        EndTime        = if ($endUtc) { [System.TimeZoneInfo]::ConvertTimeFromUtc($endUtc, $tzZone) } else { $null }
                    }
                }
            }
        }
    }
}

# Print one header and all failures + HTML export combined across clusters
if ($globalFailures.Count -gt 0) {
    Write-Host "=== Backup Failures Without Later Success Across All Clusters ==="
    $globalFailures |
      Sort-Object EndTime -Descending |
      Select-Object Cluster, ProtectionGroup, RunType, Status, Message,
        @{Name='StartTime'; Expression={ $_.StartTime.ToString("dd/MM/yyyy HH:mm:ss") }},
        @{Name='EndTime'; Expression={ $_.EndTime.ToString("dd/MM/yyyy HH:mm:ss") }} |
      Format-Table -AutoSize
}
