$logDirectory = "X:\PowerShell\Data\Cohesity\BackupFailures"

$fileCount = (Get-ChildItem -Path $logDirectory -File).Count

if ($fileCount -gt 50) {
    $filesToDelete = Get-ChildItem -Path $logDirectory -File | Sort-Object CreationTime | Select-Object -First ($fileCount - 50)
    if ($filesToDelete) {
        Remove-Item $filesToDelete -Force
        Write-Host "$($filesToDelete.Count) files Deleted."
    } else {
        Write-Host "No Files to delete."
    }
}
elseif (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory
}

function Convert-ToUTCFromEpoch($v) {
  if ($null -eq $v -or $v -eq 0) { return $null }
  try { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$v).UtcDateTime }
  catch { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$v/1000)).UtcDateTime }
}

# Build flat runs with object names
$flatRuns = @()
foreach ($run in $runs) {
  if ($run.localBackupInfo) {
    foreach ($info in $run.localBackupInfo) {
      $objName = $info.objectName
      if (-not $objName -and $info.object) { $objName = $info.object.name }
      if (-not $objName -and $info.entity) { $objName = $info.entity.displayName }
      if (-not $objName) { $objName = "<unknown>" }

      $flatRuns += [pscustomobject]@{
        RunType         = $run.runType
        Status          = $info.status
        Message         = ($info.messages -join '; ')
        StartTimeUsecs  = $info.startTimeUsecs
        EndTimeUsecs    = $info.endTimeUsecs
        Cluster         = $cluster_name
        ProtectionGroup = $pgName
        ObjectName      = $objName
      }
    }
  }
}

# Object-level suppression (per RunType & Object)
$survivors = @()
$byRtObj = $flatRuns | Group-Object RunType, ObjectName
foreach ($g in $byRtObj) {
  $latestFailed = $g.Group | Where-Object { $_.Status -eq 'Failed' } |
                  Sort-Object EndTimeUsecs -Descending | Select-Object -First 1
  if ($null -ne $latestFailed) {
    $hasLaterSuccess = $g.Group | Where-Object {
      ( $_.Status -eq 'Succeeded' -or $_.Status -eq 'SucceededWithWarning' ) -and
      $_.StartTimeUsecs -gt $latestFailed.EndTimeUsecs
    }
    if (-not $hasLaterSuccess) { $survivors += $latestFailed }
  }
}

# Collapse to one row per PG with comma-joined object names
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById('Asia/Kolkata')
$globalFailures =
  ($survivors | Group-Object Cluster, ProtectionGroup, RunType) | ForEach-Object {
    $grp = $_.Group
    $latest = $grp | Sort-Object EndTimeUsecs -Descending | Select-Object -First 1
    $startUtc = Convert-ToUTCFromEpoch $latest.StartTimeUsecs
    $endUtc   = Convert-ToUTCFromEpoch $latest.EndTimeUsecs
    [pscustomobject]@{
      Cluster         = $latest.Cluster
      ProtectionGroup = $latest.ProtectionGroup
      RunType         = $latest.RunType
      FailedObjects   = ($grp.ObjectName | Sort-Object -Unique) -join ', '
      Message         = $latest.Message
      StartTime       = if ($startUtc) { [System.TimeZoneInfo]::ConvertTimeFromUtc($startUtc, $tz) }
      EndTime         = if ($endUtc)   { [System.TimeZoneInfo]::ConvertTimeFromUtc($endUtc,   $tz) }
    }
  }

# Final output
if ($globalFailures.Count -gt 0) {
  Write-Host "=== Backup Failures Without Later Success Across All Clusters ==="
  $globalFailures |
    Sort-Object EndTime -Descending |
    Select-Object Cluster, ProtectionGroup, RunType,
      @{n='FailedObjects';e={
        if ($_.ObjectName -is [System.Array]) { ($_.ObjectName | Sort-Object -Unique) -join ', ' }
        elseif ($_.FailedObjects) { $_.FailedObjects } # support new aggregation
        else { $_.ObjectName }
      }},
      Message,
      @{Name='StartTime'; Expression={ if ($_.StartTime) { $_.StartTime.ToString("dd/MM/yyyy HH:mm:ss") } }},
      @{Name='EndTime';   Expression={ if ($_.EndTime)   { $_.EndTime.ToString("dd/MM/yyyy HH:mm:ss") } }} |
    Format-Table -AutoSize
} else {
  Write-Host "No qualifying failures found."
}
