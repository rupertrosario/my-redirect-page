import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alerts (Latest per alertCode) → Split by alertTypeBucket → 2 Emails per Bucket
 * GET-only
 *
 * OUTPUT: NO JSON helpers, NO debug, NO extra fields.
 * - Returns ONLY: { emails: [...] }
 * - Each email body is a plain-text fixed-width table inside a ```text``` block
 *   (renders as a table even if Dynatrace email is plain-text only).
 */
export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // AUTH (vault id)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  // ==============================
  // SETTINGS
  // ==============================
  const CONCURRENCY = 8;
  const MAX_ALERTS = 5000;
  const ALERT_STATES = ["kOpen", "kNote"];

  // Split emails by these buckets (type)
  const TYPE_BUCKETS = ["kHardware", "kSoftware", "kDataService", "kMaintenance"];
  const EMAIL_PREFIX = "Cohesity Helios — Active Alerts";

  // Email safety
  const MAX_DETAIL_ROWS_PER_CLUSTER = 60;
  const MAX_TOTAL_DETAIL_ROWS_PER_BUCKET = 1600;

  // Table rendering limits (plain-text)
  const MAX_MATRIX_COLS = 12; // cap categories shown as columns
  const COL_WIDTH_CLUSTER = 26;
  const COL_WIDTH_CAT = 18;

  const DETAILS_COLS = [
    { key: "Sev", label: "Sev", width: 12 },
    { key: "alertCategory", label: "Category", width: 20 },
    { key: "alertCode", label: "Code", width: 10 },
    { key: "alertState", label: "State", width: 7 },
    { key: "latestSeenUtc", label: "LatestUTC", width: 20 },
    { key: "occurrences", label: "Occ", width: 4 },
    { key: "props", label: "Props", width: 44 },
  ];

  // ==============================
  // SYMBOLS
  // ==============================
  const SYM_OK = "OK";
  const SYM_NODATA = "NO_DATA";
  const SYM_C = "C";
  const SYM_W = "W";
  const SYM_I = "I";

  // ==============================
  // HELPERS
  // ==============================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const cap = (s, n) => {
    const t = norm(s);
    return t.length > n ? t.slice(0, n - 1) + "…" : t;
  };

  function usecsToUtc(usecs) {
    const u = Number(usecs || 0);
    if (!u) return "";
    const d = new Date(Math.floor(u / 1000));
    return d.toISOString().replace("T", " ").replace(".000Z", "Z");
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try {
        txt = await resp.text();
      } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  async function poolMap(items, worker, concurrency) {
    const results = new Array(items.length);
    let idx = 0;
    const runners = new Array(Math.min(concurrency, items.length)).fill(0).map(async () => {
      while (idx < items.length) {
        const cur = idx++;
        results[cur] = await worker(items[cur], cur);
      }
    });
    await Promise.all(runners);
    return results;
  }

  function extractAlerts(payload) {
    const a =
      payload?.alertsList?.alerts ||
      payload?.alertsList ||
      payload?.alerts ||
      payload?.alertList ||
      payload;
    return toArray(a).filter((x) => x && typeof x === "object");
  }

  function severityBucket(sev) {
    const s = norm(sev).toLowerCase();
    if (s.includes("critical") || s === "kcritical") return "C";
    if (s.includes("warning") || s === "kwarning") return "W";
    if (s.includes("info") || s === "kinfo" || s.includes("informational")) return "I";
    return "U";
  }

  function sevLabel(b, rawSev) {
    const r = norm(rawSev) || "Unknown";
    if (b === "C") return `${SYM_C}:${r}`;
    if (b === "W") return `${SYM_W}:${r}`;
    if (b === "I") return `${SYM_I}:${r}`;
    return `U:${r}`;
  }

  function cellCWI(counts) {
    const C = counts.C || 0;
    const W = counts.W || 0;
    const I = counts.I || 0;
    if (!C && !W && !I) return SYM_OK;
    return `${C}${SYM_C}/${W}${SYM_W}/${I}${SYM_I}`; // e.g. 1C/2W/0I
  }

  function summarizeProps(propertyList) {
    const arr = toArray(propertyList);
    if (!arr.length) return "";
    const pairs = [];
    for (const p of arr) {
      const k = norm(p?.key || p?.name);
      const v = norm(p?.value);
      if (!k) continue;
      pairs.push(`${k}=${cap(v, 60)}`);
      if (pairs.length >= 3) break;
    }
    return pairs.join("; ");
  }

  function bucketOf(a) {
    return norm(a?.alertTypeBucket) || "Unknown";
  }
  function categoryOf(a) {
    return norm(a?.alertCategory) || "Unknown";
  }

  // ------------------------------
  // Plain-text table renderer
  // ------------------------------
  const padRight = (s, w) => {
    const t = norm(s);
    if (t.length >= w) return t.slice(0, w);
    return t + " ".repeat(w - t.length);
  };
  const padLeft = (s, w) => {
    const t = norm(s);
    if (t.length >= w) return t.slice(0, w);
    return " ".repeat(w - t.length) + t;
  };
  const hr = (widths, sep = "+") => sep + widths.map((w) => "-".repeat(w + 2)).join(sep) + sep;
  const rowLine = (values, widths, align = []) => {
    const cells = values.map((v, i) => {
      const w = widths[i];
      const a = align[i] || "L";
      const t = norm(v);
      if (a === "R") return " " + padLeft(t, w) + " ";
      return " " + padRight(t, w) + " ";
    });
    return "|" + cells.join("|") + "|";
  };
  const renderTable = (headers, rows, widths, align = []) => {
    const out = [];
    out.push(hr(widths));
    out.push(rowLine(headers, widths, align));
    out.push(hr(widths));
    for (const r of rows) out.push(rowLine(r, widths, align));
    out.push(hr(widths));
    return out.join("\n");
  };
  const asCodeBlock = (text) => "```text\n" + text + "\n```";

  // ==============================
  // COMMON HEADERS
  // ==============================
  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // 1) CLUSTERS
  // ==============================
  const clu = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, commonHeaders);
  const clusters = toArray(clu?.cohesityClusters)
    .map((c) => ({ clusterName: norm(c?.clusterName), clusterId: norm(c?.clusterId) }))
    .filter((c) => c.clusterName && c.clusterId)
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  if (!clusters.length) throw new Error("No clusters returned from /v2/mcm/cluster-mgmt/info");

  // ==============================
  // 2) PER-CLUSTER ALERTS (no time filter)
  // ==============================
  async function fetchAlertsForCluster(clusterId) {
    const headers = { ...commonHeaders, accessClusterId: String(clusterId) };
    const params = new URLSearchParams();
    params.set("maxAlerts", String(MAX_ALERTS));
    params.set("alertStateList", ALERT_STATES.join(","));
    const url = `${baseUrl}/v2/mcm/alerts?${params.toString()}`;
    const data = await getJson(url, headers);
    return extractAlerts(data);
  }

  const perClusterRaw = await poolMap(
    clusters,
    async (cl) => {
      try {
        const alerts = await fetchAlertsForCluster(cl.clusterId);
        return { ok: true, clusterName: cl.clusterName, clusterId: cl.clusterId, alerts };
      } catch (e) {
        return {
          ok: false,
          clusterName: cl.clusterName,
          clusterId: cl.clusterId,
          alerts: [],
          error: norm(e?.message),
        };
      }
    },
    CONCURRENCY
  );

  // ==============================
  // 3) DEDUPE helper (latest per alertCode), with occurrences sum
  // ==============================
  function dedupeLatestByCodeWithOcc(alerts) {
    const map = new Map();
    for (const a of alerts) {
      const code = norm(a?.alertCode);
      if (!code) continue;

      const latest = Number(a?.latestTimestampUsecs || 0);
      const first = Number(a?.firstTimestampUsecs || 0);
      const occ = Number(a?.dedupCount || 1);

      const prev = map.get(code);
      if (!prev) {
        map.set(code, {
          alertCode: code,
          latestTimestampUsecs: latest,
          firstTimestampUsecs: first,
          occurrences: occ,
          alert: a,
        });
      } else {
        prev.occurrences += occ;
        if (first && (!prev.firstTimestampUsecs || first < prev.firstTimestampUsecs)) prev.firstTimestampUsecs = first;
        if (latest >= Number(prev.latestTimestampUsecs || 0)) {
          prev.latestTimestampUsecs = latest;
          prev.alert = a;
        }
      }
    }
    return Array.from(map.values()).sort(
      (x, y) => Number(y.latestTimestampUsecs || 0) - Number(x.latestTimestampUsecs || 0)
    );
  }

  // ==============================
  // 4) Split by bucket per cluster, collect categories per bucket
  // ==============================
  const perClusterBuckets = new Map();
  const categoriesByBucket = new Map();
  for (const b of TYPE_BUCKETS) categoriesByBucket.set(b, new Set());

  for (const c of perClusterRaw) {
    const bucketMap = new Map();
    for (const b of TYPE_BUCKETS) bucketMap.set(b, []);

    if (!c.ok) {
      perClusterBuckets.set(c.clusterName, { ok: false, error: c.error, buckets: bucketMap });
      continue;
    }

    const grouped = new Map();
    for (const a of c.alerts) {
      const b = bucketOf(a);
      if (!TYPE_BUCKETS.includes(b)) continue;
      if (!grouped.has(b)) grouped.set(b, []);
      grouped.get(b).push(a);
    }

    for (const b of TYPE_BUCKETS) {
      const deduped = dedupeLatestByCodeWithOcc(grouped.get(b) || []);
      bucketMap.set(b, deduped);
      const catSet = categoriesByBucket.get(b);
      for (const u of deduped) catSet.add(categoryOf(u.alert));
    }

    perClusterBuckets.set(c.clusterName, { ok: true, buckets: bucketMap });
  }

  // ==============================
  // 5) Build 2 emails per bucket: SUMMARY + DETAILS (plain-text tables)
  // ==============================
  const utcDate = new Date().toISOString().slice(0, 10);
  const emails = [];

  for (const bucket of TYPE_BUCKETS) {
    const allCats = Array.from(categoriesByBucket.get(bucket) || new Set()).sort((a, b) => a.localeCompare(b));
    const cats = allCats.slice(0, MAX_MATRIX_COLS);
    const extraCats = Math.max(0, allCats.length - cats.length);

    // SUMMARY MATRIX: X=category, Y=cluster
    const headers = ["Cluster", ...cats, ...(extraCats ? [`…(+${extraCats})`] : [])];
    const widths = [COL_WIDTH_CLUSTER, ...cats.map(() => COL_WIDTH_CAT), ...(extraCats ? [COL_WIDTH_CAT] : [])];
    const align = ["L", ...cats.map(() => "R"), ...(extraCats ? ["R"] : [])];

    const rows = [];
    for (const cl of clusters) {
      const entry = perClusterBuckets.get(cl.clusterName);

      if (!entry || !entry.ok) {
        rows.push([cl.clusterName, ...cats.map(() => SYM_NODATA), ...(extraCats ? [SYM_NODATA] : [])]);
        continue;
      }

      const deduped = entry.buckets.get(bucket) || [];
      const countsByCategory = new Map();
      for (const cat of allCats) countsByCategory.set(cat, { C: 0, W: 0, I: 0 });

      for (const u of deduped) {
        const a = u.alert;
        const cat = categoryOf(a);
        if (!countsByCategory.has(cat)) countsByCategory.set(cat, { C: 0, W: 0, I: 0 });
        const sev = severityBucket(a?.severity);
        const cur = countsByCategory.get(cat);
        if (sev === "C" || sev === "W" || sev === "I") cur[sev] += 1;
      }

      const r = [cl.clusterName];
      for (const cat of cats) r.push(cellCWI(countsByCategory.get(cat) || { C: 0, W: 0, I: 0 }));

      if (extraCats) {
        const rest = allCats.slice(MAX_MATRIX_COLS);
        const agg = { C: 0, W: 0, I: 0 };
        for (const cat of rest) {
          const cwc = countsByCategory.get(cat) || { C: 0, W: 0, I: 0 };
          agg.C += cwc.C;
          agg.W += cwc.W;
          agg.I += cwc.I;
        }
        r.push(cellCWI(agg));
      }

      rows.push(r);
    }

    const matrixText = renderTable(headers, rows, widths, align);

    const summaryText =
      `${EMAIL_PREFIX} — ${bucket} — SUMMARY — ${utcDate}\n` +
      `Window: not filtered | States: ${ALERT_STATES.join(", ")} | MaxAlerts/cluster: ${MAX_ALERTS}\n` +
      `Dedupe: latest per alertCode (per cluster, per ${bucket})\n` +
      `Cell: xC/yW/zI (unique alertCodes)\n\n` +
      matrixText;

    emails.push({
      bucket,
      kind: "summary",
      subject: `${EMAIL_PREFIX} — ${bucket} — SUMMARY — ${utcDate}`,
      emailBodyText: asCodeBlock(summaryText),
    });

    // DETAILS: per cluster
    const parts = [];
    parts.push(`${EMAIL_PREFIX} — ${bucket} — DETAILS — ${utcDate}`);
    parts.push(`Window: not filtered | States: ${ALERT_STATES.join(", ")} | MaxAlerts/cluster: ${MAX_ALERTS}`);
    parts.push(`Dedupe: latest per alertCode (per cluster, per ${bucket})`);
    parts.push("");

    let totalRows = 0;

    for (const cl of clusters) {
      const entry = perClusterBuckets.get(cl.clusterName);

      parts.push(`Cluster: ${cl.clusterName}`);

      if (!entry || !entry.ok) {
        parts.push(`  ${SYM_NODATA} - ${cap(norm(entry?.error) || "Unreachable/failed request", 240)}`);
        parts.push("");
        continue;
      }

      const deduped = entry.buckets.get(bucket) || [];
      if (!deduped.length) {
        parts.push(`  ${SYM_OK} - No active alerts for ${bucket}`);
        parts.push("");
        continue;
      }

      const take = Math.min(MAX_DETAIL_ROWS_PER_CLUSTER, deduped.length);

      const dHeaders = DETAILS_COLS.map((c) => c.label);
      const dWidths = DETAILS_COLS.map((c) => c.width);
      const dAlign = DETAILS_COLS.map((c) => (c.key === "occurrences" || c.key === "alertCode" ? "R" : "L"));

      const dRows = [];
      for (let i = 0; i < take; i++) {
        if (totalRows >= MAX_TOTAL_DETAIL_ROWS_PER_BUCKET) break;

        const u = deduped[i];
        const a = u.alert;
        const sevB = severityBucket(a?.severity);

        const vals = DETAILS_COLS.map((cdef) => {
          switch (cdef.key) {
            case "Sev":
              return sevLabel(sevB, a?.severity);
            case "alertCategory":
              return categoryOf(a);
            case "alertCode":
              return norm(a?.alertCode);
            case "alertState":
              return norm(a?.alertState);
            case "latestSeenUtc":
              return usecsToUtc(u.latestTimestampUsecs || a?.latestTimestampUsecs);
            case "occurrences":
              return String(u.occurrences || 0);
            case "props":
              return cap(summarizeProps(a?.propertyList), cdef.width);
            default:
              return "";
          }
        });

        dRows.push(vals);
        totalRows++;
      }

      parts.push(renderTable(dHeaders, dRows, dWidths, dAlign));

      if (totalRows >= MAX_TOTAL_DETAIL_ROWS_PER_BUCKET) {
        parts.push(`NOTE: Details capped at ${MAX_TOTAL_DETAIL_ROWS_PER_BUCKET} rows for ${bucket}.`);
        parts.push("");
        break;
      }

      parts.push("");
    }

    emails.push({
      bucket,
      kind: "details",
      subject: `${EMAIL_PREFIX} — ${bucket} — DETAILS — ${utcDate}`,
      emailBodyText: asCodeBlock(parts.join("\n")),
    });
  }

  // ONLY return emails (no extra objects)
  return { emails };
}
