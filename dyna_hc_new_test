import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios — Active Alerts (Unique by alertCode, latest only) — Matrix Summary + Email
 * GET-only
 *
 * Endpoints:
 *  - GET https://helios.cohesity.com/v2/mcm/cluster-mgmt/info
 *  - GET https://helios.cohesity.com/v2/mcm/alerts   (with accessClusterId per cluster)
 *
 * Dedupe:
 *  - Per cluster, group by alertCode
 *  - Keep ONLY the latest occurrence row per code
 *
 * Matrix (UPDATED):
 *  - X-axis = Clusters (columns)
 *  - Y-axis = alertCategory → alertType (rows)
 *  - Cell = "xC / yW / zI" (unique alertCodes, latest only)
 *
 * Email:
 *  - Sends ONLY the summary (note + matrix).
 *
 * Returns:
 *  - subject
 *  - emailBodyMarkdown
 *  - note
 *  - markdownMatrix
 *  - raw (compact json)
 */
export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // AUTH (vault id)
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  // ==============================
  // SETTINGS
  // ==============================
  const CONCURRENCY = 8;
  const MAX_ALERTS = 5000; // no time window
  const ALERT_STATES = ["kOpen", "kNote"];

  // Email subject
  const EMAIL_SUBJECT_PREFIX = "Cohesity Helios — Alerts (Unique by Code)";

  // ==============================
  // SYMBOLS
  // ==============================
  const SYM_OK = "✅";
  const SYM_W = "⚠️";

  // ==============================
  // HELPERS
  // ==============================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);
  const safeCell = (v) => (v === null || v === undefined ? "" : String(v).replace(/\|/g, " "));

  function mdTable(headers, rows) {
    if (!rows.length) return "No data.";
    const head = `| ${headers.join(" | ")} |`;
    const sep = `| ${headers.map(() => "---").join(" | ")} |`;
    const body = rows.map((r) => `| ${headers.map((h) => safeCell(r[h] ?? "")).join(" | ")} |`);
    return [head, sep, ...body].join("\n");
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try {
        txt = await resp.text();
      } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  async function poolMap(items, worker, concurrency) {
    const results = new Array(items.length);
    let idx = 0;
    const runners = new Array(Math.min(concurrency, items.length)).fill(0).map(async () => {
      while (idx < items.length) {
        const cur = idx++;
        results[cur] = await worker(items[cur], cur);
      }
    });
    await Promise.all(runners);
    return results;
  }

  function extractAlerts(payload) {
    const a =
      payload?.alertsList?.alerts ||
      payload?.alertsList ||
      payload?.alerts ||
      payload?.alertList ||
      payload;
    return toArray(a).filter((x) => x && typeof x === "object");
  }

  function severityBucket(sev) {
    const s = norm(sev).toLowerCase();
    if (s.includes("critical") || s === "kcritical") return "C";
    if (s.includes("warning") || s === "kwarning") return "W";
    if (s.includes("info") || s === "kinfo" || s.includes("informational")) return "I";
    return "U";
  }

  function cellText(counts) {
    const C = counts.C || 0;
    const W = counts.W || 0;
    const I = counts.I || 0;
    if (!C && !W && !I) return SYM_OK;
    return `${C}C / ${W}W / ${I}I`;
  }

  function catTypeKey(a) {
    return `${norm(a?.alertCategory) || "Unknown"} → ${norm(a?.alertType) || "Unknown"}`;
  }

  // ==============================
  // COMMON HEADERS
  // ==============================
  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // 1) CLUSTERS
  // ==============================
  const clu = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, commonHeaders);
  const clusters = toArray(clu?.cohesityClusters)
    .map((c) => ({ clusterName: norm(c?.clusterName), clusterId: norm(c?.clusterId) }))
    .filter((c) => c.clusterName && c.clusterId)
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  if (!clusters.length) throw new Error("No clusters returned from /v2/mcm/cluster-mgmt/info");

  // ==============================
  // 2) PER-CLUSTER /v2/mcm/alerts (NO time window)
  // ==============================
  async function fetchAlertsForCluster(clusterId) {
    const headers = { ...commonHeaders, accessClusterId: String(clusterId) };

    const params = new URLSearchParams();
    params.set("maxAlerts", String(MAX_ALERTS));
    params.set("alertStateList", ALERT_STATES.join(","));
    const url = `${baseUrl}/v2/mcm/alerts?${params.toString()}`;

    const data = await getJson(url, headers);
    return extractAlerts(data);
  }

  const perClusterRaw = await poolMap(
    clusters,
    async (cl) => {
      try {
        const alerts = await fetchAlertsForCluster(cl.clusterId);
        return { ok: true, clusterName: cl.clusterName, clusterId: cl.clusterId, alerts };
      } catch (e) {
        return {
          ok: false,
          clusterName: cl.clusterName,
          clusterId: cl.clusterId,
          alerts: [],
          error: norm(e?.message),
        };
      }
    },
    CONCURRENCY
  );

  // ==============================
  // 3) DEDUPE per cluster by alertCode (keep latest only)
  // ==============================
  function dedupeLatestByCode(alerts) {
    const map = new Map(); // code -> latestRow
    for (const a of alerts) {
      const code = norm(a?.alertCode);
      if (!code) continue;

      const latest = Number(a?.latestTimestampUsecs || 0);
      const prev = map.get(code);
      if (!prev || latest >= Number(prev?.latestTimestampUsecs || 0)) {
        map.set(code, a);
      }
    }
    return Array.from(map.values());
  }

  const perCluster = perClusterRaw.map((c) => {
    if (!c.ok) return { ...c, unique: [] };
    return { ...c, unique: dedupeLatestByCode(c.alerts) };
  });

  // ==============================
  // 4) Rows set from deduped rows: alertCategory → alertType
  // ==============================
  const rowSet = new Set();
  for (const c of perCluster) {
    if (!c.ok) continue;
    for (const a of c.unique) rowSet.add(catTypeKey(a));
  }
  const rowKeys = Array.from(rowSet).sort((a, b) => a.localeCompare(b));

  // ==============================
  // 5) Matrix: rows=Category→Type, cols=Clusters (X-axis=clusters)
  // ==============================
  const headers = ["Category → Type", ...clusters.map((c) => c.clusterName)];

  // Precompute a lookup: clusterName -> (rowKey -> {C,W,I} or NO_DATA)
  const clusterRowCounts = new Map();
  for (const c of perCluster) {
    if (!c.ok) {
      clusterRowCounts.set(c.clusterName, { __NO_DATA__: true, error: c.error });
      continue;
    }
    const m = new Map();
    for (const rk of rowKeys) m.set(rk, { C: 0, W: 0, I: 0 });

    for (const a of c.unique) {
      const rk = catTypeKey(a);
      if (!m.has(rk)) m.set(rk, { C: 0, W: 0, I: 0 });
      const b = severityBucket(a?.severity);
      const cur = m.get(rk);
      if (b === "C" || b === "W" || b === "I") cur[b] += 1;
    }
    clusterRowCounts.set(c.clusterName, m);
  }

  const matrixRows = rowKeys.map((rk) => {
    const row = { "Category → Type": rk };
    for (const cl of clusters) {
      const v = clusterRowCounts.get(cl.clusterName);
      if (!v) {
        row[cl.clusterName] = `${SYM_W}NO_DATA`;
        continue;
      }
      if (v.__NO_DATA__) {
        row[cl.clusterName] = `${SYM_W}NO_DATA`;
        continue;
      }
      row[cl.clusterName] = cellText(v.get(rk) || { C: 0, W: 0, I: 0 });
    }
    return row;
  });

  const markdownMatrix =
    `**Active Alerts (Unique by alertCode, latest only) — Summary Matrix**\n` +
    `X-axis: Clusters | Y-axis: Category → Type | Cell: C/W/I (unique alertCodes)\n\n` +
    mdTable(headers, matrixRows);

  // ==============================
  // 6) NOTE + EMAIL (SUMMARY ONLY)
  // ==============================
  const note =
    `### Cohesity Helios — Active Alerts (Unique by alertCode)\n\n` +
    `**States:** ${ALERT_STATES.join(", ")} | **MaxAlerts/cluster:** ${MAX_ALERTS} | **Window:** not filtered\n\n` +
    `**Legend:** ✅ none | C/W/I = unique alertCodes by severity | ⚠️NO_DATA unreachable\n`;

  const subjectDateUtc = new Date().toISOString().slice(0, 10);
  const subject = `${EMAIL_SUBJECT_PREFIX} — ${subjectDateUtc}`;

  const emailBodyMarkdown = [note, markdownMatrix].join("\n\n");

  // ==============================
  // 7) RAW (compact)
  // ==============================
  const raw = perCluster.map((c) => ({
    ok: c.ok,
    clusterName: c.clusterName,
    clusterId: c.clusterId,
    rawAlertCount: c.ok ? c.alerts.length : null,
    uniqueAlertCodes: c.ok ? c.unique.length : null,
    error: c.ok ? null : c.error,
  }));

  return {
    subject,
    emailBodyMarkdown,
    note,
    markdownMatrix,
    raw,
  };
}
