// Cohesity Helios â€“ Capacity + Garbage + Version + Location + Node Count
// Vault: name -> id -> manual. GET-only, no metrics.
import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {

  const baseUrl = "https://helios.cohesity.com";
  const oneTiB  = 1099511627776;

  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  let apiKey   = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find(c => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log(`âœ“ loaded Helios key from vault (name): ${found.name}`);
    return detail?.token || null;
  }

  // 1) vault by name, then by id, then manual
  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = detail?.token || null;
      authMode = "vault-id";
      console.log(`âœ“ loaded Helios key from vault (id): ${detail?.name || vaultId}`);
    } catch {
      authMode = "manual";
      apiKey   = "PASTE_YOUR_API_KEY_HERE"; // fallback for testing
      console.log("âš  using manual Helios API key (fallback)");
    }
  }

  const headers = { accept: "application/json", apiKey };

  // 2) cluster list
  const listResp = await fetch(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { method: "GET", headers });
  if (listResp.status !== 200) {
    const txt = await listResp.text().catch(() => "");
    throw new Error(`cluster list failed (${listResp.status}) ${txt}`);
  }

  const listJson = await listResp.json();
  const clusters = listJson?.cohesityClusters || [];
  if (!clusters.length) {
    const empty =
      "<pre>\n" +
      "ðŸ“Š Cohesity Cluster Capacity Report\n\n" +
      "No clusters returned.\n" +
      `Auth mode used: ${authMode}\n` +
      "</pre>";
    return { clusters: [], report: empty, authMode };
  }

  console.log(`found ${clusters.length} clustersâ€¦`);

  // helper â€“ garbage bytes with your working query + entityId variants
  async function getGarbageLatest(clusterName, clusterId, h) {
    const safeName = clusterName.replace(/\s+/g, "");
    const mainId   = `${safeName}+(ID+${clusterId})`;

    const variants = [
      mainId,
      `${safeName}(ID ${clusterId})`,
      `${safeName} (ID ${clusterId})`,
      `${clusterName}(ID ${clusterId})`
    ];

    for (const v of variants) {
      const enc = encodeURIComponent(v);
      const url =
        `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
        `?schemaName=ApolloV2ClusterStats` +
        `&metricName=EstimatedGarbageBytes` +
        `&startTimeMsecs=2` +
        `&entityId=${enc}` +
        `&rollupFunction=latest` +
        `&rollupIntervalSecs=30` +
        `&metricUnitType=0` +
        `&range=day`;

      console.log(`  -> garbage GET [${clusterName}] entityId='${v}'`);
      const resp = await fetch(url, { method: "GET", headers: h });
      if (resp.status !== 200) {
        const t = await resp.text().catch(() => "");
        console.log(`     variant failed (HTTP ${resp.status}) ${t}`);
        continue;
      }

      const js  = await resp.json();
      const vec = js?.dataPointVec || [];
      if (!vec.length) {
        console.log("     variant returned no datapoints");
        continue;
      }

      const last  = vec[vec.length - 1];
      const bytes = last?.data?.int64Value ?? 0;
      console.log(`     garbage OK via '${v}' â†’ ${bytes} bytes`);
      return bytes;
    }

    console.log(`     all garbage variants failed for ${clusterName}, using 0`);
    return 0;
  }

  const results = [];

  // 3) per-cluster stats
  await Promise.all(
    clusters.map(async ({
      clusterName,
      clusterId,
      currentVersion,
      location,
      numberOfNodes
    }) => {

      const h = { ...headers, accessClusterId: String(clusterId) };

      // capacity
      const capUrl  = `${baseUrl}/irisservices/api/v1/public/stats/storage`;
      const capResp = await fetch(capUrl, { method: "GET", headers: h });
      if (capResp.status !== 200) {
        const t = await capResp.text().catch(() => "");
        console.log(`capacity failed for ${clusterName} (${capResp.status}) ${t}`);
        return;
      }

      const s = await capResp.json();
      const totalTiB = +(s.totalCapacityBytes  / oneTiB).toFixed(2);
      const usedTiB  = +(s.localUsageBytes     / oneTiB).toFixed(2);
      const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
      const percent  = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

      // garbage
      const garbageBytes = await getGarbageLatest(clusterName, clusterId, h);
      const garbageGB    = +(garbageBytes / (1024 ** 3)).toFixed(2);
      const garbageTB    = +(garbageBytes / (1024 ** 4)).toFixed(3);

      results.push({
        clusterName,
        location:      location || "Unknown",
        version:       currentVersion || "Unknown",
        numberOfNodes: numberOfNodes || 0,
        totalTiB,
        usedTiB,
        availTiB,
        consumedPercent: percent,
        garbageGB,
        garbageTB
      });

      console.log(
        `âœ“ ${clusterName} | v${currentVersion || "?"} | nodes:${numberOfNodes || 0} | ${usedTiB}/${totalTiB} TiB | ${percent}% | garbage ${garbageGB} GB`
      );
    })
  );

  // 4) build <pre> table
  const rows = results.sort((a, b) => a.clusterName.localeCompare(b.clusterName));
  const badge = (p) => (p >= 80 ? "ðŸ”´" : p > 70 ? "ðŸŸ¡" : "ðŸŸ¢");

  // column widths
  const colCluster = 22;
  const colLoc     = 14;
  const colVer     = 8;
  const colNodes   = 5;
  const colNum     = 9;

  function padRight(str, w) {
    return String(str).padEnd(w, " ");
  }
  function padLeft(str, w) {
    return String(str).padStart(w, " ");
  }

  let lines = [];
  lines.push("ðŸ“Š Cohesity Cluster Capacity Report");
  lines.push("");
  lines.push(
    padRight("Cluster", colCluster)   + "  " +
    padRight("Location", colLoc)     + "  " +
    padRight("Version", colVer)      + "  " +
    padLeft("Nodes", colNodes)       + "  " +
    padLeft("UsedTiB", colNum)       + "  " +
    padLeft("AvailTiB", colNum)      + "  " +
    padLeft("%Used", colNum)         + "  " +
    padRight("Status", 7)            + "  " +
    padLeft("GarbageGB", colNum)     + "  " +
    padLeft("GarbageTB", colNum)
  );

  lines.push(
    padRight("".padEnd(colCluster, "-"), colCluster) + "  " +
    "".padEnd(colLoc, "-")                           + "  " +
    "".padEnd(colVer, "-")                           + "  " +
    "".padEnd(colNodes, "-")                         + "  " +
    "".padEnd(colNum, "-")                           + "  " +
    "".padEnd(colNum, "-")                           + "  " +
    "".padEnd(colNum, "-")                           + "  " +
    "".padEnd(7, "-")                                + "  " +
    "".padEnd(colNum, "-")                           + "  " +
    "".padEnd(colNum, "-")
  );

  for (const c of rows) {
    lines.push(
      padRight(c.clusterName, colCluster)            + "  " +
      padRight(c.location, colLoc)                  + "  " +
      padRight(c.version, colVer)                   + "  " +
      padLeft(c.numberOfNodes, colNodes)            + "  " +
      padLeft(c.usedTiB, colNum)                    + "  " +
      padLeft(c.availTiB, colNum)                   + "  " +
      padLeft(c.consumedPercent + "%", colNum)      + "  " +
      padRight(badge(c.consumedPercent), 7)         + "  " +
      padLeft(c.garbageGB, colNum)                  + "  " +
      padLeft(c.garbageTB, colNum)
    );
  }

  lines.push("");
  lines.push(`Total clusters: ${rows.length}`);
  lines.push("");
  lines.push("Legend:");
  lines.push("ðŸŸ¢ Healthy (â‰¤70%)");
  lines.push("ðŸŸ¡ Warning (70â€“79%)");
  lines.push("ðŸ”´ Critical (â‰¥80%)");
  lines.push("");
  lines.push(`Auth mode used: ${authMode}`);

  const preReport = "<pre>\n" + lines.join("\n") + "\n</pre>";

  return {
    clusters: rows,
    report: preReport,
    authMode
  };
}
