// üöÄ Cohesity Helios ‚Üí Dynatrace Metrics (dashboard-ready)
// - GET-only from Cohesity (capacity + garbage)
// - POST-only to Dynatrace Metrics API
// - Vault by Name ‚Üí by ID ‚Üí Manual fallback for Helios API key
//
// View later in Dashboards ‚Üí Data explorer (Metrics):
//   cohesity.capacity.total.tib
//   cohesity.capacity.used.tib
//   cohesity.capacity.avail.tib
//   cohesity.capacity.consumed.percent
//   cohesity.garbage.gb
//   cohesity.garbage.tb
//
// Permissions to ask your team for (workflow actor):
//   environment-api:metrics:ingest   (Dynatrace Metrics v2 write)
//   (some tenants label it "storage:metrics:write" ‚Äî ask for both if unsure)

import {
  metricsClient,
  credentialVaultClient,
} from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  // --- Config ---
  const baseUrl   = "https://helios.cohesity.com";
  const oneTiB    = 1099511627776;
  const vaultName = "Cohesity_API_Key";       // ‚úÖ your working Vault name
  const vaultId   = "credentials_vault-312312"; // optional fallback ID

  // --- Resolve Helios API key: Vault by Name ‚Üí by ID ‚Üí Manual ---
  async function getKeyFromVaultByName(name) {
    const list = await credentialVaultClient.getCredentials();
    const found = list.credentials.find(c => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return detail?.token || null;
  }

  let apiKey = null;
  let authMode = "vault-name";
  try {
    apiKey = await getKeyFromVaultByName(vaultName);
    if (!apiKey) throw new Error("not-found-by-name");
    console.log(`üîê Loaded Helios key from vault (by name): ${vaultName}`);
  } catch (e1) {
    try {
      const d = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = d?.token || null;
      authMode = "vault-id";
      console.log(`üîê Loaded Helios key from vault (by id): ${vaultId}`);
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE"; // manual fallback for testing only
      console.log("‚ö†Ô∏è Using manual Helios API key fallback.");
    }
  }

  const headers = { accept: "application/json", apiKey };

  // --- 1) Cluster inventory (GET)
  const listUrl  = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const listResp = await fetch(listUrl, { method: "GET", headers });
  if (listResp.status !== 200) {
    const body = await listResp.text().catch(() => "");
    throw new Error(`‚ùå Cluster list failed (HTTP ${listResp.status}) ${body}`);
  }
  const clusters = (await listResp.json())?.cohesityClusters || [];
  if (!clusters.length) {
    console.log("‚ö†Ô∏è No clusters returned from Helios.");
    return { clusters: [], ingested: 0, authMode };
  }

  console.log(`üîç Found ${clusters.length} clusters. Collecting metrics...`);

  // --- Helper: fetch garbage latest for this cluster (GET)
  async function getGarbageLatest(clusterName, clusterId, h) {
    const safeName = clusterName.replace(/\s+/g, "");
    const entityId = `${safeName}+(ID+${clusterId})`; // your proven-working format

    const tsUrl =
      `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
      `?schemaName=ApolloV2ClusterStats` +
      `&metricName=EstimatedGarbageBytes` +
      `&startTimeMsecs=2` +
      `&entityId=${encodeURIComponent(entityId)}` +
      `&rollupFunction=latest` +
      `&rollupIntervalSecs=30` +
      `&metricUnitType=0` +
      `&range=day`;

    const r = await fetch(tsUrl, { method: "GET", headers: h });
    if (r.status !== 200) return { bytes: 0, ok: false, status: r.status };

    const j = await r.json();
    const vec = Array.isArray(j?.dataPointVec) ? j.dataPointVec : [];
    const latest = vec.length ? vec[vec.length - 1] : undefined;
    const bytes = latest?.data?.int64Value ?? 0;
    return { bytes, ok: true, status: 200 };
  }

  // --- 2) Per-cluster: GET capacity + garbage, build metric lines
  const metricLines = [];
  const results     = [];

  await Promise.all(clusters.map(async ({ clusterName, clusterId }) => {
    const h = { ...headers, accessClusterId: String(clusterId) };

    // Capacity (GET)
    const capUrl  = `${baseUrl}/irisservices/api/v1/public/stats/storage`;
    const capResp = await fetch(capUrl, { method: "GET", headers: h });
    if (capResp.status !== 200) {
      const t = await capResp.text().catch(() => "");
      console.log(`‚ö†Ô∏è Capacity GET failed for ${clusterName} (HTTP ${capResp.status}) ${t}`);
      return;
    }
    const s = await capResp.json();

    const totalTiB = +(s.totalCapacityBytes  / oneTiB).toFixed(2);
    const usedTiB  = +(s.localUsageBytes     / oneTiB).toFixed(2);
    const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
    const consumed = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

    // Garbage (GET)
    const g = await getGarbageLatest(clusterName, clusterId, h);
    const garbageBytes = g.bytes || 0;
    const garbageGB    = +(garbageBytes / (1024 ** 3)).toFixed(2);
    const garbageTB    = +(garbageBytes / (1024 ** 4)).toFixed(3);

    results.push({
      clusterName, clusterId, totalTiB, usedTiB, availTiB, consumedPercent: consumed, garbageGB, garbageTB
    });

    // Build Dynatrace metric lines (dimensions: clusterName, clusterId)
    const dims = `clusterName="${clusterName.replace(/"/g, '\\"')}",clusterId="${clusterId}"`;
    metricLines.push(
      `cohesity.capacity.total.tib,${dims} ${totalTiB}`,
      `cohesity.capacity.used.tib,${dims} ${usedTiB}`,
      `cohesity.capacity.avail.tib,${dims} ${availTiB}`,
      `cohesity.capacity.consumed.percent,${dims} ${consumed}`,
      `cohesity.garbage.gb,${dims} ${garbageGB}`,
      `cohesity.garbage.tb,${dims} ${garbageTB}`
    );

    console.log(`‚úÖ ${clusterName}: ${usedTiB}/${totalTiB} TiB (${consumed}%) | Garbage ${garbageGB} GB (${garbageTB} TB)`);
  }));

  // --- 3) Ingest to Dynatrace Metrics (POST to Dynatrace only)
  let ingested = 0;
  if (metricLines.length) {
    console.log(`üì° Ingesting ${metricLines.length} lines to Dynatrace Metrics...`);
    try {
      await metricsClient.ingest({ body: metricLines.join("\n") });
      ingested = metricLines.length;
      console.log("‚úÖ Metrics ingest OK.");
    } catch (e) {
      // These logs help your team diagnose missing scopes
      const maybeStatus = e?.status || e?.response?.status;
      let errText = "";
      try { errText = await e?.response?.text(); } catch { /* ignore */ }

      console.log("üö´ Dynatrace Metrics ingest failed.");
      console.log(`   HTTP status: ${maybeStatus || "unknown"}`);
      if (errText) console.log(`   Body: ${errText}`);

      console.log("   Likely missing permission/scope on the workflow actor:");
      console.log("   ‚Ä¢ environment-api:metrics:ingest   (primary)");
      console.log("   ‚Ä¢ (some tenants call it storage:metrics:write)");
      console.log("   Ask the platform team to grant the correct scope to this workflow.");
    }
  } else {
    console.log("‚ÑπÔ∏è No metric lines to ingest.");
  }

  // --- 4) Return summary
  return {
    authMode,                      // "vault-name" | "vault-id" | "manual"
    clusters: results,             // raw results
    ingestedMetricLines: ingested, // how many datapoints we tried to push
  };
}
