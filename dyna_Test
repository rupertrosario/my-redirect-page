// ğŸš€ Cohesity Helios â€“ Fast Read-Only Cluster Stats + Garbage + Capacity
// GET only (read-only). POST is only to Dynatrace metrics API (safe).
import { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';

export default async function () {
  const apiKey  = "PASTE_YOUR_API_KEY_HERE";  // Helios API key
  const baseUrl = "https://helios.cohesity.com";
  const oneTiB  = 1099511627776;
  const headers = { accept: "application/json", apiKey };

  // 1ï¸âƒ£ Get cluster list
  const listResp = await fetch(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { method: "GET", headers });
  if (listResp.status !== 200) throw new Error(`âŒ Cluster list failed (${listResp.status})`);
  const clusters = (await listResp.json())?.cohesityClusters || [];
  if (!clusters.length) {
    console.log("âš ï¸ No clusters found.");
    return { clusters: [] };
  }

  console.log(`ğŸ” Found ${clusters.length} clusters. Fetching capacity and garbage...`);

  // 2ï¸âƒ£ Process clusters in parallel
  const clusterStats = await Promise.all(clusters.map(async ({ clusterName, clusterId }) => {
    const h = { ...headers, accessClusterId: String(clusterId) };
    const safeName = clusterName.replace(/\s+/g, '');
    const entityId = `${safeName}+(ID+${clusterId})`;  // âœ… your working format

    // --- Parallel GETs for capacity & garbage
    const tsUrl =
      `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
      `?schemaName=ApolloV2ClusterStats` +
      `&metricName=EstimatedGarbageBytes` +
      `&startTimeMsecs=2` +
      `&entityId=${entityId}` +
      `&rollupFunction=latest` +
      `&rollupIntervalSecs=30` +
      `&metricUnitType=0` +
      `&range=day`;
    const capUrl = `${baseUrl}/irisservices/api/v1/public/stats/storage`;

    const [tsResp, capResp] = await Promise.all([
      fetch(tsUrl, { method: "GET", headers: h }),
      fetch(capUrl, { method: "GET", headers: h })
    ]);

    let garbageGB = 0, garbageTB = 0;
    if (tsResp.status === 200) {
      const tsJson = await tsResp.json();
      const vec = tsJson?.dataPointVec || [];
      const latest = vec.length ? vec[vec.length - 1] : undefined;
      const bytes = latest?.data?.int64Value ?? 0;
      garbageGB = +(bytes / (1024 ** 3)).toFixed(2);
      garbageTB = +(bytes / (1024 ** 4)).toFixed(3);
    } else {
      console.log(`âš ï¸ Garbage fetch failed for ${clusterName} (HTTP ${tsResp.status})`);
    }

    if (capResp.status !== 200) {
      console.log(`âš ï¸ Capacity fetch failed for ${clusterName} (HTTP ${capResp.status})`);
      return null;
    }

    const s = await capResp.json();
    const totalTiB = +(s.totalCapacityBytes / oneTiB).toFixed(2);
    const usedTiB  = +(s.localUsageBytes / oneTiB).toFixed(2);
    const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
    const consumed = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

    console.log(`âœ… ${clusterName}: ${usedTiB}/${totalTiB} TiB used (${consumed}%) | Garbage ${garbageGB} GB`);

    return {
      clusterName, clusterId,
      totalTiB, usedTiB, availTiB,
      consumedPercent: consumed,
      garbageGB, garbageTB
    };
  }));

  const valid = clusterStats.filter(Boolean);

  // 3ï¸âƒ£ (Optional) Ingest to Dynatrace Metrics
  try {
    const lines = valid.map(c => {
      const dims = `clusterName="${c.clusterName.replace(/"/g, '\\"')}",clusterId="${c.clusterId}"`;
      return [
        `cohesity.capacity.total.tib,${dims} ${c.totalTiB}`,
        `cohesity.capacity.used.tib,${dims} ${c.usedTiB}`,
        `cohesity.capacity.avail.tib,${dims} ${c.availTiB}`,
        `cohesity.capacity.consumed.percent,${dims} ${c.consumedPercent}`,
        `cohesity.garbage.gb,${dims} ${c.garbageGB}`,
        `cohesity.garbage.tb,${dims} ${c.garbageTB}`
      ].join("\n");
    }).join("\n");

    if (lines.length) await metricsClient.ingest({ body: lines });
  } catch (e) {
    let msg = e?.message || String(e);
    try {
      const parsed = JSON.parse(msg);
      msg = parsed?.error?.message || parsed?.message || msg;
    } catch {}
    console.log(`ğŸš« Dynatrace ingest error: ${msg}`);
  }

  // 4ï¸âƒ£ Return clean cluster data for output pane
  console.log("ğŸ“„ Final summary:");
  console.log(JSON.stringify(valid, null, 2));
  return { clusters: valid };
}
