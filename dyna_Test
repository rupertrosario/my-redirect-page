// ðŸš€ Cohesity Helios â€“ Read-only Capacity + Garbage + Version + Location + Node Count
// Vault priority: Name â†’ ID â†’ Manual fallback
import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";
  const oneTiB = 1099511627776;

  const vaultName = "Cohesity_API_Key";         // working vault name
  const vaultId   = "credentials_vault-312312"; // optional fallback

  let apiKey = null;
  let authMode = "vault-name";

  // helper â†’ vault by name
  async function tryGetByName(name) {
    try {
      const list = await credentialVaultClient.getCredentials();
      const found = list.credentials.find(c => c.name === name);
      if (!found) return null;
      const details = await credentialVaultClient.getCredentialsDetails({ id: found.id });
      console.log(`âœ“ loaded API key (vault name): ${found.name}`);
      return details.token;
    } catch {
      return null;
    }
  }

  // 1ï¸âƒ£ vault â†’ by name
  apiKey = await tryGetByName(vaultName);

  // 2ï¸âƒ£ vault â†’ by ID
  if (!apiKey) {
    try {
      const details = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = details?.token;
      authMode = "vault-id";
      console.log(`âœ“ loaded API key (vault ID): ${details?.name || vaultId}`);
    } catch {}
  }

  // 3ï¸âƒ£ manual fallback
  if (!apiKey) {
    apiKey = "PASTE_YOUR_API_KEY_HERE";
    authMode = "manual";
    console.log("âš ï¸ manual key fallback");
  }

  const headers = { accept: "application/json", apiKey };

  // 4ï¸âƒ£ cluster list
  const listResp = await fetch(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { method: "GET", headers });
  if (listResp.status !== 200) throw new Error(`cluster list failed (${listResp.status})`);

  const raw = await listResp.json();
  const clusters = raw?.cohesityClusters || [];
  if (!clusters.length) {
    return { clusters: [], report: "No clusters", authMode };
  }

  // helper â†’ garbage
  async function getGarbage(clusterName, clusterId, h) {
    const safe = clusterName.replace(/\s+/g, "");
    const entityId = `${safe}+(ID+${clusterId})`;

    const url =
      `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
      `?schemaName=ApolloV2ClusterStats` +
      `&metricName=EstimatedGarbageBytes` +
      `&startTimeMsecs=2` +
      `&entityId=${encodeURIComponent(entityId)}` +
      `&rollupFunction=latest` +
      `&rollupIntervalSecs=30` +
      `&metricUnitType=0` +
      `&range=day`;

    const r = await fetch(url, { method: "GET", headers: h });
    if (r.status !== 200) return 0;

    const js = await r.json();
    const vec = js?.dataPointVec || [];
    const last = vec[vec.length - 1];
    return last?.data?.int64Value ?? 0;
  }

  const results = [];

  // 5ï¸âƒ£ per cluster stats
  await Promise.all(
    clusters.map(async ({
      clusterName,
      clusterId,
      currentVersion,
      location,
      numberOfNodes   // ðŸ‘ˆ NEW field extracted from Helios metadata
    }) => {

      const h = { ...headers, accessClusterId: String(clusterId) };

      // capacity
      const capUrl = `${baseUrl}/irisservices/api/v1/public/stats/storage`;
      const cap = await fetch(capUrl, { method: "GET", headers: h });
      if (cap.status !== 200) return;

      const s = await cap.json();
      const totalTiB = +(s.totalCapacityBytes / oneTiB).toFixed(2);
      const usedTiB  = +(s.localUsageBytes / oneTiB).toFixed(2);
      const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
      const percent  = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

      // garbage
      const bytes = await getGarbage(clusterName, clusterId, h);
      const garbageGB = +(bytes / (1024 ** 3)).toFixed(2);
      const garbageTB = +(bytes / (1024 ** 4)).toFixed(3);

      results.push({
        clusterName,
        location: location || "Unknown",
        version: currentVersion || "Unknown",
        numberOfNodes: numberOfNodes || 0,  // ðŸ‘ˆ included here
        totalTiB,
        usedTiB,
        availTiB,
        consumedPercent: percent,
        garbageGB,
        garbageTB
      });

      console.log(`âœ“ ${clusterName} | Nodes: ${numberOfNodes} | ${usedTiB}/${totalTiB} TiB`);
    })
  );

  // sort by name
  const rows = results.sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  const badge = (p) => (p >= 80 ? "ðŸ”´" : p > 70 ? "ðŸŸ¡" : "ðŸŸ¢");

  // 6ï¸âƒ£ markdown output
  const header = [
    "ðŸ“Š **Cohesity Cluster Capacity Report**",
    "",
    "| Cluster | Location | Version | Nodes | Used TiB | Avail TiB | % Used | Status | Garbage GB | Garbage TB |",
    "|---------|-----------|----------|-------:|----------:|-----------:|--------:|:-------:|------------:|-------------:|"
  ].join("\n");

  const body = rows
    .map(c =>
      `| ${c.clusterName} | ${c.location} | ${c.version} | ${c.numberOfNodes} | ${c.usedTiB} | ${c.availTiB} | ${c.consumedPercent}% | ${badge(c.consumedPercent)} | ${c.garbageGB} | ${c.garbageTB} |`
    )
    .join("\n");

  const footer = [
    "",
    `**_Total clusters in report: ${rows.length}_**`,
    "",
    "ðŸŸ¢ = Healthy (â‰¤ 70%)",
    "ðŸŸ¡ = Warning (70â€“79%)",
    "ðŸ”´ = Critical (â‰¥ 80%)",
    "",
    `ðŸ”‘ Auth mode used: **${authMode}**`
  ].join("\n");

  const report = [header, body, "", footer].join("\n");

  return { clusters: rows, report, authMode };
}
