// üöÄ Cohesity Helios ‚Äì Read-only capacity + garbage (Vault by Name‚ÜíID‚ÜíManual)
// ‚ùå No metrics ingest ‚Äì just collects and returns data.
import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl   = "https://helios.cohesity.com";
  const oneTiB    = 1099511627776;
  const vaultName = "Cohesity_API_Key";          // ‚úÖ working vault name
  const vaultId   = "credentials_vault-312312";  // optional fallback ID

  // ---------- Resolve Helios API key ----------
  async function getKeyFromVaultByName(name) {
    const list = await credentialVaultClient.getCredentials();
    const found = list.credentials.find(c => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return detail?.token || null;
  }

  let apiKey = null;
  let authMode = "vault-name";

  try {
    apiKey = await getKeyFromVaultByName(vaultName);
    if (!apiKey) throw new Error("not-found-by-name");
    console.log(`üîê Loaded Helios key from vault (by name): ${vaultName}`);
  } catch (e1) {
    try {
      const d = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = d?.token || null;
      authMode = "vault-id";
      console.log(`üîê Loaded Helios key from vault (by id): ${vaultId}`);
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";  // temporary manual key
      console.log("‚ö†Ô∏è Using manual Helios API key fallback.");
    }
  }

  const headers = { accept: "application/json", apiKey };

  // ---------- 1Ô∏è‚É£ Get cluster inventory ----------
  const listUrl  = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const listResp = await fetch(listUrl, { method: "GET", headers });
  if (listResp.status !== 200) {
    const body = await listResp.text().catch(() => "");
    throw new Error(`‚ùå Cluster list failed (HTTP ${listResp.status}) ${body}`);
  }

  const clusters = (await listResp.json())?.cohesityClusters || [];
  if (!clusters.length) {
    console.log("‚ö†Ô∏è No clusters returned from Helios.");
    return { clusters: [], authMode };
  }

  console.log(`üîç Found ${clusters.length} clusters. Collecting metrics...`);

  // ---------- Helper to read garbage metric ----------
  async function getGarbageLatest(clusterName, clusterId, h) {
    const safeName = clusterName.replace(/\s+/g, "");
    const entityId = `${safeName}+(ID+${clusterId})`; // proven format

    const tsUrl =
      `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
      `?schemaName=ApolloV2ClusterStats` +
      `&metricName=EstimatedGarbageBytes` +
      `&startTimeMsecs=2` +
      `&entityId=${encodeURIComponent(entityId)}` +
      `&rollupFunction=latest` +
      `&rollupIntervalSecs=30` +
      `&metricUnitType=0` +
      `&range=day`;

    const r = await fetch(tsUrl, { method: "GET", headers: h });
    if (r.status !== 200) {
      return { bytes: 0, ok: false, status: r.status, body: await r.text().catch(() => "") };
    }

    const j = await r.json();
    const vec = Array.isArray(j?.dataPointVec) ? j.dataPointVec : [];
    const latest = vec.length ? vec[vec.length - 1] : undefined;
    const bytes = latest?.data?.int64Value ?? 0;
    return { bytes, ok: true, status: 200 };
  }

  // ---------- 2Ô∏è‚É£ Collect per-cluster capacity + garbage ----------
  const results = [];

  await Promise.all(
    clusters.map(async ({ clusterName, clusterId }) => {
      const h = { ...headers, accessClusterId: String(clusterId) };

      // Capacity
      const capUrl  = `${baseUrl}/irisservices/api/v1/public/stats/storage`;
      const capResp = await fetch(capUrl, { method: "GET", headers: h });
      if (capResp.status !== 200) {
        const t = await capResp.text().catch(() => "");
        console.log(`‚ö†Ô∏è Capacity GET failed for ${clusterName} (HTTP ${capResp.status}) ${t}`);
        return;
      }

      const s = await capResp.json();
      const totalTiB = +(s.totalCapacityBytes  / oneTiB).toFixed(2);
      const usedTiB  = +(s.localUsageBytes     / oneTiB).toFixed(2);
      const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
      const consumedPercent = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

      // Garbage
      const g = await getGarbageLatest(clusterName, clusterId, h);
      if (!g.ok) {
        console.log(`‚ö†Ô∏è Garbage GET failed for ${clusterName} (HTTP ${g.status}) ${g.body || ""}`);
      }
      const garbageBytes = g.bytes || 0;
      const garbageGB = +(garbageBytes / (1024 ** 3)).toFixed(2);
      const garbageTB = +(garbageBytes / (1024 ** 4)).toFixed(3);

      results.push({
        clusterName,
        clusterId,
        totalTiB,
        usedTiB,
        availTiB,
        consumedPercent,
        garbageGB,
        garbageTB,
      });

      console.log(
        `‚úÖ ${clusterName}: ${usedTiB}/${totalTiB} TiB (${consumedPercent}%) | Garbage ${garbageGB} GB (${garbageTB} TB)`
      );
    })
  );

  // ---------- 3Ô∏è‚É£ Return summary (for email, table, or future metrics step) ----------
  return {
    authMode,       // vault-name | vault-id | manual
    clusters: results,
    clusterCount: results.length,
  };
}
