import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {

  const baseUrl = "https://helios.cohesity.com";
  const oneTiB = 1099511627776;
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const creds = await credentialVaultClient.getCredentials();
    const found = creds.credentials.find(x => x.name === name);
    if (!found) return null;
    const details = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return details?.token || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw "not-found";
    console.log(`✅ loaded key from vault (name): ${vaultName}`);
  } catch (e1) {
    try {
      const d = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = d?.token;
      authMode = "vault-id";
      console.log(`✅ loaded key from vault (id): ${vaultId}`);
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE"; // temp for testing
      console.log("⚠️ using manual api key");
    }
  }

  const headers = { accept: "application/json", apiKey };

  // get cluster list
  const listUrl = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const listResp = await fetch(listUrl, { method: "GET", headers });
  if (listResp.status !== 200) {
    const text = await listResp.text().catch(() => "");
    throw new Error(`cluster list failed (${listResp.status}) ${text}`);
  }

  const clusters = (await listResp.json())?.cohesityClusters || [];
  if (!clusters.length) {
    console.log("no clusters found.");
    return { clusters: [], authMode };
  }

  console.log(`found ${clusters.length} clusters...`);

  async function getGarbage(clusterName, clusterId, h) {
    const safe = clusterName.replace(/\s+/g, "");
    const entityId = `${safe}+(ID+${clusterId})`;
    const url =
      `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
      `?schemaName=ApolloV2ClusterStats` +
      `&metricName=EstimatedGarbageBytes` +
      `&startTimeMsecs=2` +
      `&entityId=${encodeURIComponent(entityId)}` +
      `&rollupFunction=latest` +
      `&rollupIntervalSecs=30` +
      `&metricUnitType=0` +
      `&range=day`;

    const resp = await fetch(url, { method: "GET", headers: h });
    if (resp.status !== 200) {
      return { ok: false, status: resp.status, bytes: 0 };
    }
    const js = await resp.json();
    const vec = js?.dataPointVec || [];
    const last = vec[vec.length - 1];
    const bytes = last?.data?.int64Value ?? 0;
    return { ok: true, bytes };
  }

  const results = [];

  await Promise.all(clusters.map(async ({ clusterName, clusterId }) => {
    const h = { ...headers, accessClusterId: String(clusterId) };

    const capUrl = `${baseUrl}/irisservices/api/v1/public/stats/storage`;
    const capResp = await fetch(capUrl, { method: "GET", headers: h });
    if (capResp.status !== 200) {
      console.log(`capacity failed for ${clusterName} (${capResp.status})`);
      return;
    }
    const s = await capResp.json();
    const totalTiB = +(s.totalCapacityBytes / oneTiB).toFixed(2);
    const usedTiB = +(s.localUsageBytes / oneTiB).toFixed(2);
    const availTiB = +(s.localAvailableBytes / oneTiB).toFixed(2);
    const percent = +((s.localUsageBytes / s.totalCapacityBytes) * 100).toFixed(2);

    const g = await getGarbage(clusterName, clusterId, h);
    const garbageGB = +(g.bytes / (1024 ** 3)).toFixed(2);
    const garbageTB = +(g.bytes / (1024 ** 4)).toFixed(3);

    results.push({
      clusterName,
      clusterId,
      totalTiB,
      usedTiB,
      availTiB,
      consumedPercent: percent,
      garbageGB,
      garbageTB
    });

    console.log(`✅ ${clusterName}: ${usedTiB}/${totalTiB} TiB (${percent}%) | Garbage ${garbageGB} GB (${garbageTB} TB)`);
  }));

  console.log(`finished, got ${results.length} valid clusters`);

  return { authMode, clusters: results, count: results.length };
}
