# -------------------------------------------------------------
# Cohesity Helios - Cluster Interface Status (Picture Script + CSV fixed for Excel)
# -------------------------------------------------------------
# Fixes for CSV/Excel:
#  - NodeID exported as TEXT (prevents Excel scientific notation / precision loss)
#  - BondName / MTU and all array-like fields exported as strings (prevents System.Object[])
#  - Per-cluster summary is COMMENTED OUT using <# #>
# -------------------------------------------------------------

$ErrorActionPreference = "Stop"

# ==============================
# 0) API key from your path
# ==============================
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }

$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()
$commonHeaders = @{ "apiKey" = $apiKey }

# -------------------------------------------------------------
# Helpers for CSV/Excel only
# -------------------------------------------------------------

# Converts arrays -> "blue style" strings for CSV, avoiding System.Object[]
function To-CsvList {
    param([object]$v)

    if ($null -eq $v) { return "" }

    # scalar
    if ($v -isnot [System.Array]) { return "$v" }

    $arr = @($v | ForEach-Object { "$_" } | Where-Object { $_ -ne "" })
    if ($arr.Count -eq 0) { return "" }
    if ($arr.Count -eq 1) { return $arr[0] }

    # If all values are identical (common for MTU), collapse to single
    $uniq = @($arr | Select-Object -Unique)
    if ($uniq.Count -eq 1) { return $uniq[0] }

    return "{" + ($arr -join ",") + "}"
}

# Forces Excel to treat values as TEXT when opening the CSV
# (Excel hides the apostrophe but preserves the exact value)
function To-ExcelText {
    param([object]$v)

    if ($null -eq $v) { return "" }

    $s = "$v"
    if ([string]::IsNullOrWhiteSpace($s)) { return "" }

    # long numeric (NodeIDs)
    if ($s -match '^\d{11,}$') { return "'" + $s }

    return $s
}

# ==========================================
# 1) Get Clusters (ClusterName + ClusterId)
# ==========================================
$url      = "https://helios.cohesity.com/v2/mcm/cluster-mgmt/info"
$response = Invoke-WebRequest -Method Get -Uri $url -Headers $commonHeaders
$json_clu = $response.Content | ConvertFrom-Json
$json_clu = $json_clu.cohesityClusters

if (-not $json_clu -or $json_clu.Count -eq 0) {
    throw "No clusters returned from Helios."
}

$AllRows = @()

# ==========================================
# 2) For each cluster, call interface API
# ==========================================
foreach ($clus in $json_clu) {
    $cluster_name = $clus.clusterName
    $cluster_id   = $clus.clusterId

    $url = "https://helios.cohesity.com/irisservices/api/v1/public/interface"
    $headers = @{ "apiKey" = $apiKey; "accessClusterId" = $cluster_id }

    # NOTE: Keeping your picture-style approach (GET + Body) as-is
    $body = @{
        #nodeId = "966064711420"
        bondInterfaceOnly       = "true"
        ifaceGroupAssignedOnly  = "true"
        includeUplinkSwitchInfo = "true"
        includeBondSlaveDetails = "true"
        #includeStats            = "true"
    }

    try {
        $response = Invoke-WebRequest -Method Get -Uri $url -Headers $headers -Body $body
        $json     = $response.Content | ConvertFrom-Json
    }
    catch {
        Write-Host "Failed to get interface data for cluster '$cluster_name' (Id: $cluster_id): $_" -ForegroundColor Red
        continue
    }

    if (-not $json) {
        Write-Host "No interface data returned for cluster '$cluster_name' (Id: $cluster_id)." -ForegroundColor Yellow
        continue
    }

    foreach ($node in $json) {
        $AllRows += [PSCustomObject]@{
            Cluster              = $cluster_name
            NodeID               = $node.nodeId
            NodeIP               = $node.nodeIp
            ChassisSerial        = $node.chassisSerial
            BondName             = $node.interfaces.name
            MTU                  = $node.interfaces.mtu
            BondSlaves           = $node.interfaces.bondSlaves
            SlaveInterfaceStatus = $node.interfaces.bondSlavesDetails.linkState
            mac                  = $node.interfaces.bondSlavesDetails.macAddr
            SlaveSpeed           = $node.interfaces.bondSlavesDetails.speed
            SlotType             = $node.interfaces.bondSlavesSlotTypes
        }
    }
}

if (-not $AllRows -or $AllRows.Count -eq 0) {
    Write-Host "No rows collected from interface API." -ForegroundColor Yellow
    return
}

# =======================
# 3) Print Table (full details - console)
# =======================
$AllRows | Sort-Object Cluster, NodeID, NodeIP, ChassisSerial | Format-Table -AutoSize

# =======================
# 4) Export SAME details to CSV (Excel-safe)
# =======================
$reportdate = Get-Date -Format "yyyy-MM-dd_HHmm"

$csvDir = "X:\PowerShell\Data\Cohesity\Alerts"
if (-not (Test-Path $csvDir)) { New-Item -ItemType Directory -Path $csvDir | Out-Null }

$excelFile = Join-Path $csvDir "All_Cluster_Interface_Status_$reportdate.csv"

# Convert ALL array-like columns to strings so CSV never shows System.Object[]
# Force NodeID to text so Excel doesn't ruin it
$csvRows = $AllRows | Select-Object `
    Cluster,
    @{n="NodeID"; e={ To-ExcelText $_.NodeID }}, `
    NodeIP,
    ChassisSerial,
    @{n="BondName"; e={ To-CsvList $_.BondName }}, `
    @{n="MTU"; e={ To-CsvList $_.MTU }}, `
    @{n="BondSlaves"; e={ To-CsvList $_.BondSlaves }}, `
    @{n="SlaveInterfaceStatus"; e={ To-CsvList $_.SlaveInterfaceStatus }}, `
    @{n="mac"; e={ To-CsvList $_.mac }}, `
    @{n="SlaveSpeed"; e={ To-CsvList $_.SlaveSpeed }}, `
    @{n="SlotType"; e={ To-CsvList $_.SlotType }}

$csvRows |
    Sort-Object Cluster, NodeID |
    Export-Csv -Path $excelFile -NoTypeInformation -Encoding UTF8

Write-Host "Saved CSV report at: $excelFile" -ForegroundColor Green

# =======================
# 5) Per-cluster summary (COMMENTED OUT for now)
# =======================
<#
if ($AllRows.Count -gt 0) {
    Write-Host "`nSummary (per cluster):" -ForegroundColor Green
    Write-Host "---------------------" -ForegroundColor Green

    $byCluster = $AllRows | Group-Object Cluster | Sort-Object Name

    foreach ($grp in $byCluster) {
        $CName    = $grp.Name
        $downList = @()

        for ($i = 0; $i -lt $grp.Group.Count; $i++) {
            $slaves = $grp.Group[$i].BondSlaves
            $states = $grp.Group[$i].SlaveInterfaceStatus

            for ($j = 0; $j -lt $slaves.Count; $j++) {
                if ($states[$j] -match 'down|error|disabled|unknown') {
                    $downList += $slaves[$j]
                }
            }
        }

        $ifaceCount = ($grp.Group.BondSlaves | ForEach-Object { $_ }).Count

        Write-Host "Cluster: $CName" -ForegroundColor Cyan
        Write-Host " Total Interfaces : $ifaceCount"

        if ($downList.Count -eq 0) {
            Write-Host " Status           : Everything is up" -ForegroundColor Green
        }
        else {
            $downCsv = ($downList | Select-Object -Unique) -join ", "
            Write-Host " Status           : Down interfaces detected" -ForegroundColor Red
            Write-Host " Interfaces down  : $downCsv" -ForegroundColor Yellow
        }

        Write-Host "------------------------------------------"
    }
}
#>
