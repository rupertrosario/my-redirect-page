// Cohesity Helios â€“ Protected Objects Trend Heatmap (Oracle only, All Clusters)
//
// - GET-only
// - Uses Dynatrace classic credential vault (name -> id -> manual fallback)
// - For every Helios cluster:
//     - Fetch /irisservices/api/v1/public/reports/protectedObjectsTrends
//       with:
//         startTimeUsecs, endTimeUsecs (microseconds)
//         timezone=America/New_York   (IANA TZ)
//         rollup=day
//         environments[0]=kOracle
// - Builds Markdown heatmap:
//     * Rows  = Cluster / DBName (parentSourceName)
//     * Cols  = trendName (dates)
//     * Cell  = "succ/total" + colored emoji bar:
//           ðŸŸ© success, ðŸŸ¥ failed, ðŸŸ¨ running, â¬› cancelled
//
// - Output:
//   {
//     authMode: "vault-name" | "vault-id" | "manual",
//     clusterCount: <number>,
//     objectCount: <number>,
//     heatmapMarkdown: "<markdown DB Ã— Date heatmap>",
//     rows: [ { clusterName, id, name, parentSourceName, trends: [...] } ]
//   }

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // -------- CONFIG --------
  const DAYS      = 7;                  // lookback window for trends
  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  const REPORT_TIMEZONE = "America/New_York"; // IANA TZ (matches your curl)
  const MAX_BLOCKS      = 6;                  // max emoji blocks per cell

  // -------- 1) Credential vault: name -> id -> manual --------
  let apiKey   = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find((c) => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("âœ“ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey       = (detail && (detail.token || detail.password)) || null;
      authMode     = "vault-id";
      console.log(
        "âœ“ Helios key from vault (id): " +
        (detail && detail.name ? detail.name : vaultId)
      );
    } catch (e2) {
      authMode = "manual";
      apiKey   = "PASTE_YOUR_API_KEY_HERE"; // last-resort; still GET-only
      console.log("âš ï¸ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) {
    throw new Error("No Helios API key available (vault + manual failed).");
  }

  const commonHeaders = {
    accept: "application/json",
    apiKey: apiKey
  };

  // -------- 2) Helpers --------

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function safeNum(x) {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  }

  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      const v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) {
        v.forEach((val) => usp.append(k, String(val)));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  // -------- 3) Time range in microseconds --------

  const endMs   = Date.now();
  const startMs = endMs - DAYS * 24 * 60 * 60 * 1000;

  const startUsecs = startMs * 1000;
  const endUsecs   = endMs * 1000;

  const startDateStr = new Date(startMs).toISOString().slice(0, 10); // yyyy-MM-dd
  const endDateStr   = new Date(endMs).toISOString().slice(0, 10);

  // -------- 4) Per-cluster collector: protectedObjectsTrends --------

  async function collectClusterProtectedObjects(cluster) {
    const clusterName =
      cluster.name ||
      cluster.clusterName ||
      cluster.displayName ||
      ("Unknown-" + cluster.clusterId);

    const headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: String(cluster.clusterId)
    };

    // This matches your curl:
    //   -d 'timezone=America%2FNew_York'
    //   -d 'environments[0]=kOracle'
    //   -d 'rollup=day'
    const trendQuery = buildQuery({
      startTimeUsecs:  startUsecs,
      endTimeUsecs:    endUsecs,
      timezone:        REPORT_TIMEZONE,
      rollup:          "day",
      "environments[0]": "kOracle"
    });

    const url = `${baseUrl}/irisservices/api/v1/public/reports/protectedObjectsTrends?${trendQuery}`;

    let data;
    try {
      data = await getJson(url, headers);
    } catch (e) {
      console.log(`âš ï¸ protectedObjectsTrends failed for cluster ${clusterName}: ${e.message}`);
      return [];
    }

    // Sometimes APIs return bare array, sometimes { protectedObjects: [...] }
    const objects = Array.isArray(data)
      ? data
      : (data && (data.protectedObjects || data.objects || [])) || [];

    if (!objects.length) {
      return [];
    }

    // Enrich with cluster name; keep only fields we need.
    return objects.map((obj) => ({
      clusterName:      clusterName,
      id:               obj.id,
      name:             obj.name,
      parentSourceName: obj.parentSourceName,
      trends:           obj.trends || []
    }));
  }

  // -------- 5) Get all clusters & aggregate --------

  const clusterInfo = await getJson(
    `${baseUrl}/v2/mcm/cluster-mgmt/info`,
    commonHeaders
  );

  const clusters = (clusterInfo && clusterInfo.cohesityClusters) || [];
  if (!clusters.length) {
    return {
      authMode,
      clusterCount: 0,
      objectCount: 0,
      heatmapMarkdown: "No Helios clusters found.",
      rows: []
    };
  }

  const allObjects = [];
  for (const cluster of clusters) {
    const objs = await collectClusterProtectedObjects(cluster);
    if (objs && objs.length) {
      allObjects.push(...objs);
    }
  }

  if (!allObjects.length) {
    return {
      authMode,
      clusterCount: clusters.length,
      objectCount: 0,
      heatmapMarkdown: "No protected object trends returned for any Helios cluster (Oracle filter).",
      rows: []
    };
  }

  // -------- 6) Build Markdown heatmap (DB Ã— Date) --------

  function buildHeatmapMarkdown(objects, days, maxBlocks) {
    if (!Array.isArray(objects) || !objects.length) {
      return "_No protected objects returned._";
    }

    // 6.1 All distinct dates (trendName)
    const dateSet = new Set();
    for (const obj of objects) {
      if (!obj.trends) continue;
      for (const t of obj.trends) {
        if (t && t.trendName) dateSet.add(t.trendName);
      }
    }
    const dates = Array.from(dateSet).sort();
    if (!dates.length) {
      return "_No trend data in selected range._";
    }

    // 6.2 Sort: cluster -> name -> parentSourceName
    const rows = [...objects].sort((a, b) => {
      const ca = (a.clusterName || "").toLowerCase();
      const cb = (b.clusterName || "").toLowerCase();
      if (ca < cb) return -1;
      if (ca > cb) return 1;

      const na = (a.name || "").toLowerCase();
      const nb = (b.name || "").toLowerCase();
      if (na < nb) return -1;
      if (na > nb) return 1;

      const sa = (a.parentSourceName || "").toLowerCase();
      const sb = (b.parentSourceName || "").toLowerCase();
      if (sa < sb) return -1;
      if (sa > sb) return 1;

      return 0;
    });

    // Helper: find trend for a given date
    function findTrendForDate(obj, date) {
      if (!obj.trends) return null;
      return obj.trends.find((t) => t.trendName === date) || null;
    }

    // Helper: build emoji bar
    function buildEmojiBar(trend) {
      const succ    = safeNum(trend.successful);
      const fail    = safeNum(trend.failed);
      const running = safeNum(trend.running);
      const cancel  = safeNum(trend.cancelled);

      let remaining = maxBlocks;
      let bar = "";

      // ðŸŸ© successes
      const succBlocks = Math.min(succ, remaining);
      bar += "ðŸŸ©".repeat(succBlocks);
      remaining -= succBlocks;

      // ðŸŸ¥ failures
      if (remaining > 0) {
        const failBlocks = Math.min(fail, remaining);
        bar += "ðŸŸ¥".repeat(failBlocks);
        remaining -= failBlocks;
      }

      // ðŸŸ¨ running
      if (remaining > 0) {
        const runBlocks = Math.min(running, remaining);
        bar += "ðŸŸ¨".repeat(runBlocks);
        remaining -= runBlocks;
      }

      // â¬› cancelled
      if (remaining > 0) {
        const canBlocks = Math.min(cancel, remaining);
        bar += "â¬›".repeat(canBlocks);
        remaining -= canBlocks;
      }

      return bar;
    }

    // 6.3 Build markdown header + legend
    let md = "";

    md += `ðŸ“… ${days}-day trend window: ${startDateStr} â†’ ${endDateStr}\n\n`;
    md += "**Legend:** ðŸŸ© success, ðŸŸ¥ failed, ðŸŸ¨ running, â¬› cancelled\n\n";

    // Header row
    md += "| Cluster / Object |";
    for (const d of dates) {
      md += " " + d + " |";
    }
    md += "\n";

    // Separator row
    md += "|------------------|";
    for (let i = 0; i < dates.length; i++) {
      md += "-----------|";
    }
    md += "\n";

    // 6.4 Data rows
    for (const obj of rows) {
      const dbLabel = `${obj.clusterName || "?"} / ${obj.name || "?"} (${obj.parentSourceName || "?"})`;
      md += `| ${dbLabel} |`;

      for (const d of dates) {
        const trend = findTrendForDate(obj, d);
        if (!trend) {
          md += " - |";
          continue;
        }

        const succ  = safeNum(trend.successful);
        const total = safeNum(trend.total);

        if (total <= 0) {
          md += " 0/0 - |";
          continue;
        }

        const bar = buildEmojiBar(trend);
        const cellText = `${succ}/${total} ${bar}`;

        md += " " + cellText + " |";
      }

      md += "\n";
    }

    return md;
  }

  const heatmapMarkdown = buildHeatmapMarkdown(allObjects, DAYS, MAX_BLOCKS);

  // -------- 7) Final result --------

  return {
    authMode,
    clusterCount: clusters.length,
    objectCount: allObjects.length,
    heatmapMarkdown,
    rows: allObjects
  };
}
