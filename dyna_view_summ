// Cohesity Helios â€“ Protected Objects Trend Heatmap (Markdown, All Clusters)
//
// - GET-only
// - Uses Dynatrace classic credential vault (name -> id -> manual fallback)
// - For every Helios cluster:
//     - Fetch /public/reports/protectedobjectsTrends (kDaily rollup)
//     - Expect objects like:
//           {
//             id: ...,
//             name: "DBName",
//             parentSourceName: "ServerName",
//             trends: [
//               {
//                 trendName: "2025-12-06",
//                 total: 7,
//                 successful: 6,
//                 failed: 1,
//                 running: 0,
//                 cancelled: 0
//               },
//               ...
//             ]
//           }
// - Build Markdown heatmap:
//     * Rows  = DB (Server) per cluster
//     * Cols  = trendName (dates)
//     * Cell  = "succ/total" + colored emoji bar:
//           ðŸŸ© success, ðŸŸ¥ failed, ðŸŸ¨ running, â¬› cancelled
//
// - Output:
//   {
//     authMode: "vault-name" | "vault-id" | "manual",
//     clusterCount: <number>,
//     objectCount: <number>,   // number of protected objects across clusters
//     heatmapMarkdown: "<markdown DB Ã— Date table>",
//     rows: [ { ... raw per-object row from API, with clusterName added ... } ]
//   }

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // -------- CONFIG --------
  const DAYS      = 7;  // lookback window for trends
  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  // Timezone for Helios reports (IANA)
  const REPORT_TIMEZONE = "America/New_York";

  // Max number of emoji blocks per cell in heatmap bar
  const MAX_BLOCKS = 6;

  // -------- 1) Credential vault: name -> id -> manual --------
  let apiKey   = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find((c) => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("âœ“ Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey       = (detail && (detail.token || detail.password)) || null;
      authMode     = "vault-id";
      console.log(
        "âœ“ Helios key from vault (id): " +
          (detail && detail.name ? detail.name : vaultId)
      );
    } catch (e2) {
      authMode = "manual";
      apiKey   = "PASTE_YOUR_API_KEY_HERE"; // last resort; still GET-only
      console.log("âš ï¸ Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) {
    throw new Error("No Helios API key available (vault + manual failed).");
  }

  const commonHeaders = {
    accept: "application/json",
    apiKey: apiKey
  };

  // -------- 2) Helpers --------

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function safeNum(x) {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  }

  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      const v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) {
        v.forEach((val) => usp.append(k, String(val)));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  // -------- 3) Time range in microseconds --------

  const endMs   = Date.now();
  const startMs = endMs - DAYS * 24 * 60 * 60 * 1000;

  const startUsecs = startMs * 1000;
  const endUsecs   = endMs * 1000;

  const startDateStr = new Date(startMs).toISOString().slice(0, 10); // yyyy-MM-dd
  const endDateStr   = new Date(endMs).toISOString().slice(0, 10);

  const tzEncoded = encodeURIComponent(REPORT_TIMEZONE);

  // -------- 4) Per-cluster collector: protectedobjectsTrends --------

  async function collectClusterProtectedObjects(cluster) {
    const clusterName =
      cluster.name ||
      cluster.clusterName ||
      cluster.displayName ||
      ("Unknown-" + cluster.clusterId);

    const headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: String(cluster.clusterId)
    };

    const trendQuery = buildQuery({
      startTimeUsecs: startUsecs,
      endTimeUsecs:   endUsecs,
      timezone:       REPORT_TIMEZONE, // server expects IANA; encoded separately if needed
      rollup:         "kDaily"
    });

    const url = `${baseUrl}/irisservices/api/v1/public/reports/protectedobjectsTrends?${trendQuery}`;

    let data;
    try {
      data = await getJson(url, headers);
    } catch (e) {
      console.log(`âš ï¸ Failed protectedobjectsTrends for cluster ${clusterName}: ${e.message}`);
      return [];
    }

    // Some Helios APIs embed lists; others return bare arrays.
    // User already said "protectedObjects is not there", just array of objects.
    const objects = Array.isArray(data)
      ? data
      : (data && (data.protectedObjects || data.objects || [])) || [];

    if (!objects.length) {
      return [];
    }

    // Add clusterName to each row for later grouping/labeling
    const enriched = objects.map((obj) => ({
      clusterName: clusterName,
      id:          obj.id,
      name:        obj.name,
      parentSourceName: obj.parentSourceName,
      trends:      obj.trends || []
    }));

    return enriched;
  }

  // -------- 5) Get all clusters & aggregate --------

  const clusterInfo = await getJson(
    `${baseUrl}/v2/mcm/cluster-mgmt/info`,
    commonHeaders
  );

  const clusters = (clusterInfo && clusterInfo.cohesityClusters) || [];
  if (!clusters.length) {
    return {
      authMode,
      clusterCount: 0,
      objectCount: 0,
      heatmapMarkdown: "No Helios clusters found.",
      rows: []
    };
  }

  const allObjects = [];
  for (const cluster of clusters) {
    const objs = await collectClusterProtectedObjects(cluster);
    if (objs && objs.length) {
      allObjects.push(...objs);
    }
  }

  if (!allObjects.length) {
    return {
      authMode,
      clusterCount: clusters.length,
      objectCount: 0,
      heatmapMarkdown: "No protected object trends returned for any Helios cluster.",
      rows: []
    };
  }

  // -------- 6) Build Markdown heatmap (DB Ã— Date) --------

  function buildHeatmapMarkdown(objects, days, maxBlocks) {
    if (!Array.isArray(objects) || !objects.length) {
      return "_No protected objects returned._";
    }

    // 6.1 Collect all distinct dates (trendName)
    const dateSet = new Set();
    for (const obj of objects) {
      if (!obj.trends) continue;
      for (const t of obj.trends) {
        if (t && t.trendName) dateSet.add(t.trendName);
      }
    }
    const dates = Array.from(dateSet).sort();
    if (!dates.length) {
      return "_No trend data in selected range._";
    }

    // 6.2 Sort objects by cluster, then DB name, then parentSourceName
    const rows = [...objects].sort((a, b) => {
      const ca = (a.clusterName || "").toLowerCase();
      const cb = (b.clusterName || "").toLowerCase();
      if (ca < cb) return -1;
      if (ca > cb) return 1;

      const na = (a.name || "").toLowerCase();
      const nb = (b.name || "").toLowerCase();
      if (na < nb) return -1;
      if (na > nb) return 1;

      const sa = (a.parentSourceName || "").toLowerCase();
      const sb = (b.parentSourceName || "").toLowerCase();
      if (sa < sb) return -1;
      if (sa > sb) return 1;

      return 0;
    });

    // Helper: locate trend for specific date
    function findTrendForDate(obj, date) {
      if (!obj.trends) return null;
      return obj.trends.find((t) => t.trendName === date) || null;
    }

    // Helper: build emoji bar from trend breakdown
    function buildEmojiBar(trend) {
      const succ    = safeNum(trend.successful);
      const fail    = safeNum(trend.failed);
      const running = safeNum(trend.running);
      const cancel  = safeNum(trend.cancelled);

      let remaining = maxBlocks;
      let bar = "";

      // ðŸŸ© successes
      const succBlocks = Math.min(succ, remaining);
      bar += "ðŸŸ©".repeat(succBlocks);
      remaining -= succBlocks;

      // ðŸŸ¥ failures
      if (remaining > 0) {
        const failBlocks = Math.min(fail, remaining);
        bar += "ðŸŸ¥".repeat(failBlocks);
        remaining -= failBlocks;
      }

      // ðŸŸ¨ running
      if (remaining > 0) {
        const runBlocks = Math.min(running, remaining);
        bar += "ðŸŸ¨".repeat(runBlocks);
        remaining -= runBlocks;
      }

      // â¬› cancelled
      if (remaining > 0) {
        const canBlocks = Math.min(cancel, remaining);
        bar += "â¬›".repeat(canBlocks);
        remaining -= canBlocks;
      }

      return bar;
    }

    // 6.3 Build markdown header + legend
    let md = "";

    md += `ðŸ“… ${days}-day trend window: ${startDateStr} â†’ ${endDateStr}\n\n`;
    md += "**Legend:** ðŸŸ© success, ðŸŸ¥ failed, ðŸŸ¨ running, â¬› cancelled\n\n";

    // Header row
    md += "| Cluster / Object |";
    for (const d of dates) {
      md += " " + d + " |";
    }
    md += "\n";

    // Separator row
    md += "|------------------|";
    for (let i = 0; i < dates.length; i++) {
      md += "-----------|";
    }
    md += "\n";

    // 6.4 Data rows
    for (const obj of rows) {
      const dbLabel = `${obj.clusterName || "?"} / ${obj.name || "?"} (${obj.parentSourceName || "?"})`;
      md += `| ${dbLabel} |`;

      for (const d of dates) {
        const trend = findTrendForDate(obj, d);
        if (!trend) {
          md += " - |";
          continue;
        }

        const succ  = safeNum(trend.successful);
        const total = safeNum(trend.total);

        if (total <= 0) {
          md += " 0/0 - |";
          continue;
        }

        const bar = buildEmojiBar(trend);
        const cellText = `${succ}/${total} ${bar}`;

        md += " " + cellText + " |";
      }

      md += "\n";
    }

    return md;
  }

  const heatmapMarkdown = buildHeatmapMarkdown(allObjects, DAYS, MAX_BLOCKS);

  // -------- 7) Final result --------

  return {
    authMode,
    clusterCount: clusters.length,
    objectCount: allObjects.length,
    heatmapMarkdown,
    rows: allObjects
  };
}
