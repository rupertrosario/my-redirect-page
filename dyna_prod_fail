// ================================
// Script 2 (Run JavaScript #2)
// Cohesity Helios – Backup Failures (Latest Uncleared Only, Object-level)
// FILTER: PROD only + Policy retention >= 5 weeks (>=35 days)
// Partition: 1 (even split by cluster hash)
// GET-only | 502/429 safe
//
// Merges Script-1 failures via result("run_javascript_1")
// FINAL RETURN SHAPE (your picture):
// { authMode, count, failures, incidentText_create, incidentText_update, markdownTable, markdownEmail }
// ================================

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";
import { result } from "@dynatrace-sdk/automation-utils";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ======================
  // Split control (EVEN)
  // ======================
  const PART_ID = 1;

  // ======================
  // Tunables
  // ======================
  const NUM_RUNS_OBJECT = 7;
  const MIN_RETENTION_DAYS = 35; // 5 weeks+
  const MAX_ROWS_TOTAL = 6000;
  const CLUSTER_CONCURRENCY = 2;
  const PG_CONCURRENCY = 4;

  // Script-1 output
  const p1 = await result("run_javascript_1");
  const p1Failures = (p1 && Array.isArray(p1.failures)) ? p1.failures : [];
  const p1AuthMode = (p1 && p1.authMode) ? p1.authMode : null;

  // ======================
  // AUTH (READ-ONLY)
  // ======================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find((c) => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (detail && (detail.token || detail.password)) || null;
      authMode = "vault-id";
    } catch {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }
  if (!apiKey) throw new Error("No Helios API key available (vault + manual failed).");
  if (p1AuthMode) authMode = p1AuthMode;

  // ======================
  // Helpers (same as Script-1)
  // ======================
  function buildQuery(params) {
    const usp = new URLSearchParams();
    Object.keys(params || {}).forEach((k) => {
      const v = params[k];
      if (v === undefined || v === null) return;
      if (Array.isArray(v)) v.forEach((x) => usp.append(k, String(x)));
      else usp.append(k, String(v));
    });
    return usp.toString();
  }

  function usecsToET(usecs) {
    if (!usecs) return null;
    const ms = Number(usecs) / 1000;
    if (!Number.isFinite(ms)) return null;
    return new Date(ms).toLocaleString("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    });
  }

  function cleanMessage(msg) {
    if (msg == null) return "";
    if (Array.isArray(msg)) msg = msg.join(" | ");
    msg = String(msg);
    return msg.replace(/[\r\n]+/g, " ").replace(/,/g, " ").replace(/"/g, "'").trim();
  }

  function combineFailedAttempts(failedAttempts) {
    if (!failedAttempts || !failedAttempts.length) return "";
    const parts = [];
    for (let i = 0; i < failedAttempts.length; i++) {
      const p = cleanMessage(failedAttempts[i] && failedAttempts[i].message);
      if (p) parts.push(p);
    }
    return parts.join(" | ").trim();
  }

  function toInfoArray(localBackupInfo) {
    if (!localBackupInfo) return [];
    return Array.isArray(localBackupInfo) ? localBackupInfo : [localBackupInfo];
  }

  function isSuccessStatus(status) {
    return status === "Succeeded" || status === "SucceededWithWarning";
  }

  function getObjKey(ob) {
    if (!ob || !ob.object) return null;
    if (ob.object.id != null) return String(ob.object.id);
    const sid = (ob.object.sourceId != null) ? String(ob.object.sourceId) : "";
    return `${ob.object.environment || ""}|${ob.object.objectType || ""}|${ob.object.name || ""}|${sid}`;
  }

  function hasFailedAttempts(ob) {
    const lsi = ob && ob.localSnapshotInfo;
    const fa = lsi && lsi.failedAttempts;
    return !!(fa && fa.length);
  }

  function isSuccessForClear(ob) {
    if (!ob || !ob.localSnapshotInfo) return false;
    return !hasFailedAttempts(ob);
  }

  function findHostNameInRun(objects, sourceId) {
    if (!sourceId || !objects || !objects.length) return null;
    const sid = String(sourceId);
    for (let i = 0; i < objects.length; i++) {
      const o = objects[i] && objects[i].object ? objects[i].object : null;
      if (!o || o.id == null) continue;
      if (String(o.id) === sid) return o.name || null;
    }
    return null;
  }

  function part(clusterName) {
    const s = String(clusterName || "");
    let sum = 0;
    for (let i = 0; i < s.length; i++) sum = (sum + s.charCodeAt(i)) % 2;
    return sum;
  }

  function isProdText(s) {
    const t = String(s || "");
    if (!t) return false;
    if (/\b(dev|test|uat|qa|nonprod|non-prod|dr)\b/i.test(t)) return false;
    return /\bprod\b/i.test(t);
  }

  function isProdPg(pg, policy) {
    if (isProdText(pg?.name)) return true;
    if (isProdText(pg?.description)) return true;
    if (isProdText(policy?.name)) return true;
    if (isProdText(policy?.description)) return true;
    return false;
  }

  function pickPolicyIds(pg) {
    const ids = [];
    if (pg?.policyId != null) ids.push(String(pg.policyId));
    if (pg?.policyIds && Array.isArray(pg.policyIds)) pg.policyIds.forEach((x) => ids.push(String(x)));
    if (pg?.policyIds && typeof pg.policyIds === "object" && !Array.isArray(pg.policyIds)) {
      Object.values(pg.policyIds).forEach((x) => ids.push(String(x)));
    }
    if (pg?.policies && Array.isArray(pg.policies)) {
      pg.policies.forEach((p) => {
        if (p?.id != null) ids.push(String(p.id));
        if (p?.policyId != null) ids.push(String(p.policyId));
      });
    }
    return Array.from(new Set(ids.filter(Boolean)));
  }

  function daysFromUnitValue(unit, value) {
    const v = Number(value);
    if (!Number.isFinite(v)) return null;
    const u = String(unit || "").toLowerCase();
    if (u.includes("day")) return v;
    if (u.includes("week")) return v * 7;
    if (u.includes("month")) return v * 30;
    if (u.includes("year")) return v * 365;
    if (u.includes("hour")) return v / 24;
    return null;
  }

  function retentionDaysFromPolicy(p) {
    if (!p) return null;

    const directDays =
      p.retentionDays ??
      p.daysToKeep ??
      p.daysToRetain ??
      p?.snapshotRetentionDays ??
      p?.backupRetentionDays ??
      null;

    if (directDays != null && Number.isFinite(Number(directDays))) return Number(directDays);

    const uvCandidates = [
      p?.retention,
      p?.retentionPolicy,
      p?.backupRetention,
      p?.snapshotRetention,
      p?.snapshotRetentionPolicy,
      p?.snapshotSettings?.retention,
      p?.snapshotSettings?.retentionPolicy,
      p?.incremental?.retention,
      p?.full?.retention
    ];

    for (let i = 0; i < uvCandidates.length; i++) {
      const x = uvCandidates[i];
      if (!x) continue;

      const d1 = daysFromUnitValue(x.unit, x.value ?? x.count ?? x.num ?? x.duration);
      if (d1 != null) return d1;

      const d2 = daysFromUnitValue(x.timeUnit, x.timePeriod ?? x.period ?? x.value);
      if (d2 != null) return d2;
    }

    const d3 = daysFromUnitValue(p.retentionUnit, p.retentionPeriod);
    if (d3 != null) return d3;

    const secs = p.retentionPeriodSecs ?? p.retentionSecs ?? null;
    if (secs != null && Number.isFinite(Number(secs))) return Number(secs) / 86400;

    return null;
  }

  async function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
  }

  async function getJson(url, headers, attempt = 0) {
    const resp = await fetch(url, { method: "GET", headers });
    if (resp.ok) return resp.json();

    const status = resp.status;
    let txt = "";
    try { txt = await resp.text(); } catch {}

    if ((status === 429 || status === 502 || status === 503 || status === 504) && attempt < 2) {
      await sleep(250 * (attempt + 1));
      return getJson(url, headers, attempt + 1);
    }
    throw new Error(`GET ${url} -> HTTP ${status} ${txt}`);
  }

  async function mapLimit(items, limit, fn) {
    const out = [];
    let idx = 0;
    const workers = new Array(Math.min(limit, items.length)).fill(0).map(async () => {
      while (idx < items.length) {
        const i = idx++;
        try { out[i] = await fn(items[i], i); } catch { out[i] = null; }
      }
    });
    await Promise.all(workers);
    return out;
  }

  // ======================
  // Environment maps
  // ======================
  const ENV_LABELS = {
    kOracle: "Oracle",
    kSQL: "SQL",
    kPhysical: "Physical",
    kGenericNas: "NAS",
    kIsilon: "NAS",
    kHyperV: "HyperV",
    kAcropolis: "Acropolis",
    kRemoteAdapter: "RemoteAdapter"
  };

  const ENV_OBJECT_TYPES = {
    kOracle: "kDatabase",
    kSQL: "kDatabase",
    kPhysical: "kHost",
    kGenericNas: "kHost",
    kIsilon: "kHost",
    kHyperV: "kVirtualMachine",
    kAcropolis: "kVirtualMachine",
    kRemoteAdapter: "kRemoteAdapter"
  };

  const ENV_FILTERS = {
    kOracle: ["kOracle"],
    kSQL: ["kSQL"],
    kPhysical: ["kPhysical"],
    kGenericNas: ["kGenericNas", "kIsilon"],
    kIsilon: ["kIsilon", "kGenericNas"],
    kHyperV: ["kHyperV"],
    kAcropolis: ["kAcropolis"],
    kRemoteAdapter: ["kRemoteAdapter"]
  };

  function getEnvCode(pg) {
    let envRaw = pg.environment;
    if (!envRaw && Array.isArray(pg.environmentTypes) && pg.environmentTypes.length > 0) {
      envRaw = pg.environmentTypes[0];
    }
    return envRaw || null;
  }

  function mapEnvironmentLabel(envCode) {
    if (!envCode) return "Unknown";
    return ENV_LABELS[envCode] || envCode;
  }

  function extractRemoteAdapterInfo(pg) {
    let raHost = null;
    let raDB = null;

    const ra = pg.remoteAdapterParams || {};
    const hosts = ra.hosts || ra.host || ra.hostList || null;

    let firstHost = null;
    if (Array.isArray(hosts) && hosts.length > 0) firstHost = hosts[0];
    else if (hosts && typeof hosts === "object") firstHost = hosts;

    if (firstHost) {
      raHost = firstHost.hostname || firstHost.hostName || firstHost.name || null;

      const inc =
        firstHost.incrementalBackupScript ||
        firstHost.backupScript ||
        ra.incrementalBackupScript ||
        ra.backupScript ||
        {};

      let args = inc.params || inc.arguments || inc.args || null;
      if (Array.isArray(args)) args = args.join(" ");
      if (typeof args === "string") {
        const m = args.match(/-o\s+(\S+)/i);
        if (m) raDB = m[1];
      }
    }
    return { raHost, raDB };
  }

  async function collectRemoteAdapterPg(clusterName, headers, pg, envLbl) {
    const pgId = pg.id;
    const pgName = pg.name || "Unknown PG";

    const raInfo = extractRemoteAdapterInfo(pg);
    const raHost = raInfo.raHost;
    const raDB = raInfo.raDB;

    const runQuery = buildQuery({
      numRuns: NUM_RUNS_OBJECT,
      excludeNonRestorableRuns: false,
      includeObjectDetails: true
    });

    let runData;
    try {
      runData = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs?${runQuery}`,
        headers
      );
    } catch {
      return [];
    }

    const runs = runData && runData.runs ? runData.runs : [];
    if (!runs.length) return [];

    const flat = [];
    for (let i = 0; i < runs.length; i++) {
      const infos = toInfoArray(runs[i].localBackupInfo);
      for (let j = 0; j < infos.length; j++) {
        const info = infos[j] || {};
        flat.push({
          RunType: info.runType || "UNKNOWN",
          Status: info.status || "Unknown",
          Message: cleanMessage(info.messages),
          StartUsecs: info.startTimeUsecs || 0,
          EndUsecs: info.endTimeUsecs || 0
        });
      }
    }
    if (!flat.length) return [];

    const byType = {};
    for (let i = 0; i < flat.length; i++) {
      const r = flat[i];
      if (!byType[r.RunType]) byType[r.RunType] = [];
      byType[r.RunType].push(r);
    }

    const out = [];
    for (const rt of Object.keys(byType)) {
      const arr = byType[rt].slice().sort((a, b) => (b.EndUsecs || 0) - (a.EndUsecs || 0));
      const latestFailed = arr.find((x) => x.Status === "Failed");
      if (!latestFailed) continue;

      const hasLaterSuccess = arr.some(
        (x) => isSuccessStatus(x.Status) && (x.StartUsecs || 0) > (latestFailed.EndUsecs || 0)
      );
      if (hasLaterSuccess) continue;

      out.push({
        Environment: envLbl,
        Cluster: clusterName,
        ProtectionGroup: pgName,
        RunType: rt,
        StartTime: usecsToET(latestFailed.StartUsecs),
        EndTime: usecsToET(latestFailed.EndUsecs),
        Status: "Failed",
        Host: raHost || null,
        ObjectName: raDB || raHost || "Unknown RemoteAdapter",
        DatabaseName: null,
        FailedMessage: latestFailed.Message || "",
        StartTimeUsecs: latestFailed.StartUsecs,
        EndTimeUsecs: latestFailed.EndUsecs
      });
    }
    return out;
  }

  async function collectPgLatestUncleared(clusterName, headers, pg) {
    const pgId = pg.id;
    const pgName = pg.name || "Unknown PG";
    const envCode = getEnvCode(pg);
    const envLbl = mapEnvironmentLabel(envCode);

    if (envCode === "kRemoteAdapter") {
      return collectRemoteAdapterPg(clusterName, headers, pg, envLbl);
    }

    const targetType = ENV_OBJECT_TYPES[envCode] || null;
    const envFilter = ENV_FILTERS[envCode] || null;
    const parentHostNeeded = envCode === "kOracle" || envCode === "kSQL";

    const runQuery = buildQuery({
      numRuns: NUM_RUNS_OBJECT,
      excludeNonRestorableRuns: false,
      includeObjectDetails: true
    });

    let runData;
    try {
      runData = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs?${runQuery}`,
        headers
      );
    } catch {
      return [];
    }

    const runs = runData && runData.runs ? runData.runs : [];
    if (!runs.length) return [];

    const byType = {};
    for (let i = 0; i < runs.length; i++) {
      const infos = toInfoArray(runs[i].localBackupInfo);
      if (!infos.length) continue;
      const rType = infos[0]?.runType ? infos[0].runType : "UNKNOWN";
      if (!byType[rType]) byType[rType] = [];
      byType[rType].push(runs[i]);
    }

    const out = [];

    for (const rType of Object.keys(byType)) {
      const runsForType = byType[rType]
        .slice()
        .sort(
          (a, b) =>
            ((b.localBackupInfo?.[0]?.endTimeUsecs) || 0) -
            ((a.localBackupInfo?.[0]?.endTimeUsecs) || 0)
        );

      const cleared = new Set();
      const latestFailByKey = new Map();

      for (let ri = 0; ri < runsForType.length; ri++) {
        const run = runsForType[ri];
        const info = run.localBackupInfo?.[0] || {};
        const status = info.status || "Unknown";

        const startUsecs = info.startTimeUsecs || 0;
        const endUsecs = info.endTimeUsecs || 0;

        const startTimeStr = usecsToET(startUsecs);
        const endTimeStr = usecsToET(endUsecs);

        const objects = run.objects || [];
        if (!objects.length) continue;

        for (let oi = 0; oi < objects.length; oi++) {
          const ob = objects[oi];
          if (!ob?.object || !ob.localSnapshotInfo) continue;
          if (ob.localSnapshotInfo && !hasFailedAttempts(ob)) {
            const k = getObjKey(ob);
            if (k) cleared.add(k);
          }
        }

        if (parentHostNeeded) {
          for (let oi = 0; oi < objects.length; oi++) {
            const ob = objects[oi];
            const obj = ob?.object || null;
            if (!obj) continue;

            const isHostObj = obj.objectType === "kHost" || obj.environment === "kPhysical";
            if (!isHostObj) continue;

            const fa = ob.localSnapshotInfo?.failedAttempts || [];
            if (!fa.length) continue;

            const k = getObjKey(ob);
            if (!k || cleared.has(k) || latestFailByKey.has(k)) continue;

            const msg = combineFailedAttempts(fa);
            if (!msg) continue;

            latestFailByKey.set(k, {
              Environment: envLbl,
              Cluster: clusterName,
              ProtectionGroup: pgName,
              RunType: rType,
              StartTime: startTimeStr,
              EndTime: endTimeStr,
              Status: status,
              Host: obj.name || null,
              ObjectName: null,
              DatabaseName: "No DBs Found (Host-Level Failure)",
              FailedMessage: msg,
              StartTimeUsecs: startUsecs,
              EndTimeUsecs: endUsecs
            });
          }
        }

        for (let oi = 0; oi < objects.length; oi++) {
          const ob = objects[oi];
          const obj = ob?.object || null;
          if (!obj) continue;

          if (targetType && obj.objectType !== targetType) continue;
          if (envFilter && obj.environment && envFilter.indexOf(obj.environment) === -1) continue;

          const k = getObjKey(ob);
          if (!k || cleared.has(k) || latestFailByKey.has(k)) continue;

          const fa = ob.localSnapshotInfo?.failedAttempts || [];

          if (!fa.length) continue;

          const msg = combineFailedAttempts(fa);
          if (!msg) continue;

          let hostName = null;
          if (parentHostNeeded) hostName = findHostNameInRun(objects, obj.sourceId);

          if (parentHostNeeded) {
            latestFailByKey.set(k, {
              Environment: envLbl,
              Cluster: clusterName,
              ProtectionGroup: pgName,
              RunType: rType,
              StartTime: startTimeStr,
              EndTime: endTimeStr,
              Status: status,
              Host: hostName,
              ObjectName: null,
              DatabaseName: obj.name || null,
              FailedMessage: msg,
              StartTimeUsecs: startUsecs,
              EndTimeUsecs: endUsecs
            });
          } else {
            latestFailByKey.set(k, {
              Environment: envLbl,
              Cluster: clusterName,
              ProtectionGroup: pgName,
              RunType: rType,
              StartTime: startTimeStr,
              EndTime: endTimeStr,
              Status: status,
              Host: null,
              ObjectName: obj.name || null,
              DatabaseName: null,
              FailedMessage: msg,
              StartTimeUsecs: startUsecs,
              EndTimeUsecs: endUsecs
            });
          }
        }
      }

      for (const v of latestFailByKey.values()) out.push(v);
    }

    return out;
  }

  async function collectClusterFailures(cluster) {
    const clusterId = cluster.clusterId;
    const clusterName =
      cluster.name || cluster.clusterName || cluster.displayName || `Unknown-${clusterId}`;

    if (part(clusterName) !== PART_ID) return [];

    const headers = {
      accept: "application/json",
      apiKey,
      accessClusterId: String(clusterId)
    };

    // policies
    let policiesData = null;
    try {
      policiesData = await getJson(`${baseUrl}/v1/protectionPolicies`, headers);
    } catch {
      try {
        policiesData = await getJson(`${baseUrl}/protectionPolicies`, headers);
      } catch {
        policiesData = null;
      }
    }

    const policiesArr =
      policiesData?.protectionPolicies ||
      policiesData?.policies ||
      policiesData?.items ||
      policiesData ||
      [];

    const policyById = new Map();
    if (Array.isArray(policiesArr)) {
      for (let i = 0; i < policiesArr.length; i++) {
        const p = policiesArr[i];
        const id = p?.id ?? p?.policyId ?? p?._id ?? null;
        if (id != null) policyById.set(String(id), p);
      }
    }

    // active PGs
    let pgData;
    try {
      pgData = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups?${buildQuery({
          isDeleted: false,
          isPaused: false,
          isActive: true
        })}`,
        headers
      );
    } catch {
      return [];
    }

    const pgsAll = pgData && pgData.protectionGroups ? pgData.protectionGroups : [];
    if (!pgsAll.length) return [];

    const pgs = [];
    for (let i = 0; i < pgsAll.length; i++) {
      const pg = pgsAll[i];
      const pids = pickPolicyIds(pg);
      if (!pids.length) continue;

      let bestDays = null;
      let bestPolicy = null;

      for (let j = 0; j < pids.length; j++) {
        const pol = policyById.get(String(pids[j])) || null;
        const d = retentionDaysFromPolicy(pol);
        if (d == null) continue;
        if (bestDays == null || d > bestDays) {
          bestDays = d;
          bestPolicy = pol;
        }
      }

      if (bestDays == null) continue;
      if (bestDays < MIN_RETENTION_DAYS) continue;
      if (!isProdPg(pg, bestPolicy)) continue;

      pgs.push(pg);
    }

    if (!pgs.length) return [];

    const pgResults = await mapLimit(pgs, PG_CONCURRENCY, async (pg) => {
      return collectPgLatestUncleared(clusterName, headers, pg);
    });

    const rows = [];
    for (let i = 0; i < pgResults.length; i++) {
      const r = pgResults[i];
      if (r && r.length) rows.push(...r);
      if (rows.length >= MAX_ROWS_TOTAL) break;
    }
    return rows;
  }

  // clusters
  const clustersResp = await getJson(
    `${baseUrl}/v2/mcm/cluster-mgmt/info`,
    { accept: "application/json", apiKey }
  );
  const clusters = clustersResp && clustersResp.cohesityClusters ? clustersResp.cohesityClusters : [];

  const clusterResults = await mapLimit(clusters, CLUSTER_CONCURRENCY, async (c) => {
    return collectClusterFailures(c);
  });

  const myFailures = [];
  for (let i = 0; i < clusterResults.length; i++) {
    const r = clusterResults[i];
    if (r && r.length) myFailures.push(...r);
    if (myFailures.length >= MAX_ROWS_TOTAL) break;
  }

  const failures = []
    .concat(p1Failures || [])
    .concat(myFailures || []);

  if (failures.length > MAX_ROWS_TOTAL) failures.length = MAX_ROWS_TOTAL;
  failures.sort((a, b) => (b.EndTimeUsecs || 0) - (a.EndTimeUsecs || 0));

  // ======================
  // Output builders (your picture)
  // ======================
  function toIncidentTextCreate(rows) {
    if (!rows || rows.length === 0) return "✅ No FAILED backup objects without a later successful run (last 7 runs scope).";
    const lines = [];
    lines.push("=== Backup Failures (Latest Uncleared Only) ===");
    lines.push(`Count: ${rows.length}`);
    lines.push("");
    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];
      const obj = r.DatabaseName || r.ObjectName || "-";
      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${obj} | End(ET)=${r.EndTime || "-"}`
      );
    }
    return lines.join("\n");
  }

  function toIncidentTextUpdate(rows) {
    if (!rows || rows.length === 0) return "✅ No FAILED backup objects without a later successful run (last 7 runs scope).";
    const lines = [];
    lines.push("=== Backup Failures (Latest Uncleared Only) ===");
    lines.push(`Count: ${rows.length}`);
    lines.push("");
    for (let i = 0; i < rows.length; i++) {
      const r = rows[i];
      const obj = r.DatabaseName || r.ObjectName || "-";
      lines.push(
        `#${i + 1} [${r.Environment}] Cluster=${r.Cluster} | PG=${r.ProtectionGroup} | RunType=${r.RunType} | ` +
        `Host=${r.Host || "-"} | Obj=${obj} | End(ET)=${r.EndTime || "-"}`
      );
      if (r.FailedMessage) lines.push(`    Message: ${String(r.FailedMessage)}`);
      lines.push("");
    }
    return lines.join("\n");
  }

  function toMarkdownTable(rows) {
    if (!rows || rows.length === 0) return "✅ No FAILED backup objects without a later successful run (last 7 runs scope).";

    function safeCell(v) {
      if (v == null) return "";
      return String(v).replace(/\|/g, " ").replace(/[\r\n]+/g, " ").trim();
    }

    const headerLabels = ["Cluster", "ProtectionGroup", "Host", "ObjectName", "RunType", "StartTime", "EndTime", "FailedMessage"];
    const headerRow = "| " + headerLabels.join(" | ") + " |";
    const separator = "| " + headerLabels.map(() => "---").join(" | ") + " |";

    const bodyRows = rows.map((r) => {
      const obj = r.DatabaseName || r.ObjectName || "";
      const vals = [
        safeCell(r.Cluster),
        safeCell(r.ProtectionGroup),
        safeCell(r.Host),
        safeCell(obj),
        safeCell(r.RunType),
        safeCell(r.StartTime),
        safeCell(r.EndTime),
        safeCell(r.FailedMessage)
      ];
      return "| " + vals.join(" | ") + " |";
    });

    const introLines = ["### Backup failures without a latest successful run", "", ""];
    return introLines.join("\n") + "\n" + [headerRow, separator].concat(bodyRows).join("\n");
  }

  const markdownTable = toMarkdownTable(failures);

  return {
    authMode: authMode,
    count: failures.length,
    failures: failures,
    incidentText_create: toIncidentTextCreate(failures),
    incidentText_update: toIncidentTextUpdate(failures),
    markdownTable: markdownTable,
    markdownEmail: markdownTable
  };
}
