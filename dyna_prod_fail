// Cohesity Helios â€” Active Protection Groups with Policy daysToKeep >= 35 (All Clusters)
// GET-only | Fast inventory | 502/429 safe
//
// What it does:
// 1) For each cluster: list active PGs (v2)
// 2) For each PG: fetch policy details via irisservices (daysToKeep)
// 3) Keep only PGs where daysToKeep >= 35
//
// Output:
// {
//   authMode,
//   count,
//   protectionGroups: [
//     { Cluster, ClusterId, ProtectionGroup, PgId, Environment, PolicyId, PolicyName, DaysToKeep }
//   ]
// }

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  const MIN_DAYS = 35;
  const CLUSTER_CONCURRENCY = 2;
  const PG_CONCURRENCY = 6;
  const POLICY_CONCURRENCY = 10;
  const MAX_ROWS_TOTAL = 20000;

  // ======================
  // AUTH (READ-ONLY)
  // ======================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find((c) => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (detail && (detail.token || detail.password)) || null;
      authMode = "vault-id";
    } catch {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }
  if (!apiKey) throw new Error("No Helios API key available (vault + manual failed).");

  // ======================
  // Helpers
  // ======================
  function buildQuery(params) {
    const usp = new URLSearchParams();
    Object.keys(params || {}).forEach((k) => {
      const v = params[k];
      if (v === undefined || v === null) return;
      if (Array.isArray(v)) v.forEach((x) => usp.append(k, String(x)));
      else usp.append(k, String(v));
    });
    return usp.toString();
  }

  function envLabel(pg) {
    const ENV_LABELS = {
      kOracle: "Oracle",
      kSQL: "SQL",
      kPhysical: "Physical",
      kGenericNas: "NAS",
      kIsilon: "NAS",
      kHyperV: "HyperV",
      kAcropolis: "Acropolis",
      kRemoteAdapter: "RemoteAdapter"
    };
    const env = pg?.environment || (Array.isArray(pg?.environmentTypes) ? pg.environmentTypes[0] : null);
    return ENV_LABELS[env] || env || "Unknown";
  }

  function pickPolicyId(pg) {
    if (pg?.policyId != null) return String(pg.policyId);
    if (Array.isArray(pg?.policyIds) && pg.policyIds.length) return String(pg.policyIds[0]);
    if (Array.isArray(pg?.policies) && pg.policies.length) {
      const p = pg.policies[0];
      if (p?.id != null) return String(p.id);
      if (p?.policyId != null) return String(p.policyId);
    }
    return null;
  }

  function policyDetailUrl(baseUrl, policyId) {
    // keep ":" intact (avoid %3A in path)
    const safeId = encodeURIComponent(String(policyId)).replace(/%3A/gi, ":");
    return `${baseUrl}/irisservices/api/v1/public/protectionPolicies/${safeId}`;
  }

  async function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
  }

  async function getJson(url, headers, attempt = 0) {
    const resp = await fetch(url, { method: "GET", headers });
    if (resp.ok) return resp.json();

    const status = resp.status;
    let txt = "";
    try { txt = await resp.text(); } catch {}

    if ((status === 429 || status === 502 || status === 503 || status === 504) && attempt < 2) {
      await sleep(250 * (attempt + 1));
      return getJson(url, headers, attempt + 1);
    }
    throw new Error(`GET ${url} -> HTTP ${status} ${txt}`);
  }

  async function mapLimit(items, limit, fn) {
    const out = [];
    let idx = 0;
    const workers = new Array(Math.min(limit, items.length)).fill(0).map(async () => {
      while (idx < items.length) {
        const i = idx++;
        try { out[i] = await fn(items[i], i); } catch { out[i] = null; }
      }
    });
    await Promise.all(workers);
    return out;
  }

  // ======================
  // Clusters
  // ======================
  const clustersResp = await getJson(
    `${baseUrl}/v2/mcm/cluster-mgmt/info`,
    { accept: "application/json", apiKey }
  );
  const clusters = clustersResp?.cohesityClusters || [];

  // ======================
  // Collect PGs + policies
  // ======================
  const perCluster = await mapLimit(clusters, CLUSTER_CONCURRENCY, async (c) => {
    const clusterId = c.clusterId;
    const clusterName = c.name || c.clusterName || c.displayName || `Unknown-${clusterId}`;

    const headers = {
      accept: "application/json",
      apiKey,
      accessClusterId: String(clusterId)
    };

    // active PGs only
    let pgData;
    try {
      pgData = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups?${buildQuery({
          isDeleted: false,
          isPaused: false,
          isActive: true
        })}`,
        headers
      );
    } catch {
      return [];
    }

    const pgs = pgData?.protectionGroups || [];
    if (!pgs.length) return [];

    // Dedup policy lookups per cluster
    const policyCache = new Map(); // policyId -> { daysToKeep, name }
    async function getPolicy(policyId) {
      if (!policyId) return null;
      if (policyCache.has(policyId)) return policyCache.get(policyId);

      let p = null;
      try {
        p = await getJson(policyDetailUrl(baseUrl, policyId), headers);
      } catch {
        p = null;
      }

      const policyObj = p?.protectionPolicy || p; // handle wrapper
      const daysToKeep = policyObj?.daysToKeep ?? null;
      const name = policyObj?.name ?? policyObj?.policyName ?? null;

      const rec = { daysToKeep, name };
      policyCache.set(policyId, rec);
      return rec;
    }

    // First collect PG skeletons
    const pgSkeletons = [];
    for (let i = 0; i < pgs.length; i++) {
      const pg = pgs[i];
      const policyId = pickPolicyId(pg);
      if (!policyId) continue;
      pgSkeletons.push({
        Cluster: clusterName,
        ClusterId: String(clusterId),
        ProtectionGroup: pg.name || "Unknown PG",
        PgId: String(pg.id),
        Environment: envLabel(pg),
        PolicyId: policyId
      });
    }

    // Fetch policy details in parallel (bounded)
    const enriched = await mapLimit(pgSkeletons, POLICY_CONCURRENCY, async (x) => {
      const pol = await getPolicy(x.PolicyId);
      const days = (pol && pol.daysToKeep != null) ? Number(pol.daysToKeep) : null;
      if (!Number.isFinite(days)) return null;
      if (days < MIN_DAYS) return null;

      return {
        ...x,
        PolicyName: pol?.name || "",
        DaysToKeep: days
      };
    });

    return enriched.filter(Boolean);
  });

  const protectionGroups = [];
  for (let i = 0; i < perCluster.length; i++) {
    const r = perCluster[i];
    if (r && r.length) protectionGroups.push(...r);
    if (protectionGroups.length >= MAX_ROWS_TOTAL) break;
  }

  // Sort
  protectionGroups.sort((a, b) => {
    const c = String(a.Cluster).localeCompare(String(b.Cluster));
    if (c !== 0) return c;
    const d = (b.DaysToKeep || 0) - (a.DaysToKeep || 0);
    if (d !== 0) return d;
    return String(a.ProtectionGroup).localeCompare(String(b.ProtectionGroup));
  });

  return {
    authMode,
    count: protectionGroups.length,
    protectionGroups
  };
}
