// Cohesity Helios â€” SIMPLE Policy List (All Clusters)
// GET-only | Fast | 502/429 safe
// Output: { authMode, count, policies: [ { Cluster, PolicyId, PolicyName } ] }

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";
  const CLUSTER_CONCURRENCY = 4;
  const MAX_ROWS_TOTAL = 50000;

  // ======================
  // AUTH (READ-ONLY)
  // ======================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find((c) => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (detail && (detail.token || detail.password)) || null;
      authMode = "vault-id";
    } catch {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }
  if (!apiKey) throw new Error("No Helios API key available (vault + manual failed).");

  // ======================
  // Helpers
  // ======================
  async function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
  }

  async function getJson(url, headers, attempt = 0) {
    const resp = await fetch(url, { method: "GET", headers });
    if (resp.ok) return resp.json();

    const status = resp.status;
    let txt = "";
    try { txt = await resp.text(); } catch {}

    if ((status === 429 || status === 502 || status === 503 || status === 504) && attempt < 2) {
      await sleep(250 * (attempt + 1));
      return getJson(url, headers, attempt + 1);
    }
    throw new Error(`GET ${url} -> HTTP ${status} ${txt}`);
  }

  async function mapLimit(items, limit, fn) {
    const out = [];
    let idx = 0;
    const workers = new Array(Math.min(limit, items.length)).fill(0).map(async () => {
      while (idx < items.length) {
        const i = idx++;
        try { out[i] = await fn(items[i], i); } catch { out[i] = null; }
      }
    });
    await Promise.all(workers);
    return out;
  }

  // ======================
  // Clusters
  // ======================
  const clustersResp = await getJson(
    `${baseUrl}/v2/mcm/cluster-mgmt/info`,
    { accept: "application/json", apiKey }
  );
  const clusters = clustersResp?.cohesityClusters || [];

  // ======================
  // Policies per cluster
  // ======================
  const perCluster = await mapLimit(clusters, CLUSTER_CONCURRENCY, async (c) => {
    const clusterId = c.clusterId;
    const clusterName = c.name || c.clusterName || c.displayName || `Unknown-${clusterId}`;

    const headers = {
      accept: "application/json",
      apiKey,
      accessClusterId: String(clusterId)
    };

    let policiesData = null;
    try {
      policiesData = await getJson(`${baseUrl}/v1/protectionPolicies`, headers);
    } catch {
      try {
        policiesData = await getJson(`${baseUrl}/protectionPolicies`, headers);
      } catch {
        return [];
      }
    }

    const policiesArr =
      policiesData?.protectionPolicies ||
      policiesData?.policies ||
      policiesData?.items ||
      policiesData ||
      [];

    if (!Array.isArray(policiesArr) || !policiesArr.length) return [];

    const rows = [];
    for (let i = 0; i < policiesArr.length; i++) {
      const p = policiesArr[i];
      const id = p?.id ?? p?.policyId ?? p?._id ?? null;
      const name = p?.name ?? p?.policyName ?? "UnknownPolicy";
      rows.push({
        Cluster: clusterName,
        PolicyId: id != null ? String(id) : null,
        PolicyName: String(name)
      });
      if (rows.length >= MAX_ROWS_TOTAL) break;
    }
    return rows;
  });

  const policies = [];
  for (let i = 0; i < perCluster.length; i++) {
    const r = perCluster[i];
    if (r && r.length) policies.push(...r);
    if (policies.length >= MAX_ROWS_TOTAL) break;
  }

  // Sort
  policies.sort((a, b) => {
    const c = String(a.Cluster).localeCompare(String(b.Cluster));
    if (c !== 0) return c;
    return String(a.PolicyName).localeCompare(String(b.PolicyName));
  });

  return { authMode, count: policies.length, policies };
}
