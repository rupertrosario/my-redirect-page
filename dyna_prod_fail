// Cohesity Helios â€” Protection Policies + Retention (per cluster)
// GET-only | 502/429 safe
// Output:
// { authMode, count, policies: [ { Cluster, PolicyId, PolicyName, RetentionDays, RetentionRaw } ] }

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";
  const CLUSTER_CONCURRENCY = 3;
  const MAX_ROWS_TOTAL = 20000;

  // ======================
  // AUTH (READ-ONLY)
  // ======================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find((c) => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (detail && (detail.token || detail.password)) || null;
      authMode = "vault-id";
    } catch {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }
  if (!apiKey) throw new Error("No Helios API key available (vault + manual failed).");

  // ======================
  // Helpers
  // ======================
  async function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
  }

  async function getJson(url, headers, attempt = 0) {
    const resp = await fetch(url, { method: "GET", headers });
    if (resp.ok) return resp.json();
    const status = resp.status;
    let txt = "";
    try { txt = await resp.text(); } catch {}
    if ((status === 429 || status === 502 || status === 503 || status === 504) && attempt < 2) {
      await sleep(250 * (attempt + 1));
      return getJson(url, headers, attempt + 1);
    }
    throw new Error(`GET ${url} -> HTTP ${status} ${txt}`);
  }

  async function mapLimit(items, limit, fn) {
    const out = [];
    let idx = 0;
    const workers = new Array(Math.min(limit, items.length)).fill(0).map(async () => {
      while (idx < items.length) {
        const i = idx++;
        try { out[i] = await fn(items[i], i); } catch { out[i] = null; }
      }
    });
    await Promise.all(workers);
    return out;
  }

  function daysFromUnitValue(unit, value) {
    const v = Number(value);
    if (!Number.isFinite(v)) return null;
    const u = String(unit || "").toLowerCase();
    if (u.includes("day")) return v;
    if (u.includes("week")) return v * 7;
    if (u.includes("month")) return v * 30;
    if (u.includes("year")) return v * 365;
    if (u.includes("hour")) return v / 24;
    return null;
  }

  function retentionDaysFromPolicy(p) {
    if (!p) return { days: null, raw: null };

    // Common direct days fields
    const directDays =
      p.retentionDays ??
      p.daysToKeep ??
      p.daysToRetain ??
      p.snapshotRetentionDays ??
      p.backupRetentionDays ??
      null;

    if (directDays != null && Number.isFinite(Number(directDays))) {
      return { days: Number(directDays), raw: { retentionDays: Number(directDays) } };
    }

    // unit/value style (best-effort)
    const uvCandidates = [
      p.retention,
      p.retentionPolicy,
      p.backupRetention,
      p.snapshotRetention,
      p.snapshotRetentionPolicy,
      p.snapshotSettings?.retention,
      p.snapshotSettings?.retentionPolicy,
      p.incremental?.retention,
      p.full?.retention
    ];

    for (let i = 0; i < uvCandidates.length; i++) {
      const x = uvCandidates[i];
      if (!x) continue;

      const v = x.value ?? x.count ?? x.num ?? x.duration ?? x.timePeriod ?? x.period ?? null;
      const u = x.unit ?? x.timeUnit ?? null;

      const d = daysFromUnitValue(u, v);
      if (d != null) return { days: d, raw: x };
    }

    // nested retentionPeriod + retentionUnit
    const d2 = daysFromUnitValue(p.retentionUnit, p.retentionPeriod);
    if (d2 != null) return { days: d2, raw: { retentionUnit: p.retentionUnit, retentionPeriod: p.retentionPeriod } };

    // seconds fallback
    const secs = p.retentionPeriodSecs ?? p.retentionSecs ?? null;
    if (secs != null && Number.isFinite(Number(secs))) {
      return { days: Number(secs) / 86400, raw: { retentionSecs: Number(secs) } };
    }

    return { days: null, raw: null };
  }

  // ======================
  // Clusters
  // ======================
  const clustersResp = await getJson(
    `${baseUrl}/v2/mcm/cluster-mgmt/info`,
    { accept: "application/json", apiKey }
  );
  const clusters = clustersResp?.cohesityClusters || [];

  // ======================
  // Per-cluster policies
  // ======================
  const perCluster = await mapLimit(clusters, CLUSTER_CONCURRENCY, async (c) => {
    const clusterId = c.clusterId;
    const clusterName = c.name || c.clusterName || c.displayName || `Unknown-${clusterId}`;

    const headers = {
      accept: "application/json",
      apiKey,
      accessClusterId: String(clusterId)
    };

    let policiesData = null;
    try {
      policiesData = await getJson(`${baseUrl}/v1/protectionPolicies`, headers);
    } catch {
      try {
        policiesData = await getJson(`${baseUrl}/protectionPolicies`, headers);
      } catch {
        return [];
      }
    }

    const policiesArr =
      policiesData?.protectionPolicies ||
      policiesData?.policies ||
      policiesData?.items ||
      policiesData ||
      [];

    if (!Array.isArray(policiesArr) || !policiesArr.length) return [];

    const rows = [];
    for (let i = 0; i < policiesArr.length; i++) {
      const p = policiesArr[i];
      const id = p?.id ?? p?.policyId ?? p?._id ?? null;
      const name = p?.name ?? p?.policyName ?? "UnknownPolicy";

      const rd = retentionDaysFromPolicy(p);

      rows.push({
        Cluster: clusterName,
        PolicyId: id != null ? String(id) : null,
        PolicyName: String(name),
        RetentionDays: rd.days != null ? Math.round(rd.days * 100) / 100 : null,
        RetentionRaw: rd.raw
      });

      if (rows.length >= MAX_ROWS_TOTAL) break;
    }
    return rows;
  });

  const policies = [];
  for (let i = 0; i < perCluster.length; i++) {
    const r = perCluster[i];
    if (r && r.length) policies.push(...r);
    if (policies.length >= MAX_ROWS_TOTAL) break;
  }

  // Sort: Cluster, then RetentionDays desc, then PolicyName
  policies.sort((a, b) => {
    const c = String(a.Cluster).localeCompare(String(b.Cluster));
    if (c !== 0) return c;
    const da = a.RetentionDays == null ? -1 : a.RetentionDays;
    const db = b.RetentionDays == null ? -1 : b.RetentionDays;
    if (db !== da) return db - da;
    return String(a.PolicyName).localeCompare(String(b.PolicyName));
  });

  return {
    authMode,
    count: policies.length,
    policies
  };
}
