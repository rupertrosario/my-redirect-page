$ErrorActionPreference = 'Stop'

# -------------------------------------------------------------
# 0️⃣ API key from your path (local file only)
# -------------------------------------------------------------
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) {
    throw "API key file not found at $apikeypath"
}

$apiKey        = (Get-Content -Path $apikeypath -Raw).Trim()
$commonHeaders = @{ "apiKey" = $apiKey }

# Base URLs (read-only Helios APIs)
$baseMcm  = "https://helios.cohesity.com/v2/mcm"
$baseIris = "https://helios.cohesity.com/irisservices/api/v1/public"

# -------------------------------------------------------------
# 1️⃣ Get clusters from Helios (GET ONLY)
# -------------------------------------------------------------
$clusterUrl  = "$baseMcm/cluster-mgmt/info"
$clusterResp = Invoke-WebRequest -Method Get -Uri $clusterUrl -Headers $commonHeaders
$clusterJson = $clusterResp.Content | ConvertFrom-Json
$json_clus   = $clusterJson.cohesityClusters

if (-not $json_clus -or $json_clus.Count -eq 0) {
    throw "No clusters returned from Helios."
}

# Sort clusters alphabetically
$json_clus = $json_clus | Sort-Object -Property clusterName

$clusters = for ($i = 0; $i -lt $json_clus.Count; $i++) {
    [pscustomobject]@{
        Index       = $i + 1
        ClusterName = $json_clus[$i].clusterName
        ClusterId   = $json_clus[$i].clusterId
    }
}

Write-Host ""
Write-Host "Available Helios Clusters (sorted by name):" -ForegroundColor Cyan
$clusters | Format-Table -AutoSize

Write-Host ""
Write-Host "[0] All clusters" -ForegroundColor Yellow
Write-Host "[X] Exit without selecting" -ForegroundColor Yellow
Write-Host ""

# -------------------------------------------------------------
# 2️⃣ Let user select ALL, ONE, or EXIT (local only)
# -------------------------------------------------------------
while ($true) {

    $inputVal = Read-Host "Enter 0 for ALL, 1-$($clusters.Count) for single, or X to exit"

    if ($inputVal -match '^(x|X|q|Q)$') {
        Write-Host "Exit selected. No clusters chosen." -ForegroundColor Cyan
        return
    }

    [int]$num = 0
    if (-not [int]::TryParse($inputVal, [ref]$num)) {
        Write-Host "Please enter a valid number or X to exit." -ForegroundColor Red
        continue
    }

    if ($num -lt 0 -or $num -gt $clusters.Count) {
        Write-Host "Please enter 0, 1-$($clusters.Count), or X to exit." -ForegroundColor Red
        continue
    }

    $selection = $num
    break
}

if ($selection -eq 0) {
    $SelectedClusters   = $clusters
    $SelectedClusterIds = $clusters.ClusterId

    Write-Host ""
    Write-Host "You selected: ALL clusters" -ForegroundColor Green
    $SelectedClusters | Format-Table -AutoSize
}
else {
    $selectedCluster    = $clusters | Where-Object { $_.Index -eq $selection }
    $SelectedClusters   = @($selectedCluster)
    $SelectedClusterIds = @($selectedCluster.ClusterId)

    Write-Host ""
    Write-Host "You selected cluster:" -ForegroundColor Green
    Write-Host "  Name: $($selectedCluster.ClusterName)"
    Write-Host "  Id:   $($selectedCluster.ClusterId)"
    Write-Host ""
}

# -------------------------------------------------------------
# 3️⃣ Helpers: decimal size, K-format, data reduction
# -------------------------------------------------------------
function Format-SizeDecimal {
    param([long]$Bytes)

    $abs = [math]::Abs([double]$Bytes)

    if ($abs -ge 1e12) { "{0:N1} TB" -f ($Bytes / 1e12) }
    elseif ($abs -ge 1e9) { "{0:N1} GB" -f ($Bytes / 1e9) }
    elseif ($abs -ge 1e6) { "{0:N1} MB" -f ($Bytes / 1e6) }
    elseif ($abs -ge 1e3) { "{0:N1} KB" -f ($Bytes / 1e3) }
    else { "{0} B" -f $Bytes }
}

function Format-K {
    param([long]$Value)

    if ($null -eq $Value) { return $null }
    if ($Value -eq 0)     { return "0" }

    $abs = [math]::Abs([double]$Value)
    if ($abs -lt 1000) { return ("{0:N0}" -f $Value) }

    return ("{0:N1}K" -f ($Value / 1e3))
}

function Compute-Reduction {
    param(
        [long]$LogicalBytes,
        [long]$PhysicalBytes
    )

    if ($PhysicalBytes -le 0 -or $LogicalBytes -le 0) { return "-" }

    $ratio = [double]$LogicalBytes / [double]$PhysicalBytes
    "{0:N1}x" -f $ratio
}

# -------------------------------------------------------------
# 4️⃣ GET /views?includeStats=true per selected cluster
#     Use stats.dataUsageStats (matches your blue dump)
# -------------------------------------------------------------
foreach ($cid in $SelectedClusterIds) {

    $cluster_name = ($SelectedClusters | Where-Object { $_.ClusterId -eq $cid }).ClusterName

    Write-Host ""
    Write-Host "Cluster: $cluster_name  (views?includeStats=true)" -ForegroundColor Cyan
    Write-Host ""

    $headers = @{
        "apiKey"          = $apiKey
        "accessClusterId" = "$cid"
        "Accept"          = "application/json"
    }

    # Mirrors: curl -G ... -d 'includeStats=true'
    $viewsUrl = "$baseIris/views?includeStats=true"

    try {
        $viewsResp = Invoke-WebRequest -Method Get -Uri $viewsUrl -Headers $headers
        $viewsJson = $viewsResp.Content | ConvertFrom-Json
    }
    catch {
        Write-Host "  ⚠ Failed to get views+stats for cluster '$cluster_name': $_" -ForegroundColor Red
        continue
    }

    # Handle both shapes: either { views = [...] } or bare array
    if ($viewsJson.views) {
        $views = $viewsJson.views
    }
    else {
        $views = $viewsJson
    }

    if (-not $views) {
        Write-Host "  ⚠ No views returned for cluster '$cluster_name'." -ForegroundColor Yellow
        continue
    }

    $rows = @()

    foreach ($view in $views) {

        $viewName = $view.name
        if (-not $viewName) { $viewName = "<UnnamedView>" }

        # stats.dataUsageStats is what you showed in the blue dump
        $stats = $view.stats.dataUsageStats
        if (-not $stats) { continue }

        # If dataUsageStats is an array, take the first element
        if ($stats -is [System.Collections.IEnumerable] -and
            -not ($stats -is [string])) {
            $stats = $stats[0]
        }

        $logicalBytes    = [int64]$stats.totalLogicalUsageBytes
        $dataInBytes     = [int64]$stats.dataInBytes
        $afterDedupBytes = [int64]$stats.dataInBytesAfterDedup
        $storageBytes    = [int64]$stats.storageConsumedBytes
        $resBytes        = [int64]$stats.localTierResiliencyImpactBytes
        $physBytes       = [int64]$stats.localTotalPhysicalUsageBytes
        $uniqPhysBytes   = [int64]$stats.uniquePhysicalDataBytes
        $numFilesRaw     = [int64]$stats.numFiles
        $numDirsRaw      = [int64]$stats.numDirectories

        $dataReduction   = Compute-Reduction -LogicalBytes $logicalBytes -PhysicalBytes $physBytes

        $rows += [pscustomobject]@{
            ViewName        = $viewName

            # raw bytes for totals
            LogicalBytes    = $logicalBytes
            PhysicalBytes   = $physBytes
            ResilBytes      = $resBytes
            StorageBytes    = $storageBytes
            DataInBytes     = $dataInBytes
            AfterDedupBytes = $afterDedupBytes
            UniquePhysBytes = $uniqPhysBytes
            NumFilesRaw     = $numFilesRaw
            NumDirsRaw      = $numDirsRaw

            # formatted columns (what we actually display)
            Logical         = Format-SizeDecimal $logicalBytes
            DataReduction   = $dataReduction
            Physical        = Format-SizeDecimal $physBytes
            ResiliencyImpact= Format-SizeDecimal $resBytes
            StorageUsed     = Format-SizeDecimal $storageBytes
            DataIn          = Format-SizeDecimal $dataInBytes
            AfterDedup      = Format-SizeDecimal $afterDedupBytes
            UniquePhysical  = Format-SizeDecimal $uniqPhysBytes
            NumFiles        = Format-K $numFilesRaw
            NumDirs         = Format-K $numDirsRaw
        }
    }

    if (-not $rows) {
        Write-Host "  ⚠ No view stats (dataUsageStats) for cluster '$cluster_name'." -ForegroundColor Yellow
        continue
    }

    # ---------------------------------------------------------
    # 5️⃣ TOTAL row across all views (sums, then reduction)
    # ---------------------------------------------------------
    $totLogicalBytes    = [int64](($rows.LogicalBytes    | Measure-Object -Sum).Sum)
    $totPhysicalBytes   = [int64](($rows.PhysicalBytes   | Measure-Object -Sum).Sum)
    $totResiliencyBytes = [int64](($rows.ResilBytes      | Measure-Object -Sum).Sum)
    $totStorageBytes    = [int64](($rows.StorageBytes    | Measure-Object -Sum).Sum)
    $totDataInBytes     = [int64](($rows.DataInBytes     | Measure-Object -Sum).Sum)
    $totAfterDedupBytes = [int64](($rows.AfterDedupBytes | Measure-Object -Sum).Sum)
    $totUniquePhysBytes = [int64](($rows.UniquePhysBytes | Measure-Object -Sum).Sum)
    $totNumFiles        = [int64](($rows.NumFilesRaw     | Measure-Object -Sum).Sum)
    $totNumDirs         = [int64](($rows.NumDirsRaw      | Measure-Object -Sum).Sum)

    $totalReduction     = Compute-Reduction -LogicalBytes $totLogicalBytes -PhysicalBytes $totPhysicalBytes

    $totalRow = [pscustomobject]@{
        ViewName         = 'TOTAL'
        Logical          = Format-SizeDecimal $totLogicalBytes
        DataReduction    = $totalReduction
        Physical         = Format-SizeDecimal $totPhysicalBytes
        ResiliencyImpact = Format-SizeDecimal $totResiliencyBytes
        StorageUsed      = Format-SizeDecimal $totStorageBytes
        DataIn           = Format-SizeDecimal $totDataInBytes
        AfterDedup       = Format-SizeDecimal $totAfterDedupBytes
        UniquePhysical   = Format-SizeDecimal $totUniquePhysBytes
        NumFiles         = Format-K $totNumFiles
        NumDirs          = Format-K $totNumDirs
    }

    # ---------------------------------------------------------
    # 6️⃣ Output: per-view rows + TOTAL, all in one table
    # ---------------------------------------------------------
    $sortedViews = $rows | Sort-Object -Property ViewName

    $outputRows  = @()
    $outputRows += $sortedViews |
        Select-Object ViewName, Logical, DataReduction, Physical, ResiliencyImpact,
                      StorageUsed, DataIn, AfterDedup, UniquePhysical, NumFiles, NumDirs
    $outputRows += $totalRow

    $outputRows |
        Format-Table ViewName,
                     Logical,
                     DataReduction,
                     Physical,
                     ResiliencyImpact,
                     StorageUsed,
                     DataIn,
                     AfterDedup,
                     UniquePhysical,
                     NumFiles,
                     NumDirs -AutoSize

    Write-Host ""
}
