# =====================================================================
# Cohesity Long-Running Jobs ‚Äì Multi-Cluster (Helios)
# Shows jobs where *any copy* (backup / replication / archival)
# has been Running for >= 24 hours.
#
# Output:
#   - Table 1: Backup (Local) long-running copies
#   - Table 2: Remote (Replication + Archival) long-running copies
#   - CSVs only when rows exist, UTF-8
# API behaviour:
#   - Helios + apiKey
#   - v2 /mcm/cluster-mgmt/info + /data-protect/protection-groups + /{id}/runs
#   - GET only (no POST/DELETE/etc.)
# =====================================================================

# -------------------------------
# Folder + API key
# -------------------------------
$logDirectory = "X:\PowerShell\Data\Cohesity\LongRunningJobs"
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory | Out-Null
}

# Hygiene 1: keep at most 50 newest files
try {
    $files = Get-ChildItem -Path $logDirectory -File -ErrorAction Stop
    if ($files.Count -gt 50) {
        $toDelete = $files | Sort-Object CreationTime | Select-Object -First ($files.Count - 50)
        $count = ($toDelete | Measure-Object).Count
        if ($count -gt 0) {
            $toDelete | Remove-Item -Force -ErrorAction SilentlyContinue
            Write-Host "üßπ Removed $count old files to keep last 50."
        }
    }
} catch {}

# Hygiene 2: delete anything older than 30 days
try {
    $threshold = (Get-Date).AddDays(-30)
    $older = Get-ChildItem -Path $logDirectory -File -ErrorAction SilentlyContinue |
             Where-Object { $_.LastWriteTime -lt $threshold }
    $oldCount = ($older | Measure-Object).Count
    if ($oldCount -gt 0) {
        $older | Remove-Item -Force -ErrorAction SilentlyContinue
        Write-Host "üßΩ Deleted $oldCount files older than 30 days."
    }
} catch {}

$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()

$baseUrl       = "https://helios.cohesity.com"
$commonHeaders = @{ "apiKey" = $apiKey }

# -------------------------------
# Helpers
# -------------------------------
function Convert-ToUtcFromEpoch {
    param($v)
    if ($null -eq $v -or $v -eq 0) { return $null }

    # Your failure script passes *usecs* here; reuse the same logic
    try {
        # divide by 1000 for usecs -> millis
        [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$v / 1000)).UtcDateTime
    } catch {
        [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$v).UtcDateTime
    }
}

function Convert-ToLocalFromUsecs {
    param(
        $usecs,
        [System.TimeZoneInfo]$tz
    )
    $utc = Convert-ToUtcFromEpoch $usecs
    if ($null -eq $utc) { return $null }
    if ($tz) {
        [System.TimeZoneInfo]::ConvertTimeFromUtc($utc, $tz)
    } else {
        $utc.ToLocalTime()
    }
}

function Format-Duration {
    param([double]$Hours)

    if ($Hours -lt 0) { return "0d 0h 0m" }

    $totalMinutes = [math]::Floor($Hours * 60)
    $days         = [math]::Floor($totalMinutes / (24 * 60))
    $remMinutes   = $totalMinutes - ($days * 24 * 60)
    $hrs          = [math]::Floor($remMinutes / 60)
    $mins         = $remMinutes - ($hrs * 60)

    "{0}d {1}h {2}m" -f $days, $hrs, $mins
}

$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")

# Adjust this if you ever want a different threshold
$thresholdHours = 24

# -------------------------------
# Get clusters (Helios)
# -------------------------------
try {
    $resp     = Invoke-WebRequest -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders -Method Get
    $json_clu = ($resp.Content | ConvertFrom-Json).cohesityClusters
} catch {
    throw "Failed to query Helios clusters: $($_.Exception.Message)"
}

if (-not $json_clu) { throw "No clusters returned from Helios." }

# -------------------------------
# Collect running copies
# -------------------------------
$backupRows = @()  # Local backup copies
$remoteRows = @()  # Replication + Archival copies

foreach ($cluster in $json_clu) {

    $cluster_name = ($cluster.name, $cluster.clusterName, $cluster.displayName |
                     Where-Object { $_ -and $_.Trim() } |
                     Select-Object -First 1)
    if (-not $cluster_name) { $cluster_name = "Unknown-$($cluster.clusterId)" }

    $headers = @{
        apiKey          = $apiKey
        accessClusterId = $cluster.clusterId
    }

    Write-Host "`nüîπ Processing cluster: $cluster_name" -ForegroundColor Cyan

    # Get Protection Groups on this cluster
    try {
        $pgResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups" -Headers $headers -Body @{
            isDeleted = "False"
            isPaused  = "False"
            isActive  = "True"
        } -Method Get

        $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
    } catch {
        Write-Host "  ‚ö†Ô∏è Failed to list PGs on $cluster_name: $($_.Exception.Message)" -ForegroundColor Yellow
        continue
    }

    if (-not $pgs) {
        Write-Host "  ‚ÑπÔ∏è No active protection groups on $cluster_name." -ForegroundColor DarkGray
        continue
    }

    foreach ($pg in $pgs) {
        $pgId   = $pg.id
        $pgName = $pg.name

        Write-Host "  üì¶ PG: $pgName" -ForegroundColor DarkCyan

        # Get recent runs for this PG
        try {
            $runResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" -Headers $headers -Body @{
                numRuns                  = "50"
                excludeNonRestorableRuns = "False"
                includeObjectDetails     = "False"
            } -Method Get

            $jsonRuns = $runResp.Content | ConvertFrom-Json
        } catch {
            Write-Host "    ‚ö†Ô∏è Failed to get runs: $($_.Exception.Message)" -ForegroundColor Yellow
            continue
        }

        if (-not $jsonRuns.runs) { continue }

        foreach ($run in $jsonRuns.runs) {

            $env = if ($run.environment) { $run.environment } elseif ($pg.environment) { $pg.environment } else { "Unknown" }

            # ---------------------------
            # 1) Local BACKUP copy
            # ---------------------------
            if ($run.localBackupInfo) {
                $bInfo = $run.localBackupInfo
                if ($bInfo -is [System.Array]) { $bInfo = $bInfo[0] }

                $bStatus = $bInfo.status
                if ($bStatus -eq "Running" -or $bStatus -eq "kRunning") {

                    $startUsecs = $bInfo.startTimeUsecs
                    $startUtc   = Convert-ToUtcFromEpoch $startUsecs
                    if ($startUtc) {
                        $hoursRunning = ([DateTime]::UtcNow - $startUtc).TotalHours

                        if ($hoursRunning -ge $thresholdHours) {
                            $startLocal = Convert-ToLocalFromUsecs $startUsecs $tz
                            $durStr     = Format-Duration -Hours $hoursRunning

                            $runTypeRaw = $bInfo.runType
                            $runType    = if ($runTypeRaw -and $runTypeRaw.StartsWith('k')) { $runTypeRaw.Substring(1) } else { $runTypeRaw }

                            $backupRows += [pscustomobject]@{
                                Cluster         = $cluster_name
                                ProtectionGroup = $pgName
                                Environment     = $env
                                RunType         = $runType
                                CopyType        = "Backup"
                                StartTime       = $startLocal
                                Duration        = $durStr
                                Status          = "Running"
                            }
                        }
                    }
                }
            }

            # ---------------------------
            # 2) REMOTE copies ‚Äì REPLICATION
            # ---------------------------
            if ($run.replicationInfo -and $run.replicationInfo.replicationTargetResults) {
                foreach ($rep in $run.replicationInfo.replicationTargetResults) {

                    $rStatus = $rep.status
                    if ($rStatus -ne "Running" -and $rStatus -ne "kRunning") { continue }

                    $startUsecs = $rep.startTimeUsecs
                    $startUtc   = Convert-ToUtcFromEpoch $startUsecs
                    if (-not $startUtc) { continue }

                    $hoursRunning = ([DateTime]::UtcNow - $startUtc).TotalHours
                    if ($hoursRunning -lt $thresholdHours) { continue }

                    $startLocal = Convert-ToLocalFromUsecs $startUsecs $tz
                    $durStr     = Format-Duration -Hours $hoursRunning

                    $targetCluster = $rep.clusterName
                    $copyType      = "Replication"
                    $targetType    = "RemoteCluster"

                    $remoteRows += [pscustomobject]@{
                        Cluster         = $cluster_name
                        ProtectionGroup = $pgName
                        Environment     = $env
                        RunType         = $copyType
                        CopyType        = $copyType
                        TargetType      = $targetType
                        TargetName      = $targetCluster
                        StartTime       = $startLocal
                        Duration        = $durStr
                        Status          = "Running"
                    }
                }
            }

            # ---------------------------
            # 3) REMOTE copies ‚Äì ARCHIVAL
            # ---------------------------
            if ($run.archivalInfo -and $run.archivalInfo.archivalTargetResults) {
                foreach ($arch in $run.archivalInfo.archivalTargetResults) {

                    $aStatus = $arch.status
                    if ($aStatus -ne "Running" -and $aStatus -ne "kRunning") { continue }

                    $startUsecs = $arch.startTimeUsecs
                    $startUtc   = Convert-ToUtcFromEpoch $startUsecs
                    if (-not $startUtc) { continue }

                    $hoursRunning = ([DateTime]::UtcNow - $startUtc).TotalHours
                    if ($hoursRunning -lt $thresholdHours) { continue }

                    $startLocal = Convert-ToLocalFromUsecs $startUsecs $tz
                    $durStr     = Format-Duration -Hours $hoursRunning

                    $copyType   = "Archival"
                    $targetType = $arch.targetType
                    $targetName = $arch.targetName

                    $remoteRows += [pscustomobject]@{
                        Cluster         = $cluster_name
                        ProtectionGroup = $pgName
                        Environment     = $env
                        RunType         = $copyType
                        CopyType        = $copyType
                        TargetType      = $targetType
                        TargetName      = $targetName
                        StartTime       = $startLocal
                        Duration        = $durStr
                        Status          = "Running"
                    }
                }
            }
        } # foreach run
    } # foreach PG
} # foreach cluster

# -------------------------------
# Output ‚Äì Backup vs Remote tables
# -------------------------------
$timestamp = Get-Date -Format "yyyyMMdd_HHmm"

if ($backupRows.Count -eq 0 -and $remoteRows.Count -eq 0) {
    Write-Host "`n‚úÖ No jobs running longer than $thresholdHours hours (All Clusters)." -ForegroundColor Green
    return
}

# BACKUP TABLE
if ($backupRows.Count -gt 0) {
    $backupSorted = $backupRows | Sort-Object Cluster, ProtectionGroup, StartTime

    Write-Host "`nJobs running longer than $thresholdHours hours ‚Äì BACKUP (Local):`n" -ForegroundColor Cyan
    $backupSorted | Format-Table Cluster,ProtectionGroup,Environment,RunType,StartTime,Duration,Status -AutoSize

    $backupCsv = Join-Path $logDirectory ("LongRunningJobs_Backup_AllClusters_Over{0}h_{1}.csv" -f $thresholdHours, $timestamp)
    $backupSorted | Select-Object Cluster,ProtectionGroup,Environment,RunType,CopyType,StartTime,Duration,Status |
        Export-Csv -Path $backupCsv -NoTypeInformation -Encoding utf8
    Write-Host "`nüìÇ Backup CSV saved: $backupCsv" -ForegroundColor Gray
} else {
    Write-Host "`n‚úÖ No BACKUP copies running longer than $thresholdHours hours." -ForegroundColor Green
}

# REMOTE TABLE (Replication + Archival)
if ($remoteRows.Count -gt 0) {
    $remoteSorted = $remoteRows | Sort-Object Cluster, ProtectionGroup, StartTime

    Write-Host "`nJobs running longer than $thresholdHours hours ‚Äì REMOTE (Replication/Archival):`n" -ForegroundColor Magenta
    $remoteSorted | Format-Table Cluster,ProtectionGroup,Environment,RunType,CopyType,TargetType,TargetName,StartTime,Duration,Status -AutoSize

    $remoteCsv = Join-Path $logDirectory ("LongRunningJobs_Remote_AllClusters_Over{0}h_{1}.csv" -f $thresholdHours, $timestamp)
    $remoteSorted | Select-Object Cluster,ProtectionGroup,Environment,RunType,CopyType,TargetType,TargetName,StartTime,Duration,Status |
        Export-Csv -Path $remoteCsv -NoTypeInformation -Encoding utf8
    Write-Host "`nüìÇ Remote CSV saved: $remoteCsv" -ForegroundColor Gray
} else {
    Write-Host "`n‚úÖ No REMOTE (Replication/Archival) copies running longer than $thresholdHours hours." -ForegroundColor Green
}

Write-Host "`n‚úÖ Long-running job scan complete!" -ForegroundColor White
