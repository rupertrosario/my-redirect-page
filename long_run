# =====================================================================
# Cohesity Long-Running Jobs ‚Äì Multi-Cluster (Helios, API key)
# GET-only | Read-only
# - Scans ALL Helios-managed clusters via accessClusterId
# - Finds backup + replication/archival runs that are "Running"
#   for more than $thresholdHours (default 24)
# - Separate tables + CSVs:
#     1) Long-running BACKUP (Local) jobs
#     2) Long-running REPLICATION/ARCHIVAL (Remote/Cloud) jobs
# - Duration shown as "Xd Yh ZZm" (e.g. 1d 0h 05m)
# =====================================================================

# Threshold in hours for "long-running"
$thresholdHours = 24

# -------------------------------
# Folder + API key
# -------------------------------
$logDirectory = "X:\PowerShell\Data\Cohesity\LongRunningJobs"
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory | Out-Null
}

# Hygiene 1: keep at most 50 newest files
try {
    $files = Get-ChildItem -Path $logDirectory -File -ErrorAction Stop
    if ($files.Count -gt 50) {
        $toDelete = $files | Sort-Object CreationTime | Select-Object -First ($files.Count - 50)
        $count = ($toDelete | Measure-Object).Count
        if ($count -gt 0) { $toDelete | Remove-Item -Force -ErrorAction SilentlyContinue }
        Write-Host "üßπ Removed $count old files to keep last 50." -ForegroundColor DarkGray
    }
} catch {}

# Hygiene 2: delete anything older than 30 days
try {
    $thresholdDate = (Get-Date).AddDays(-30)
    $older = Get-ChildItem -Path $logDirectory -File -ErrorAction SilentlyContinue |
             Where-Object { $_.LastWriteTime -lt $thresholdDate }
    $oldCount = ($older | Measure-Object).Count
    if ($oldCount -gt 0) {
        $older | Remove-Item -Force -ErrorAction SilentlyContinue
        Write-Host "üßΩ Deleted $oldCount files older than 30 days." -ForegroundColor DarkGray
    }
} catch {}

$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()

$baseUrl = "https://helios.cohesity.com"
$commonHeaders = @{ "apiKey" = $apiKey }

# -------------------------------
# Helpers (same style as failures script)
# -------------------------------
function Convert-ToUtcFromEpoch($v){
    if ($null -eq $v -or $v -eq 0) { return $null }
    try {
        # handles microseconds by dividing by 1000
        [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$v/1000)).UtcDateTime
    }
    catch {
        [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$v).UtcDateTime
    }
}

function Convert-ToLocalFromUsecs($usecs, $tz){
    $utc = Convert-ToUtcFromEpoch $usecs
    if ($null -eq $utc) { return $null }
    if ($tz) { [System.TimeZoneInfo]::ConvertTimeFromUtc($utc,$tz) } else { $utc.ToLocalTime() }
}

function Format-Duration {
    param(
        [double]$Hours
    )
    if ($Hours -lt 0) {
        $Hours = 0
    }
    $ts    = [TimeSpan]::FromHours($Hours)
    $days  = [int][Math]::Floor($ts.TotalDays)
    $hrs   = $ts.Hours
    $mins  = $ts.Minutes
    # 1d 0h 05m
    return ("{0}d {1}h {2:00}m" -f $days, $hrs, $mins)
}

function Write-Log($msg,$color="Gray"){
    # flip to $true if you want verbose debug here
    if($script:VerboseMode){
        Write-Host $msg -ForegroundColor $color
    }
}

# EST (to match your failures script style)
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")

# -------------------------------
# Get Helios-managed clusters
# -------------------------------
try {
    $resp = Invoke-WebRequest -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders -Method Get
    $json_clu = ($resp.Content | ConvertFrom-Json).cohesityClusters
} catch {
    throw "Failed to query Helios clusters: $($_.Exception.Message)"
}

if (-not $json_clu) { throw "No clusters returned from Helios." }

# -------------------------------
# Collectors: Backup vs Replication/Archival
# -------------------------------
$backupRows    = New-Object System.Collections.ArrayList
$replicaRows   = New-Object System.Collections.ArrayList

Write-Host "=============================================" -ForegroundColor Cyan
Write-Host "   COHESITY LONG-RUNNING JOBS ‚Äì ALL CLUSTERS" -ForegroundColor White
Write-Host "=============================================" -ForegroundColor Cyan
Write-Host ("Threshold: {0} hours`n" -f $thresholdHours) -ForegroundColor Yellow

foreach ($cluster in $json_clu) {

    $cluster_name = ($cluster.name, $cluster.clusterName, $cluster.displayName |
                    Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
    if (-not $cluster_name) { $cluster_name = "Unknown-$($cluster.clusterId)" }

    $headers = @{
        apiKey        = $apiKey
        accessClusterId = $cluster.clusterId  # NOTE: no 'clusters:' param; Helios prefers this header
    }

    Write-Log ("`nüîπ Processing cluster: {0}" -f $cluster_name) "Cyan"

    # Active protection groups
    try {
        $pgResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups" -Headers $headers -Method Get -Body @{
            isDeleted = "False"
            isPaused  = "False"
            isActive  = "True"
        }
        $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
    } catch {
        Write-Log ("‚ö†Ô∏è Failed to list PGs on {0}: {1}" -f $cluster_name, $_.Exception.Message) "Yellow"
        continue
    }
    if (-not $pgs) { continue }

    foreach ($pg in $pgs) {

        $pgId   = $pg.id
        $pgName = $pg.name
        $env    = $pg.environment

        Write-Log ("üì¶ Checking PG: {0} ({1})" -f $pgName, $env) "Yellow"

        # Get recent runs for this PG (GET-only)
        try {
            $runResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" `
                                         -Headers $headers -Method Get -Body @{
                numRuns                  = "50"
                excludeNonRestorableRuns = "False"
                includeObjectDetails     = "False"
            }
            $jsonRuns = $runResp.Content | ConvertFrom-Json
        } catch {
            Write-Log ("‚ö†Ô∏è Failed to list runs for PG {0} on {1}: {2}" -f $pgName, $cluster_name, $_.Exception.Message) "Yellow"
            continue
        }

        if (-not $jsonRuns -or -not $jsonRuns.runs) { continue }
        $runs = $jsonRuns.runs

        foreach ($run in $runs) {

            # -----------------------
            # BACKUP (Local) long-running
            # -----------------------
            if ($run.PSObject.Properties['localBackupInfo'] -and $run.localBackupInfo) {
                $backupInfo = $run.localBackupInfo

                $bStatus = $backupInfo.status
                # Cohesity uses values like "Running", "Succeeded", etc
                if ($bStatus -eq 'Running' -or $bStatus -eq 'kRunning') {

                    $startLocal = Convert-ToLocalFromUsecs $backupInfo.startTimeUsecs $tz
                    if ($null -ne $startLocal) {
                        $hoursRunning = ((Get-Date) - $startLocal).TotalHours
                        if ($hoursRunning -ge $thresholdHours) {

                            $durationStr = Format-Duration -Hours $hoursRunning

                            $null = $backupRows.Add([pscustomobject]@{
                                Cluster         = $cluster_name
                                ProtectionGroup = $pgName
                                Environment     = $run.environment
                                RunType         = $backupInfo.runType
                                StartTime       = $startLocal
                                Duration        = $durationStr
                                Status          = "Running"
                                CopyType        = "LocalBackup"
                            })
                        }
                    }
                }
            }

            # -----------------------
            # REPLICATION long-running (RemoteCluster)
            # -----------------------
            if ($run.PSObject.Properties['replicationInfo'] -and
                $run.replicationInfo -and
                $run.replicationInfo.replicationTargetResults) {

                foreach ($rTarget in $run.replicationInfo.replicationTargetResults) {

                    $rStatus = $rTarget.status
                    if ($rStatus -ne 'Running' -and $rStatus -ne 'kRunning') { continue }

                    $startLocalRep = Convert-ToLocalFromUsecs $rTarget.startTimeUsecs $tz
                    if ($null -eq $startLocalRep) { continue }

                    $hrsRep = ((Get-Date) - $startLocalRep).TotalHours
                    if ($hrsRep -lt $thresholdHours) { continue }

                    $durationRep = Format-Duration -Hours $hrsRep
                    $destName    = if ($rTarget.clusterName) { $rTarget.clusterName } else { "RemoteCluster" }

                    $null = $replicaRows.Add([pscustomobject]@{
                        Cluster         = $cluster_name
                        ProtectionGroup = $pgName
                        Environment     = $run.environment
                        RunType         = $run.localBackupInfo.runType
                        StartTime       = $startLocalRep
                        Duration        = $durationRep
                        Status          = "Running"
                        CopyType        = "RemoteReplication"
                        Destination     = $destName
                    })
                }
            }

            # -----------------------
            # ARCHIVAL long-running (Cloud targets)
            # -----------------------
            if ($run.PSObject.Properties['archivalInfo'] -and
                $run.archivalInfo -and
                $run.archivalInfo.archivalTargetResults) {

                foreach ($aTarget in $run.archivalInfo.archivalTargetResults) {

                    $aStatus = $aTarget.status
                    if ($aStatus -ne 'Running' -and $aStatus -ne 'kRunning') { continue }

                    $startLocalArch = Convert-ToLocalFromUsecs $aTarget.startTimeUsecs $tz
                    if ($null -eq $startLocalArch) { continue }

                    $hrsArch = ((Get-Date) - $startLocalArch).TotalHours
                    if ($hrsArch -lt $thresholdHours) { continue }

                    $durationArch = Format-Duration -Hours $hrsArch
                    $destName     = if ($aTarget.targetName) { $aTarget.targetName } else { $aTarget.targetType }

                    $null = $replicaRows.Add([pscustomobject]@{
                        Cluster         = $cluster_name
                        ProtectionGroup = $pgName
                        Environment     = $run.environment
                        RunType         = $aTarget.runType
                        StartTime       = $startLocalArch
                        Duration        = $durationArch
                        Status          = "Running"
                        CopyType        = "CloudArchival"
                        Destination     = $destName
                    })
                }
            }
        }
    }
}

$nowStamp  = Get-Date -Format "yyyyMMdd_HHmm"

# -------------------------------
# BACKUP TABLE + CSV
# -------------------------------
$backupRows = @($backupRows) | Sort-Object Cluster,ProtectionGroup,StartTime

Write-Host "`n==================================================" -ForegroundColor Cyan
Write-Host (" Jobs running longer than {0} hours (Backup ‚Äì Local)" -f $thresholdHours) -ForegroundColor White
Write-Host "==================================================" -ForegroundColor Cyan

if ($backupRows.Count -gt 0) {
    $backupRows | Format-Table Cluster,ProtectionGroup,Environment,RunType,StartTime,Duration,Status -AutoSize

    $backupCsv = Join-Path $logDirectory ("LongRunningJobs_Backup_AllClusters_Over{0}h_{1}.csv" -f $thresholdHours,$nowStamp)
    $backupRows | Select-Object Cluster,ProtectionGroup,Environment,RunType,StartTime,Duration,Status,CopyType |
        Export-Csv -Path $backupCsv -NoTypeInformation -Encoding utf8

    Write-Host ("`nüìÇ Backup CSV saved: {0}" -f $backupCsv) -ForegroundColor Gray
} else {
    Write-Host ("‚úÖ No BACKUP (local) jobs running longer than {0} hours across all clusters." -f $thresholdHours) -ForegroundColor Green
}

# -------------------------------
# REPLICATION / ARCHIVAL TABLE + CSV
# -------------------------------
$replicaRows = @($replicaRows) | Sort-Object Cluster,ProtectionGroup,StartTime

Write-Host "`n============================================================" -ForegroundColor Cyan
Write-Host (" Jobs running longer than {0} hours (Replication/Archival)" -f $thresholdHours) -ForegroundColor White
Write-Host "============================================================" -ForegroundColor Cyan

if ($replicaRows.Count -gt 0) {
    $replicaRows | Format-Table Cluster,ProtectionGroup,Environment,RunType,CopyType,Destination,StartTime,Duration,Status -AutoSize

    $replicaCsv = Join-Path $logDirectory ("LongRunningJobs_Replication_AllClusters_Over{0}h_{1}.csv" -f $thresholdHours,$nowStamp)
    $replicaRows | Select-Object Cluster,ProtectionGroup,Environment,RunType,CopyType,Destination,StartTime,Duration,Status |
        Export-Csv -Path $replicaCsv -NoTypeInformation -Encoding utf8

    Write-Host ("`nüìÇ Replication/Archival CSV saved: {0}" -f $replicaCsv) -ForegroundColor Gray
} else {
    Write-Host ("‚úÖ No REPLICATION/ARCHIVAL jobs running longer than {0} hours across all clusters." -f $thresholdHours) -ForegroundColor Green
}

Write-Host "`n‚úÖ Long-running jobs scan complete.`n" -ForegroundColor Cyan
