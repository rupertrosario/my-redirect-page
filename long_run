# =====================================================================
# Cohesity Running Jobs ‚Äì Multi-Cluster (Helios, API key)
# GET-only | Read-only
#
# What this script does:
#   - Queries Helios for all managed clusters
#   - For each cluster, lists active protection groups
#   - For each PG, gets runs via:
#       GET /v2/data-protect/protection-groups/{id}/runs
#   - Finds ALL runs where:
#       * localBackupInfo.status is Running   (backup)
#       * replicationTargetResults / archivalTargetResults are Running
#   - Calculates duration for each run (Xd Yh ZZm)
#   - Adds a flag IsLongRunning if duration ‚â• $thresholdHours
#   - Produces two tables + two CSVs:
#       1) Backup (Local)
#       2) Replication / Archival (Remote/Cloud)
#
# IMPORTANT:
#   - No POST/PUT/DELETE: all calls are GET (safe / read-only)
#   - No 'clusters:' parameter; we use accessClusterId header like your failures script
# =====================================================================

# Threshold in hours to mark a job as "long-running"
# (we do NOT filter by this, just flag with IsLongRunning)
$thresholdHours = 24

# -------------------------------
# Folder + API key
# -------------------------------
$logDirectory = "X:\PowerShell\Data\Cohesity\LongRunningJobs"
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory | Out-Null
}

# Hygiene 1: keep at most 50 newest files
try {
    $files = Get-ChildItem -Path $logDirectory -File -ErrorAction Stop
    if ($files.Count -gt 50) {
        $toDelete = $files | Sort-Object CreationTime | Select-Object -First ($files.Count - 50)
        $count = ($toDelete | Measure-Object).Count
        if ($count -gt 0) {
            $toDelete | Remove-Item -Force -ErrorAction SilentlyContinue
            Write-Host "üßπ Removed $count old files to keep last 50." -ForegroundColor DarkGray
        }
    }
} catch {}

# Hygiene 2: delete anything older than 30 days
try {
    $thresholdDate = (Get-Date).AddDays(-30)
    $older = Get-ChildItem -Path $logDirectory -File -ErrorAction SilentlyContinue |
             Where-Object { $_.LastWriteTime -lt $thresholdDate }
    $oldCount = ($older | Measure-Object).Count
    if ($oldCount -gt 0) {
        $older | Remove-Item -Force -ErrorAction SilentlyContinue
        Write-Host "üßΩ Deleted $oldCount files older than 30 days." -ForegroundColor DarkGray
    }
} catch {}

$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()

$baseUrl       = "https://helios.cohesity.com"
$commonHeaders = @{ "apiKey" = $apiKey }

# -------------------------------
# Helpers (matching your style)
# -------------------------------
function Convert-ToUtcFromEpoch($v){
    if ($null -eq $v -or $v -eq 0) { return $null }
    try {
        # Cohesity time values are in microseconds; divide by 1000 ‚Üí ms
        [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$v/1000)).UtcDateTime
    }
    catch {
        [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$v).UtcDateTime
    }
}

function Convert-ToLocalFromUsecs($usecs, $tz){
    $utc = Convert-ToUtcFromEpoch $usecs
    if ($null -eq $utc) { return $null }
    if ($tz) { [System.TimeZoneInfo]::ConvertTimeFromUtc($utc,$tz) } else { $utc.ToLocalTime() }
}

function Format-Duration {
    param([double]$Hours)

    if ($Hours -lt 0) { $Hours = 0 }
    $ts   = [TimeSpan]::FromHours($Hours)
    $days = [int][Math]::Floor($ts.TotalDays)
    $hrs  = $ts.Hours
    $mins = $ts.Minutes
    # Example: "1d 0h 05m"
    return ("{0}d {1}h {2:00}m" -f $days, $hrs, $mins)
}

function Write-Log($msg,$color="Gray"){
    if($script:VerboseMode){
        Write-Host $msg -ForegroundColor $color
    }
}

# Use same timezone style as your failures script
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")

# -------------------------------
# Get Helios-managed clusters
# -------------------------------
try {
    $resp     = Invoke-WebRequest -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders -Method Get
    $json_clu = ($resp.Content | ConvertFrom-Json).cohesityClusters
} catch {
    throw "Failed to query Helios clusters: $($_.Exception.Message)"
}

if (-not $json_clu) { throw "No clusters returned from Helios." }

# -------------------------------
# Collections: Backup vs Replication/Archival
# -------------------------------
$backupRows  = New-Object System.Collections.ArrayList
$replRows    = New-Object System.Collections.ArrayList

Write-Host "==================================================" -ForegroundColor Cyan
Write-Host "   COHESITY RUNNING JOBS ‚Äì ALL CLUSTERS (Helios)" -ForegroundColor White
Write-Host "==================================================" -ForegroundColor Cyan
Write-Host ("Flagging IsLongRunning when runtime ‚â• {0} hours" -f $thresholdHours) -ForegroundColor Yellow

foreach ($cluster in $json_clu) {

    $cluster_name = ($cluster.name, $cluster.clusterName, $cluster.displayName |
                     Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
    if (-not $cluster_name) { $cluster_name = "Unknown-$($cluster.clusterId)" }

    $headers = @{
        apiKey          = $apiKey
        accessClusterId = $cluster.clusterId     # ‚úÖ cluster scope via header, no 'clusters:' param
    }

    Write-Log ("`nüîπ Processing cluster: {0}" -f $cluster_name) "Cyan"

    # Active protection groups (GET-only)
    try {
        $pgResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups" `
                                    -Headers $headers -Method Get -Body @{
            isDeleted = "False"
            isPaused  = "False"
            isActive  = "True"
        }
        $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
    } catch {
        Write-Log ("‚ö†Ô∏è Failed to list PGs on {0}: {1}" -f $cluster_name, $_.Exception.Message) "Yellow"
        continue
    }

    if (-not $pgs) { continue }

    foreach ($pg in $pgs) {

        $pgId   = $pg.id
        $pgName = $pg.name
        $pgEnv  = $pg.environment

        Write-Log ("üì¶ PG: {0} ({1})" -f $pgName, $pgEnv) "Gray"

        # GET /v2/data-protect/protection-groups/{id}/runs
        try {
            $runResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" `
                                         -Headers $headers -Method Get -Body @{
                numRuns                  = "50"
                excludeNonRestorableRuns = "False"
                includeObjectDetails     = "False"
            }
            $jsonRuns = $runResp.Content | ConvertFrom-Json
        } catch {
            Write-Log ("‚ö†Ô∏è Failed to list runs for PG {0} on {1}: {2}" -f $pgName, $cluster_name, $_.Exception.Message) "Yellow"
            continue
        }

        if (-not $jsonRuns -or -not $jsonRuns.runs) { continue }
        $runs = $jsonRuns.runs

        foreach ($run in $runs) {

            # -----------------------
            # BACKUP (local) ‚Äì ALL running backups
            # -----------------------
            if ($run.PSObject.Properties['localBackupInfo'] -and $run.localBackupInfo) {
                $bInfo   = $run.localBackupInfo
                $bStatus = $bInfo.status

                # We care about any RUNNING backup
                if ($bStatus -eq 'Running' -or $bStatus -eq 'kRunning') {

                    $startLocal = Convert-ToLocalFromUsecs $bInfo.startTimeUsecs $tz
                    if ($null -ne $startLocal) {
                        $hoursRunning  = ((Get-Date) - $startLocal).TotalHours
                        $durationStr   = Format-Duration -Hours $hoursRunning
                        $isLongRunning = if ($hoursRunning -ge $thresholdHours) { "Yes" } else { "No" }

                        $null = $backupRows.Add([pscustomobject]@{
                            Cluster         = $cluster_name
                            ProtectionGroup = $pgName
                            Environment     = $pgEnv
                            RunType         = $bInfo.runType
                            StartTime       = $startLocal
                            Duration        = $durationStr
                            HoursRunning    = [math]::Round($hoursRunning,2)
                            Status          = "Running"
                            IsLongRunning   = $isLongRunning
                            CopyType        = "LocalBackup"
                        })
                    }
                }
            }

            # -----------------------
            # REPLICATION ‚Äì ALL running replica copies
            # -----------------------
            if ($run.PSObject.Properties['replicationInfo'] -and
                $run.replicationInfo -and
                $run.replicationInfo.replicationTargetResults) {

                foreach ($rTarget in $run.replicationInfo.replicationTargetResults) {

                    $rStatus = $rTarget.status
                    if ($rStatus -ne 'Running' -and $rStatus -ne 'kRunning') { continue }

                    $startLocalRep = Convert-ToLocalFromUsecs $rTarget.startTimeUsecs $tz
                    if ($null -eq $startLocalRep) { continue }

                    $hrsRep        = ((Get-Date) - $startLocalRep).TotalHours
                    $durationRep   = Format-Duration -Hours $hrsRep
                    $isLongRunning = if ($hrsRep -ge $thresholdHours) { "Yes" } else { "No" }
                    $destName      = if ($rTarget.clusterName) { $rTarget.clusterName } else { "RemoteCluster" }

                    $null = $replRows.Add([pscustomobject]@{
                        Cluster         = $cluster_name
                        ProtectionGroup = $pgName
                        Environment     = $pgEnv
                        RunType         = $run.localBackupInfo.runType
                        CopyType        = "RemoteReplication"
                        Destination     = $destName
                        StartTime       = $startLocalRep
                        Duration        = $durationRep
                        HoursRunning    = [math]::Round($hrsRep,2)
                        Status          = "Running"
                        IsLongRunning   = $isLongRunning
                    })
                }
            }

            # -----------------------
            # ARCHIVAL ‚Äì ALL running archive copies
            # -----------------------
            if ($run.PSObject.Properties['archivalInfo'] -and
                $run.archivalInfo -and
                $run.archivalInfo.archivalTargetResults) {

                foreach ($aTarget in $run.archivalInfo.archivalTargetResults) {

                    $aStatus = $aTarget.status
                    if ($aStatus -ne 'Running' -and $aStatus -ne 'kRunning') { continue }

                    $startLocalArch = Convert-ToLocalFromUsecs $aTarget.startTimeUsecs $tz
                    if ($null -eq $startLocalArch) { continue }

                    $hrsArch       = ((Get-Date) - $startLocalArch).TotalHours
                    $durationArch  = Format-Duration -Hours $hrsArch
                    $isLongRunning = if ($hrsArch -ge $thresholdHours) { "Yes" } else { "No" }
                    $destName      = if ($aTarget.targetName) { $aTarget.targetName } else { $aTarget.targetType }

                    $null = $replRows.Add([pscustomobject]@{
                        Cluster         = $cluster_name
                        ProtectionGroup = $pgName
                        Environment     = $pgEnv
                        RunType         = $aTarget.runType
                        CopyType        = "CloudArchival"
                        Destination     = $destName
                        StartTime       = $startLocalArch
                        Duration        = $durationArch
                        HoursRunning    = [math]::Round($hrsArch,2)
                        Status          = "Running"
                        IsLongRunning   = $isLongRunning
                    })
                }
            }
        }
    }
}

$timestamp = Get-Date -Format "yyyyMMdd_HHmm"

# -------------------------------
# BACKUP ‚Äì all running backup jobs
# -------------------------------
$backupRows = @($backupRows) | Sort-Object Cluster,ProtectionGroup,StartTime

Write-Host "`n==============================================" -ForegroundColor Cyan
Write-Host " Running BACKUP Jobs (Local) ‚Äì All Clusters"   -ForegroundColor White
Write-Host "==============================================" -ForegroundColor Cyan

if ($backupRows.Count -gt 0) {
    $backupRows |
        Select-Object Cluster,ProtectionGroup,Environment,RunType,StartTime,Duration,HoursRunning,Status,IsLongRunning |
        Format-Table -AutoSize

    $backupCsv = Join-Path $logDirectory ("RunningJobs_Backup_AllClusters_{0}.csv" -f $timestamp)
    $backupRows |
        Select-Object Cluster,ProtectionGroup,Environment,RunType,StartTime,Duration,HoursRunning,Status,IsLongRunning,CopyType |
        Export-Csv -Path $backupCsv -NoTypeInformation -Encoding utf8

    Write-Host ("`nüìÇ Backup CSV saved: {0}" -f $backupCsv) -ForegroundColor Gray
} else {
    Write-Host "‚úÖ No BACKUP jobs currently running on any cluster." -ForegroundColor Green
}

# -------------------------------
# REPLICATION / ARCHIVAL ‚Äì all running
# -------------------------------
$replRows = @($replRows) | Sort-Object Cluster,ProtectionGroup,StartTime

Write-Host "`n====================================================" -ForegroundColor Cyan
Write-Host " Running REPLICATION / ARCHIVAL Jobs ‚Äì All Clusters" -ForegroundColor White
Write-Host "====================================================" -ForegroundColor Cyan

if ($replRows.Count -gt 0) {
    $replRows |
        Select-Object Cluster,ProtectionGroup,Environment,RunType,CopyType,Destination,StartTime,Duration,HoursRunning,Status,IsLongRunning |
        Format-Table -AutoSize

    $replCsv = Join-Path $logDirectory ("RunningJobs_Replication_AllClusters_{0}.csv" -f $timestamp)
    $replRows |
        Select-Object Cluster,ProtectionGroup,Environment,RunType,CopyType,Destination,StartTime,Duration,HoursRunning,Status,IsLongRunning |
        Export-Csv -Path $replCsv -NoTypeInformation -Encoding utf8

    Write-Host ("`nüìÇ Replication/Archival CSV saved: {0}" -f $replCsv) -ForegroundColor Gray
} else {
    Write-Host "‚úÖ No REPLICATION/ARCHIVAL jobs currently running on any cluster." -ForegroundColor Green
}

Write-Host "`n‚úÖ Running jobs scan complete.`n" -ForegroundColor Cyan
