# =====================================================================
# Cohesity Long-Running Jobs ‚Äì Multi-Cluster (Helios, API key)
# GET-only | Read-only
#
# Logic:
#   ‚Ä¢ Discover all Helios-managed clusters (v2/mcm/cluster-mgmt/info)
#   ‚Ä¢ For each cluster, list active Protection Groups (v2/data-protect/protection-groups)
#   ‚Ä¢ For each PG, fetch runs via:
#       GET /v2/data-protect/protection-groups/{id}/runs
#       with:
#         localBackupRunStatus[0]  = Running
#         replicationRunStatus[0]  = Running
#   ‚Ä¢ From ALL running runs, compute runtime and KEEP ONLY:
#         runtime >= $thresholdHours
#   ‚Ä¢ Output:
#       1) Backup (Local) jobs running >= threshold
#       2) Replication/Archival (Remote) jobs running >= threshold
#   ‚Ä¢ Each row includes "Location" = Local/Remote and a duration like: 1d 0h 05m
# =====================================================================

# Threshold in hours
$thresholdHours = 24

# -------------------------------
# Folder + API key (same pattern as failures script)
# -------------------------------
$logDirectory = "X:\PowerShell\Data\Cohesity\LongRunningJobs"
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory | Out-Null
}

# Hygiene 1: keep at most 50 newest files
try {
    $files = Get-ChildItem -Path $logDirectory -File -ErrorAction Stop
    if ($files.Count -gt 50) {
        $toDelete = $files | Sort-Object CreationTime | Select-Object -First ($files.Count - 50)
        $count = ($toDelete | Measure-Object).Count
        if ($count -gt 0) {
            $toDelete | Remove-Item -Force -ErrorAction SilentlyContinue
            Write-Host "üßπ Removed $count old files to keep last 50." -ForegroundColor DarkGray
        }
    }
} catch {}

# Hygiene 2: delete anything older than 30 days
try {
    $thresholdDate = (Get-Date).AddDays(-30)
    $older = Get-ChildItem -Path $logDirectory -File -ErrorAction SilentlyContinue |
             Where-Object { $_.LastWriteTime -lt $thresholdDate }
    $oldCount = ($older | Measure-Object).Count
    if ($oldCount -gt 0) {
        $older | Remove-Item -Force -ErrorAction SilentlyContinue
        Write-Host "üßΩ Deleted $oldCount files older than 30 days." -ForegroundColor DarkGray
    }
} catch {}

$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()

$baseUrl       = "https://helios.cohesity.com"
$commonHeaders = @{ "apiKey" = $apiKey }

# -------------------------------
# Helpers (aligned with your failures script)
# -------------------------------
function Convert-ToUtcFromEpoch($v){
    if ($null -eq $v -or $v -eq 0) { return $null }
    try {
        # Cohesity times are usually in microseconds; divide by 1000 ‚Üí ms
        [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$v/1000)).UtcDateTime
    }
    catch {
        [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$v).UtcDateTime
    }
}

function Convert-ToLocalFromUsecs($usecs, $tz){
    $utc = Convert-ToUtcFromEpoch $usecs
    if ($null -eq $utc) { return $null }
    if ($tz) { [System.TimeZoneInfo]::ConvertTimeFromUtc($utc,$tz) } else { $utc.ToLocalTime() }
}

function Format-Duration {
    param([double]$Hours)

    if ($Hours -lt 0) { $Hours = 0 }
    $ts   = [TimeSpan]::FromHours($Hours)
    $days = [int][Math]::Floor($ts.TotalDays)
    $hrs  = $ts.Hours
    $mins = $ts.Minutes
    # 1d 0h 05m
    return ("{0}d {1}h {2:00}m" -f $days, $hrs, $mins)
}

function Write-Log($msg,$color="Gray"){
    if($script:VerboseMode){
        Write-Host $msg -ForegroundColor $color
    }
}

# Same time zone style as your failures script
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")

# -------------------------------
# Get clusters (Helios ‚Äì GET only)
# -------------------------------
try {
    $resp     = Invoke-WebRequest -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders -Method Get
    $json_clu = ($resp.Content | ConvertFrom-Json).cohesityClusters
} catch {
    throw "Failed to query Helios clusters: $($_.Exception.Message)"
}

if (-not $json_clu) { throw "No clusters returned from Helios." }

# -------------------------------
# Collections: Backup vs Replication/Archival (only long-running)
# -------------------------------
$backupRows = New-Object System.Collections.ArrayList
$replRows   = New-Object System.Collections.ArrayList

Write-Host "==================================================" -ForegroundColor Cyan
Write-Host "   COHESITY LONG-RUNNING JOBS ‚Äì ALL CLUSTERS"      -ForegroundColor White
Write-Host "==================================================" -ForegroundColor Cyan
Write-Host ("Threshold: {0} hours (only jobs ‚â• threshold shown)" -f $thresholdHours) -ForegroundColor Yellow

foreach ($cluster in $json_clu) {

    $cluster_name = ($cluster.name, $cluster.clusterName, $cluster.displayName |
                     Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
    if (-not $cluster_name) { $cluster_name = "Unknown-$($cluster.clusterId)" }

    $headers = @{
        apiKey          = $apiKey
        accessClusterId = $cluster.clusterId   # ‚úÖ No 'clusters:' param; we scope via header
    }

    Write-Log ("`nüîπ Processing cluster: {0}" -f $cluster_name) "Cyan"

    # Active PGs
    try {
        $pgResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups" `
                                    -Headers $headers -Method Get -Body @{
            isDeleted = "False"
            isPaused  = "False"
            isActive  = "True"
        }
        $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
    } catch {
        Write-Log ("‚ö†Ô∏è Failed to list PGs on {0}: {1}" -f $cluster_name, $_.Exception.Message) "Yellow"
        continue
    }

    if (-not $pgs) { continue }

    foreach ($pg in $pgs) {

        $pgId   = $pg.id
        $pgName = $pg.name
        $pgEnv  = $pg.environment

        Write-Log ("üì¶ PG: {0} ({1})" -f $pgName, $pgEnv) "Gray"

        # GET /data-protect/protection-groups/{id}/runs
        # Note: using localBackupRunStatus & replicationRunStatus filters as you requested
        try {
            $runResp = Invoke-WebRequest `
                -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" `
                -Headers $headers -Method Get -Body @{
                    numRuns                      = "50"
                    excludeNonRestorableRuns     = "False"
                    includeObjectDetails         = "False"
                    'localBackupRunStatus[0]'    = "Running"
                    'replicationRunStatus[0]'    = "Running"
                }

            $jsonRuns = $runResp.Content | ConvertFrom-Json
        } catch {
            Write-Log ("‚ö†Ô∏è Failed to list runs for PG {0} on {1}: {2}" -f $pgName, $cluster_name, $_.Exception.Message) "Yellow"
            continue
        }

        if (-not $jsonRuns -or -not $jsonRuns.runs) { continue }
        $runs = $jsonRuns.runs

        foreach ($run in $runs) {

            # -----------------------
            # BACKUP (LOCAL) ‚Äì check ALL running backups, then keep ‚â• thresholdHours
            # -----------------------
            if ($run.PSObject.Properties['localBackupInfo'] -and $run.localBackupInfo) {
                $bInfo = $run.localBackupInfo[0]
                if (-not $bInfo) { }
                else {
                    $bStatus = $bInfo.status
                    if ($bStatus -eq 'Running' -or $bStatus -eq 'kRunning') {

                        $startLocal = Convert-ToLocalFromUsecs $bInfo.startTimeUsecs $tz
                        if ($null -ne $startLocal) {
                            $hoursRunning = ((Get-Date).ToUniversalTime() - $startLocal.ToUniversalTime()).TotalHours

                            # Only keep those running ‚â• thresholdHours
                            if ($hoursRunning -ge $thresholdHours) {
                                $durationStr = Format-Duration -Hours $hoursRunning

                                $null = $backupRows.Add([pscustomobject]@{
                                    Cluster         = $cluster_name
                                    ProtectionGroup = $pgName
                                    Environment     = $pgEnv
                                    RunType         = $bInfo.runType
                                    StartTime       = $startLocal
                                    Duration        = $durationStr
                                    HoursRunning    = [math]::Round($hoursRunning,2)
                                    Status          = "Running"
                                    Location        = "Local"     # <-- explicitly says local
                                    CopyType        = "Backup"
                                })
                            }
                        }
                    }
                }
            }

            # -----------------------
            # REPLICATION & ARCHIVAL ‚Äì from localBackupInfo
            # -----------------------
            if ($run.PSObject.Properties['localBackupInfo'] -and $run.localBackupInfo) {
                $info = $run.localBackupInfo[0]
                if ($info) {

                    # Replication info (remote cluster)
                    if ($info.PSObject.Properties['replicationInfo'] -and $info.replicationInfo) {
                        foreach ($rep in $info.replicationInfo) {

                            $rStatus = $rep.status
                            if ($rStatus -ne 'Running' -and $rStatus -ne 'kRunning') { continue }

                            $startLocalRep = Convert-ToLocalFromUsecs $rep.startTimeUsecs $tz
                            if ($null -eq $startLocalRep) { continue }

                            $hrsRep = ((Get-Date).ToUniversalTime() - $startLocalRep.ToUniversalTime()).TotalHours
                            if ($hrsRep -lt $thresholdHours) { continue }

                            $durationRep = Format-Duration -Hours $hrsRep
                            $destName   = $null
                            if ($rep.PSObject.Properties['targetClusterName'] -and $rep.targetClusterName) {
                                $destName = $rep.targetClusterName
                            } elseif ($rep.PSObject.Properties['targetName'] -and $rep.targetName) {
                                $destName = $rep.targetName
                            } elseif ($rep.PSObject.Properties['targetType'] -and $rep.targetType) {
                                $destName = $rep.targetType
                            } else {
                                $destName = "RemoteTarget"
                            }

                            $null = $replRows.Add([pscustomobject]@{
                                Cluster         = $cluster_name
                                ProtectionGroup = $pgName
                                Environment     = $pgEnv
                                RunType         = $info.runType
                                StartTime       = $startLocalRep
                                Duration        = $durationRep
                                HoursRunning    = [math]::Round($hrsRep,2)
                                Status          = "Running"
                                Location        = "Remote"       # <-- explicitly says remote
                                CopyType        = "Replication"
                                Destination     = $destName
                            })
                        }
                    }

                    # Archival info (cloud / tape / external)
                    if ($info.PSObject.Properties['archivalInfo'] -and $info.archivalInfo) {
                        foreach ($arch in $info.archivalInfo) {

                            $aStatus = $arch.status
                            if ($aStatus -ne 'Running' -and $aStatus -ne 'kRunning') { continue }

                            $startLocalArch = Convert-ToLocalFromUsecs $arch.startTimeUsecs $tz
                            if ($null -eq $startLocalArch) { continue }

                            $hrsArch = ((Get-Date).ToUniversalTime() - $startLocalArch.ToUniversalTime()).TotalHours
                            if ($hrsArch -lt $thresholdHours) { continue }

                            $durationArch = Format-Duration -Hours $hrsArch
                            $destName     = $null
                            if ($arch.PSObject.Properties['targetName'] -and $arch.targetName) {
                                $destName = $arch.targetName
                            } elseif ($arch.PSObject.Properties['targetType'] -and $arch.targetType) {
                                $destName = $arch.targetType
                            } else {
                                $destName = "ArchivalTarget"
                            }

                            $null = $replRows.Add([pscustomobject]@{
                                Cluster         = $cluster_name
                                ProtectionGroup = $pgName
                                Environment     = $pgEnv
                                RunType         = $arch.runType
                                StartTime       = $startLocalArch
                                Duration        = $durationArch
                                HoursRunning    = [math]::Round($hrsArch,2)
                                Status          = "Running"
                                Location        = "Remote"       # <-- remote (cloud/tape)
                                CopyType        = "Archival"
                                Destination     = $destName
                            })
                        }
                    }
                }
            }
        }
    }
}

$timestamp = Get-Date -Format "yyyyMMdd_HHmm"

# -------------------------------
# BACKUP ‚Äì jobs running ‚â• thresholdHours
# -------------------------------
$backupRows = @($backupRows) | Sort-Object Cluster,ProtectionGroup,StartTime

Write-Host "`n==================================================" -ForegroundColor Cyan
Write-Host (" Jobs running longer than {0} hours ‚Äì BACKUP (Local)" -f $thresholdHours) -ForegroundColor White
Write-Host "==================================================" -ForegroundColor Cyan

if ($backupRows.Count -gt 0) {
    $backupRows |
        Select-Object Cluster,ProtectionGroup,Environment,RunType,StartTime,Duration,HoursRunning,Status,Location |
        Format-Table -AutoSize

    $backupCsv = Join-Path $logDirectory ("LongRunningJobs_Backup_AllClusters_Over{0}h_{1}.csv" -f $thresholdHours,$timestamp)
    $backupRows |
        Select-Object Cluster,ProtectionGroup,Environment,RunType,StartTime,Duration,HoursRunning,Status,Location,CopyType |
        Export-Csv -Path $backupCsv -NoTypeInformation -Encoding utf8

    Write-Host ("`nüìÇ Backup CSV saved: {0}" -f $backupCsv) -ForegroundColor Gray
} else {
    Write-Host ("‚úÖ No BACKUP (local) jobs running longer than {0} hours across all clusters." -f $thresholdHours) -ForegroundColor Green
}

# -------------------------------
# REPLICATION / ARCHIVAL ‚Äì jobs running ‚â• thresholdHours
# -------------------------------
$replRows = @($replRows) | Sort-Object Cluster,ProtectionGroup,StartTime

Write-Host "`n================================================================" -ForegroundColor Cyan
Write-Host (" Jobs running longer than {0} hours ‚Äì REPLICATION / ARCHIVAL" -f $thresholdHours) -ForegroundColor White
Write-Host "================================================================" -ForegroundColor Cyan

if ($replRows.Count -gt 0) {
    $replRows |
        Select-Object Cluster,ProtectionGroup,Environment,RunType,CopyType,Destination,StartTime,Duration,HoursRunning,Status,Location |
        Format-Table -AutoSize

    $replCsv = Join-Path $logDirectory ("LongRunningJobs_Replication_AllClusters_Over{0}h_{1}.csv" -f $thresholdHours,$timestamp)
    $replRows |
        Select-Object Cluster,ProtectionGroup,Environment,RunType,CopyType,Destination,StartTime,Duration,HoursRunning,Status,Location |
        Export-Csv -Path $replCsv -NoTypeInformation -Encoding utf8

    Write-Host ("`nüìÇ Replication/Archival CSV saved: {0}" -f $replCsv) -ForegroundColor Gray
} else {
    Write-Host ("‚úÖ No REPLICATION/ARCHIVAL jobs running longer than {0} hours across all clusters." -f $thresholdHours) -ForegroundColor Green
}

Write-Host "`n‚úÖ Long-running jobs scan complete.`n" -ForegroundColor Cyan
