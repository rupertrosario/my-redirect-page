# =====================================================================
# Cohesity Long-Running Jobs ‚Äì Multi-Cluster (Helios)
# Shows jobs where *any copy* (backup / replication / archival)
# has been Running for >= 24 hours.
#
# Output:
#   - Table 1: Backup (Local) long-running copies
#   - Table 2: Remote (Replication + Archival) long-running copies
#   - CSVs only when rows exist, UTF-8
# API behaviour:
#   - Helios + apiKey
#   - v2 /mcm/cluster-mgmt/info + /data-protect/protection-groups + /{id}/runs
#   - GET only (no POST/DELETE/etc.)
# =====================================================================

# -------------------------------
# Folder + API key
# -------------------------------
$logDirectory = "X:\PowerShell\Data\Cohesity\LongRunningJobs"
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
    New-Item -Path $logDirectory -ItemType Directory | Out-Null
}

# Hygiene 1: keep at most 50 newest files
try {
    $files = Get-ChildItem -Path $logDirectory -File -ErrorAction Stop
    if ($files.Count -gt 50) {
        $toDelete = $files | Sort-Object CreationTime | Select-Object -First ($files.Count - 50)
        $count = ($toDelete | Measure-Object).Count
        if ($count -gt 0) {
            $toDelete | Remove-Item -Force -ErrorAction SilentlyContinue
            Write-Host "üßπ Removed $count old files to keep last 50."
        }
    }
} catch {}

# Hygiene 2: delete anything older than 30 days
try {
    $threshold = (Get-Date).AddDays(-30)
    $older = Get-ChildItem -Path $logDirectory -File -ErrorAction SilentlyContinue |
             Where-Object { $_.LastWriteTime -lt $threshold }
    $oldCount = ($older | Measure-Object).Count
    if ($oldCount -gt 0) {
        $older | Remove-Item -Force -ErrorAction SilentlyContinue
        Write-Host "üßΩ Deleted $oldCount files older than 30 days."
    }
} catch {}

$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()

$baseUrl       = "https://helios.cohesity.com"
$commonHeaders = @{ "apiKey" = $apiKey }

# -------------------------------
# Helpers
# -------------------------------
function Convert-ToUtcFromEpoch {
    param($v)
    if ($null -eq $v -or $v -eq 0) { return $null }

    # Your failure script passes *usecs* here; reuse the same logic
    try {
        # divide by 1000 for usecs -> millis
        [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$v / 1000)).UtcDateTime
    } catch {
        [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$v).UtcDateTime
    }
}

function Convert-ToLocalFromUsecs {
    param(
        $usecs,
        [System.TimeZoneInfo]$tz
    )
    $utc = Convert-ToUtcFromEpoch $usecs
    if ($null -eq $utc) { return $null }
    if ($tz) {
        [System.TimeZoneInfo]::ConvertTimeFromUtc($utc, $tz)
    } else {
        $utc.ToLocalTime()
    }
}

function Format-Duration {
    param([double]$Hours)

    if ($Hours -lt 0) { return "0d 0h 0m" }

    $totalMinutes = [math]::Floor($Hours * 60)
    $days         = [math]::Floor($totalMinutes / (24 * 60))
    $remMinutes   = $totalMinutes - ($days * 24 * 60)
    $hrs          = [math]::Floor($remMinutes / 60)
    $mins         = $remMinutes - ($hrs * 60)

    "{0}d {1}h {2}m" -f $days, $hrs, $mins
}

$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")

# Adjust this if you ever want a different threshold
$thresholdHours = 24

# -------------------------------
# Get clusters (Helios)
# -------------------------------
try {
    $resp     = Invoke-WebRequest -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders -Method Get
    $json_clu = ($resp.Content | ConvertFrom-Json).cohesityClusters
} catch {
    throw "Failed to query Helios clusters: $($_.Exception.Message)"
}

if (-not $json_clu) { throw "No clusters returned from Helios." }

# -------------------------------
# Collect running copies
# -------------------------------
$backupRows = @()  # Local backup copies
$remoteRows = @()  # Replication + Archival copies

foreach ($cluster in $json_clu) {

    $cluster_name = ($cluster.name, $cluster.clusterName, $cluster.displayName |
                     Where-Object { $_ -and $_.Trim() } |
                     Select-Object -First 1)
    if (-not $cluster_name) { $cluster_name = "Unknown-$($cluster.clusterId)" }

    $headers = @{
        apiKey          = $apiKey
        accessClusterId = $cluster.clusterId
    }

    Write-Host "`nüîπ Processing cluster: $cluster_name" -ForegroundColor Cyan

    # Get Protection Groups on this cluster
    try {
        $pgResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups" -Headers $headers -Body @{
            isDeleted = "False"
            isPaused  = "False"
            isActive  = "True"
        } -Method Get

        $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
    } catch {
        Write-Host "  ‚ö†Ô∏è Failed to list PGs on $cluster_name:_
