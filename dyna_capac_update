// Cohesity Helios â€” Capacity + Garbage + Version + Location + Node Count
// GET-only. Decimal units: GB=1e9, TB=1e12.
// Behavior:
// - Cluster down / non-200 on capacity: SKIP cluster (no row)
// - Garbage entityId variants: silence expected HTTP 400 (kInvalidInput/entity does not exist)
// - If all garbage variants fail: garbageBytes=0 (shows 0.00)

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ===== Units (DECIMAL) =====
  const oneGB = 1e9;
  const oneTB = 1e12;

  // ===== Auth (Vault name -> Vault id -> manual fallback) =====
  const vaultName = "Cohesity_API_Key";
  const vaultId = "CREDENTIALS_VAULT-7F2FF2BB6BCD9B63";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find((c) => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log(`âœ“ loaded Helios key from vault (name): ${found.name}`);
    return detail?.token || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = detail?.token || null;
      authMode = "vault-id";
      console.log(`âœ“ loaded Helios key from vault (id): ${detail?.name || vaultId}`);
    } catch {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("âš  using manual Helios API key (fallback)");
    }
  }

  const headers = { accept: "application/json", apiKey };

  // ===== Helpers =====
  const fmt = (v, digits = 2) =>
    v === null || v === undefined || Number.isNaN(v) ? "-" : (+v).toFixed(digits);
  const fmtPct = (v) =>
    v === null || v === undefined || Number.isNaN(v) ? "-" : `${(+v).toFixed(2)}%`;
  const badge = (p) =>
    p === null || p === undefined || Number.isNaN(p) ? "âš ï¸" : p >= 80 ? "ðŸ”´" : p > 70 ? "ðŸŸ¡" : "ðŸŸ¢";

  async function safeText(resp) {
    try {
      return await resp.text();
    } catch {
      return "";
    }
  }
  async function safeJson(resp) {
    try {
      return await resp.json();
    } catch {
      return null;
    }
  }

  // Prevent hangs
  async function fetchWithTimeout(url, opts, timeoutMs = 15000) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      return await fetch(url, { ...opts, signal: ctrl.signal });
    } finally {
      clearTimeout(t);
    }
  }

  // ===== Cluster list =====
  const listResp = await fetchWithTimeout(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { method: "GET", headers }, 15000);
  if (listResp.status !== 200) {
    const txt = await safeText(listResp);
    throw new Error(`cluster list failed (${listResp.status}) ${txt}`);
  }

  const listJson = await safeJson(listResp);
  const clusters = listJson?.cohesityClusters || [];
  if (!clusters.length) {
    const msg = "ðŸ“Š **Cohesity Cluster Capacity Report**\n\n_No clusters returned._";
    return { clusters: [], report: msg, authMode };
  }

  console.log(`found ${clusters.length} clusters`);

  // ===== Garbage helper (returns bytes; 0 if all variants fail) =====
  async function getGarbageLatest(clusterName, clusterId, h) {
    const safeName = (clusterName || "").replace(/\s+/g, " ").trim();
    const variants = [
      `${safeName}+(ID+${clusterId})`,
      `${safeName}(ID ${clusterId})`,
      `${safeName} (ID ${clusterId})`,
      `${clusterName}(ID ${clusterId})`,
    ];

    for (const v of variants) {
      const encId = encodeURIComponent(v);
      const url =
        `${baseUrl}/irisservices/api/v1/public/statistics/timeSeriesStats` +
        `?schemaName=ApolloV2ClusterStats` +
        `&metricName=EstimatedGarbageBytes` +
        `&startTimeMsecs=2` +
        `&entityId=${encId}` +
        `&rollupFunction=latest` +
        `&rollupIntervalSecs=30` +
        `&metricUnitType=0` +
        `&range=day`;

      let resp;
      try {
        resp = await fetchWithTimeout(url, { method: "GET", headers: h }, 15000);
      } catch {
        continue;
      }

      if (resp.status !== 200) {
        // Silence expected bad-entityId responses
        if (resp.status === 400) continue; // kInvalidInput / entity does not exist
        continue; // keep quiet for other non-200s too
      }

      const js = await safeJson(resp);
      const vec = js?.dataPointVec || [];
      if (!vec.length) continue;

      const last = vec[vec.length - 1];
      return last?.data?.int64Value ?? 0;
    }

    return 0;
  }

  const results = [];

  // ===== Per-cluster stats =====
  await Promise.all(
    clusters.map(async ({ clusterName, clusterId, currentVersion, location, numberOfNodes }) => {
      const h = { ...headers, accessClusterId: String(clusterId) };

      // capacity
      const capUrl = `${baseUrl}/irisservices/api/v1/public/stats/storage`;

      let capResp;
      try {
        capResp = await fetchWithTimeout(capUrl, { method: "GET", headers: h }, 15000);
      } catch {
        console.log(`skipping ${clusterName}: fetch error`);
        return; // DO NOT REPORT
      }

      if (capResp.status !== 200) {
        console.log(`skipping ${clusterName}: HTTP ${capResp.status}`);
        return; // DO NOT REPORT
      }

      const s = await safeJson(capResp);
      if (!s) {
        console.log(`skipping ${clusterName}: invalid JSON`);
        return; // DO NOT REPORT
      }

      const totalBytes = s?.totalCapacityBytes ?? 0;
      const usedBytes = s?.localUsageBytes ?? 0;
      const availBytes = s?.localAvailableBytes ?? 0;

      // Capacity in TB (DECIMAL)
      const totalTB = +(totalBytes / oneTB).toFixed(2);
      const usedTB = +(usedBytes / oneTB).toFixed(2);
      const availTB = +(availBytes / oneTB).toFixed(2);
      const percent = +(totalBytes ? ((usedBytes / totalBytes) * 100).toFixed(2) : (0).toFixed(2));

      // Garbage in GB/TB (DECIMAL)
      const garbageBytes = await getGarbageLatest(clusterName, clusterId, h);
      const garbageGB = +(garbageBytes / oneGB).toFixed(2);
      const garbageTB = +(garbageBytes / oneTB).toFixed(3);

      results.push({
        clusterName,
        location: location || "Unknown",
        version: currentVersion || "Unknown",
        numberOfNodes: numberOfNodes || 0,
        totalTB,
        usedTB,
        availTB,
        consumedPercent: percent,
        garbageGB,
        garbageTB,
      });

      console.log(
        `âœ“ ${clusterName} | v${currentVersion || "?"} | nodes:${numberOfNodes || 0} | ${usedTB}/${totalTB} TB | ${percent}%`
      );
    })
  );

  // ===== Markdown report =====
  const rows = results.sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  const header = [
    "ðŸ“Š **Cohesity Cluster Capacity Report**",
    "",
    "| Cluster | Location | Version | Nodes | Used TB | Avail TB | % Used | Status | Garbage GB | Garbage TB |",
    "|---|---|---|---:|---:|---:|---:|:---:|---:|---:|",
  ].join("\n");

  const body = rows
    .map(
      (c) =>
        `| ${c.clusterName} | ${c.location} | ${c.version} | ${c.numberOfNodes} | ` +
        `${fmt(c.usedTB, 2)} | ${fmt(c.availTB, 2)} | ${fmtPct(c.consumedPercent)} | ${badge(c.consumedPercent)} | ` +
        `${fmt(c.garbageGB, 2)} | ${fmt(c.garbageTB, 3)} |`
    )
    .join("\n");

  const footer = [
    "",
    `**Total clusters in report: ${rows.length}**`,
    "",
    "ðŸŸ¢ = Healthy (â‰¤ 70%)",
    "ðŸŸ¡ = Warning (70â€“79%)",
    "ðŸ”´ = Critical (â‰¥ 80%)",
    "",
    `// Auth mode used: **${authMode}**`,
  ].join("\n");

  const report = [header, body, footer].join("\n");

  return { clusters: rows, report, authMode };
}
