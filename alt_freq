# ------------------------------------------------------------
# Helios Alerts (GET only): last 24 hours (ET), latest per (ClusterId + NodeId)
# - Does NOT change system time
# - Does NOT use POST/PUT/PATCH/DELETE (GET only)
# - Uses startDateUsecs / endDateUsecs (epoch microseconds)
# ------------------------------------------------------------

$ErrorActionPreference = "Stop"
try { [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 } catch {}

# ===========================
# 0) API Key
# ===========================
$apikeypath = "X:\PowerShell\Cohesity_API_scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }

$ApiKey = (Get-Content -Path $apikeypath -Raw).Trim()
if (-not $ApiKey) { throw "API key is empty: $apikeypath" }

$commonHeaders = @{ "apiKey" = $ApiKey }

# ===========================
# 0.5) Time Window: last 24h in ET -> UTC epoch usecs
# ===========================
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")  # ET (DST aware)

$nowUtc = (Get-Date).ToUniversalTime()
$endEt   = [System.TimeZoneInfo]::ConvertTimeFromUtc($nowUtc, $tz)
$startEt = $endEt.AddHours(-24)

$endUtc   = [System.TimeZoneInfo]::ConvertTimeToUtc($endEt, $tz)
$startUtc = [System.TimeZoneInfo]::ConvertTimeToUtc($startEt, $tz)

$endUsecs   = [int64]([DateTimeOffset]$endUtc).ToUnixTimeSeconds()   * 1000000
$startUsecs = [int64]([DateTimeOffset]$startUtc).ToUnixTimeSeconds() * 1000000

# ===========================
# 1) Get Clusters
# ===========================
$uri = "https://helios.cohesity.com/v2/mcm/cluster-mgmt/info"
$response = Invoke-WebRequest -Method Get -Uri $uri -Headers $commonHeaders -UseBasicParsing
if ($response.StatusCode -ne 200) { throw "Cluster call failed: HTTP $($response.StatusCode)" }

$json_clu = $response.Content | ConvertFrom-Json
$json_clu = $json_clu.cohesityClusters
if (-not $json_clu) { throw "No cohesityClusters returned." }

# ===========================
# 2) Get Alerts per cluster (GET only), extract node_id, collect rows
# ===========================
$results = @()

# --- SANITY (prints, doesnâ€™t change anything) ---
Write-Host ("SANITY: ET window = {0}  ->  {1}" -f $startEt, $endEt)
Write-Host ("SANITY: UTC window = {0}  ->  {1}" -f $startUtc, $endUtc)
Write-Host ("SANITY: startDateUsecs={0} endDateUsecs={1}" -f $startUsecs, $endUsecs)
Write-Host ("SANITY: clusters found = {0}" -f $json_clu.Count)

foreach ($clus in $json_clu) {

  $cluster_name = $clus.clusterName
  $cluster_id   = $clus.clusterId

  $headers = @{
    "apiKey"          = "$ApiKey"
    "accessClusterId" = "$cluster_id"
  }

  # URL already filters the alert type(s) you want + time window (last 24h ET)
  $URL_EP = "https://helios.cohesity.com/v2/alerts" +
            "?maxAlerts=200" +
            "&alertTypes=11001" +
            "&alertStates=kOpen,kNote" +
            "&alertCategories=kNodeHealth" +
            "&startDateUsecs=$startUsecs" +
            "&endDateUsecs=$endUsecs"

  $r = Invoke-WebRequest -Method Get -Uri $URL_EP -Headers $headers -UseBasicParsing
  if ($r.StatusCode -ne 200) {
    Write-Host ("WARN: alerts call failed for {0} ({1}): HTTP {2}" -f $cluster_name, $cluster_id, $r.StatusCode)
    continue
  }

  $json = $r.Content | ConvertFrom-Json

  # If no alerts array, skip cleanly
  if (-not $json.alerts) { continue }

  foreach ($alt in @($json.alerts)) {

    # propertyList key = node_id
    $prop = $alt.propertyList | Where-Object { $_.key -eq 'node_id' } | Select-Object -First 1
    $nodeId = $prop.value
    if (-not $nodeId) { $nodeId = $prop.values }  # some payloads use "values"

    $results += [pscustomobject]@{
      ClusterName          = $cluster_name
      ClusterId            = $cluster_id
      ClusterNodeId        = $nodeId
      AlertCode            = $alt.alertCode
      AlertState           = $alt.alertState
      Severity             = $alt.severity
      AlertCause           = $alt.alertDocument.alertCause
      LatestTimestampUsecs = $alt.latestTimestampUsecs
      #Id                 = $alt.id
    }
  }
}

# ===========================
# 3) Latest per Cluster + Node, sort newest first
# ===========================
$latestPerClusterNode = $results |
  Where-Object { $_.ClusterNodeId } |
  Group-Object { "$($_.ClusterId)|$($_.ClusterNodeId)" } |
  ForEach-Object { $_.Group | Sort-Object LatestTimestampUsecs -Descending | Select-Object -First 1 } |
  Sort-Object LatestTimestampUsecs -Descending

# --- SANITY counts ---
Write-Host ("SANITY: raw rows collected = {0}" -f $results.Count)
Write-Host ("SANITY: latest per (cluster|node) = {0}" -f $latestPerClusterNode.Count)

$latestPerClusterNode | Format-Table -AutoSize
