# ------------------------------------------------------------
# Helios Alerts (GET only):
# - Multiple alertTypes (comma-separated in URL)
# - Optional alertCategories, alertStates
# - Optional filter to multiple node_ids
# - Window: last 24 hours in ET, enforced locally via latestTimestampUsecs
# - Latest per (ClusterId + NodeId)
# - Output: human readable ET time
# ------------------------------------------------------------

$ErrorActionPreference = "Stop"
try { [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 } catch {}

# ---------------------------
# User options (edit these)
# ---------------------------
$ApiKeyPath = "X:\PowerShell\Cohesity_API_scripts\DO_NOT_Delete\apikey.txt"

# Multiple codes:
$AlertTypes = @("11001","1105")   # <-- put as many as you want

# States:
$AlertStates = @("kOpen")         # recommended default
# If you want both open and noted/acknowledged-like:
# $AlertStates = @("kOpen","kNote")

# Categories are optional. Leave empty to not send this filter at all.
$AlertCategories = @()            # e.g. @("kNodeHealth","kNetworking")

$MaxAlerts = 200

# Optional: only these node IDs (leave empty to include all nodes)
$NodeIds = @()                    # e.g. @("1","2","3")

# ---------------------------
# Helpers
# ---------------------------
function Join-Query([string]$k, [string[]]$vals) {
  if (-not $vals -or $vals.Count -eq 0) { return $null }
  return "$k=$([Uri]::EscapeDataString(($vals -join ',')))"
}

function Convert-UsecsToEtString([int64]$usecs, $tz) {
  if (-not $usecs -or $usecs -le 0) { return $null }
  $sec = [int64]($usecs / 1000000)
  $utc = [DateTimeOffset]::FromUnixTimeSeconds($sec).UtcDateTime
  $et  = [System.TimeZoneInfo]::ConvertTimeFromUtc($utc, $tz)
  $et.ToString("yyyy-MM-dd HH:mm:ss")
}

# ---------------------------
# API Key
# ---------------------------
if (-not (Test-Path $ApiKeyPath)) { throw "API key file not found at $ApiKeyPath" }
$ApiKey = (Get-Content -Path $ApiKeyPath -Raw).Trim()
if (-not $ApiKey) { throw "API key is empty: $ApiKeyPath" }

$commonHeaders = @{ apiKey = $ApiKey }

# ---------------------------
# ET window (last 24h) -> epoch usecs
# ---------------------------
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")  # ET, DST-aware

$nowUtc  = (Get-Date).ToUniversalTime()
$endEt   = [System.TimeZoneInfo]::ConvertTimeFromUtc($nowUtc, $tz)
$startEt = $endEt.AddHours(-24)

$endUtc   = [System.TimeZoneInfo]::ConvertTimeToUtc($endEt, $tz)
$startUtc = [System.TimeZoneInfo]::ConvertTimeToUtc($startEt, $tz)

$endUsecs   = [int64]([DateTimeOffset]$endUtc).ToUnixTimeSeconds()   * 1000000
$startUsecs = [int64]([DateTimeOffset]$startUtc).ToUnixTimeSeconds() * 1000000

$windowStartEtStr = $startEt.ToString("yyyy-MM-dd HH:mm:ss")
$windowEndEtStr   = $endEt.ToString("yyyy-MM-dd HH:mm:ss")

# ---------------------------
# Get clusters
# ---------------------------
$clusterUri = "https://helios.cohesity.com/v2/mcm/cluster-mgmt/info"
$clusterResp = Invoke-WebRequest -Method Get -Uri $clusterUri -Headers $commonHeaders -UseBasicParsing
$clusters = (($clusterResp.Content | ConvertFrom-Json).cohesityClusters)
if (-not $clusters) { throw "No clusters returned." }

# ---------------------------
# Query string builder (kept simple for future JS)
# ---------------------------
$q = @()
$q += "maxAlerts=$MaxAlerts"
$q += (Join-Query "alertTypes" $AlertTypes)
$q += (Join-Query "alertStates" $AlertStates)
$q += (Join-Query "alertCategories" $AlertCategories)
$q += "startDateUsecs=$startUsecs"
$q += "endDateUsecs=$endUsecs"
$q = $q | Where-Object { $_ }  # remove nulls

# ---------------------------
# Fetch alerts per cluster and collect
# ---------------------------
$results = @()

foreach ($clus in $clusters) {

  $cluster_name = $clus.clusterName
  $cluster_id   = $clus.clusterId

  $headers = @{
    apiKey          = $ApiKey
    accessClusterId = "$cluster_id"
  }

  $alertsUrl = "https://helios.cohesity.com/v2/alerts?$($q -join '&')"

  $r = Invoke-WebRequest -Method Get -Uri $alertsUrl -Headers $headers -UseBasicParsing
  $json = $r.Content | ConvertFrom-Json
  if (-not $json.alerts) { continue }

  foreach ($alt in @($json.alerts)) {

    # Enforce last 24h window locally (donâ€™t rely on API honoring the params)
    if (-not $alt.latestTimestampUsecs) { continue }
    $latestUsecs = [int64]$alt.latestTimestampUsecs
    if ($latestUsecs -lt $startUsecs -or $latestUsecs -gt $endUsecs) { continue }

    # node_id from propertyList
    $prop = $alt.propertyList | Where-Object { $_.key -eq 'node_id' } | Select-Object -First 1
    $nodeId = $prop.value
    if (-not $nodeId) { $nodeId = $prop.values }

    # Optional node filter (multiple node_ids)
    if ($NodeIds.Count -gt 0 -and ($NodeIds -notcontains "$nodeId")) { continue }

    $results += [pscustomobject]@{
      ClusterName   = $cluster_name
      ClusterId     = $cluster_id
      ClusterNodeId = $nodeId
      AlertCode     = $alt.alertCode
      AlertState    = $alt.alertState
      Severity      = $alt.severity
      AlertCause    = $alt.alertDocument.alertCause
      WindowStartET = $windowStartEtStr
      WindowEndET   = $windowEndEtStr
      LatestTimeET  = (Convert-UsecsToEtString $latestUsecs $tz)
      LatestUsecs   = $latestUsecs
    }
  }
}

# ---------------------------
# Latest per (ClusterId + NodeId), sorted newest first
# ---------------------------
$latestPerClusterNode =
  $results |
  Where-Object { $_.ClusterNodeId } |
  Group-Object { "$($_.ClusterId)|$($_.ClusterNodeId)" } |
  ForEach-Object { $_.Group | Sort-Object LatestUsecs -Descending | Select-Object -First 1 } |
  Sort-Object LatestUsecs -Descending

$latestPerClusterNode |
Select-Object ClusterName, ClusterId, ClusterNodeId, AlertCode, Severity, AlertState, AlertCause, WindowStartET, WindowEndET, LatestTimeET |
Format-Table -AutoSize
