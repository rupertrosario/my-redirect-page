# ------------------------------------------------------------
# Helios Alerts (GET only):
# - Multiple alertTypes (comma-separated in URL)
# - Optional alertCategories, alertStates
# - Optional filter to multiple node_ids
# - Window: last 24 hours in ET, enforced locally via latestTimestampUsecs
# - Latest per (ClusterId + NodeId)
# - Output: table with IP + human readable ET time + Wrap (no truncation)
# ------------------------------------------------------------

$ErrorActionPreference = "Stop"
try { [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 } catch {}

# ---------------------------
# User options (edit these)
# ---------------------------
$ApiKeyPath = "X:\PowerShell\Cohesity_API_scripts\DO_NOT_Delete\apikey.txt"

$AlertTypes = @("11001","1105")      # <-- edit as needed
$AlertStates = @("kOpen")            # or @("kOpen","kNote")
$AlertCategories = @()               # optional; e.g. @("kNodeHealth","kNetworking")
$MaxAlerts = 200

$NodeIds = @()                       # optional; e.g. @("1","2","3")

# ---------------------------
# Helpers
# ---------------------------
function Join-Query([string]$k, [string[]]$vals) {
  if (-not $vals -or $vals.Count -eq 0) { return $null }
  return "$k=$([Uri]::EscapeDataString(($vals -join ',')))"
}

function Convert-UsecsToEtString([int64]$usecs, $tz) {
  if (-not $usecs -or $usecs -le 0) { return $null }
  $sec = [int64]($usecs / 1000000)
  $utc = [DateTimeOffset]::FromUnixTimeSeconds($sec).UtcDateTime
  $et  = [System.TimeZoneInfo]::ConvertTimeFromUtc($utc, $tz)
  $et.ToString("yyyy-MM-dd HH:mm:ss")
}

function Get-Prop([object[]]$plist, [string[]]$keys) {
  if (-not $plist) { return $null }
  foreach ($k in $keys) {
    $p = $plist | Where-Object { $_.key -eq $k } | Select-Object -First 1
    if ($p) {
      if ($p.value) { return $p.value }
      if ($p.values) { return $p.values }
    }
  }
  return $null
}

# ---------------------------
# API Key
# ---------------------------
if (-not (Test-Path $ApiKeyPath)) { throw "API key file not found at $ApiKeyPath" }
$ApiKey = (Get-Content -Path $ApiKeyPath -Raw).Trim()
if (-not $ApiKey) { throw "API key is empty: $ApiKeyPath" }

$commonHeaders = @{ apiKey = $ApiKey }

# ---------------------------
# ET window (last 24h) -> epoch usecs
# ---------------------------
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")  # ET, DST-aware

$nowUtc  = (Get-Date).ToUniversalTime()
$endEt   = [System.TimeZoneInfo]::ConvertTimeFromUtc($nowUtc, $tz)
$startEt = $endEt.AddHours(-24)

$endUtc   = [System.TimeZoneInfo]::ConvertTimeToUtc($endEt, $tz)
$startUtc = [System.TimeZoneInfo]::ConvertTimeToUtc($startEt, $tz)

$endUsecs   = [int64]([DateTimeOffset]$endUtc).ToUnixTimeSeconds()   * 1000000
$startUsecs = [int64]([DateTimeOffset]$startUtc).ToUnixTimeSeconds() * 1000000

# ---------------------------
# Get clusters
# ---------------------------
$clusterUri  = "https://helios.cohesity.com/v2/mcm/cluster-mgmt/info"
$clusterResp = Invoke-WebRequest -Method Get -Uri $clusterUri -Headers $commonHeaders -UseBasicParsing
$clusters    = (($clusterResp.Content | ConvertFrom-Json).cohesityClusters)
if (-not $clusters) { throw "No clusters returned." }

# ---------------------------
# Build query
# ---------------------------
$q = @()
$q += "maxAlerts=$MaxAlerts"
$q += (Join-Query "alertTypes" $AlertTypes)
$q += (Join-Query "alertStates" $AlertStates)
$q += (Join-Query "alertCategories" $AlertCategories)
$q += "startDateUsecs=$startUsecs"
$q += "endDateUsecs=$endUsecs"
$q = $q | Where-Object { $_ }

# ---------------------------
# Fetch alerts per cluster and collect
# ---------------------------
$results = @()

foreach ($clus in $clusters) {

  $cluster_name = $clus.clusterName
  $cluster_id   = $clus.clusterId

  $headers = @{
    apiKey          = $ApiKey
    accessClusterId = "$cluster_id"
  }

  $alertsUrl = "https://helios.cohesity.com/v2/alerts?$($q -join '&')"

  $r = Invoke-WebRequest -Method Get -Uri $alertsUrl -Headers $headers -UseBasicParsing
  $json = $r.Content | ConvertFrom-Json
  if (-not $json.alerts) { continue }

  foreach ($alt in @($json.alerts)) {

    # Enforce last 24h window locally
    if (-not $alt.latestTimestampUsecs) { continue }
    $latestUsecs = [int64]$alt.latestTimestampUsecs
    if ($latestUsecs -lt $startUsecs -or $latestUsecs -gt $endUsecs) { continue }

    # Node ID + IP from propertyList (keys vary by alert type; try common ones)
    $nodeId = Get-Prop $alt.propertyList @("node_id","nodeId")
    $ip     = Get-Prop $alt.propertyList @("node_ip","ip","ipAddress","host_ip","source_ip","sourceIp","remote_ip","remoteIp")

    # Optional node filter (multiple node_ids)
    if ($NodeIds.Count -gt 0 -and ($NodeIds -notcontains "$nodeId")) { continue }

    $results += [pscustomobject]@{
      ClusterName   = $cluster_name
      ClusterId     = $cluster_id
      ClusterNodeId = $nodeId
      IP            = $ip
      AlertCode     = $alt.alertCode
      Severity      = $alt.severity
      AlertState    = $alt.alertState
      AlertCause    = $alt.alertDocument.alertCause
      LatestTimeET  = (Convert-UsecsToEtString $latestUsecs $tz)
      LatestUsecs   = $latestUsecs
    }
  }
}

# ---------------------------
# Latest per (ClusterId + NodeId), sorted newest first
# ---------------------------
$latestPerClusterNode =
  $results |
  Where-Object { $_.ClusterNodeId } |
  Group-Object { "$($_.ClusterId)|$($_.ClusterNodeId)" } |
  ForEach-Object { $_.Group | Sort-Object LatestUsecs -Descending | Select-Object -First 1 } |
  Sort-Object LatestUsecs -Descending

# ---------------------------
# Output (no window start/end, include IP)
# ---------------------------
$latestPerClusterNode |
Select-Object ClusterName, ClusterId, ClusterNodeId, IP, AlertCode, Severity, AlertState, AlertCause, LatestTimeET |
Format-Table -AutoSize -Wrap
