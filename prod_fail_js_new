import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * =====================================================================
 * Cohesity Helios – Cluster + PG Selector (GET-only) — Dynatrace Workflow JS
 * - Non-interactive selector driven by variables (ALL/ID/NAME)
 * - Returns selectedClusters, selectedPGs, markdownEmail
 *
 * Vaulting: uses the EXACT vault section style from your reference script.
 * =====================================================================
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // =========================================================
  // SELECTOR INPUTS (edit these defaults or pass as env vars)
  // =========================================================
  // Cluster selection: ALL | ID | NAME
  const CLUSTER_SELECT_MODE = String(process.env.CLUSTER_SELECT_MODE || "ALL").trim().toUpperCase();
  const CLUSTER_SELECT_VALUE = String(process.env.CLUSTER_SELECT_VALUE || "").trim();

  // PG selection: ALL | ID | NAME
  const PG_SELECT_MODE = String(process.env.PG_SELECT_MODE || "ALL").trim().toUpperCase();
  const PG_SELECT_VALUE = String(process.env.PG_SELECT_VALUE || "").trim();

  // =========================================================
  // AUTH (vault id) ✅ EXACT style from your reference script
  // =========================================================
  const vaultId = String(process.env.COHESITY_VAULT_ID || "credentials_vault-312312").trim();
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // GET helper (same style)
  // ==============================
  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try {
        txt = await resp.text();
      } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // ==============================
  // Markdown helpers
  // ==============================
  function mdEscape(s) {
    return String(s ?? "").replace(/\|/g, "\\|").replace(/[\r\n]+/g, " ").trim();
  }

  function mdTable(headers, rows) {
    const out = [];
    out.push(`| ${headers.map(mdEscape).join(" | ")} |`);
    out.push(`| ${headers.map(() => "---").join(" | ")} |`);
    for (const r of rows) {
      out.push(`| ${headers.map((h) => mdEscape(r[h])).join(" | ")} |`);
    }
    return out.join("\n");
  }

  function pickName(c) {
    return (
      String(c?.name || "").trim() ||
      String(c?.clusterName || "").trim() ||
      String(c?.displayName || "").trim() ||
      `Unknown-${c?.clusterId}`
    );
  }

  // ==============================
  // 1) CLUSTERS
  // ==============================
  const clu = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { ...commonHeaders, Accept: "application/json" });
  const clustersRaw = Array.isArray(clu?.cohesityClusters) ? clu.cohesityClusters : [];
  if (!clustersRaw.length) throw new Error("No clusters returned from /v2/mcm/cluster-mgmt/info");

  const clusters = clustersRaw
    .map((c) => ({
      clusterName: pickName(c),
      clusterId: String(c?.clusterId ?? "").trim(),
    }))
    .filter((c) => c.clusterId)
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName))
    .map((c, i) => ({ index: i + 1, ...c }));

  // ==============================
  // 2) SELECT CLUSTERS (ALL/ID/NAME)
  // ==============================
  let selectedClusters = clusters;

  if (CLUSTER_SELECT_MODE === "ID") {
    if (!CLUSTER_SELECT_VALUE) throw new Error("CLUSTER_SELECT_MODE=ID requires CLUSTER_SELECT_VALUE=<clusterId>");
    selectedClusters = clusters.filter((c) => c.clusterId === CLUSTER_SELECT_VALUE);
  } else if (CLUSTER_SELECT_MODE === "NAME") {
    if (!CLUSTER_SELECT_VALUE) throw new Error("CLUSTER_SELECT_MODE=NAME requires CLUSTER_SELECT_VALUE=<exact clusterName>");
    selectedClusters = clusters.filter((c) => c.clusterName === CLUSTER_SELECT_VALUE);
  } else if (CLUSTER_SELECT_MODE !== "ALL") {
    throw new Error("CLUSTER_SELECT_MODE must be ALL | ID | NAME");
  }

  if (!selectedClusters.length) {
    throw new Error(`No clusters matched. Mode=${CLUSTER_SELECT_MODE} Value=${CLUSTER_SELECT_VALUE || "(empty)"}`);
  }

  // ==============================
  // 3) PGs (active only) per selected cluster
  // ==============================
  const pgRows = [];

  for (const c of selectedClusters) {
    const headers = {
      ...commonHeaders,
      Accept: "application/json",
      accessClusterId: String(c.clusterId),
    };

    let pgJson;
    try {
      pgJson = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups?isDeleted=false&isPaused=false&isActive=true`,
        headers
      );
    } catch (e) {
      // fail-open per cluster (but you still get visibility in markdown)
      pgRows.push({
        clusterName: c.clusterName,
        clusterId: c.clusterId,
        pgName: "⚠️NO_DATA",
        pgId: "",
        policyId: "",
        environment: "",
        _error: String(e?.message || e),
      });
      continue;
    }

    const pgs = Array.isArray(pgJson?.protectionGroups) ? pgJson.protectionGroups : [];
    for (const pg of pgs) {
      pgRows.push({
        clusterName: c.clusterName,
        clusterId: c.clusterId,
        pgName: String(pg?.name ?? "").trim(),
        pgId: String(pg?.id ?? "").trim(),
        policyId: String(pg?.policyId ?? "").trim(),
        environment: pg?.environment ?? "",
      });
    }
  }

  const pgsActive = pgRows
    .filter((r) => r.pgName && r.pgName !== "⚠️NO_DATA")
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName) || a.pgName.localeCompare(b.pgName))
    .map((r, i) => ({ index: i + 1, ...r }));

  if (!pgsActive.length) throw new Error("No protection groups found in selected cluster scope.");

  // ==============================
  // 4) SELECT PGs (ALL/ID/NAME)
  // ==============================
  let selectedPGs = pgsActive;

  if (PG_SELECT_MODE === "ID") {
    if (!PG_SELECT_VALUE) throw new Error("PG_SELECT_MODE=ID requires PG_SELECT_VALUE=<pgId>");
    selectedPGs = pgsActive.filter((p) => p.pgId === PG_SELECT_VALUE);
  } else if (PG_SELECT_MODE === "NAME") {
    if (!PG_SELECT_VALUE) throw new Error("PG_SELECT_MODE=NAME requires PG_SELECT_VALUE=<exact pgName>");
    selectedPGs = pgsActive.filter((p) => p.pgName === PG_SELECT_VALUE);
  } else if (PG_SELECT_MODE !== "ALL") {
    throw new Error("PG_SELECT_MODE must be ALL | ID | NAME");
  }

  if (!selectedPGs.length) {
    throw new Error(`No PGs matched. Mode=${PG_SELECT_MODE} Value=${PG_SELECT_VALUE || "(empty)"}`);
  }

  // ==============================
  // MARKDOWN EMAIL
  // ==============================
  const clustersTable = mdTable(
    ["Index", "ClusterName", "ClusterId"],
    selectedClusters.map((x) => ({
      Index: x.index,
      ClusterName: x.clusterName,
      ClusterId: x.clusterId,
    }))
  );

  const pgsTable = mdTable(
    ["Index", "ClusterName", "PGName", "PGId", "PolicyId", "Environment"],
    selectedPGs.map((x) => ({
      Index: x.index,
      ClusterName: x.clusterName,
      PGName: x.pgName,
      PGId: x.pgId,
      PolicyId: x.policyId,
      Environment: x.environment ?? "",
    }))
  );

  const markdownEmail =
    `### Cohesity – Selected Clusters\n\n` +
    clustersTable +
    `\n\n### Cohesity – Selected Protection Groups\n\n` +
    pgsTable;

  // ==============================
  // OUTPUT
  // ==============================
  return {
    selectedClusters: selectedClusters.map((c) => ({
      index: c.index,
      clusterName: c.clusterName,
      clusterId: c.clusterId,
    })),
    selectedPGs: selectedPGs.map((p) => ({
      index: p.index,
      clusterName: p.clusterName,
      clusterId: p.clusterId,
      pgName: p.pgName,
      pgId: p.pgId,
      policyId: p.policyId,
      environment: p.environment ?? "",
    })),
    markdownEmail,
    markdownClustersTable: clustersTable,
    markdownPGsTable: pgsTable,
    counts: {
      clustersReturned: clusters.length,
      clustersSelected: selectedClusters.length,
      pgsReturnedInScope: pgsActive.length,
      pgsSelected: selectedPGs.length,
    },
    selector: {
      CLUSTER_SELECT_MODE,
      CLUSTER_SELECT_VALUE,
      PG_SELECT_MODE,
      PG_SELECT_VALUE,
      vaultIdUsed: vaultId,
    },
  };
}
