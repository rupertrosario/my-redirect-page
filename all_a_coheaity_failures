# =====================================================================
# Cohesity Helios â€” UNCLEARED failures from LAST 10 runs (per PG)
#
# Requirement:
# - Show all OBJECT failures across the last 10 runs per Protection Group
# - Suppress an older failure ONLY if that SAME object shows an explicit SUCCESS
#   in a newer run within those 10 runs.
#
# Critical correction:
# - Do NOT infer object success from runStatus.
# - Do NOT treat "no failedAttempts" as success.
# - Clear only when an explicit success marker exists for that object in the newer run.
#
# GET-only calls:
# - GET /v2/mcm/cluster-mgmt/info
# - GET /v2/data-protect/protection-groups
# - GET /v2/data-protect/protection-groups/{pgId}/runs
# =====================================================================

$ErrorActionPreference = "Stop"

# -------------------------
# Config
# -------------------------
$baseUrl    = "https://helios.cohesity.com"
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
$outDir     = "X:\PowerShell\Data\Cohesity\BackupFailures"
$numRuns    = 10

# SUCCESS MARKER MODE
#   "strict" = require explicit snapshot marker (recommended for your rerun scenario)
#   "loose"  = if localSnapshotInfo exists and no failedAttempts, treat as success (not recommended)
$SuccessMarkerMode = "strict"

if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
if (-not (Test-Path $outDir)) { New-Item -Path $outDir -ItemType Directory | Out-Null }

$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()
$commonHeaders = @{ apiKey = $apiKey }

# ET timezone (optional)
$tz = $null
try { $tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time") } catch { $tz = $null }

function Convert-ToLocalFromUsecs([object]$usecs) {
  if ($null -eq $usecs -or $usecs -eq 0) { return $null }
  $utc = [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$usecs/1000)).UtcDateTime
  if ($tz) { return [System.TimeZoneInfo]::ConvertTimeFromUtc($utc, $tz) }
  return $utc.ToLocalTime()
}

function CleanMsg([string]$s) {
  if ([string]::IsNullOrWhiteSpace($s)) { return $null }
  return ($s -replace "[\r\n]+"," " -replace ",",";" -replace '"','''').Trim()
}

function Get-ObjKey($o) {
  if ($o -and $o.object) {
    if ($o.object.id) { return [string]$o.object.id }
    $n = [string]$o.object.name
    $t = [string]$o.object.objectType
    $e = [string]$o.object.environment
    $s = if ($o.object.PSObject.Properties["sourceId"]) { [string]$o.object.sourceId } else { "" }
    return "$e|$t|$n|$s"
  }
  return $null
}

function Get-ObjName($o, [string]$nameField) {
  try {
    $v = $o.object.$nameField
    if ($v) { return [string]$v }
  } catch {}
  try { return [string]$o.object.name } catch { return $null }
}

function Has-ObjFailure($obj) {
  try {
    $fa = $obj.localSnapshotInfo.failedAttempts
    return ($fa -and $fa.Count -gt 0)
  } catch { return $false }
}

function Get-FirstFailureMsg($obj) {
  try {
    $fa = @($obj.localSnapshotInfo.failedAttempts)
    if ($fa -and $fa.Count -gt 0) {
      $m = $fa | ForEach-Object { CleanMsg $_.message } | Where-Object { $_ } | Select-Object -First 1
      if ($m) { return $m }
    }
  } catch {}
  return "Object failed (no message provided)"
}

function Has-Value($v) {
  if ($null -eq $v) { return $false }
  if ($v -is [string] -and [string]::IsNullOrWhiteSpace($v)) { return $false }
  return $true
}

function Get-PropValue($obj, [string]$propName) {
  try {
    $p = $obj.PSObject.Properties[$propName]
    if ($p) { return $p.Value }
  } catch {}
  return $null
}

function Is-ObjSucceededStrict($obj) {
  # Must NOT have failedAttempts
  if (Has-ObjFailure $obj) { return $false }

  $lsi = $null
  try { $lsi = $obj.localSnapshotInfo } catch { $lsi = $null }
  if (-not $lsi) { return $false }

  if ($SuccessMarkerMode -eq "loose") {
    return $true
  }

  # STRICT markers: require at least one explicit indicator of a created snapshot / success state
  $snapshotId   = Get-PropValue $lsi "snapshotId"
  $snapshotInfo = Get-PropValue $lsi "snapshotInfo"
  $stats        = Get-PropValue $lsi "stats"
  $status       = Get-PropValue $lsi "status"
  $attemptStatus= Get-PropValue $lsi "attemptStatus"

  if (Has-Value $snapshotId)   { return $true }
  if (Has-Value $snapshotInfo) { return $true }
  if (Has-Value $stats)        { return $true }

  # Some tenants return a status/attemptStatus at object level
  if (Has-Value $status) {
    $s = [string]$status
    if ($s -match "Success|Succeeded") { return $true }
  }
  if (Has-Value $attemptStatus) {
    $a = [string]$attemptStatus
    if ($a -match "Success|Succeeded") { return $true }
  }

  return $false
}

function Invoke-HeliosGet([string]$uri, [hashtable]$headers, [hashtable]$body) {
  $resp = Invoke-WebRequest -Uri $uri -Headers $headers -Method Get -Body $body
  return ($resp.Content | ConvertFrom-Json)
}

# -------------------------
# Select environment
# -------------------------
Write-Host "============================================================" -ForegroundColor Cyan
Write-Host " UNCLEARED Failures (Last $numRuns Runs / PG) â€” Select Env" -ForegroundColor White
Write-Host "============================================================" -ForegroundColor Cyan
Write-Host "1) Hyper-V     (kHyperv / kVirtualMachine)" -ForegroundColor Cyan
Write-Host "2) Acropolis   (kAcropolis / kVirtualMachine)" -ForegroundColor Cyan
Write-Host "3) Physical    (kPhysical / kHost)" -ForegroundColor Cyan
Write-Host "4) NAS         (kGenericNas,kIsilon / kHost)" -ForegroundColor Cyan
Write-Host "5) Oracle      (kOracle / kDatabase)" -ForegroundColor Cyan
Write-Host "6) SQL         (kSQL / kDatabase)" -ForegroundColor Cyan
$sel = Read-Host "Choose [1-6]"

$envFilter = $null
$objType   = $null
$nameField = "name"
$label     = $null
$needsHost = $false

switch ($sel) {
  "1" { $envFilter="kHyperv";             $objType="kVirtualMachine"; $label="Hyperv" }
  "2" { $envFilter="kAcropolis";          $objType="kVirtualMachine"; $label="Acropolis" }
  "3" { $envFilter="kPhysical";           $objType="kHost";           $label="Physical" }
  "4" { $envFilter="kGenericNas,kIsilon"; $objType="kHost";           $label="NAS" }
  "5" { $envFilter="kOracle";             $objType="kDatabase";       $label="Oracle"; $needsHost=$true }
  "6" { $envFilter="kSQL";                $objType="kDatabase";       $label="SQL";    $needsHost=$true }
  default { throw "Invalid selection." }
}

$envSet = $envFilter.Split(",") | ForEach-Object { $_.Trim() } | Where-Object { $_ }

# -------------------------
# Fetch clusters
# -------------------------
$clustersJson = Invoke-HeliosGet "$baseUrl/v2/mcm/cluster-mgmt/info" $commonHeaders @{}
$clusters = $clustersJson.cohesityClusters
if (-not $clusters) { throw "No clusters returned from Helios." }

# -------------------------
# Collect uncleared failures
# -------------------------
$results = New-Object System.Collections.Generic.List[object]

foreach ($c in $clusters) {
  $clusterName = @($c.name, $c.clusterName, $c.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
  if (-not $clusterName) { $clusterName = "Unknown-$($c.clusterId)" }

  $headers = @{ apiKey = $apiKey; accessClusterId = $c.clusterId }

  # PG list (active only)
  try {
    $pgJson = Invoke-HeliosGet "$baseUrl/v2/data-protect/protection-groups" $headers @{
      environments = $envFilter
      isDeleted    = "False"
      isPaused     = "False"
      isActive     = "True"
    }
    $pgs = @($pgJson.protectionGroups)
  } catch {
    Write-Host "PG list failed for $clusterName: $($_.Exception.Message)" -ForegroundColor Yellow
    continue
  }
  if (-not $pgs -or $pgs.Count -eq 0) { continue }

  foreach ($pg in $pgs) {
    $pgId   = $pg.id
    $pgName = $pg.name

    # Runs (last 10) â€” DO NOT send environments filter here (prevents mismatch/missed runs)
    try {
      $runsJson = Invoke-HeliosGet "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" $headers @{
        numRuns                  = "$numRuns"
        includeObjectDetails     = "True"
        excludeNonRestorableRuns = "False"
      }
      $runs = @($runsJson.runs)
    } catch {
      Write-Host "Runs fetch failed for $clusterName / $($pgName): $($_.Exception.Message)" -ForegroundColor Yellow
      continue
    }
    if (-not $runs -or $runs.Count -eq 0) { continue }

    # Sort newest -> oldest
    $runsTop = $runs |
      Sort-Object { $_.localBackupInfo[0].endTimeUsecs } -Descending |
      Select-Object -First $numRuns

    # Oracle/SQL host resolve (best effort)
    $idToName = @{}
    if ($needsHost) {
      foreach ($r in $runsTop) {
        foreach ($ob in @($r.objects)) {
          if ($ob -and $ob.object -and $ob.object.id) {
            $idToName[[string]$ob.object.id] = [string]$ob.object.name
          }
        }
      }
    }

    # Cleared object set: only objects with explicit success marker in newer runs
    $Cleared = New-Object "System.Collections.Generic.HashSet[string]"

    foreach ($r in $runsTop) {
      $info = $r.localBackupInfo[0]
      if (-not $info) { continue }

      $runType   = [string]$info.runType
      $runStatus = [string]$info.status
      $runId     = if ($r.id) { [string]$r.id } else { [string]$info.endTimeUsecs }
      $endLocal  = Convert-ToLocalFromUsecs $info.endTimeUsecs
      $startLocal= Convert-ToLocalFromUsecs $info.startTimeUsecs

      $objs = @($r.objects | Where-Object {
        $_ -and $_.object -and $_.object.objectType -eq $objType -and ($_.object.environment -in $envSet)
      })
      if (-not $objs -or $objs.Count -eq 0) { continue }

      # PASS 1: mark explicit successes in THIS (newer) run
      foreach ($o in $objs) {
        $k = Get-ObjKey $o
        if (-not $k) { continue }
        if (Is-ObjSucceededStrict $o) { [void]$Cleared.Add($k) }
      }

      # PASS 2: emit failures from THIS run only if NOT cleared by newer success
      foreach ($o in $objs) {
        if (-not (Has-ObjFailure $o)) { continue }

        $k = Get-ObjKey $o
        if (-not $k) { continue }
        if ($Cleared.Contains($k)) { continue }  # cleared by later success (newer run)

        $objName = Get-ObjName $o $nameField
        $msg = Get-FirstFailureMsg $o

        $host = $null
        $db   = $null

        if ($needsHost) {
          $db = $objName
          if ($o.object.PSObject.Properties["sourceId"]) {
            $sid = [string]$o.object.sourceId
            if ($sid -and $idToName.ContainsKey($sid)) { $host = $idToName[$sid] }
          }
        }

        $results.Add([pscustomobject]@{
          Cluster         = $clusterName
          ProtectionGroup = $pgName
          Environment     = $label
          RunId           = $runId
          RunType         = $runType
          RunStatus       = $runStatus
          StartTime       = $startLocal
          EndTime         = $endLocal
          ObjectId        = $k
          Host            = $host
          ObjectName      = $(if ($needsHost) { $null } else { $objName })
          DatabaseName    = $(if ($needsHost) { $db } else { $null })
          FailedMessage   = (CleanMsg $msg)
        })
      }
    }
  }
}

# -------------------------
# Output + CSV
# -------------------------
if ($results.Count -eq 0) {
  Write-Host "âœ” No UNCLEARED object failures found in last $numRuns runs (per PG) for $label." -ForegroundColor Green
  Write-Host "   If you EXPECT failures: your tenant may not expose a usable object success marker in localSnapshotInfo." -ForegroundColor Yellow
  Write-Host "   In that case set `$SuccessMarkerMode = 'loose' (but that can clear too aggressively)." -ForegroundColor Yellow
  return
}

# De-dupe exact duplicates only (same run+object+message)
$results = $results |
  Group-Object { "$($_.RunId)|$($_.ObjectId)|$($_.FailedMessage)" } |
  ForEach-Object { $_.Group | Select-Object -First 1 } |
  Sort-Object Cluster,ProtectionGroup,EndTime -Descending

$timestamp = Get-Date -Format "yyyyMMdd_HHmm"
$csvPath = Join-Path $outDir ("BackupFailures_Uncleared_{0}_Last{1}Runs_{2}.csv" -f $label,$numRuns,$timestamp)

$results | Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8

Write-Host ""
Write-Host "ðŸ§¨ UNCLEARED object failures (last $numRuns runs per PG) â€” $label" -ForegroundColor Cyan
if ($label -in @("Oracle","SQL")) {
  $results | Format-Table Cluster,ProtectionGroup,RunId,RunStatus,Host,DatabaseName,EndTime,FailedMessage -AutoSize
} else {
  $results | Format-Table Cluster,ProtectionGroup,RunId,RunStatus,ObjectName,EndTime,FailedMessage -AutoSize
}
Write-Host ""
Write-Host "ðŸ“„ CSV: $csvPath" -ForegroundColor Gray
