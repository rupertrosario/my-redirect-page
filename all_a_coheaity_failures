# =====================================================================
# Cohesity Backup Failures ‚Äî Multi-Cluster (Helios)
# Menu-driven | Verbose/Silent | CSV only when failures exist (UTF-8)
#
# FIXES vs your ‚Äúlatest-only‚Äù behavior:
# - Pull LAST 10 RUNS per PG
# - Collect ALL object failures across those runs
# - Suppress a failure ONLY if that SAME object has a later success within those 10 runs
#   (rerun of 1 VM clears only that VM; other older failures remain)
#
# Runtime fix:
# - If Windows PowerShell 5.1 prompts for -UseBasicParsing, wrapper adds it conditionally.
# =====================================================================

$ErrorActionPreference = "Stop"

# ==============================
# 0) Folder + hygiene
# ==============================
$logDirectory = "X:\PowerShell\Data\Cohesity\BackupFailures"
if (-not (Test-Path -Path $logDirectory -PathType Container)) {
  New-Item -Path $logDirectory -ItemType Directory | Out-Null
}

# Hygiene 1: keep at most 50 newest files
try {
  $files = Get-ChildItem -Path $logDirectory -File -ErrorAction Stop
  if ($files.Count -gt 50) {
    $toDelete = $files | Sort-Object CreationTime | Select-Object -First ($files.Count - 50)
    $count = ($toDelete | Measure-Object).Count
    if ($count -gt 0) { $toDelete | Remove-Item -Force -ErrorAction SilentlyContinue }
    Write-Host "üßπ Removed $count old files to keep last 50." -ForegroundColor Gray
  }
} catch {}

# Hygiene 2: delete anything older than 30 days
try {
  $threshold = (Get-Date).AddDays(-30)
  $older = Get-ChildItem -Path $logDirectory -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $threshold }
  $oldCount = ($older | Measure-Object).Count
  if ($oldCount -gt 0) {
    $older | Remove-Item -Force -ErrorAction SilentlyContinue
    Write-Host "üßπ Deleted $oldCount files older than 30 days." -ForegroundColor Gray
  }
} catch {}

# ==============================
# 1) Auth (READ-ONLY)
# ==============================
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()

$baseUrl = "https://helios.cohesity.com"

# ==============================
# 2) PS 5.1 IWR wrapper (UseBasicParsing)
# ==============================
function IWR {
  param(
    [Parameter(Mandatory)][string]$Uri,
    [hashtable]$Headers,
    [ValidateSet("Get","Post","Put","Delete","Patch")][string]$Method = "Get",
    $Body = $null
  )

  if ($PSVersionTable.PSVersion.Major -lt 6) {
    if ($null -ne $Body) {
      return Invoke-WebRequest -Uri $Uri -Headers $Headers -Method $Method -Body $Body -UseBasicParsing
    } else {
      return Invoke-WebRequest -Uri $Uri -Headers $Headers -Method $Method -UseBasicParsing
    }
  } else {
    if ($null -ne $Body) {
      return Invoke-WebRequest -Uri $Uri -Headers $Headers -Method $Method -Body $Body
    } else {
      return Invoke-WebRequest -Uri $Uri -Headers $Headers -Method $Method
    }
  }
}

# ==============================
# 3) Helpers
# ==============================
function Convert-FromEpoch([object]$u) {
  if ($null -eq $u -or $u -eq 0) { return $null }
  try { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$u/1000)).UtcDateTime }
  catch { [DateTimeOffset]::FromUnixTimeMilliseconds([int64]$u).UtcDateTime }
}

$tz = $null
try { $tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time") } catch { $tz = $null }

function Convert-ToLocalFromUsecs([object]$usecs, $tzObj) {
  $utc = Convert-FromEpoch $usecs
  if (-not $utc) { return $null }
  if ($tzObj) { return [System.TimeZoneInfo]::ConvertTimeFromUtc($utc, $tzObj) }
  return $utc.ToLocalTime()
}

function CleanMsg([string]$s) {
  if ([string]::IsNullOrWhiteSpace($s)) { return $null }
  return ($s -replace "[\r\n]+"," " -replace ",",";" -replace '"','''').Trim()
}

function Write-Log([string]$msg, [string]$color = "Gray") {
  if ($script:VerboseMode) { Write-Host $msg -ForegroundColor $color }
}

# Object key for cross-run compare (prefer stable id)
function Get-ObjKey($o) {
  if ($o -and $o.object) {
    if ($o.object.id) { return [string]$o.object.id }
    $sid = ""
    if ($o.object.PSObject.Properties["sourceId"]) { $sid = [string]$o.object.sourceId }
    return "$($o.object.environment)|$($o.object.objectType)|$($o.object.name)|$sid"
  }
  return $null
}

function Has-FailedAttempts($o) {
  try {
    $fa = $o.localSnapshotInfo.failedAttempts
    return ($fa -and $fa.Count -gt 0)
  } catch { return $false }
}

function Get-FailureMessage($o) {
  try {
    $fa = @($o.localSnapshotInfo.failedAttempts)
    if ($fa -and $fa.Count -gt 0) {
      $m = $fa | ForEach-Object { CleanMsg $_.message } | Where-Object { $_ } | Select-Object -First 1
      if ($m) { return $m }
    }
  } catch {}
  return "Object failed (no message)"
}

# Success marker used ONLY to clear older failures.
# Default behavior: if object exists in run and has no failedAttempts => treat as success.
# (This matches your expectation that rerun clearing is object-scoped, not run-scoped.)
function Is-ObjectSucceededForClear($o) {
  if (Has-FailedAttempts $o) { return $false }
  $lsi = $null
  try { $lsi = $o.localSnapshotInfo } catch { $lsi = $null }
  if (-not $lsi) { return $false }
  return $true
}

# ==============================
# 4) Get clusters (Helios)
# ==============================
try {
  $resp = IWR -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers @{ apiKey = $apiKey } -Method Get
  $json_clu = ($resp.Content | ConvertFrom-Json).cohesityClusters
} catch {
  throw "Failed to query Helios clusters: $($_.Exception.Message)"
}
if (-not $json_clu) { throw "No clusters returned from Helios." }

# ==============================
# 5) Menu
# ==============================
Write-Host "============================================================" -ForegroundColor Cyan
Write-Host "     COHESITY BACKUP FAILURES ‚Äî MAIN MENU" -ForegroundColor White
Write-Host "============================================================" -ForegroundColor Cyan
Write-Host "1. All Environments" -ForegroundColor Cyan
Write-Host "2. Oracle" -ForegroundColor Cyan
Write-Host "3. SQL" -ForegroundColor Cyan
Write-Host "4. Physical (File system)" -ForegroundColor Cyan
Write-Host "5. NAS (GenericNas/Isilon)" -ForegroundColor Cyan
Write-Host "6. Hyper-V" -ForegroundColor Cyan
Write-Host "7. Acropolis (AHV)" -ForegroundColor Cyan
Write-Host "8. Remote Adapter" -ForegroundColor Cyan
Write-Host "9. Combined Report Only (silent)" -ForegroundColor Cyan
Write-Host "10. Exit" -ForegroundColor Cyan
Write-Host "------------------------------------------------------------" -ForegroundColor Cyan

$choice = Read-Host "Enter your choice(s) (e.g. 2,3,4)"
if ($choice.Trim() -eq "10") { Write-Host "Exiting..."; return }

Write-Host "`nSelect mode:" -ForegroundColor Yellow
Write-Host "1 = Verbose (detailed, color output)" -ForegroundColor Yellow
Write-Host "2 = Silent  (tables only for failures; still prints 'no failures' one-liners)" -ForegroundColor Yellow
$modeChoice = Read-Host "Enter mode [1 or 2]"
$script:VerboseMode = ($modeChoice -eq "1")

# Combined-only forces silent per-env sections
$CombinedOnly = ($choice.Trim() -eq "9")

# ==============================
# 6) Environment Map
# ==============================
$envMap = @(
  @{ Key=2; Label="Oracle";        Filter="kOracle";             ObjectType="kDatabase";       NameField="name"; ParentHostNeeded=$true  }
  @{ Key=3; Label="SQL";           Filter="kSQL";                ObjectType="kDatabase";       NameField="name"; ParentHostNeeded=$true  }
  @{ Key=4; Label="Physical";      Filter="kPhysical";           ObjectType="kHost";           NameField="name"; ParentHostNeeded=$false }
  @{ Key=5; Label="NAS";           Filter="kGenericNas,kIsilon"; ObjectType="kHost";           NameField="name"; ParentHostNeeded=$false }
  @{ Key=6; Label="Hyperv";        Filter="kHyperv";             ObjectType="kVirtualMachine"; NameField="name"; ParentHostNeeded=$false }
  @{ Key=7; Label="Acropolis";     Filter="kAcropolis";          ObjectType="kVirtualMachine"; NameField="name"; ParentHostNeeded=$false }
  @{ Key=8; Label="RemoteAdapter"; Filter="kRemoteAdapter";      ObjectType="kRemoteAdapter";  NameField="name"; ParentHostNeeded=$false }
)

# ==============================
# 7) Collectors
# ==============================

# Core collector (Oracle/SQL/Physical/NAS/Hyperv/Acropolis)
# - Pull last 10 runs per PG
# - Clear older failures only if later run shows same object with no failedAttempts
function Collect-EnvFailuresLast10 {
  param(
    [string]$Label,
    [string]$Filter,             # comma-separated envs
    [string]$ObjectType,
    [string]$NameField,
    [bool]$ParentHostNeeded
  )

  $global = @()
  $filterSet = $Filter.Split(",") | ForEach-Object { $_.Trim() } | Where-Object { $_ }

  foreach ($cluster in $json_clu) {

    $cluster_name = @($cluster.name, $cluster.clusterName, $cluster.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
    if (-not $cluster_name) { $cluster_name = "Unknown-$($cluster.clusterId)" }

    $headers = @{ apiKey = $apiKey; accessClusterId = $cluster.clusterId }

    Write-Log "`n‚è≥ Processing cluster: $cluster_name" "Cyan"

    # List PGs (active)
    try {
      $pgResp = IWR -Uri "$baseUrl/v2/data-protect/protection-groups" -Headers $headers -Method Get -Body @{
        environments = $Filter
        isDeleted    = "False"
        isPaused     = "False"
        isActive     = "True"
      }
      $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
    } catch {
      Write-Log "‚ö† PG list failed for $cluster_name: $($_.Exception.Message)" "Yellow"
      continue
    }

    if (-not $pgs) { continue }

    foreach ($pg in $pgs) {

      $pgId   = $pg.id
      $pgName = $pg.name
      Write-Log ("  üîé Checking PG: {0}" -f $pgName) "Yellow"

      # Last 10 runs (include objects)
      try {
        $runResp = IWR -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" -Headers $headers -Method Get -Body @{
          environments              = $Filter
          numRuns                   = "10"
          excludeNonRestorableRuns  = "False"
          includeObjectDetails      = "True"
        }
        $runs = (($runResp.Content | ConvertFrom-Json).runs)
      } catch {
        Write-Log "‚ö† Runs fetch failed for $cluster_name / $pgName: $($_.Exception.Message)" "Yellow"
        continue
      }

      if (-not $runs) { continue }

      # Sort newest -> oldest (by endTimeUsecs) and take 10
      $runsTop = @($runs) | Sort-Object { $_.localBackupInfo[0].endTimeUsecs } -Descending | Select-Object -First 10

      # Host map for Oracle/SQL (best effort): object.id -> object.name
      $idToName = @{}
      if ($ParentHostNeeded) {
        foreach ($r in $runsTop) {
          foreach ($ob in @($r.objects)) {
            if ($ob -and $ob.object -and $ob.object.id -and $ob.object.name) {
              $idToName[[string]$ob.object.id] = [string]$ob.object.name
            }
          }
        }
      }

      # Cleared set (object-scoped): if object is seen successful in a newer run, older failures suppressed
      $cleared = New-Object "System.Collections.Generic.HashSet[string]"

      foreach ($run in $runsTop) {

        # Determine run info (use the first localBackupInfo entry; matches your original style)
        $info = $run.localBackupInfo[0]
        if (-not $info) { continue }

        $runType = [string]$info.runType
        $status  = [string]$info.status
        $startLocal = Convert-ToLocalFromUsecs $info.startTimeUsecs $tz
        $endLocal   = Convert-ToLocalFromUsecs $info.endTimeUsecs $tz

        # Filter objects to target type + env set
        $objs = @($run.objects | Where-Object {
          $_ -and $_.object -and
          $_.object.objectType -eq $ObjectType -and
          ($_.object.environment -in $filterSet)
        })

        if (-not $objs) { continue }

        # 1) Mark successes (for clearing) in this newer run
        foreach ($o in $objs) {
          $k = Get-ObjKey $o
          if (-not $k) { continue }
          if (Is-ObjectSucceededForClear $o) { [void]$cleared.Add($k) }
        }

        # 2) Oracle/SQL host-level failures (DB discovery failures)
        if ($ParentHostNeeded) {
          $hostObjs = @($run.objects | Where-Object {
            $_ -and $_.object -and $_.object.objectType -eq "kHost"
          })

          foreach ($h in $hostObjs) {
            if (-not (Has-FailedAttempts $h)) { continue }
            $hk = Get-ObjKey $h
            if ($hk -and $cleared.Contains($hk)) { continue } # host later succeeded

            $global += [pscustomobject]@{
              Cluster          = $cluster_name
              ProtectionGroup  = $pgName
              Environment      = $Label
              RunType          = $runType
              Host             = [string]$h.object.name
              ObjectName       = $null
              DatabaseName     = "No DBs Found (Host-Level Failure)"
              StartTime        = $startLocal
              EndTime          = $endLocal
              FailedMessage    = (CleanMsg (Get-FailureMessage $h))
            }
          }
        }

        # 3) Object-level failures
        foreach ($o in $objs) {

          if (-not (Has-FailedAttempts $o)) { continue }

          $k = Get-ObjKey $o
          if (-not $k) { continue }
          if ($cleared.Contains($k)) { continue } # cleared by newer success

          # Resolve name
          $objName = $null
          try { $objName = [string]$o.object.$NameField } catch { $objName = [string]$o.object.name }

          if ($ParentHostNeeded) {
            $dbName = $objName
            $host = $null
            if ($o.object.PSObject.Properties["sourceId"]) {
              $sid = [string]$o.object.sourceId
              if ($sid -and $idToName.ContainsKey($sid)) { $host = $idToName[$sid] }
            }
            $global += [pscustomobject]@{
              Cluster          = $cluster_name
              ProtectionGroup  = $pgName
              Environment      = $Label
              RunType          = $runType
              Host             = $host
              ObjectName       = $null
              DatabaseName     = $dbName
              StartTime        = $startLocal
              EndTime          = $endLocal
              FailedMessage    = (CleanMsg (Get-FailureMessage $o))
            }
          } else {
            $global += [pscustomobject]@{
              Cluster          = $cluster_name
              ProtectionGroup  = $pgName
              Environment      = $Label
              RunType          = $runType
              Host             = $null
              ObjectName       = $objName
              DatabaseName     = $null
              StartTime        = $startLocal
              EndTime          = $endLocal
              FailedMessage    = (CleanMsg (Get-FailureMessage $o))
            }
          }
        }
      }
    }
  }

  # Dedup: keep latest EndTime per (Cluster+PG+Env+RunType+Host+Object/DB+Message)
  if ($global.Count -gt 0) {
    $global = $global |
      Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.Environment)|$($_.RunType)|$($_.Host)|$($_.ObjectName)|$($_.DatabaseName)|$($_.FailedMessage)" } |
      ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 }
  }

  # Export per-env CSV only if failures exist
  $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
  $csvPath = $null

  if ($global.Count -gt 0) {
    $csvPath = Join-Path $logDirectory ("BackupFailures_{0}_AllClusters_{1}.csv" -f $Label, $timestamp)

    if ($Label -in @("Oracle","SQL")) {
      $global |
        Select-Object Cluster,ProtectionGroup,Host,DatabaseName,RunType,EndTime,FailedMessage |
        Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8
    } else {
      $global |
        Select-Object Cluster,ProtectionGroup,ObjectName,RunType,EndTime,FailedMessage |
        Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8
    }
  }

  return [pscustomobject]@{
    Rows = @($global)
    Csv  = $csvPath
  }
}

# RemoteAdapter collector (run-level ‚Äúfailed w/o later success‚Äù using last 10 runs)
function Collect-RemoteAdapter {
  $Label = "RemoteAdapter"
  $global = @()

  foreach ($clus in $json_clu) {
    $cluster_name = @($clus.name, $clus.clusterName, $clus.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
    if (-not $cluster_name) { $cluster_name = "Unknown-$($clus.clusterId)" }

    $headers = @{ apiKey = $apiKey; accessClusterId = $clus.clusterId }

    try {
      $pgResp = IWR -Uri "$baseUrl/v2/data-protect/protection-groups" -Headers $headers -Method Get -Body @{
        environments = "kRemoteAdapter"
        isDeleted    = "False"
        isPaused     = "False"
        isActive     = "True"
      }
      $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
    } catch { continue }

    if (-not $pgs) { continue }

    foreach ($pg in $pgs) {
      $pgId   = $pg.id
      $pgName = $pg.name

      # Best-effort parse RA host/db from params (kept from your approach)
      $raHost = $null; $raDB = $null
      try {
        $raHost = $pg.remoteAdapterParams.hosts.hostname
        if ($raHost -is [System.Array]) { $raHost = ($raHost -join ",") }
        $args = $pg.remoteAdapterParams.hosts.incrementalBackupScript.params
        if ($args -is [System.Array]) { $args = ($args -join " ") }
        if ($args -match "-o\s+(\S+)") { $raDB = $Matches[1] }
      } catch {}

      try {
        $runResp = IWR -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" -Headers $headers -Method Get -Body @{
          environments              = "kRemoteAdapter"
          numRuns                   = "10"
          excludeNonRestorableRuns  = "False"
          includeObjectDetails      = "True"
        }
        $json = $runResp.Content | ConvertFrom-Json
      } catch { continue }

      $runs = if ($json -and $json.runs) { $json.runs } else { @() }
      if (-not $runs) { continue }

      # Flatten localBackupInfo entries (per runType)
      $flat = @()
      foreach ($r in $runs) {
        foreach ($i in @($r.localBackupInfo)) {
          $flat += [pscustomobject]@{
            RunType        = [string]$i.runType
            Status         = [string]$i.status
            Message        = $i.messages
            StartTimeUsecs = [int64]$i.startTimeUsecs
            EndTimeUsecs   = [int64]$i.endTimeUsecs
            Cluster        = $cluster_name
            ProtectionGroup= $pgName
            RAHost         = $raHost
            RADB           = $raDB
          }
        }
      }
      if (-not $flat) { continue }

      foreach ($grp in ($flat | Group-Object RunType)) {
        $latestFailed = $grp.Group | Where-Object { $_.Status -eq "Failed" } | Sort-Object EndTimeUsecs -Descending | Select-Object -First 1
        if ($null -eq $latestFailed) { continue }

        $hasLaterSuccess = $grp.Group | Where-Object {
          $_.Status -in @("Succeeded","Succeededwithwarning","SucceededWithWarning") -and
          $_.StartTimeUsecs -gt $latestFailed.EndTimeUsecs
        } | Select-Object -First 1

        if ($hasLaterSuccess) { continue }

        $msg = $latestFailed.Message
        if ($msg -is [System.Array]) { $msg = ($msg -join " | ") }

        $global += [pscustomobject]@{
          Cluster          = $latestFailed.Cluster
          ProtectionGroup  = $latestFailed.ProtectionGroup
          Environment      = $Label
          RunType          = $latestFailed.RunType
          Host             = $null
          ObjectName       = $(if ($latestFailed.RADB) { $latestFailed.RADB } else { $latestFailed.RAHost })
          DatabaseName     = $null
          StartTime        = Convert-ToLocalFromUsecs $latestFailed.StartTimeUsecs $tz
          EndTime          = Convert-ToLocalFromUsecs $latestFailed.EndTimeUsecs $tz
          FailedMessage    = (CleanMsg ([string]$msg))
        }
      }
    }
  }

  # Dedup keep latest
  if ($global.Count -gt 0) {
    $global = $global |
      Group-Object { "$($_.Cluster)|$($_.ProtectionGroup)|$($_.Environment)|$($_.RunType)|$($_.ObjectName)|$($_.FailedMessage)" } |
      ForEach-Object { $_.Group | Sort-Object EndTime -Descending | Select-Object -First 1 }
  }

  $timestamp = Get-Date -Format "yyyyMMdd_HHmm"
  $csvPath = $null
  if ($global.Count -gt 0) {
    $csvPath = Join-Path $logDirectory ("BackupFailures_RemoteAdapter_AllClusters_{0}.csv" -f $timestamp)
    $global | Select-Object Cluster,ProtectionGroup,ObjectName,RunType,EndTime,FailedMessage |
      Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8
  }

  return [pscustomobject]@{ Rows=@($global); Csv=$csvPath }
}

# ==============================
# 8) Renderers
# ==============================
$summary = New-Object System.Collections.ArrayList
$allTables = New-Object System.Collections.ArrayList

function Add-SummaryLine([string]$label, [string]$csv) {
  $csvText = if ($csv -and -not [string]::IsNullOrWhiteSpace($csv)) { [string]$csv } else { "no csv (no failures)" }
  $null = $summary.Add(("{0} - {1}" -f $label, $csvText))
}

function Show-Table {
  param([string]$label, $rows, [string]$csvPath)

  $rows = @($rows)

  if ($rows.Count -eq 0) {
    Write-Host "‚úî No failures found for $label (All Clusters)" -ForegroundColor Green
    Add-SummaryLine $label $null
    return
  }

  Write-Host "`nüß® Failures for $label (All Clusters) ‚Äî UNCLEARED within last 10 runs/PG:`n" -ForegroundColor Cyan

  if ($label -in @("Oracle","SQL")) {
    $view = $rows | ForEach-Object {
      [pscustomobject]@{
        Cluster          = $_.Cluster
        ProtectionGroup  = $_.ProtectionGroup
        Host             = $_.Host
        DatabaseName     = $_.DatabaseName
        RunType          = $_.RunType
        EndTime          = $_.EndTime
        FailedMessage    = $_.FailedMessage
      }
    }
    $view | Sort-Object Cluster,ProtectionGroup,EndTime -Descending |
      Format-Table Cluster,ProtectionGroup,Host,DatabaseName,RunType,EndTime,FailedMessage -AutoSize
  } else {
    $view = $rows | ForEach-Object {
      [pscustomobject]@{
        Cluster          = $_.Cluster
        ProtectionGroup  = $_.ProtectionGroup
        ObjectName       = $_.ObjectName
        RunType          = $_.RunType
        EndTime          = $_.EndTime
        FailedMessage    = $_.FailedMessage
      }
    }
    $view | Sort-Object Cluster,ProtectionGroup,EndTime -Descending |
      Format-Table Cluster,ProtectionGroup,ObjectName,RunType,EndTime,FailedMessage -AutoSize
  }

  if ($csvPath) { Write-Host "`nüìÑ CSV saved: $csvPath" -ForegroundColor Gray }
  Add-SummaryLine $label $csvPath

  # Add to combined (normalized)
  foreach ($r in $rows) {
    $null = $allTables.Add([pscustomobject]@{
      Environment     = $label
      Cluster         = $r.Cluster
      ProtectionGroup = $r.ProtectionGroup
      Host            = $r.Host
      ObjectName      = $(if ($label -in @("Oracle","SQL")) { $r.DatabaseName } else { $r.ObjectName })
      RunType         = $r.RunType
      EndTime         = $r.EndTime
      FailedMessage   = $r.FailedMessage
    })
  }
}

# ==============================
# 9) Run selection
# ==============================
$selected = @()
if ($choice -eq "1" -or $CombinedOnly) {
  # all envs except RemoteAdapter handled by same collector; RemoteAdapter separate
  $selected = @($envMap | Where-Object { $_.Key -ne 8 })
  $includeRemote = $true
} else {
  $selected = $choice.Split(",") | ForEach-Object { $_.Trim() } | Where-Object { $_ -match "^\d+$" -and $_ -ne "10" -and $_ -ne "9" } | ForEach-Object { [int]$_ }
  $includeRemote = ($selected -contains 8)
}

if (-not $CombinedOnly) { Write-Host "`nRunning selection..." -ForegroundColor Cyan }

# Per-env execution
if ($choice -eq "1" -or $CombinedOnly) {
  foreach ($e in $envMap | Where-Object { $_.Key -ne 8 }) {
    if (-not $CombinedOnly) {
      Write-Host "`n============================================================" -ForegroundColor DarkCyan
      Write-Host ("‚û§ Environment: {0}" -f $e.Label) -ForegroundColor Cyan
      Write-Host "============================================================" -ForegroundColor DarkCyan
    }
    $res = Collect-EnvFailuresLast10 -Label $e.Label -Filter $e.Filter -ObjectType $e.ObjectType -NameField $e.NameField -ParentHostNeeded:$e.ParentHostNeeded
    if (-not $CombinedOnly) { Show-Table -label $e.Label -rows $res.Rows -csvPath $res.Csv }
    else {
      if ($res.Rows.Count -eq 0) { Add-SummaryLine $e.Label $null } else { Add-SummaryLine $e.Label $res.Csv }
      foreach ($r in $res.Rows) { $null = $allTables.Add([pscustomobject]@{
        Environment=$e.Label; Cluster=$r.Cluster; ProtectionGroup=$r.ProtectionGroup; Host=$r.Host;
        ObjectName=$(if ($e.Label -in @("Oracle","SQL")) { $r.DatabaseName } else { $r.ObjectName });
        RunType=$r.RunType; EndTime=$r.EndTime; FailedMessage=$r.FailedMessage
      }) }
    }
  }
  if ($includeRemote) {
    $ra = Collect-RemoteAdapter
    if (-not $CombinedOnly) { Show-Table -label "RemoteAdapter" -rows $ra.Rows -csvPath $ra.Csv }
    else {
      if ($ra.Rows.Count -eq 0) { Add-SummaryLine "RemoteAdapter" $null } else { Add-SummaryLine "RemoteAdapter" $ra.Csv }
      foreach ($r in $ra.Rows) { $null = $allTables.Add([pscustomobject]@{
        Environment="RemoteAdapter"; Cluster=$r.Cluster; ProtectionGroup=$r.ProtectionGroup; Host=$null;
        ObjectName=$r.ObjectName; RunType=$r.RunType; EndTime=$r.EndTime; FailedMessage=$r.FailedMessage
      }) }
    }
  }
} else {
  foreach ($k in $selected) {
    $env = $envMap | Where-Object { $_.Key -eq $k } | Select-Object -First 1
    if (-not $env) { Write-Host "‚ö† Invalid selection: $k" -ForegroundColor Yellow; continue }

    if ($env.Key -eq 8) {
      $ra = Collect-RemoteAdapter
      Show-Table -label "RemoteAdapter" -rows $ra.Rows -csvPath $ra.Csv
    } else {
      $res = Collect-EnvFailuresLast10 -Label $env.Label -Filter $env.Filter -ObjectType $env.ObjectType -NameField $env.NameField -ParentHostNeeded:$env.ParentHostNeeded
      Show-Table -label $env.Label -rows $res.Rows -csvPath $res.Csv
    }
  }
}

# ==============================
# 10) Combined output
# ==============================
if ($allTables.Count -gt 0) {
  Write-Host "`nüßæ Combined Failures ‚Äî All Selected Environments" -ForegroundColor Magenta
  $sortedAll = @($allTables) | Sort-Object Environment,Cluster,ProtectionGroup,EndTime -Descending

  $ts = Get-Date -Format "yyyyMMdd_HHmm"
  $combinedPath = Join-Path $logDirectory ("BackupFailures_AllEnvironments_{0}.csv" -f $ts)

  $sortedAll |
    Select-Object Environment,Cluster,ProtectionGroup,Host,ObjectName,RunType,EndTime,FailedMessage |
    Export-Csv -Path $combinedPath -NoTypeInformation -Encoding utf8

  $sortedAll |
    Format-Table Environment,Cluster,ProtectionGroup,Host,ObjectName,RunType,EndTime,FailedMessage -AutoSize

  Write-Host "`nüìÑ Combined CSV saved: $combinedPath" -ForegroundColor Gray
  $null = $summary.Add(("All Environments - {0}" -f $combinedPath))
} else {
  Write-Host "`n‚úî No backup failures in the selected scope (combined)." -ForegroundColor Green
  $null = $summary.Add("All Environments - no csv (no failures)")
}

# ==============================
# 11) Summary footer
# ==============================
Write-Host "`n============================================================" -ForegroundColor Cyan
Write-Host "SUMMARY" -ForegroundColor White
Write-Host "============================================================" -ForegroundColor Cyan
if ($summary.Count -gt 0) {
  foreach ($line in $summary) { Write-Host $line }
} else {
  Write-Host "No backup failures in the selected scope." -ForegroundColor Green
}
Write-Host "‚úÖ Processing complete!" -ForegroundColor Cyan
