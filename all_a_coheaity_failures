# =====================================================================
# Cohesity Helios — Failures from LAST 10 runs (per PG)
# Rule: list all failures, but suppress an older failure if the SAME object
#       is successful in any NEWER run within the last 10 runs.
#
# Minimal operational changes vs typical "latest run only" scripts:
#  - Add PS5.1-safe Invoke-WebRequest wrapper (-UseBasicParsing)
#  - Fetch numRuns=10
#  - Iterate ALL 10 runs (newest -> oldest) instead of only latest per runType
#
# GET-only. Uses query string (NO -Body on GET) to avoid 400 Bad Request.
# =====================================================================

$ErrorActionPreference = "Stop"

# -------------------------
# CONFIG
# -------------------------
$baseUrl    = "https://helios.cohesity.com"
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
$outDir     = "X:\PowerShell\Data\Cohesity\BackupFailures"
$numRuns    = 10

# CLEAR MODE:
#  - "presenceNoFail"  : treat object as successful in a run if present AND it has NO failedAttempts (recommended if API lacks explicit success fields)
#  - "strictSnapshotId": clear only if localSnapshotInfo.snapshotId exists (use if your tenant reliably returns it)
$ClearMode  = "presenceNoFail"

if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
if (-not (Test-Path $outDir)) { New-Item -Path $outDir -ItemType Directory | Out-Null }

$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()
$hdr0   = @{ apiKey = $apiKey }

# -------------------------
# PS 5.1 parsing fix (your only runtime issue)
# -------------------------
function IWR {
  param(
    [Parameter(Mandatory)] [string]$Uri,
    [hashtable]$Headers,
    [ValidateSet("Get","Post","Put","Delete","Patch")] [string]$Method="Get"
  )
  if ($PSVersionTable.PSVersion.Major -lt 6) {
    Invoke-WebRequest -Uri $Uri -Headers $Headers -Method $Method -UseBasicParsing
  } else {
    Invoke-WebRequest -Uri $Uri -Headers $Headers -Method $Method
  }
}

# -------------------------
# Helpers
# -------------------------
Add-Type -AssemblyName System.Web | Out-Null

function New-QueryString([hashtable]$q) {
  if (-not $q -or $q.Count -eq 0) { return "" }
  $pairs = foreach ($k in $q.Keys) {
    $v = $q[$k]
    if ($null -eq $v) { continue }
    "{0}={1}" -f [System.Web.HttpUtility]::UrlEncode([string]$k),
               [System.Web.HttpUtility]::UrlEncode([string]$v)
  }
  "?" + ($pairs -join "&")
}

function HeliosGet([string]$path, [hashtable]$headers, [hashtable]$query) {
  $qs  = New-QueryString $query
  $uri = "$baseUrl$path$qs"
  $resp = IWR -Uri $uri -Headers $headers -Method Get
  return ($resp.Content | ConvertFrom-Json)
}

function CleanMsg([string]$s) {
  if ([string]::IsNullOrWhiteSpace($s)) { return $null }
  ($s -replace "[\r\n]+"," " -replace ",",";" -replace '"','''').Trim()
}

function EndUsecs($run) {
  try { [int64]$run.localBackupInfo[0].endTimeUsecs } catch { 0 }
}

function RunId($run) {
  try { if ($run.id) { [string]$run.id } else { [string]$run.localBackupInfo[0].endTimeUsecs } } catch { "" }
}

function HasFail($o) {
  try {
    $fa = $o.localSnapshotInfo.failedAttempts
    return ($fa -and $fa.Count -gt 0)
  } catch { return $false }
}

function FirstFailMsg($o) {
  try {
    $fa = @($o.localSnapshotInfo.failedAttempts)
    if ($fa -and $fa.Count -gt 0) {
      $m = $fa | ForEach-Object { CleanMsg $_.message } | Where-Object { $_ } | Select-Object -First 1
      if ($m) { return $m }
    }
  } catch {}
  return "Object failed (no message)"
}

function ObjKey($o) {
  if ($o.object.id) { return [string]$o.object.id }
  $sid = ""
  if ($o.object.PSObject.Properties["sourceId"]) { $sid = [string]$o.object.sourceId }
  "$($o.object.environment)|$($o.object.objectType)|$($o.object.name)|$sid"
}

function ObjSuccessInRun($o) {
  # Important: this is ONLY used to clear older failures.
  if (HasFail $o) { return $false }

  $lsi = $null
  try { $lsi = $o.localSnapshotInfo } catch { $lsi = $null }
  if (-not $lsi) { return $false }

  if ($ClearMode -eq "strictSnapshotId") {
    try { return ($lsi.PSObject.Properties["snapshotId"] -and $lsi.snapshotId) } catch { return $false }
  }

  # presenceNoFail:
  # object exists in the run + no failedAttempts => treat as success for clearing purposes
  return $true
}

# -------------------------
# Menu (environment)
# -------------------------
Write-Host "============================================================" -ForegroundColor Cyan
Write-Host "Cohesity — Failures (Last $numRuns Runs / PG) cleared by later success" -ForegroundColor White
Write-Host "============================================================" -ForegroundColor Cyan
Write-Host "1. Hyper-V" -ForegroundColor Cyan
Write-Host "2. Acropolis (AHV)" -ForegroundColor Cyan
Write-Host "3. Physical" -ForegroundColor Cyan
Write-Host "4. NAS (GenericNas/Isilon)" -ForegroundColor Cyan
Write-Host "5. Oracle" -ForegroundColor Cyan
Write-Host "6. SQL" -ForegroundColor Cyan
Write-Host "7. RemoteAdapter (run-level only)" -ForegroundColor Cyan
Write-Host "8. All (runs each of the above 1-7)" -ForegroundColor Cyan

$choice = Read-Host "Enter choice [1-8]"

# env map (kept compact)
$envDefs = @(
  @{ Key=1; Label="Hyperv";        Env="kHyperv";              ObjType="kVirtualMachine"; NameField="name"; NeedsHost=$false; Mode="object" }
  @{ Key=2; Label="Acropolis";     Env="kAcropolis";           ObjType="kVirtualMachine"; NameField="name"; NeedsHost=$false; Mode="object" }
  @{ Key=3; Label="Physical";      Env="kPhysical";            ObjType="kHost";           NameField="name"; NeedsHost=$false; Mode="object" }
  @{ Key=4; Label="NAS";           Env="kGenericNas,kIsilon";  ObjType="kHost";           NameField="name"; NeedsHost=$false; Mode="object" }
  @{ Key=5; Label="Oracle";        Env="kOracle";              ObjType="kDatabase";       NameField="name"; NeedsHost=$true;  Mode="object" }
  @{ Key=6; Label="SQL";           Env="kSQL";                 ObjType="kDatabase";       NameField="name"; NeedsHost=$true;  Mode="object" }
  @{ Key=7; Label="RemoteAdapter"; Env="kRemoteAdapter";       ObjType=$null;             NameField="name"; NeedsHost=$false; Mode="remote" }
)

$selectedDefs = @()
if ($choice -eq "8") { $selectedDefs = $envDefs }
else {
  $d = $envDefs | Where-Object { $_.Key -eq [int]$choice } | Select-Object -First 1
  if (-not $d) { throw "Invalid choice." }
  $selectedDefs = @($d)
}

# -------------------------
# Fetch clusters
# -------------------------
$clu = HeliosGet "/v2/mcm/cluster-mgmt/info" $hdr0 @{}
$clusters = @($clu.cohesityClusters)
if (-not $clusters -or $clusters.Count -eq 0) { throw "No clusters returned." }

# -------------------------
# Collect per env
# -------------------------
$allRows = New-Object System.Collections.Generic.List[object]

foreach ($def in $selectedDefs) {

  $label = $def.Label
  Write-Host "`n=== $label ===" -ForegroundColor Yellow

  foreach ($c in $clusters) {

    $clusterName = @($c.name, $c.clusterName, $c.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
    if (-not $clusterName) { $clusterName = "Unknown-$($c.clusterId)" }

    $hdr = @{ apiKey = $apiKey; accessClusterId = $c.clusterId }

    # PG list (active) — query string only
    $pgJson = HeliosGet "/v2/data-protect/protection-groups" $hdr @{
      environments = $def.Env
      isDeleted    = "False"
      isPaused     = "False"
      isActive     = "True"
    }
    $pgs = @($pgJson.protectionGroups)
    if (-not $pgs -or $pgs.Count -eq 0) { continue }

    foreach ($pg in $pgs) {

      $pgId   = $pg.id
      $pgName = $pg.name

      if ($def.Mode -eq "remote") {
        # RemoteAdapter: keep your original-style rule: show latest failed per runType if no later success
        $runJson = HeliosGet "/v2/data-protect/protection-groups/$pgId/runs" $hdr @{
          numRuns              = "$numRuns"
          includeObjectDetails = "False"
          excludeNonRestorableRuns = "False"
        }
        $runs = @($runJson.runs)
        if (-not $runs) { continue }

        # flatten runInfos
        $flat = @()
        foreach ($r in $runs) {
          foreach ($i in @($r.localBackupInfo)) {
            $flat += [pscustomobject]@{
              RunId   = (RunId $r)
              RunType = [string]$i.runType
              Status  = [string]$i.status
              Start   = [int64]$i.startTimeUsecs
              End     = [int64]$i.endTimeUsecs
              Msg     = $i.messages
            }
          }
        }

        foreach ($g in ($flat | Group-Object RunType)) {
          $latestFailed = $g.Group | Where-Object { $_.Status -eq "Failed" } | Sort-Object End -Descending | Select-Object -First 1
          if (-not $latestFailed) { continue }

          $laterSuccess = $g.Group | Where-Object { $_.Status -in @("Succeeded","SucceededWithWarning") -and $_.Start -gt $latestFailed.End } | Select-Object -First 1
          if ($laterSuccess) { continue }

          $endUtc = [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$latestFailed.End/1000)).UtcDateTime
          $msg = $latestFailed.Msg
          if ($msg -is [array]) { $msg = ($msg -join " | ") }

          $allRows.Add([pscustomobject]@{
            Environment = $label
            Cluster     = $clusterName
            PG          = $pgName
            RunId       = $latestFailed.RunId
            RunType     = $latestFailed.RunType
            RunStatus   = $latestFailed.Status
            EndTimeUTC  = $endUtc
            Host        = $null
            ObjectName  = "(RemoteAdapter run-level)"
            DatabaseName= $null
            Message     = (CleanMsg ([string]$msg))
          })
        }

        continue
      }

      # Runs (last 10) — IMPORTANT: no env filter here (prevents missed runs)
      $runJson = HeliosGet "/v2/data-protect/protection-groups/$pgId/runs" $hdr @{
        numRuns                  = "$numRuns"
        includeObjectDetails     = "True"
        excludeNonRestorableRuns = "False"
      }
      $runs = @($runJson.runs)
      if (-not $runs -or $runs.Count -eq 0) { continue }

      $runsTop = $runs | Sort-Object { EndUsecs $_ } -Descending | Select-Object -First $numRuns

      $envSet = $def.Env.Split(",") | ForEach-Object { $_.Trim() } | Where-Object { $_ }

      # Oracle/SQL host mapping best-effort
      $idToName = @{}
      if ($def.NeedsHost) {
        foreach ($r in $runsTop) {
          foreach ($ob in @($r.objects)) {
            if ($ob -and $ob.object -and $ob.object.id) { $idToName[[string]$ob.object.id] = [string]$ob.object.name }
          }
        }
      }

      # cleared-by-later-success set
      $cleared = New-Object "System.Collections.Generic.HashSet[string]"

      foreach ($r in $runsTop) {  # newest -> oldest
        $info = $r.localBackupInfo[0]
        if (-not $info) { continue }

        $rid = RunId $r
        $runType   = [string]$info.runType
        $runStatus = [string]$info.status
        $endUtc    = [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$info.endTimeUsecs/1000)).UtcDateTime

        $objs = @($r.objects | Where-Object {
          $_ -and $_.object -and $_.object.objectType -eq $def.ObjType -and ($_.object.environment -in $envSet)
        })
        if (-not $objs -or $objs.Count -eq 0) { continue }

        # PASS 1: mark successes in this newer run (object-scoped)
        foreach ($o in $objs) {
          $k = ObjKey $o
          if ($k -and (ObjSuccessInRun $o)) { [void]$cleared.Add($k) }
        }

        # PASS 2: emit failures not cleared by later success
        foreach ($o in $objs) {
          if (-not (HasFail $o)) { continue }
          $k = ObjKey $o
          if (-not $k) { continue }
          if ($cleared.Contains($k)) { continue }

          $objName = [string]$o.object.$($def.NameField)
          $msg = FirstFailMsg $o

          $host = $null
          $db   = $null
          if ($def.NeedsHost) {
            $db = $objName
            if ($o.object.PSObject.Properties["sourceId"]) {
              $sid = [string]$o.object.sourceId
              if ($sid -and $idToName.ContainsKey($sid)) { $host = $idToName[$sid] }
            }
            $objName = $null
          }

          $allRows.Add([pscustomobject]@{
            Environment = $label
            Cluster     = $clusterName
            PG          = $pgName
            RunId       = $rid
            RunType     = $runType
            RunStatus   = $runStatus
            EndTimeUTC  = $endUtc
            Host        = $host
            ObjectName  = $objName
            DatabaseName= $db
            Message     = (CleanMsg $msg)
          })
        }
      }
    }
  }
}

# -------------------------
# Output + CSV
# -------------------------
if ($allRows.Count -eq 0) {
  Write-Host "`nNO UNCLEARED FAILURES found in last $numRuns runs." -ForegroundColor Green
  Write-Host "If you EXPECT failures and they disappear after reruns: set `$ClearMode='strictSnapshotId' only if snapshotId exists in your payload." -ForegroundColor Yellow
  return
}

# De-dupe exact duplicates only
$final = $allRows |
  Group-Object { "$($_.Environment)|$($_.RunId)|$($_.Cluster)|$($_.PG)|$($_.ObjectName)|$($_.DatabaseName)|$($_.Message)" } |
  ForEach-Object { $_.Group | Select-Object -First 1 } |
  Sort-Object Environment,Cluster,PG,EndTimeUTC -Descending

$ts = Get-Date -Format "yyyyMMdd_HHmm"
$csv = Join-Path $outDir ("BackupFailures_Uncleared_Last{0}_{1}.csv" -f $numRuns,$ts)

$final | Export-Csv -Path $csv -NoTypeInformation -Encoding utf8

Write-Host "`nCSV: $csv" -ForegroundColor Gray
$final | Format-Table Environment,Cluster,PG,RunId,RunStatus,ObjectName,DatabaseName,EndTimeUTC,Message -AutoSize
