# =====================================================================
# Cohesity Helios â€” "Last 10 runs" Failures with "Cleared by later success"
#
# Rule:
# - Collect failures from the last 10 runs for each PG
# - BUT: if an object succeeds in ANY later (newer) run within those 10,
#        do NOT list its older failures.
#
# Key implementation:
# - Sort runs newest -> oldest
# - Maintain a HashSet of objectIds that have succeeded (SucceededObjectIds)
# - While scanning older runs, only emit failures for objects NOT in that set
#
# Notes:
# - Uses object.id as the stable key (fallback to name+type if id missing)
# - Success detection:
#     1) If object has failedAttempts => failure
#     2) Else if run status is Succeeded/SucceededWithWarning => treat as success for that object
# - If Cohesity returns object-level status fields in your tenant, you can tighten Is-ObjSuccess().
# =====================================================================

$ErrorActionPreference = "Stop"

# ========== Config ==========
$baseUrl     = "https://helios.cohesity.com"
$apikeypath  = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
$outDir      = "X:\PowerShell\Data\Cohesity\BackupFailures"
$numRuns     = 10

if (-not (Test-Path $apikeypath)) { throw "API key file not found at $apikeypath" }
if (-not (Test-Path $outDir)) { New-Item -Path $outDir -ItemType Directory | Out-Null }

$apiKey = (Get-Content -Path $apikeypath -Raw).Trim()
$commonHeaders = @{ apiKey = $apiKey }

# ET timezone (optional)
$tz = $null
try { $tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time") } catch { $tz = $null }

function Convert-ToLocalFromUsecs([object]$usecs) {
  if ($null -eq $usecs -or $usecs -eq 0) { return $null }
  $utc = [DateTimeOffset]::FromUnixTimeMilliseconds([int64]([double]$usecs/1000)).UtcDateTime
  if ($tz) { return [System.TimeZoneInfo]::ConvertTimeFromUtc($utc, $tz) }
  return $utc.ToLocalTime()
}

function CleanMsg([string]$s) {
  if ([string]::IsNullOrWhiteSpace($s)) { return $null }
  return ($s -replace "[\r\n]+"," " -replace ",",";" -replace '"','''').Trim()
}

function Get-ObjKey($o) {
  if ($o -and $o.object) {
    if ($o.object.id) { return [string]$o.object.id }
    $n = [string]$o.object.name
    $t = [string]$o.object.objectType
    $s = if ($o.object.PSObject.Properties["sourceId"]) { [string]$o.object.sourceId } else { "" }
    return "$t|$n|$s"
  }
  return $null
}

function Is-RunSuccess([string]$runStatus) {
  return ($runStatus -in @("Succeeded","SucceededWithWarning"))
}

function Has-ObjFailure($obj) {
  try {
    $fa = $obj.localSnapshotInfo.failedAttempts
    return ($fa -and $fa.Count -gt 0)
  } catch { return $false }
}

function Is-ObjSuccess($obj, [string]$runStatus) {
  # If Cohesity gives object-level status in your API payload, tighten here.
  if (Has-ObjFailure $obj) { return $false }
  if (Is-RunSuccess $runStatus) { return $true }
  return $false
}

# =========================
# Fetch clusters
# =========================
$cluResp = Invoke-WebRequest -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers $commonHeaders -Method Get
$clusters = ($cluResp.Content | ConvertFrom-Json).cohesityClusters
if (-not $clusters) { throw "No clusters returned from Helios." }

# =========================
# Menu (environment)
# =========================
Write-Host "1) Hyper-V (kHyperv / VM objects)" -ForegroundColor Cyan
Write-Host "2) Acropolis (kAcropolis / VM objects)" -ForegroundColor Cyan
Write-Host "3) Physical (kPhysical / Host objects)" -ForegroundColor Cyan
Write-Host "4) NAS (kGenericNas,kIsilon / Host objects)" -ForegroundColor Cyan
Write-Host "5) Oracle (kOracle / DB objects)" -ForegroundColor Cyan
Write-Host "6) SQL (kSQL / DB objects)" -ForegroundColor Cyan
$sel = Read-Host "Choose [1-6]"

switch ($sel) {
  "1" { $envFilter="kHyperv";                $objType="kVirtualMachine"; $nameField="name"; $label="Hyperv" }
  "2" { $envFilter="kAcropolis";             $objType="kVirtualMachine"; $nameField="name"; $label="Acropolis" }
  "3" { $envFilter="kPhysical";              $objType="kHost";           $nameField="name"; $label="Physical" }
  "4" { $envFilter="kGenericNas,kIsilon";    $objType="kHost";           $nameField="name"; $label="NAS" }
  "5" { $envFilter="kOracle";                $objType="kDatabase";       $nameField="name"; $label="Oracle" }
  "6" { $envFilter="kSQL";                   $objType="kDatabase";       $nameField="name"; $label="SQL" }
  default { throw "Invalid selection." }
}

$results = @()

foreach ($c in $clusters) {
  $clusterName = @($c.name, $c.clusterName, $c.displayName | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
  if (-not $clusterName) { $clusterName = "Unknown-$($c.clusterId)" }

  $headers = @{ apiKey = $apiKey; accessClusterId = $c.clusterId }

  # PG list
  try {
    $pgResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups" -Headers $headers -Method Get -Body @{
      environments = $envFilter; isDeleted="False"; isPaused="False"; isActive="True"
    }
    $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
  } catch {
    Write-Host "PG list failed for $clusterName: $($_.Exception.Message)" -ForegroundColor Yellow
    continue
  }
  if (-not $pgs) { continue }

  foreach ($pg in $pgs) {
    $pgId = $pg.id
    $pgName = $pg.name

    # Runs (last 10)
    try {
      $runResp = Invoke-WebRequest -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" -Headers $headers -Method Get -Body @{
        environments = $envFilter
        numRuns = "$numRuns"
        includeObjectDetails = "True"
        excludeNonRestorableRuns = "False"
      }
      $jsonRuns = $runResp.Content | ConvertFrom-Json
      $runs = @($jsonRuns.runs)
    } catch {
      Write-Host "Runs fetch failed for $clusterName / $($pgName): $($_.Exception.Message)" -ForegroundColor Yellow
      continue
    }
    if (-not $runs -or $runs.Count -eq 0) { continue }

    # Sort runs newest -> oldest by endTimeUsecs (localBackupInfo[0])
    $runsTop = $runs |
      Sort-Object { $_.localBackupInfo[0].endTimeUsecs } -Descending |
      Select-Object -First $numRuns

    # Success tracker (newest -> oldest)
    $SucceededObjectIds = New-Object "System.Collections.Generic.HashSet[string]"

    foreach ($r in $runsTop) {
      $info = $r.localBackupInfo[0]
      if (-not $info) { continue }

      $runStatus = [string]$info.status
      $runType   = [string]$info.runType
      $runId     = if ($r.id) { [string]$r.id } else { [string]$info.endTimeUsecs }
      $endLocal  = Convert-ToLocalFromUsecs $info.endTimeUsecs
      $startLocal= Convert-ToLocalFromUsecs $info.startTimeUsecs

      $objs = @($r.objects | Where-Object { $_ -and $_.object -and $_.object.objectType -eq $objType })
      if (-not $objs) { continue }

      # First pass: mark successes in THIS (newer) run
      foreach ($o in $objs) {
        $k = Get-ObjKey $o
        if (-not $k) { continue }
        if (Is-ObjSuccess $o $runStatus) { [void]$SucceededObjectIds.Add($k) }
      }

      # Second pass: emit failures from THIS run only if NOT cleared by later success
      foreach ($o in $objs) {
        $k = Get-ObjKey $o
        if (-not $k) { continue }

        if (Has-ObjFailure $o) {
          if ($SucceededObjectIds.Contains($k)) { continue }  # cleared by later success

          $objName = $o.object.$nameField
          $fa = @($o.localSnapshotInfo.failedAttempts)
          $msg = $null
          if ($fa -and $fa.Count -gt 0) {
            $msg = ($fa | ForEach-Object { CleanMsg $_.message } | Where-Object { $_ } | Select-Object -First 1)
          }
          if (-not $msg) { $msg = "Object failed (no message provided)" }

          $results += [pscustomobject]@{
            Cluster         = $clusterName
            ProtectionGroup = $pgName
            RunId           = $runId
            RunType         = $runType
            RunStatus       = $runStatus
            StartTime       = $startLocal
            EndTime         = $endLocal
            ObjectId        = $k
            ObjectName      = $objName
            FailedMessage   = $msg
          }
        }
      }
    }
  }
}

# Output + CSV
if (-not $results -or $results.Count -eq 0) {
  Write-Host "âœ” No uncleared failures found in last $numRuns runs (per PG) for $label." -ForegroundColor Green
  return
}

$results = $results | Sort-Object Cluster,ProtectionGroup,EndTime -Descending

$timestamp = Get-Date -Format "yyyyMMdd_HHmm"
$csvPath = Join-Path $outDir ("BackupFailures_Uncleared_{0}_Last{1}Runs_{2}.csv" -f $label,$numRuns,$timestamp)

$results | Export-Csv -Path $csvPath -NoTypeInformation -Encoding utf8

Write-Host "`nðŸ§¨ Uncleared failures (last $numRuns runs per PG) â€” $label:`n" -ForegroundColor Cyan
$results | Format-Table Cluster,ProtectionGroup,RunId,RunStatus,ObjectName,EndTime,FailedMessage -AutoSize
Write-Host "`nðŸ“„ CSV: $csvPath" -ForegroundColor Gray
