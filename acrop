# -------------------------------------------------------------
# Cohesity Acropolis (AHV) Inventory â€“ Menu + API
# Output:
# 1) Cluster Summary
# 2) Protection Group Summary
# 3) Full VM List (with LastSuccessfulET)
#
# Notes:
# - localBackupInfo can be OBJECT or ARRAY -> handled via @()
# - PG list filtered to active/non-deleted (adds isActive/isPaused/isDeleted)
# -------------------------------------------------------------

$ErrorActionPreference = "Stop"
$baseUrl = "https://helios.cohesity.com"

# --- API key ---
$apikeypath = "X:\PowerShell\Cohesity_API_Scripts\DO_NOT_Delete\apikey.txt"
if (-not (Test-Path $apikeypath)) { throw "API key file not found: $apikeypath" }
$apiKey = (Get-Content $apikeypath -Raw).Trim()

# --- ET conversion ---
$tz = [System.TimeZoneInfo]::FindSystemTimeZoneById("Eastern Standard Time")
function Convert-ToET([object]$usecs) {
    if (-not $usecs) { return $null }
    try {
        $utc = [DateTimeOffset]::FromUnixTimeMilliseconds([int64]($usecs / 1000)).UtcDateTime
        return [System.TimeZoneInfo]::ConvertTimeFromUtc($utc, $tz)
    } catch { return $null }
}

function Get-LbiFirst($runObj) {
    if (-not $runObj) { return $null }
    $lb = @($runObj.localBackupInfo)     # object/array safe
    if ($lb.Count -gt 0) { return $lb[0] }
    return $null
}

function Get-EndUsecs([object]$runObj) {
    $info = Get-LbiFirst $runObj
    if ($info -and $info.endTimeUsecs) { return [int64]$info.endTimeUsecs }
    return 0
}

# -------------------------------------------------------------
# 1) Get clusters (sorted) + menu
# -------------------------------------------------------------
$response = Invoke-WebRequest -Method Get -Uri "$baseUrl/v2/mcm/cluster-mgmt/info" -Headers @{ apiKey = $apiKey }
$json = $response.Content | ConvertFrom-Json
$json_clu = $json.cohesityClusters
if (-not $json_clu -or $json_clu.Count -eq 0) { throw "No clusters returned from Helios." }

$sorted = $json_clu | Sort-Object -Property clusterName

$clusters = for ($i = 0; $i -lt $sorted.Count; $i++) {
    [pscustomobject]@{
        Index       = $i + 1
        ClusterName = $sorted[$i].clusterName
        ClusterId   = $sorted[$i].clusterId
    }
}

Write-Host ""
Write-Host "Available Helios Clusters (sorted by name):" -ForegroundColor Cyan
$clusters | Format-Table -AutoSize
Write-Host ""
Write-Host "[0] All clusters" -ForegroundColor Yellow
Write-Host "[X] Exit without selecting" -ForegroundColor Yellow
Write-Host ""

while ($true) {
    $inputVal = Read-Host "Enter 0 for ALL, 1-$($clusters.Count) for single, or X to exit"
    if ($inputVal -match '^(x|X|q|Q)$') { return }

    [int]$num = 0
    if (-not [int]::TryParse($inputVal.Trim(), [ref]$num)) { continue }
    if ($num -lt 0 -or $num -gt $clusters.Count) { continue }

    $selection = $num
    break
}

$SelectedClusters   = if ($selection -eq 0) { $clusters } else { @($clusters | Where-Object { $_.Index -eq $selection }) }
$SelectedClusterIds = $SelectedClusters.ClusterId

# -------------------------------------------------------------
# 2) Collect inventories
# -------------------------------------------------------------
$PGInventory = @()
$VMInventory = @()

foreach ($cid in $SelectedClusterIds) {

    $clus = $SelectedClusters | Where-Object { $_.ClusterId -eq $cid } | Select-Object -First 1
    $clusterName = $clus.ClusterName
    $clusterId   = $clus.ClusterId

    $headers = @{ apiKey = $apiKey; accessClusterId = $clusterId }

    # --- Get Acropolis PGs (add isActive/isPaused/isDeleted filters) ---
    try {
        $pgResp = Invoke-WebRequest `
            -Uri "$baseUrl/v2/data-protect/protection-groups" `
            -Headers $headers `
            -Body @{
                environments = "kAcropolis"
                isDeleted    = "False"
                isActive     = "True"
                isPaused     = "False"
            } `
            -Method Get
        $pgs = ($pgResp.Content | ConvertFrom-Json).protectionGroups
    } catch {
        continue
    }

    if (-not $pgs) { continue }

    foreach ($pg in $pgs) {

        $pgId   = $pg.id
        $pgName = $pg.name

        # --- Get runs WITH object details (needed for VM list) ---
        try {
            $runResp = Invoke-WebRequest `
                -Uri "$baseUrl/v2/data-protect/protection-groups/$pgId/runs" `
                -Headers $headers `
                -Body @{
                    environments        = "kAcropolis"
                    numRuns             = "15"
                    includeObjectDetails= "True"
                } `
                -Method Get

            $runs = (($runResp.Content | ConvertFrom-Json).runs)
        } catch {
            continue
        }

        if (-not $runs) { continue }

        # Inventory run = latest run that has objects (for VM list)
        $inventoryRun = $runs |
            Where-Object { $_.objects } |
            Sort-Object { Get-EndUsecs $_ } -Descending |
            Select-Object -First 1

        if (-not $inventoryRun -or -not $inventoryRun.objects) { continue }

        # Meta run = latest run with localBackupInfo (for status/time)
        $metaRun = $runs |
            Where-Object { @($_.localBackupInfo).Count -gt 0 } |
            Sort-Object { Get-EndUsecs $_ } -Descending |
            Select-Object -First 1

        $metaInfo = Get-LbiFirst $metaRun
        $lastStatus = if ($metaInfo -and $metaInfo.status) { $metaInfo.status } else { "Unknown" }
        $lastEndUsecs = if ($metaInfo -and $metaInfo.endTimeUsecs) { [int64]$metaInfo.endTimeUsecs } else { $null }
        $lastEndET = if ($lastEndUsecs) { Convert-ToET $lastEndUsecs } else { $null }
        $lastEndETText = if ($lastEndET) { $lastEndET.ToString("yyyy-MM-dd HH:mm:ss") } else { "" }

        # Last Successful run time (Succeeded only)
        $successRun = $runs |
            Where-Object {
                $i = Get-LbiFirst $_
                $i -and $i.status -eq "Succeeded" -and $i.endTimeUsecs
            } |
            Sort-Object { Get-EndUsecs $_ } -Descending |
            Select-Object -First 1

        $successInfo = Get-LbiFirst $successRun
        $succEndUsecs = if ($successInfo -and $successInfo.endTimeUsecs) { [int64]$successInfo.endTimeUsecs } else { $null }
        $succEndET = if ($succEndUsecs) { Convert-ToET $succEndUsecs } else { $null }
        $lastSuccessETText = if ($succEndET) { $succEndET.ToString("yyyy-MM-dd HH:mm:ss") } else { "" }

        # Count VMs from inventoryRun.objects
        $pgVMs = 0
        $pgFailed = 0

        foreach ($obj in $inventoryRun.objects) {

            if ($obj.object.environment -ne "kAcropolis") { continue }
            if ($obj.object.objectType -ne "kVirtualMachine") { continue }

            $pgVMs++
            if ($lastStatus -ne "Succeeded") { $pgFailed++ }

            $VMInventory += [pscustomobject]@{
                Cluster          = $clusterName
                ProtectionGroup  = $pgName
                VMName           = $obj.object.name
                LastRunStatus    = $lastStatus
                LastRunET        = $lastEndETText
                LastSuccessfulET = $lastSuccessETText
            }
        }

        $PGInventory += [pscustomobject]@{
            Cluster          = $clusterName
            ProtectionGroup  = $pgName
            TotalVMs         = $pgVMs
            FailedVMs        = $pgFailed
            LastRunStatus    = $lastStatus
            LastRunET        = $lastEndETText
            LastSuccessfulET = $lastSuccessETText
        }
    }
}

if (-not $PGInventory -or $PGInventory.Count -eq 0) {
    Write-Host "`nNo Acropolis inventory collected." -ForegroundColor Yellow
    return
}

# -------------------------------------------------------------
# 3) Cluster Summary (Summary 1)
# -------------------------------------------------------------
$ClusterSummary = $PGInventory |
    Group-Object Cluster |
    ForEach-Object {
        $g = $_.Group
        [pscustomobject]@{
            Cluster            = $_.Name
            PGs                = $g.Count
            TotalVMs           = ($g.TotalVMs | Measure-Object -Sum).Sum
            FailedVMs          = ($g.FailedVMs | Measure-Object -Sum).Sum
            LatestRunET        = (($g.LastRunET | Where-Object { $_ -ne "" }) | Sort-Object -Descending | Select-Object -First 1)
            LatestSuccessfulET = (($g.LastSuccessfulET | Where-Object { $_ -ne "" }) | Sort-Object -Descending | Select-Object -First 1)
        }
    }

# -------------------------------------------------------------
# 4) Output: 2 summaries + full VM list
# -------------------------------------------------------------
Write-Host ""
Write-Host "NOTE:" -ForegroundColor Yellow
Write-Host "VM list shows LastSuccessfulET (Succeeded-only) per protection group." -ForegroundColor Yellow
Write-Host ""

Write-Host "=== Summary 1: Cluster Summary ===" -ForegroundColor Cyan
$ClusterSummary |
    Sort-Object Cluster |
    Format-Table Cluster, PGs, TotalVMs, FailedVMs, LatestRunET, LatestSuccessfulET -AutoSize

Write-Host ""
Write-Host "=== Summary 2: Protection Group Summary ===" -ForegroundColor Cyan
$PGInventory |
    Sort-Object Cluster, ProtectionGroup |
    Format-Table Cluster, ProtectionGroup, TotalVMs, FailedVMs, LastRunStatus, LastRunET, LastSuccessfulET -AutoSize

Write-Host ""
Write-Host "=== Full VM List (with LastSuccessfulET) ===" -ForegroundColor Cyan
$VMInventory |
    Sort-Object Cluster, ProtectionGroup, VMName |
    Format-Table Cluster, ProtectionGroup, VMName, LastRunStatus, LastSuccessfulET -AutoSize
