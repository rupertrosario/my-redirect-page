// -------------------------------------------------------------
// Cohesity Helios ‚Äì AHV (Acropolis) Inventory + Weekly Baseline (STRICT)
// Dynatrace Workflow JS (GET-only)
//
// Output Sections (Markdown + HTML):
// 1) Active Scope Today (Monitored) + Trend (Œî 1d, Net 7d) [STRICT: only if 100% coverage]
// 2) PG State Changes (last 7 days ‚Äî changes only)          [no stable actives]
// 3) VM Scope Trend (7 days) ‚Äî Active PGs only + TOTAL row  [reconciles Section 1]
// 4) Current VM List (latest inventory run only)            [üü¢/üî¥ + last success ET]
//
// Architecture rules:
// - COMPLETED runs only (skip Running everywhere).
// - Global "Inventory As Of" anchored to the PG that completes last:
//   max(endTimeUsecs) among latest completed runs for all ACTIVE PGs.
// - Baseline/trend calculations only use runs with endUsecs <= globalAsOfUsecs.
// - STRICT baseline: show Œî/Net only when Coverage = 100% for required dates.
// -------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // CONFIG
  // ------------------------------
  const DAYS = 7;
  const NUM_RUNS_PULL = 60;              // history depth (tradeoff: time vs completeness)
  const LAST_SUCCESS_RUN_LOOKBACK = 10;  // per-VM last success scan

  // If empty => ALL clusters. Else restrict.
  // const TARGET_CLUSTER_IDS = ["12345", "67890"];
  const TARGET_CLUSTER_IDS = [];

  // ------------------------------
  // 1) Credential vault: name -> id -> manual (same pattern you use)
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312"; // optional fallback

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    let found = null;
    for (let i = 0; i < (all.credentials || []).length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;

    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("‚úì Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
      console.log("‚úì Helios key from vault (id): " + (d2 && d2.name ? d2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("‚ö†Ô∏è Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  // ------------------------------
  // Helpers
  // ------------------------------
  const TZ = "America/New_York";

  function norm(v) { return v === null || v === undefined ? "" : String(v).trim(); }
  function arr(v) { return !v ? [] : (Array.isArray(v) ? v : [v]); }
  function cmpStr(a, b) { return String(a ?? "").localeCompare(String(b ?? "")); }
  function safeCell(v) { return v === null || v === undefined ? "" : String(v).replace(/\|/g, " "); }

  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      const v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) for (let i = 0; i < v.length; i++) usp.append(k, String(v[i]));
      else usp.append(k, String(v));
    }
    return usp.toString();
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  function lbiFirst(runObj) {
    if (!runObj) return null;
    const lb = runObj.localBackupInfo;
    if (!lb) return null;
    return Array.isArray(lb) ? (lb.length ? lb[0] : null) : lb;
  }

  function getEndUsecs(runObj) {
    const info = lbiFirst(runObj);
    const v = info && info.endTimeUsecs;
    const n = Number(v || 0);
    return Number.isFinite(n) ? n : 0;
  }

  function getRunStatus(runObj) {
    const info = lbiFirst(runObj);
    return norm(info && info.status);
  }

  function isCompleted(runObj) {
    // We only trust: status != Running AND endTimeUsecs > 0
    if (!runObj) return false;
    if (getRunStatus(runObj) === "Running") return false;
    return getEndUsecs(runObj) > 0;
  }

  function objFailed(obj) {
    try {
      const fa = obj && obj.localSnapshotInfo && obj.localSnapshotInfo.failedAttempts;
      if (!fa) return false;
      return arr(fa).length > 0;
    } catch {
      return false;
    }
  }

  function usecsToET(usecs) {
    if (!usecs) return { etDate: "", etTs: "" };
    const ms = Math.floor(Number(usecs) / 1000);
    if (!Number.isFinite(ms) || ms <= 0) return { etDate: "", etTs: "" };
    const d = new Date(ms);
    try {
      const fmt = new Intl.DateTimeFormat("en-CA", {
        timeZone: TZ,
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit",
        hour12: false
      });
      const parts = fmt.formatToParts(d);
      const m = {};
      for (let i = 0; i < parts.length; i++) m[parts[i].type] = parts[i].value;
      const etDate = `${m.year}-${m.month}-${m.day}`;
      const etTs = `${etDate} ${m.hour}:${m.minute}:${m.second}`;
      return { etDate, etTs };
    } catch {
      const iso = d.toISOString().replace("T", " ").slice(0, 19);
      return { etDate: iso.slice(0, 10), etTs: iso };
    }
  }

  function mdTable(title, cols, rows) {
    if (!rows || rows.length === 0) return `### ${title}\n\n‚úÖ No rows.\n\n`;
    const header = `| ${cols.join(" | ")} |`;
    const sep = `| ${cols.map(() => "---").join(" | ")} |`;
    const body = rows.map(r => `| ${cols.map(c => safeCell(r[c])).join(" | ")} |`);
    return `### ${title}\n\n${[header, sep].concat(body).join("\n")}\n\n`;
  }

  function htmlEscape(s) {
    return String(s ?? "")
      .replace(/&/g, "&amp;").replace(/</g, "&lt;")
      .replace(/>/g, "&gt;").replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function htmlTable(title, cols, rows, opts = {}) {
    const { highlightTotalRow = false, totalKey = null } = opts;
    let h = `<h3 style="margin:14px 0 8px 0;">${htmlEscape(title)}</h3>`;
    if (!rows || rows.length === 0) return h + `<div>‚úÖ No rows.</div>`;

    h += `<table style="border-collapse:collapse;width:100%;font-family:Segoe UI,Arial,sans-serif;font-size:13px;">`;
    h += `<tr style="background:#e5e7eb;">` +
      cols.map(c => `<th style="text-align:left;padding:8px;border:1px solid #d1d5db;">${htmlEscape(c)}</th>`).join("") +
      `</tr>`;

    for (let i = 0; i < rows.length; i++) {
      const r = rows[i] || {};
      const isTotal = highlightTotalRow && totalKey && norm(r[totalKey]) === "‚≠ê TOTAL";
      const trStyle = isTotal ? `background:#fff7ed;font-weight:800;` : ``;

      h += `<tr style="${trStyle}">`;
      for (let j = 0; j < cols.length; j++) {
        const v = r[cols[j]];
        const s = String(v ?? "");
        let tdStyle = `padding:8px;border:1px solid #d1d5db;`;

        // delta colors
        if (s.includes("üü¢")) tdStyle += `color:#16a34a;font-weight:800;`;
        if (s.includes("üî¥")) tdStyle += `color:#dc2626;font-weight:800;`;
        if (s.includes("‚ö†Ô∏è")) tdStyle += `color:#b45309;font-weight:800;`;

        // radio style for VM status in HTML: green/red dot
        if (cols[j] === "BackupStatus") {
          if (s === "üü¢") tdStyle += `color:#16a34a;font-size:16px;font-weight:900;`;
          if (s === "üî¥") tdStyle += `color:#dc2626;font-size:16px;font-weight:900;`;
          // render dot instead of emoji
          const dot = (s === "üü¢") ? "‚óè" : (s === "üî¥") ? "‚óè" : s;
          h += `<td style="${tdStyle}">${dot}</td>`;
          continue;
        }

        h += `<td style="${tdStyle}">${htmlEscape(v)}</td>`;
      }
      h += `</tr>`;
    }

    h += `</table>`;
    return h;
  }

  function deltaBadge(n) {
    if (n === null || n === undefined) return "‚Äî";
    const v = Number(n);
    if (!Number.isFinite(v)) return "‚Äî";
    if (v === 0) return "0";
    return v > 0 ? `üü¢ **+${v}**` : `üî¥ **-${Math.abs(v)}**`;
  }

  // Count AHV VMs from objects array (only VMs)
  function countAHVVmsFromObjects(objects) {
    let total = 0;
    const objs = arr(objects);
    for (let i = 0; i < objs.length; i++) {
      const x = objs[i] || {};
      const o = x.object || {};
      if (norm(o.environment) !== "kAcropolis") continue;
      if (norm(o.objectType) !== "kVirtualMachine") continue;
      if (!norm(o.name)) continue;
      total++;
    }
    return total;
  }

  // ------------------------------
  // 2) Clusters
  // ------------------------------
  const commonHeaders = { accept: "application/json", apiKey: apiKey };
  const cluData = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, commonHeaders);
  let clusters = arr(cluData && cluData.cohesityClusters);

  clusters.sort((a, b) => cmpStr(a && a.clusterName, b && b.clusterName));

  if (TARGET_CLUSTER_IDS && TARGET_CLUSTER_IDS.length) {
    const allow = {};
    for (let i = 0; i < TARGET_CLUSTER_IDS.length; i++) allow[String(TARGET_CLUSTER_IDS[i])] = true;
    clusters = clusters.filter(c => allow[String(c && c.clusterId)]);
  }

  if (!clusters.length) {
    return { authMode, markdownAll: "‚ö†Ô∏è No clusters returned from /v2/mcm/cluster-mgmt/info" };
  }

  // ------------------------------
  // 3) PG lists per cluster
  // ------------------------------
  async function fetchPGs(clusterId, qp) {
    const headers = { accept: "application/json", apiKey: apiKey, accessClusterId: String(clusterId) };
    const url = `${baseUrl}/v2/data-protect/protection-groups?` +
      buildQuery(Object.assign({ environments: "kAcropolis" }, qp));
    const data = await getJson(url, headers);
    return arr(data && data.protectionGroups);
  }

  const activePGs = [];   // [{clusterId,clusterName,pgId,pgName}]
  const pausedPGs = [];   // for changes section
  const deletedPGs = [];  // for changes section

  // For "PG changes": we want to detect NEW/NO RUNS for active today, plus paused/deleted today.
  for (let ci = 0; ci < clusters.length; ci++) {
    const c = clusters[ci] || {};
    const clusterId = norm(c.clusterId);
    const clusterName = norm(c.clusterName);
    if (!clusterId) continue;

    let pActive = [], pPaused = [], pDeleted = [];

    try { pActive = await fetchPGs(clusterId, { isDeleted: "False", isActive: "True", isPaused: "False" }); } catch {}
    try { pPaused = await fetchPGs(clusterId, { isDeleted: "False", isPaused: "True" }); } catch {}
    try { pDeleted = await fetchPGs(clusterId, { isDeleted: "True" }); } catch {}

    for (let i = 0; i < pActive.length; i++) {
      const pg = pActive[i] || {};
      const pgId = norm(pg.id);
      const pgName = norm(pg.name);
      if (!pgId || !pgName) continue;
      activePGs.push({ clusterId, clusterName, pgId, pgName });
    }

    for (let i = 0; i < pPaused.length; i++) {
      const pg = pPaused[i] || {};
      const pgId = norm(pg.id);
      const pgName = norm(pg.name);
      if (!pgName) continue;
      pausedPGs.push({ clusterId, clusterName, pgId, pgName });
    }

    for (let i = 0; i < pDeleted.length; i++) {
      const pg = pDeleted[i] || {};
      const pgId = norm(pg.id);
      const pgName = norm(pg.name);
      if (!pgName) continue;
      deletedPGs.push({ clusterId, clusterName, pgId, pgName });
    }
  }

  if (!activePGs.length) {
    return { authMode, markdownAll: "‚ö†Ô∏è No ACTIVE AHV protection groups found (isDeleted=False,isActive=True,isPaused=False)." };
  }

  // ------------------------------
  // 4) Pull runs for ACTIVE PGs and build:
  // - latest inventory run per PG (completed, has objects) for VM list
  // - per PG totals by ET date (completed, objects) for trend
  // - globalAsOfUsecs = max end time among latest inventory runs (PG that completes last)
  // - only use runs <= globalAsOfUsecs for baseline/trend scope
  // ------------------------------
  async function fetchRuns(clusterId, pgId, includeObjectDetails) {
    const headers = { accept: "application/json", apiKey: apiKey, accessClusterId: String(clusterId) };
    const url =
      `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs?` +
      buildQuery({
        environments: "kAcropolis",
        numRuns: String(NUM_RUNS_PULL),
        includeObjectDetails: includeObjectDetails ? "True" : "False"
      });
    const data = await getJson(url, headers);
    return arr(data && data.runs);
  }

  // Storage
  const perPG = {}; // key clusterName|pgName => {Cluster,ProtectionGroup, totalsByDate:{date->count}, inventoryRun, inventoryEndUsecs}
  const VMInventory = [];
  const inventoryEndTimes = []; // endUsecs for each PG inventory run
  const allDatesSet = new Set();

  // We need objects to count VMs per day (for trend) and to build VM list.
  // So includeObjectDetails=True here.
  for (let i = 0; i < activePGs.length; i++) {
    const p = activePGs[i];

    let runs = [];
    try {
      runs = await fetchRuns(p.clusterId, p.pgId, true);
    } catch {
      continue;
    }

    // completed only + must have objects (for counting VMs)
    runs = runs
      .filter(r => r && r.objects && isCompleted(r))
      .sort((a, b) => getEndUsecs(b) - getEndUsecs(a));

    if (!runs.length) {
      // Active PG with no completed runs in pulled history => still valid for "NO RUNS (7d)" classification later
      perPG[`${p.clusterName}|${p.pgName}`] = {
        Cluster: p.clusterName,
        ProtectionGroup: p.pgName,
        totalsByDate: {},
        inventoryRun: null,
        inventoryEndUsecs: 0,
        allCompletedEndUsecs: []
      };
      continue;
    }

    // Inventory run = latest completed with objects
    const inventoryRun = runs[0];
    const invEndUsecs = getEndUsecs(inventoryRun);
    if (invEndUsecs > 0) inventoryEndTimes.push(invEndUsecs);

    const key = `${p.clusterName}|${p.pgName}`;
    const totalsByDate = {};
    const completedEnds = [];

    // Build latest-run-per-ET-date counts
    // NOTE: we will later scope to <= globalAsOfUsecs, but we can collect now.
    for (let r = 0; r < runs.length; r++) {
      const endUsecs = getEndUsecs(runs[r]);
      completedEnds.push(endUsecs);

      const et = usecsToET(endUsecs);
      if (!et.etDate) continue;

      // Keep first we see for each date because runs are sorted desc => first = latest for that date
      if (!Object.prototype.hasOwnProperty.call(totalsByDate, et.etDate)) {
        totalsByDate[et.etDate] = countAHVVmsFromObjects(runs[r].objects);
        allDatesSet.add(et.etDate);
      }
    }

    perPG[key] = {
      Cluster: p.clusterName,
      ProtectionGroup: p.pgName,
      totalsByDate: totalsByDate,
      inventoryRun: inventoryRun,
      inventoryEndUsecs: invEndUsecs,
      allCompletedEndUsecs: completedEnds
    };
  }

  // Global As Of anchored to PG that completes last
  let globalAsOfUsecs = 0;
  for (let i = 0; i < inventoryEndTimes.length; i++) {
    const u = Number(inventoryEndTimes[i] || 0);
    if (u > globalAsOfUsecs) globalAsOfUsecs = u;
  }
  const globalAsOfET = globalAsOfUsecs ? usecsToET(globalAsOfUsecs).etTs : "";

  // Scope dates (last DAYS) based on completed runs <= globalAsOfUsecs
  // We take unique dates that appear in perPG totalsByDate, but only those with some run <= globalAsOfUsecs.
  // Since totalsByDate was built from all runs, we need to ensure the date exists <= asOf:
  // easiest: we rebuild a date set using endUsecs <= asOf by checking each PG's completedEnds.
  const scopedDatesSet = new Set();
  const keys = Object.keys(perPG);

  for (let k = 0; k < keys.length; k++) {
    const pg = perPG[keys[k]];
    const ends = pg.allCompletedEndUsecs || [];
    for (let e = 0; e < ends.length; e++) {
      const endUsecs = Number(ends[e] || 0);
      if (!endUsecs || endUsecs > globalAsOfUsecs) continue;
      const et = usecsToET(endUsecs);
      if (et.etDate) scopedDatesSet.add(et.etDate);
    }
  }

  const dateList = Array.from(scopedDatesSet).sort((a, b) => b.localeCompare(a)).slice(0, DAYS);

  // Helper: does this PG have a completed run (count) on date within scoped window?
  function pgHasDate(pgObj, d) {
    // totalsByDate might include that date from a run beyond asOf, but we scoped date list from <=asOf.
    // So if d is in dateList, totalsByDate[d] is acceptable as "latest for that date" within pulled runs.
    return Object.prototype.hasOwnProperty.call(pgObj.totalsByDate || {}, d);
  }

  // ------------------------------
  // 5) STRICT coverage computation
  // Coverage by date across ALL active PGs (global) and per cluster.
  // ------------------------------
  const activeKeys = keys; // perPG is built for active PGs only

  function coverageForDate(date, clusterNameOrNull) {
    let total = 0;
    let have = 0;
    for (let i = 0; i < activeKeys.length; i++) {
      const pg = perPG[activeKeys[i]];
      if (!pg) continue;
      if (clusterNameOrNull && pg.Cluster !== clusterNameOrNull) continue;

      total++;
      if (pgHasDate(pg, date)) have++;
    }
    const pct = total ? Math.round((have / total) * 100) : 0;
    return { total, have, pct };
  }

  // Baseline date (global) = OLDEST date in dateList with 100% coverage
  let baselineDateGlobal = "";
  for (let i = dateList.length - 1; i >= 0; i--) {
    const d = dateList[i];
    const cov = coverageForDate(d, null);
    if (cov.total > 0 && cov.have === cov.total) { baselineDateGlobal = d; break; }
  }

  // For Œî1d, we use dateList[0] as "today date" (latest seen date) and dateList[1] as previous.
  const todayDate = dateList.length ? dateList[0] : "";
  const prevDate = dateList.length > 1 ? dateList[1] : "";

  // strict: Œî1d only if both dates have 100% coverage
  const covTodayGlobal =
