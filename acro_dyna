// -------------------------------------------------------------
// Cohesity Helios â€“ AHV Inventory + Drift + VM Exceptions
// Completed runs only. No POST/PUT/DELETE.
// -------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {

  const BASE_URL = "https://helios.cohesity.com";
  const TODAY_ET = new Date(); // used only for labeling
  const LOOKBACK_DAYS = 7;     // drift window
  const MAX_LOOKBACK_DAYS = 35;// retention cap
  const STALE_VM_DAYS = 14;

  // ---------------------------
  // Auth (vault â†’ manual)
  // ---------------------------
  let apiKey = null;
  try {
    const creds = await credentialVaultClient.getCredentials();
    const found = creds.credentials.find(c => c.name === "Cohesity_API_Key");
    if (found) {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
      apiKey = detail.token || detail.password;
    }
  } catch (_) {}

  if (!apiKey) {
    apiKey = "PASTE_API_KEY_HERE";
  }

  const commonHeaders = {
    accept: "application/json",
    apiKey
  };

  // ---------------------------
  // Helpers
  // ---------------------------
  const toArr = v => Array.isArray(v) ? v : (v ? [v] : []);
  const norm = v => (v ?? "").toString().trim();

  function usecsToET(usecs) {
    if (!usecs) return "";
    const ms = Math.floor(Number(usecs) / 1000);
    return new Intl.DateTimeFormat("en-CA", {
      timeZone: "America/New_York",
      hour12: false,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    }).format(new Date(ms)).replace(",", "");
  }

  function dayKey(etString) {
    return etString.split(" ")[0]; // YYYY-MM-DD
  }

  async function getJson(url, headers) {
    const r = await fetch(url, { method: "GET", headers });
    if (!r.ok) throw new Error(`${url} ${r.status}`);
    return r.json();
  }

  // ---------------------------
  // 1) Get clusters
  // ---------------------------
  const clustersResp = await getJson(`${BASE_URL}/v2/mcm/cluster-mgmt/info`, commonHeaders);
  const clusters = toArr(clustersResp.cohesityClusters);

  const pgRows = [];
  const vmExceptions = [];
  const activeScope = [];

  // ---------------------------
  // 2) Per cluster â†’ PGs â†’ runs
  // ---------------------------
  for (const c of clusters) {

    const headers = { ...commonHeaders, accessClusterId: c.clusterId };

    const pgResp = await getJson(
      `${BASE_URL}/v2/data-protect/protection-groups?environments=kAcropolis&isActive=True&isDeleted=False&isPaused=False`,
      headers
    );

    const pgs = toArr(pgResp.protectionGroups);

    for (const pg of pgs) {

      const runResp = await getJson(
        `${BASE_URL}/v2/data-protect/protection-groups/${pg.id}/runs?includeObjectDetails=True&numRuns=50`,
        headers
      );

      const runs = toArr(runResp.runs)
        .filter(r => r.localBackupInfo?.[0]?.status !== "Running")
        .map(r => ({
          endET: usecsToET(r.localBackupInfo?.[0]?.endTimeUsecs),
          objects: toArr(r.objects)
        }))
        .filter(r => r.endET);

      if (!runs.length) {
        // No completed runs ever
        pgRows.push({
          cluster: c.clusterName,
          pg: pg.name,
          todayVMs: 0,
          daily: Array(LOOKBACK_DAYS).fill("NR"),
          status: "-",
          lastDelta: "-"
        });
        continue;
      }

      // Build per-day snapshots
      const daySnapshots = {};
      for (const r of runs) {
        const d = dayKey(r.endET);
        if (!daySnapshots[d]) {
          const vms = r.objects.filter(o => o.object?.objectType === "kVirtualMachine");
          daySnapshots[d] = {
            vmCount: vms.length,
            failedVMs: vms.filter(o => o.localSnapshotInfo?.failedAttempts?.length).length,
            endET: r.endET,
            objects: vms
          };
        }
      }

      const days = Object.keys(daySnapshots).sort().reverse();
      const todayDay = days[0];

      // Build drift
      const daily = [];
      let lastKnownDelta = "-";
      let todayDelta = null;

      for (let i = 0; i < LOOKBACK_DAYS; i++) {
        const d = days[i];
        if (!d) {
          daily.push("NR");
          continue;
        }
        const curr = daySnapshots[d];
        const prev = days[i + 1] ? daySnapshots[days[i + 1]] : null;
        if (!prev) {
          daily.push("NR");
          continue;
        }
        const delta = curr.vmCount - prev.vmCount;
        if (delta === 0) daily.push("0");
        else {
          const cell = `${delta > 0 ? "ðŸŸ¢ +" : "ðŸ”´ "}${delta} (${d.slice(8,10)}/${d.slice(5,7)})`;
          daily.push(cell);
          if (lastKnownDelta === "-") lastKnownDelta = cell;
          if (i === 0) todayDelta = delta;
        }
      }

      // Active scope only if completed today
      if (todayDelta !== null) {
        activeScope.push({
          cluster: c.clusterName,
          pg: pg.name,
          vms: daySnapshots[todayDay].vmCount,
          delta: todayDelta
        });
      }

      // VM exceptions (latest snapshot only)
      const latest = daySnapshots[todayDay];
      if (latest) {
        for (const o of latest.objects) {
          const failed = o.localSnapshotInfo?.failedAttempts?.length > 0;
          if (failed) {
            vmExceptions.push({
              cluster: c.clusterName,
              pg: pg.name,
              vm: o.object.name,
              status: "ðŸ”´",
              lastSuccess: "-",
              flag: "ðŸ”´ Failed (latest)"
            });
          }
        }
      }

      pgRows.push({
        cluster: c.clusterName,
        pg: pg.name,
        todayVMs: daySnapshots[todayDay]?.vmCount ?? 0,
        daily,
        status: daily.every(x => x === "NR") ? "-" : "OK",
        lastDelta: lastKnownDelta
      });
    }
  }

  // ---------------------------
  // 3) Build Active Scope totals
  // ---------------------------
  const scopeByCluster = {};
  for (const a of activeScope) {
    if (!scopeByCluster[a.cluster]) {
      scopeByCluster[a.cluster] = { pgs: 0, vms: 0, delta: 0 };
    }
    scopeByCluster[a.cluster].pgs++;
    scopeByCluster[a.cluster].vms += a.vms;
    scopeByCluster[a.cluster].delta += a.delta;
  }

  const activeScopeTable = Object.entries(scopeByCluster).map(([k, v]) => ({
    Cluster: k,
    Active_PGs: v.pgs,
    TotalVMs: v.vms,
    TodayDelta: v.delta
  }));

  const totalScope = activeScopeTable.reduce(
    (a, b) => ({
      Cluster: "TOTAL",
      Active_PGs: a.Active_PGs + b.Active_PGs,
      TotalVMs: a.TotalVMs + b.TotalVMs,
      TodayDelta: a.TodayDelta + b.TodayDelta
    }),
    { Active_PGs: 0, TotalVMs: 0, TodayDelta: 0 }
  );

  // ---------------------------
  // Final return
  // ---------------------------
  return {
    activeScope: [...activeScopeTable, totalScope],
    pgDrift: pgRows,
    vmExceptions
  };
}
