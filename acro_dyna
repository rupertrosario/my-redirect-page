// -------------------------------------------------------------
// Dynatrace JS2 | Cohesity AHV Inventory (Object-level)
// READ ONLY â€” GET requests only
// NO POST / PUT / DELETE
//
// OUTPUT:
// - markdownEmail (email-safe Markdown tables)
//
// SECTIONS:
// 1) Active Scope Today (Monitored)
// 2) PG Trend (7-day) + PG State (Combined)
// 3) VM Backup Issues (FAILED + STALE only)
//
// Vault handling: NAME â†’ ID â†’ manual (matches Interface-DOWN script)
// -------------------------------------------------------------

import { credentialVaultClient as vault } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {

  const baseUrl = "https://helios.cohesity.com";
  const TZ = "America/New_York";

  const TREND_DAYS = 7;
  const MAX_RETENTION = 35;
  const LAST_SUCCESS_RUNS = 10;

  // -------------------------------------------------------------
  // Vault (NAME â†’ ID â†’ manual fallback) â€” SAME AS SAMPLE
  // -------------------------------------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await vault.getCredentials();
    const creds = (all && all.credentials) ? all.credentials : [];
    const found = creds.find(c => c && c.name === name);
    if (!found) return null;

    const detail = await vault.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const d2 = await vault.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey || apiKey === "PASTE_YOUR_API_KEY_HERE") {
    throw new Error("No valid Helios API key available.");
  }

  const commonHeaders = {
    accept: "application/json",
    apiKey
  };

  // -------------------------------------------------------------
  // Helpers
  // -------------------------------------------------------------
  const A = v => Array.isArray(v) ? v : (v ? [v] : []);
  const N = v => (v === null || v === undefined) ? "" : String(v).trim();

  async function getJson(url, headers) {
    const r = await fetch(url, { method: "GET", headers });
    if (!r.ok) {
      const t = await r.text().catch(() => "");
      throw new Error(`HTTP ${r.status} ${t}`);
    }
    return r.json();
  }

  function et(usecs) {
    const d = new Date(Math.floor(usecs / 1000));
    return new Intl.DateTimeFormat("en-CA", {
      timeZone: TZ,
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      hour12: false
    }).format(d).replace(",", "");
  }

  function day(usecs) {
    return et(usecs).slice(0, 10);
  }

  function runCompleted(r) {
    const lb = A(r.localBackupInfo)[0];
    return lb && lb.status !== "Running" && lb.endTimeUsecs;
  }

  function vmCount(run) {
    return A(run.objects).filter(o =>
      o.object?.environment === "kAcropolis" &&
      o.object?.objectType === "kVirtualMachine"
    ).length;
  }

  function failed(obj) {
    return A(obj.localSnapshotInfo?.failedAttempts).length > 0;
  }

  function retentionFromDays(d) {
    if (!d || d <= 7) return 7;
    if (d <= 14) return 14;
    return 35;
  }

  function mdEsc(v) {
    return String(v ?? "").replace(/\|/g, " ").replace(/\n/g, " ").trim();
  }

  function mdTable(title, cols, rows) {
    let out = `## ${title}\n\n`;
    if (!rows.length) return out + "_(no rows)_\n\n";
    out += `| ${cols.join(" | ")} |\n`;
    out += `| ${cols.map(() => "---").join(" | ")} |\n`;
    for (const r of rows) {
      out += `| ${cols.map(c => mdEsc(r[c])).join(" | ")} |\n`;
    }
    out += "\n";
    return out;
  }

  // -------------------------------------------------------------
  // Data holders
  // -------------------------------------------------------------
  const activeSummary = {};
  const pgTrend = [];
  const vmIssues = [];

  // -------------------------------------------------------------
  // Clusters
  // -------------------------------------------------------------
  const clusters = A((await getJson(
    `${baseUrl}/v2/mcm/cluster-mgmt/info`,
    commonHeaders
  )).cohesityClusters);

  for (const c of clusters) {

    const CH = { ...commonHeaders, accessClusterId: c.clusterId };

    // Active + Paused PGs only (Deleted excluded)
    const pgs = A((await getJson(
      `${baseUrl}/v2/data-protect/protection-groups?environments=kAcropolis&isDeleted=False`,
      CH
    )).protectionGroups).filter(pg => pg.isActive || pg.isPaused);

    for (const pg of pgs) {

      // ---------------------------------------------------------
      // Policy â†’ retention
      // ---------------------------------------------------------
      let retention = 7;
      if (pg.policyId) {
        try {
          const pol = await getJson(
            `${baseUrl}/irisservices/api/v1/public/protectionPolicies/${pg.policyId}`,
            CH
          );
          retention = retentionFromDays(pol.daysToKeep);
        } catch {}
      }

      // ---------------------------------------------------------
      // Runs (completed only)
      // ---------------------------------------------------------
      const runs = A((await getJson(
        `${baseUrl}/v2/data-protect/protection-groups/${pg.id}/runs?numRuns=150&includeObjectDetails=True`,
        CH
      )).runs)
        .filter(runCompleted)
        .sort((a, b) =>
          A(b.localBackupInfo)[0].endTimeUsecs -
          A(a.localBackupInfo)[0].endTimeUsecs
        );

      if (!runs.length) continue;

      const todayRun = runs[0];
      const todayDay = day(A(todayRun.localBackupInfo)[0].endTimeUsecs);

      // ---------------------------------------------------------
      // Daily deltas (7-day window)
      // ---------------------------------------------------------
      const byDay = {};
      for (const r of runs) {
        const u = A(r.localBackupInfo)[0].endTimeUsecs;
        const d = day(u);
        if (!byDay[d]) byDay[d] = vmCount(r);
      }

      const days = Object.keys(byDay).sort();
      let todayDelta = 0;
      let lastKnownDelta = "";

      for (let i = 1; i < days.length; i++) {
        const delta = byDay[days[i]] - byDay[days[i - 1]];
        if (delta !== 0) {
          lastKnownDelta = `${delta > 0 ? "ðŸŸ¢ +" : "ðŸ”´ "}${delta} (${days[i]})`;
          if (days[i] === todayDay) todayDelta = delta;
        }
      }

      const totalVMs = vmCount(todayRun);

      // ---------------------------------------------------------
      // PG Trend row
      // ---------------------------------------------------------
      pgTrend.push({
        Cluster: c.clusterName,
        ProtectionGroup: pg.name,
        TotalVMs: totalVMs,
        "Today (Î”)": todayDelta > 0 ? `ðŸŸ¢ +${todayDelta}` :
                     todayDelta < 0 ? `ðŸ”´ ${todayDelta}` : "0",
        "Last Known Delta": lastKnownDelta || "-",
        "Last Completed Job (ET)": et(A(todayRun.localBackupInfo)[0].endTimeUsecs),
        "PG State": pg.isPaused ? "ðŸŸ¡ PAUSED" : "ðŸŸ¢ ACTIVE"
      });

      // ---------------------------------------------------------
      // Active summary
      // ---------------------------------------------------------
      activeSummary[c.clusterName] ??= { pgs: 0, vms: 0, delta: 0 };
      activeSummary[c.clusterName].pgs++;
      activeSummary[c.clusterName].vms += totalVMs;
      activeSummary[c.clusterName].delta += todayDelta;

      // ---------------------------------------------------------
      // VM Backup Issues (FAILED + STALE only)
      // ---------------------------------------------------------
      const cutoffUsecs = Date.now() * 1000 - (retention * 86400000000);

      for (const obj of A(todayRun.objects)) {
        if (obj.object?.objectType !== "kVirtualMachine") continue;

        let lastSuccess = "";
        for (const r of runs.slice(0, LAST_SUCCESS_RUNS)) {
          const u = A(r.localBackupInfo)[0].endTimeUsecs;
          if (u < cutoffUsecs) break;

          const o = A(r.objects).find(x => x.object?.name === obj.object.name);
          if (o && !failed(o)) {
            lastSuccess = et(u);
            break;
          }
        }

        if (failed(obj) || !lastSuccess) {
          vmIssues.push({
            Cluster: c.clusterName,
            ProtectionGroup: pg.name,
            VMName: obj.object.name,
            Status: failed(obj) ? "ðŸ”´ FAILED" : "ðŸŸ  STALE",
            "Last Backup": lastSuccess || `No backup within â‰¤${retention}d retention`
          });
        }
      }
    }
  }

  // -------------------------------------------------------------
  // Build markdownEmail
  // -------------------------------------------------------------
  const activeRows = Object.keys(activeSummary).map(k => ({
    Cluster: k,
    Active_PGs: activeSummary[k].pgs,
    TotalVMs: activeSummary[k].vms,
    "Todayâ€™s Delta":
      activeSummary[k].delta > 0 ? `ðŸŸ¢ +${activeSummary[k].delta}` :
      activeSummary[k].delta < 0 ? `ðŸ”´ ${activeSummary[k].delta}` : "0"
  }));

  const markdownEmail =
    "## Cohesity AHV Inventory (Object-level)\n\n" +
    `Inventory As Of (ET): **${et(Date.now() * 1000)}**\n\n` +
    mdTable(
      "1) Active Scope Today (Monitored)",
      ["Cluster", "Active_PGs", "TotalVMs", "Todayâ€™s Delta"],
      activeRows
    ) +
    mdTable(
      "2) PG Trend (7-day) + PG State (Combined)",
      ["Cluster", "ProtectionGroup", "TotalVMs", "Today (Î”)", "Last Known Delta", "Last Completed Job (ET)", "PG State"],
      pgTrend
    ) +
    mdTable(
      "3) VM Backup Issues (FAILED + STALE only)",
      ["Cluster", "ProtectionGroup", "VMName", "Status", "Last Backup"],
      vmIssues
    );

  return {
    ok: true,
    authMode,
    markdownEmail
  };
}
