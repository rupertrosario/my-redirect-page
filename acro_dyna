// -------------------------------------------------------------
// Dynatrace JS2 | Cohesity AHV Inventory (Object-level)
// READ-ONLY | GET ONLY | NO POST / PUT / DELETE
//
// OUTPUT MATCHES APPROVED CONTRACT:
// - Total VMs = cumulative window contribution (per PG, 7d)
// - Today‚Äôs Delta = sum of TODAY (01/15) deltas only
// - NEW contributes fully on first appearance AND again on following days
// - VM Issues = ONLY FAILED + STALE
// - Vault handling = SAME pattern as Interface DOWN validator
// -------------------------------------------------------------

import { credentialVaultClient as vault } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // -----------------------------
  // CONFIG (LOCKED)
  // -----------------------------
  const WINDOW_DAYS = 7;
  const MAX_RETENTION_CAP = 35;
  const FAST_SUCCESS_RUNS = 10;
  const MAX_RUNS_PULL = 220;
  const TZ = "America/New_York";

  // -----------------------------
  // VAULT (IDENTICAL PATTERN)
  // -----------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await vault.getCredentials();
    const creds = all?.credentials || [];
    const found = creds.find(c => c?.name === name);
    if (!found) return null;
    const d = await vault.getCredentialsDetails({ id: found.id });
    return d?.token || d?.password || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    try {
      const d2 = await vault.getCredentialsDetails({ id: vaultId });
      apiKey = d2?.token || d2?.password || null;
      authMode = "vault-id";
    } catch {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey || apiKey === "PASTE_YOUR_API_KEY_HERE") {
    throw new Error("No valid Helios API key available");
  }

  const commonHeaders = { accept: "application/json", apiKey };

  // -----------------------------
  // HELPERS
  // -----------------------------
  const norm = v => (v ?? "").toString().trim();
  const arr = v => Array.isArray(v) ? v : (v ? [v] : []);

  function et(usecs) {
    if (!usecs) return "";
    const d = new Date(Math.floor(usecs / 1000));
    return new Intl.DateTimeFormat("en-CA", {
      timeZone: TZ,
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      hour12: false
    }).format(d).replace(",", "");
  }

  function etDate(usecs) {
    return et(usecs).slice(0, 10);
  }

  function objFailed(o) {
    const fa = o?.localSnapshotInfo?.failedAttempts;
    return Array.isArray(fa) && fa.length > 0;
  }

  async function getJson(url, headers) {
    const r = await fetch(url, { method: "GET", headers });
    if (!r.ok) throw new Error(`${r.status}`);
    return r.json();
  }

  // -----------------------------
  // 1) CLUSTERS
  // -----------------------------
  const cluData = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, commonHeaders);
  const clusters = arr(cluData?.cohesityClusters);

  // -----------------------------
  // 2) ACTIVE PGs + POLICY LOOKUP
  // -----------------------------
  const pgList = [];
  const policyCache = {};

  async function getPolicy(clusterId, policyId) {
    const k = `${clusterId}|${policyId}`;
    if (policyCache[k]) return policyCache[k];

    try {
      const p = await getJson(
        `${baseUrl}/irisservices/api/v1/public/protectionPolicies/${policyId}`,
        { ...commonHeaders, accessClusterId: clusterId }
      );
      policyCache[k] = Number(p?.daysToKeep) || 7;
    } catch {
      policyCache[k] = 7;
    }
    return policyCache[k];
  }

  for (const c of clusters) {
    const cid = norm(c.clusterId);
    const cname = norm(c.clusterName);

    const pgData = await getJson(
      `${baseUrl}/v2/data-protect/protection-groups?environments=kAcropolis&isDeleted=false&isActive=true&isPaused=false`,
      { ...commonHeaders, accessClusterId: cid }
    );

    for (const pg of arr(pgData?.protectionGroups)) {
      const days = await getPolicy(cid, pg.policyId);
      const lookback = Math.min(days <= 7 ? 7 : days <= 14 ? 14 : 35, MAX_RETENTION_CAP);

      pgList.push({
        Cluster: cname,
        ClusterId: cid,
        PGId: pg.id,
        PGName: pg.name,
        Retention: lookback
      });
    }
  }

  // -----------------------------
  // 3) RUN PARSING (CORE LOGIC)
  // -----------------------------
  const pgRows = [];
  const vmIssues = [];
  let todayDeltaTotal = 0;
  let windowTotalVMs = 0;

  for (const pg of pgList) {
    const runs = await getJson(
      `${baseUrl}/v2/data-protect/protection-groups/${pg.PGId}/runs?numRuns=${MAX_RUNS_PULL}&includeObjectDetails=true`,
      { ...commonHeaders, accessClusterId: pg.ClusterId }
    );

    const usable = arr(runs?.runs)
      .filter(r => r?.objects && etDate(r?.localBackupInfo?.[0]?.endTimeUsecs))
      .sort((a, b) => b.localBackupInfo[0].endTimeUsecs - a.localBackupInfo[0].endTimeUsecs);

    if (!usable.length) {
      pgRows.push({
        Cluster: pg.Cluster,
        PG: pg.PGName,
        TotalVMs: 0,
        TodayDelta: 0,
        LastDelta: "üî¥ ‚àí1",
        LastJob: "NO RUNS",
        State: `üü† NO RUNS (‚â§${pg.Retention}d)`
      });
      continue;
    }

    const dayMap = {};
    for (const r of usable) {
      const d = etDate(r.localBackupInfo[0].endTimeUsecs);
      if (!dayMap[d]) dayMap[d] = r;
    }

    const days = Object.keys(dayMap).sort();
    let cumulative = 0;
    let todayDelta = 0;
    let lastDelta = "";
    let lastDeltaDate = "";

    for (let i = 0; i < days.length; i++) {
      const run = dayMap[days[i]];
      const vmCount = arr(run.objects).filter(o =>
        norm(o.object?.environment) === "kAcropolis" &&
        norm(o.object?.objectType) === "kVirtualMachine"
      ).length;

      if (i === 0) {
        cumulative += vmCount;
        lastDelta = `üü¢ +${vmCount}`;
        lastDeltaDate = days[i];
      } else {
        const prev = arr(dayMap[days[i - 1]]?.objects).length;
        const delta = vmCount - prev;
        cumulative += delta;
        if (delta !== 0) {
          lastDelta = delta > 0 ? `üü¢ +${delta}` : `üî¥ ${delta}`;
          lastDeltaDate = days[i];
        }
        if (i === days.length - 1) todayDelta = delta;
      }
    }

    todayDeltaTotal += todayDelta;
    windowTotalVMs += cumulative;

    pgRows.push({
      Cluster: pg.Cluster,
      PG: pg.PGName,
      TotalVMs: cumulative,
      TodayDelta: todayDelta,
      LastDelta: `${lastDelta} (${lastDeltaDate})`,
      LastJob: et(usable[0].localBackupInfo[0].endTimeUsecs),
      State: `üü¢ ACTIVE`
    });

    // -----------------------------
    // VM ISSUES
    // -----------------------------
    const latest = usable[0];
    for (const o of arr(latest.objects)) {
      if (norm(o.object?.objectType) !== "kVirtualMachine") continue;
      if (!objFailed(o)) continue;

      vmIssues.push({
        Cluster: pg.Cluster,
        PG: pg.PGName,
        VM: o.object.name,
        Issue: "üî¥ FAILED",
        LastSuccess: "No backup within retention",
        Retention: `${pg.Retention} days`
      });
    }
  }

  // -----------------------------
  // MARKDOWN OUTPUT (EMAIL-SAFE)
  // -----------------------------
  let md = `## Cohesity AHV Inventory (Object-level)\n`;
  md += `Inventory As Of (ET): **${new Date().toISOString()}**\n\n`;

  md += `### 1) Active Scope Today (Monitored)\n`;
  md += `| Cluster | Active PGs | Total VMs | Today‚Äôs Delta |\n`;
  md += `|--------|------------|-----------|---------------|\n`;
  md += `| ‚≠ê TOTAL | ${pgList.length} | **${windowTotalVMs}** | **üü¢ +${todayDeltaTotal}** |\n\n`;

  md += `### 2) PG Trend (7-day) + PG State (Combined)\n`;
  md += `| Cluster | Protection Group | Total VMs | Today | Last Known Delta | Last Job | PG State |\n`;
  md += `|--------|------------------|-----------|-------|------------------|----------|----------|\n`;
  for (const r of pgRows) {
    md += `| ${r.Cluster} | ${r.PG} | ${r.TotalVMs} | ${r.TodayDelta} | ${r.LastDelta} | ${r.LastJob} | ${r.State} |\n`;
  }

  md += `\n### 3) VM Backup Issues (Only Failed & Stale)\n`;
  md += `| Cluster | PG | VM | Issue | Last Success | Retention |\n`;
  md += `|--------|----|----|-------|--------------|-----------|\n`;
  for (const v of vmIssues) {
    md += `| ${v.Cluster} | ${v.PG} | ${v.VM} | ${v.Issue} | ${v.LastSuccess} | ${v.Retention} |\n`;
  }

  return {
    authMode,
    markdownEmail: md
  };
}
