// -------------------------------------------------------------
// Cohesity Helios ‚Äì AHV (Acropolis) Inventory + Weekly Baseline (STRICT)
// Dynatrace Workflow JS (GET-only)
//
// Output Sections (Markdown + HTML):
// 1) Active Scope Today (Monitored) + Trend (Œî 1d, Net 7d) [STRICT: only if 100% coverage]
// 2) PG State Changes (last 7 days ‚Äî changes only)          [no stable actives]
// 3) VM Scope Trend (7 days) ‚Äî Active PGs only + TOTAL row  [reconciles Section 1]
// 4) Current VM List (latest inventory run only)            [üü¢/üî¥ + last success ET]
//
// Architecture rules:
// - COMPLETED runs only (skip Running everywhere).
// - Global "Inventory As Of" anchored to the PG that completes last:
//   max(endTimeUsecs) among latest completed runs for all ACTIVE PGs.
// - Baseline/trend calculations only use runs with endUsecs <= globalAsOfUsecs.
// - STRICT baseline: show Œî/Net only when Coverage = 100% for required dates.
// -------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // CONFIG
  // ------------------------------
  const DAYS = 7;
  const NUM_RUNS_PULL = 60;              // history depth (tradeoff: time vs completeness)
  const LAST_SUCCESS_RUN_LOOKBACK = 10;  // per-VM last success scan

  // If empty => ALL clusters. Else restrict.
  // const TARGET_CLUSTER_IDS = ["12345", "67890"];
  const TARGET_CLUSTER_IDS = [];

  // ------------------------------
  // 1) Credential vault: name -> id -> manual (same pattern you use)
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312"; // optional fallback

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    let found = null;
    for (let i = 0; i < (all.credentials || []).length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;

    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("‚úì Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
      console.log("‚úì Helios key from vault (id): " + (d2 && d2.name ? d2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("‚ö†Ô∏è Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  // ------------------------------
  // Helpers
  // ------------------------------
  const TZ = "America/New_York";

  function norm(v) { return v === null || v === undefined ? "" : String(v).trim(); }
  function arr(v) { return !v ? [] : (Array.isArray(v) ? v : [v]); }
  function cmpStr(a, b) { return String(a ?? "").localeCompare(String(b ?? "")); }
  function safeCell(v) { return v === null || v === undefined ? "" : String(v).replace(/\|/g, " "); }

  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      const v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) for (let i = 0; i < v.length; i++) usp.append(k, String(v[i]));
      else usp.append(k, String(v));
    }
    return usp.toString();
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  function lbiFirst(runObj) {
    if (!runObj) return null;
    const lb = runObj.localBackupInfo;
    if (!lb) return null;
    return Array.isArray(lb) ? (lb.length ? lb[0] : null) : lb;
  }

  function getEndUsecs(runObj) {
    const info = lbiFirst(runObj);
    const v = info && info.endTimeUsecs;
    const n = Number(v || 0);
    return Number.isFinite(n) ? n : 0;
  }

  function getRunStatus(runObj) {
    const info = lbiFirst(runObj);
    return norm(info && info.status);
  }

  function isCompleted(runObj) {
    // We only trust: status != Running AND endTimeUsecs > 0
    if (!runObj) return false;
    if (getRunStatus(runObj) === "Running") return false;
    return getEndUsecs(runObj) > 0;
  }

  function objFailed(obj) {
    try {
      const fa = obj && obj.localSnapshotInfo && obj.localSnapshotInfo.failedAttempts;
      if (!fa) return false;
      return arr(fa).length > 0;
    } catch {
      return false;
    }
  }

  function usecsToET(usecs) {
    if (!usecs) return { etDate: "", etTs: "" };
    const ms = Math.floor(Number(usecs) / 1000);
    if (!Number.isFinite(ms) || ms <= 0) return { etDate: "", etTs: "" };
    const d = new Date(ms);
    try {
      const fmt = new Intl.DateTimeFormat("en-CA", {
        timeZone: TZ,
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit",
        hour12: false
      });
      const parts = fmt.formatToParts(d);
      const m = {};
      for (let i = 0; i < parts.length; i++) m[parts[i].type] = parts[i].value;
      const etDate = `${m.year}-${m.month}-${m.day}`;
      const etTs = `${etDate} ${m.hour}:${m.minute}:${m.second}`;
      return { etDate, etTs };
    } catch {
      const iso = d.toISOString().replace("T", " ").slice(0, 19);
      return { etDate: iso.slice(0, 10), etTs: iso };
    }
  }

  function mdTable(title, cols, rows) {
    if (!rows || rows.length === 0) return `### ${title}\n\n‚úÖ No rows.\n\n`;
    const header = `| ${cols.join(" | ")} |`;
    const sep = `| ${cols.map(() => "---").join(" | ")} |`;
    const body = rows.map(r => `| ${cols.map(c => safeCell(r[c])).join(" | ")} |`);
    return `### ${title}\n\n${[header, sep].concat(body).join("\n")}\n\n`;
  }

  function htmlEscape(s) {
    return String(s ?? "")
      .replace(/&/g, "&amp;").replace(/</g, "&lt;")
      .replace(/>/g, "&gt;").replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function htmlTable(title, cols, rows, opts = {}) {
    const { highlightTotalRow = false, totalKey = null } = opts;
    let h = `<h3 style="margin:14px 0 8px 0;">${htmlEscape(title)}</h3>`;
    if (!rows || rows.length === 0) return h + `<div>‚úÖ No rows.</div>`;

    h += `<table style="border-collapse:collapse;width:100%;font-family:Segoe UI,Arial,sans-serif;font-size:13px;">`;
    h += `<tr style="background:#e5e7eb;">` +
      cols.map(c => `<th style="text-align:left;padding:8px;border:1px solid #d1d5db;">${htmlEscape(c)}</th>`).join("") +
      `</tr>`;

    for (let i = 0; i < rows.length; i++) {
      const r = rows[i] || {};
      const isTotal = highlightTotalRow && totalKey && norm(r[totalKey]) === "‚≠ê TOTAL";
      const trStyle = isTotal ? `background:#fff7ed;font-weight:800;` : ``;

      h += `<tr style="${trStyle}">`;
      for (let j = 0; j < cols.length; j++) {
        const v = r[cols[j]];
        const s = String(v ?? "");
        let tdStyle = `padding:8px;border:1px solid #d1d5db;`;

        // delta colors
        if (s.includes("üü¢")) tdStyle += `color:#16a34a;font-weight:800;`;
        if (s.includes("üî¥")) tdStyle += `color:#dc2626;font-weight:800;`;
        if (s.includes("‚ö†Ô∏è")) tdStyle += `color:#b45309;font-weight:800;`;

        // radio style for VM status in HTML: green/red dot
        if (cols[j] === "BackupStatus") {
          if (s === "üü¢") tdStyle += `color:#16a34a;font-size:16px;font-weight:900;`;
          if (s === "üî¥") tdStyle += `color:#dc2626;font-size:16px;font-weight:900;`;
          // render dot instead of emoji
          const dot = (s === "üü¢") ? "‚óè" : (s === "üî¥") ? "‚óè" : s;
          h += `<td style="${tdStyle}">${dot}</td>`;
          continue;
        }

        h += `<td style="${tdStyle}">${htmlEscape(v)}</td>`;
      }
      h += `</tr>`;
    }

    h += `</table>`;
    return h;
  }

  function deltaBadge(n) {
    if (n === null || n === undefined) return "‚Äî";
    const v = Number(n);
    if (!Number.isFinite(v)) return "‚Äî";
    if (v === 0) return "0";
    return v > 0 ? `üü¢ **+${v}**` : `üî¥ **-${Math.abs(v)}**`;
  }

  // Count AHV VMs from objects array (only VMs)
  function countAHVVmsFromObjects(objects) {
    let total = 0;
    const objs = arr(objects);
    for (let i = 0; i < objs.length; i++) {
      const x = objs[i] || {};
      const o = x.object || {};
      if (norm(o.environment) !== "kAcropolis") continue;
      if (norm(o.objectType) !== "kVirtualMachine") continue;
      if (!norm(o.name)) continue;
      total++;
    }
    return total;
  }

  // ------------------------------
  // 2) Clusters
  // ------------------------------
  const commonHeaders = { accept: "application/json", apiKey: apiKey };
  const cluData = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, commonHeaders);
  let clusters = arr(cluData && cluData.cohesityClusters);

  clusters.sort((a, b) => cmpStr(a && a.clusterName, b && b.clusterName));

  if (TARGET_CLUSTER_IDS && TARGET_CLUSTER_IDS.length) {
    const allow = {};
    for (let i = 0; i < TARGET_CLUSTER_IDS.length; i++) allow[String(TARGET_CLUSTER_IDS[i])] = true;
    clusters = clusters.filter(c => allow[String(c && c.clusterId)]);
  }

  if (!clusters.length) {
    return { authMode, markdownAll: "‚ö†Ô∏è No clusters returned from /v2/mcm/cluster-mgmt/info" };
  }

  // ------------------------------
  // 3) PG lists per cluster
  // ------------------------------
  async function fetchPGs(clusterId, qp) {
    const headers = { accept: "application/json", apiKey: apiKey, accessClusterId: String(clusterId) };
    const url = `${baseUrl}/v2/data-protect/protection-groups?` +
      buildQuery(Object.assign({ environments: "kAcropolis" }, qp));
    const data = await getJson(url, headers);
    return arr(data && data.protectionGroups);
  }

  const activePGs = [];   // [{clusterId,clusterName,pgId,pgName}]
  const pausedPGs = [];   // for changes section
  const deletedPGs = [];  // for changes section

  // For "PG changes": we want to detect NEW/NO RUNS for active today, plus paused/deleted today.
  for (let ci = 0; ci < clusters.length; ci++) {
    const c = clusters[ci] || {};
    const clusterId = norm(c.clusterId);
    const clusterName = norm(c.clusterName);
    if (!clusterId) continue;

    let pActive = [], pPaused = [], pDeleted = [];

    try { pActive = await fetchPGs(clusterId, { isDeleted: "False", isActive: "True", isPaused: "False" }); } catch {}
    try { pPaused = await fetchPGs(clusterId, { isDeleted: "False", isPaused: "True" }); } catch {}
    try { pDeleted = await fetchPGs(clusterId, { isDeleted: "True" }); } catch {}

    for (let i = 0; i < pActive.length; i++) {
      const pg = pActive[i] || {};
      const pgId = norm(pg.id);
      const pgName = norm(pg.name);
      if (!pgId || !pgName) continue;
      activePGs.push({ clusterId, clusterName, pgId, pgName });
    }

    for (let i = 0; i < pPaused.length; i++) {
      const pg = pPaused[i] || {};
      const pgId = norm(pg.id);
      const pgName = norm(pg.name);
      if (!pgName) continue;
      pausedPGs.push({ clusterId, clusterName, pgId, pgName });
    }

    for (let i = 0; i < pDeleted.length; i++) {
      const pg = pDeleted[i] || {};
      const pgId = norm(pg.id);
      const pgName = norm(pg.name);
      if (!pgName) continue;
      deletedPGs.push({ clusterId, clusterName, pgId, pgName });
    }
  }

  if (!activePGs.length) {
    return { authMode, markdownAll: "‚ö†Ô∏è No ACTIVE AHV protection groups found (isDeleted=False,isActive=True,isPaused=False)." };
  }

  // ------------------------------
  // 4) Pull runs for ACTIVE PGs and build:
  // - latest inventory run per PG (completed, has objects) for VM list
  // - per PG totals by ET date (completed, objects) for trend
  // - globalAsOfUsecs = max end time among latest inventory runs (PG that completes last)
  // - only use runs <= globalAsOfUsecs for baseline/trend scope
  // ------------------------------
  async function fetchRuns(clusterId, pgId, includeObjectDetails) {
    const headers = { accept: "application/json", apiKey: apiKey, accessClusterId: String(clusterId) };
    const url =
      `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs?` +
      buildQuery({
        environments: "kAcropolis",
        numRuns: String(NUM_RUNS_PULL),
        includeObjectDetails: includeObjectDetails ? "True" : "False"
      });
    const data = await getJson(url, headers);
    return arr(data && data.runs);
  }

  // Storage
  const perPG = {}; // key clusterName|pgName => {Cluster,ProtectionGroup, totalsByDate:{date->count}, inventoryRun, inventoryEndUsecs}
  const VMInventory = [];
  const inventoryEndTimes = []; // endUsecs for each PG inventory run
  const allDatesSet = new Set();

  // We need objects to count VMs per day (for trend) and to build VM list.
  // So includeObjectDetails=True here.
  for (let i = 0; i < activePGs.length; i++) {
    const p = activePGs[i];

    let runs = [];
    try {
      runs = await fetchRuns(p.clusterId, p.pgId, true);
    } catch {
      continue;
    }

    // completed only + must have objects (for counting VMs)
    runs = runs
      .filter(r => r && r.objects && isCompleted(r))
      .sort((a, b) => getEndUsecs(b) - getEndUsecs(a));

    if (!runs.length) {
      // Active PG with no completed runs in pulled history => still valid for "NO RUNS (7d)" classification later
      perPG[`${p.clusterName}|${p.pgName}`] = {
        Cluster: p.clusterName,
        ProtectionGroup: p.pgName,
        totalsByDate: {},
        inventoryRun: null,
        inventoryEndUsecs: 0,
        allCompletedEndUsecs: []
      };
      continue;
    }

    // Inventory run = latest completed with objects
    const inventoryRun = runs[0];
    const invEndUsecs = getEndUsecs(inventoryRun);
    if (invEndUsecs > 0) inventoryEndTimes.push(invEndUsecs);

    const key = `${p.clusterName}|${p.pgName}`;
    const totalsByDate = {};
    const completedEnds = [];

    // Build latest-run-per-ET-date counts
    // NOTE: we will later scope to <= globalAsOfUsecs, but we can collect now.
    for (let r = 0; r < runs.length; r++) {
      const endUsecs = getEndUsecs(runs[r]);
      completedEnds.push(endUsecs);

      const et = usecsToET(endUsecs);
      if (!et.etDate) continue;

      // Keep first we see for each date because runs are sorted desc => first = latest for that date
      if (!Object.prototype.hasOwnProperty.call(totalsByDate, et.etDate)) {
        totalsByDate[et.etDate] = countAHVVmsFromObjects(runs[r].objects);
        allDatesSet.add(et.etDate);
      }
    }

    perPG[key] = {
      Cluster: p.clusterName,
      ProtectionGroup: p.pgName,
      totalsByDate: totalsByDate,
      inventoryRun: inventoryRun,
      inventoryEndUsecs: invEndUsecs,
      allCompletedEndUsecs: completedEnds
    };
  }

  // Global As Of anchored to PG that completes last
  let globalAsOfUsecs = 0;
  for (let i = 0; i < inventoryEndTimes.length; i++) {
    const u = Number(inventoryEndTimes[i] || 0);
    if (u > globalAsOfUsecs) globalAsOfUsecs = u;
  }
  const globalAsOfET = globalAsOfUsecs ? usecsToET(globalAsOfUsecs).etTs : "";

  // Scope dates (last DAYS) based on completed runs <= globalAsOfUsecs
  // We take unique dates that appear in perPG totalsByDate, but only those with some run <= globalAsOfUsecs.
  // Since totalsByDate was built from all runs, we need to ensure the date exists <= asOf:
  // easiest: we rebuild a date set using endUsecs <= asOf by checking each PG's completedEnds.
  const scopedDatesSet = new Set();
  const keys = Object.keys(perPG);

  for (let k = 0; k < keys.length; k++) {
    const pg = perPG[keys[k]];
    const ends = pg.allCompletedEndUsecs || [];
    for (let e = 0; e < ends.length; e++) {
      const endUsecs = Number(ends[e] || 0);
      if (!endUsecs || endUsecs > globalAsOfUsecs) continue;
      const et = usecsToET(endUsecs);
      if (et.etDate) scopedDatesSet.add(et.etDate);
    }
  }

  const dateList = Array.from(scopedDatesSet).sort((a, b) => b.localeCompare(a)).slice(0, DAYS);

  // Helper: does this PG have a completed run (count) on date within scoped window?
  function pgHasDate(pgObj, d) {
    // totalsByDate might include that date from a run beyond asOf, but we scoped date list from <=asOf.
    // So if d is in dateList, totalsByDate[d] is acceptable as "latest for that date" within pulled runs.
    return Object.prototype.hasOwnProperty.call(pgObj.totalsByDate || {}, d);
  }

  // ------------------------------
  // 5) STRICT coverage computation
  // Coverage by date across ALL active PGs (global) and per cluster.
  // ------------------------------
  const activeKeys = keys; // perPG is built for active PGs only

  function coverageForDate(date, clusterNameOrNull) {
    let total = 0;
    let have = 0;
    for (let i = 0; i < activeKeys.length; i++) {
      const pg = perPG[activeKeys[i]];
      if (!pg) continue;
      if (clusterNameOrNull && pg.Cluster !== clusterNameOrNull) continue;

      total++;
      if (pgHasDate(pg, date)) have++;
    }
    const pct = total ? Math.round((have / total) * 100) : 0;
    return { total, have, pct };
  }

  // Baseline date (global) = OLDEST date in dateList with 100% coverage
  let baselineDateGlobal = "";
  for (let i = dateList.length - 1; i >= 0; i--) {
    const d = dateList[i];
    const cov = coverageForDate(d, null);
    if (cov.total > 0 && cov.have === cov.total) { baselineDateGlobal = d; break; }
  }

  // For Œî1d, we use dateList[0] as "today date" (latest seen date) and dateList[1] as previous.
  const todayDate = dateList.length ? dateList[0] : "";
  const prevDate = dateList.length > 1 ? dateList[1] : "";

  // strict: Œî1d only if both dates have 100% coverage
  const covTodayGlobal = todayDate ? coverageForDate(todayDate, null) : { total: 0, have: 0, pct: 0 };
  const covPrevGlobal = prevDate ? coverageForDate(prevDate, null) : { total: 0, have: 0, pct: 0 };

  const strictDelta1dOkGlobal = todayDate && prevDate &&
    covTodayGlobal.total > 0 && covTodayGlobal.have === covTodayGlobal.total &&
    covPrevGlobal.total > 0 && covPrevGlobal.have === covPrevGlobal.total;

  const strictNet7dOkGlobal = !!baselineDateGlobal && covTodayGlobal.total > 0 && covTodayGlobal.have === covTodayGlobal.total;

  // Best coverage (for reporting when strict fails)
  let bestCoveragePct = 0;
  for (let i = 0; i < dateList.length; i++) {
    const cov = coverageForDate(dateList[i], null);
    if (cov.pct > bestCoveragePct) bestCoveragePct = cov.pct;
  }

  // ------------------------------
  // 6) Section 3: VM Scope Trend (PG-level) + TOTAL row
  // ------------------------------
  const trendRows = [];

  for (let i = 0; i < activeKeys.length; i++) {
    const pg = perPG[activeKeys[i]];
    const out = {
      Cluster: pg.Cluster,
      ProtectionGroup: pg.ProtectionGroup,
      Today_TotalVMs: (todayDate && pgHasDate(pg, todayDate)) ? String(pg.totalsByDate[todayDate]) : "‚Äî"
    };

    // Per-day deltas: dateList[di] vs dateList[di+1]
    for (let di = 0; di < dateList.length; di++) {
      const d0 = dateList[di];
      const d1 = dateList[di + 1];
      if (!d1) { out[d0] = "‚Äî"; continue; }

      if (!pgHasDate(pg, d0) || !pgHasDate(pg, d1)) { out[d0] = "‚Äî"; continue; }
      const delta = Number(pg.totalsByDate[d0]) - Number(pg.totalsByDate[d1]);
      out[d0] = deltaBadge(delta);
    }

    // Net VMs (7d) uses GLOBAL baselineDateGlobal only if strictNet7dOkGlobal is valid AND PG has baseline+today
    if (strictNet7dOkGlobal && todayDate && baselineDateGlobal && pgHasDate(pg, todayDate) && pgHasDate(pg, baselineDateGlobal)) {
      const net = Number(pg.totalsByDate[todayDate]) - Number(pg.totalsByDate[baselineDateGlobal]);
      out["Net VMs (7d)"] = deltaBadge(net);
    } else {
      out["Net VMs (7d)"] = "‚ö†Ô∏è baseline incomplete";
    }

    trendRows.push(out);
  }

  trendRows.sort((a, b) => cmpStr(a.Cluster, b.Cluster) || cmpStr(a.ProtectionGroup, b.ProtectionGroup));

  // TOTAL (Active PGs) row for Section 3 (reconciliation anchor)
  const totalRow3 = {
    Cluster: "‚≠ê TOTAL (Active PGs)",
    ProtectionGroup: "",
    Today_TotalVMs: "‚Äî"
  };
  for (let di = 0; di < dateList.length; di++) totalRow3[dateList[di]] = "‚Äî";
  totalRow3["Net VMs (7d)"] = "‚ö†Ô∏è baseline incomplete";

  // Compute totals only when strict coverage allows
  if (todayDate && covTodayGlobal.total > 0 && covTodayGlobal.have === covTodayGlobal.total) {
    let sumToday = 0;
    for (let i = 0; i < activeKeys.length; i++) sumToday += Number(perPG[activeKeys[i]].totalsByDate[todayDate] || 0);
    totalRow3.Today_TotalVMs = String(sumToday);
  }

  // Per-day deltas totals for TOTAL row: only if BOTH days have 100% coverage
  for (let di = 0; di < dateList.length; di++) {
    const d0 = dateList[di];
    const d1 = dateList[di + 1];
    if (!d1) continue;

    const cov0 = coverageForDate(d0, null);
    const cov1 = coverageForDate(d1, null);
    if (cov0.total > 0 && cov0.have === cov0.total && cov1.total > 0 && cov1.have === cov1.total) {
      let sum0 = 0, sum1 = 0;
      for (let i = 0; i < activeKeys.length; i++) {
        sum0 += Number(perPG[activeKeys[i]].totalsByDate[d0] || 0);
        sum1 += Number(perPG[activeKeys[i]].totalsByDate[d1] || 0);
      }
      totalRow3[d0] = deltaBadge(sum0 - sum1);
    } else {
      totalRow3[d0] = "‚ö†Ô∏è baseline incomplete";
    }
  }

  if (strictNet7dOkGlobal && todayDate && baselineDateGlobal) {
    let sumToday = 0, sumBase = 0;
    for (let i = 0; i < activeKeys.length; i++) {
      sumToday += Number(perPG[activeKeys[i]].totalsByDate[todayDate] || 0);
      sumBase += Number(perPG[activeKeys[i]].totalsByDate[baselineDateGlobal] || 0);
    }
    totalRow3["Net VMs (7d)"] = deltaBadge(sumToday - sumBase);
  } else {
    totalRow3["Net VMs (7d)"] = "‚ö†Ô∏è baseline incomplete";
  }

  trendRows.push(totalRow3);

  // ------------------------------
  // 7) Section 1: Active Scope Today + Trend (Option C, STRICT)
  // Uses the same strict gating and same baselineDateGlobal to avoid mismatches.
  // ------------------------------
  const clusterMap = {}; // cluster -> {Active_PGs, totalsByDate:{}}
  for (let i = 0; i < activeKeys.length; i++) {
    const pg = perPG[activeKeys[i]];
    if (!clusterMap[pg.Cluster]) clusterMap[pg.Cluster] = { Cluster: pg.Cluster, Active_PGs: 0, totalsByDate: {} };
    clusterMap[pg.Cluster].Active_PGs += 1;

    for (let di = 0; di < dateList.length; di++) {
      const d = dateList[di];
      if (!pgHasDate(pg, d)) continue;
      clusterMap[pg.Cluster].totalsByDate[d] = Number(clusterMap[pg.Cluster].totalsByDate[d] || 0) + Number(pg.totalsByDate[d] || 0);
    }
  }

  const clusterRows = Object.keys(clusterMap)
    .sort((a, b) => a.localeCompare(b))
    .map(cn => {
      const x = clusterMap[cn];
      const covToday = todayDate ? coverageForDate(todayDate, cn) : { total: 0, have: 0, pct: 0 };
      const covPrev = prevDate ? coverageForDate(prevDate, cn) : { total: 0, have: 0, pct: 0 };
      const covBase = baselineDateGlobal ? coverageForDate(baselineDateGlobal, cn) : { total: 0, have: 0, pct: 0 };

      const totalToday = (todayDate && covToday.total > 0 && covToday.have === covToday.total && Object.prototype.hasOwnProperty.call(x.totalsByDate, todayDate))
        ? String(x.totalsByDate[todayDate])
        : "‚Äî";

      let d1 = "‚ö†Ô∏è baseline incomplete";
      if (todayDate && prevDate && covToday.total > 0 && covToday.have === covToday.total && covPrev.total > 0 && covPrev.have === covPrev.total) {
        const v0 = Number(x.totalsByDate[todayDate] || 0);
        const v1 = Number(x.totalsByDate[prevDate] || 0);
        d1 = deltaBadge(v0 - v1);
      }

      let net7 = "‚ö†Ô∏è baseline incomplete";
      if (todayDate && baselineDateGlobal && covToday.total > 0 && covToday.have === covToday.total && covBase.total > 0 && covBase.have === covBase.total) {
        const v0 = Number(x.totalsByDate[todayDate] || 0);
        const vb = Number(x.totalsByDate[baselineDateGlobal] || 0);
        net7 = deltaBadge(v0 - vb);
      }

      // show coverage (cluster-level) for transparency
      const coverageStr = covToday.total ? `${covToday.have}/${covToday.total} (${covToday.pct}%)` : "‚Äî";

      return {
        Cluster: cn,
        Active_PGs: String(x.Active_PGs),
        TotalVMs: totalToday,
        "Œî VMs (1d)": strictDelta1dOkGlobal ? d1 : "‚ö†Ô∏è baseline incomplete",
        "Net VMs (7d)": strictNet7dOkGlobal ? net7 : "‚ö†Ô∏è baseline incomplete",
        "Baseline Date (ET)": (strictNet7dOkGlobal ? baselineDateGlobal : "‚Äî"),
        Coverage: coverageStr
      };
    });

  // TOTAL row for Section 1 (global)
  const totalRow1 = {
    Cluster: "‚≠ê TOTAL",
    Active_PGs: String(clusterRows.reduce((s, r) => s + Number(r.Active_PGs || 0), 0)),
    TotalVMs: totalRow3.Today_TotalVMs === "‚Äî" ? "‚Äî" : totalRow3.Today_TotalVMs,
    "Œî VMs (1d)": strictDelta1dOkGlobal ? totalRow3[todayDate] : "‚ö†Ô∏è baseline incomplete",
    "Net VMs (7d)": strictNet7dOkGlobal ? totalRow3["Net VMs (7d)"] : "‚ö†Ô∏è baseline incomplete",
    "Baseline Date (ET)": strictNet7dOkGlobal ? baselineDateGlobal : "‚Äî",
    Coverage: (covTodayGlobal.total ? `${covTodayGlobal.have}/${covTodayGlobal.total} (${covTodayGlobal.pct}%)` : "‚Äî")
  };

  clusterRows.push(totalRow1);

  // ------------------------------
  // 8) Section 2: PG State CHANGES ONLY (last 7 days)
  // We won‚Äôt list stable actives.
  // Definitions (practical + consistent):
  // - üü† NO RUNS (7d): Active today but no completed runs in scoped dateList.
  // - üü¢ NEW (7d): Active today AND has runs in dateList AND no completed run older than the oldest scoped date (within pulled history).
  // - ‚è∏Ô∏è PAUSED: Appears in paused list today.
  // - üóëÔ∏è DELETED: Appears in deleted list today.
  // - ‚ùì NOT RETURNED is not reliable without an all-PG historical index; skipped by design.
  // ------------------------------
  const changes = [];

  const oldestScoped = dateList.length ? dateList[dateList.length - 1] : "";

  // Helper: does PG have any run date in dateList?
  function hasRunsInWindow(pgObj) {
    if (!dateList.length) return false;
    for (let i = 0; i < dateList.length; i++) if (pgHasDate(pgObj, dateList[i])) return true;
    return false;
  }

  // Helper: does PG have any completed run older than oldest scoped date (based on pulled runs)?
  function hasOlderThanWindow(pgObj) {
    if (!oldestScoped) return false;
    // If totalsByDate contains a date older than oldestScoped, it implies we saw a run older.
    const dates = Object.keys(pgObj.totalsByDate || {});
    for (let i = 0; i < dates.length; i++) {
      if (dates[i] < oldestScoped) return true;
    }
    return false;
  }

  // NEW / NO RUNS from active PGs
  for (let i = 0; i < activeKeys.length; i++) {
    const pg = perPG[activeKeys[i]];
    const inWindow = hasRunsInWindow(pg);

    if (!inWindow) {
      changes.push({
        Status: "üü† **NO RUNS (7d)**",
        Cluster: pg.Cluster,
        ProtectionGroup: pg.ProtectionGroup,
        Meaning: "Active today; but no completed runs in last 7 days"
      });
      continue;
    }

    if (!hasOlderThanWindow(pg)) {
      changes.push({
        Status: "üü¢ **NEW (7d)**",
        Cluster: pg.Cluster,
        ProtectionGroup: pg.ProtectionGroup,
        Meaning: "Active today; first completed run appears within last 7 days"
      });
    }
  }

  // PAUSED / DELETED (listed today)
  // (These are "changes" by virtue of being out-of-scope for monitoring.)
  // Dedup by cluster+name
  function dedup(list) {
    const out = [];
    const seen = {};
    for (let i = 0; i < list.length; i++) {
      const x = list[i];
      const key = `${x.clusterName}|${x.pgName}|${x.type}`;
      if (seen[key]) continue;
      seen[key] = true;
      out.push(x);
    }
    return out;
  }

  const pausedD = dedup(pausedPGs.map(x => ({ clusterName: x.clusterName, pgName: x.pgName, type: "PAUSED" })));
  const deletedD = dedup(deletedPGs.map(x => ({ clusterName: x.clusterName, pgName: x.pgName, type: "DELETED" })));

  for (let i = 0; i < pausedD.length; i++) {
    changes.push({
      Status: "‚è∏Ô∏è **PAUSED**",
      Cluster: pausedD[i].clusterName,
      ProtectionGroup: pausedD[i].pgName,
      Meaning: "Paused today; excluded from monitoring scope"
    });
  }
  for (let i = 0; i < deletedD.length; i++) {
    changes.push({
      Status: "üóëÔ∏è **DELETED**",
      Cluster: deletedD[i].clusterName,
      ProtectionGroup: deletedD[i].pgName,
      Meaning: "Deleted today; historical only"
    });
  }

  // Sort changes for readability
  changes.sort((a, b) =>
    cmpStr(a.Status, b.Status) ||
    cmpStr(a.Cluster, b.Cluster) ||
    cmpStr(a.ProtectionGroup, b.ProtectionGroup)
  );

  // ------------------------------
  // 9) Section 4: Current VM List (Latest inventory run only)
  // - Uses per-VM status from inventoryRun (üü¢/üî¥)
  // - Finds last successful backup time by scanning last N completed runs (<= asOf)
  // ------------------------------
  // Build a lookup from cluster|pgName -> {clusterId, pgId} to refetch smaller run history for last success if needed
  const activeKeyToIds = {};
  for (let i = 0; i < activePGs.length; i++) {
    const p = activePGs[i];
    activeKeyToIds[`${p.clusterName}|${p.pgName}`] = { clusterId: p.clusterId, pgId: p.pgId };
  }

  // For last success, we reuse already pulled runs+objects in perPG where possible:
  // We kept only counts by date; but we still have inventoryRun objects in perPG and (for active PGs with runs) we pulled runs with objects initially.
  // We don't keep all runs objects, so we will do a smaller refetch for last success lookback (N runs) with objects, but capped.
  async function fetchRunsForLastSuccess(clusterId, pgId, numRuns) {
    const headers = { accept: "application/json", apiKey: apiKey, accessClusterId: String(clusterId) };
    const url =
      `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs?` +
      buildQuery({
        environments: "kAcropolis",
        numRuns: String(numRuns),
        includeObjectDetails: "True"
      });
    const data = await getJson(url, headers);
    return arr(data && data.runs);
  }

  // Build VM inventory from each PG's inventoryRun
  for (let i = 0; i < activeKeys.length; i++) {
    const pg = perPG[activeKeys[i]];
    if (!pg.inventoryRun || !pg.inventoryRun.objects) continue;

    const ids = activeKeyToIds[`${pg.Cluster}|${pg.ProtectionGroup}`];
    if (!ids) continue;

    // Determine inventory VM names
    const invObjs = arr(pg.inventoryRun.objects);
    const invVms = [];
    for (let oi = 0; oi < invObjs.length; oi++) {
      const x = invObjs[oi] || {};
      const o = x.object || {};
      if (norm(o.environment) !== "kAcropolis") continue;
      if (norm(o.objectType) !== "kVirtualMachine") continue;
      const name = norm(o.name);
      if (name) invVms.push(name);
    }

    // Initialize map
    const lastSuccessMap = {};
    for (let v = 0; v < invVms.length; v++) lastSuccessMap[invVms[v]] = "";

    // Pull last N completed runs (with objects) and scan for first success per VM
    let runsLS = [];
    try {
      runsLS = await fetchRunsForLastSuccess(ids.clusterId, ids.pgId, Math.max(LAST_SUCCESS_RUN_LOOKBACK, 10));
    } catch {
      runsLS = [];
    }

    runsLS = runsLS
      .filter(r => r && r.objects && isCompleted(r))
      .sort((a, b) => getEndUsecs(b) - getEndUsecs(a));

    let checked = 0;
    let remaining = invVms.length;

    for (let rr = 0; rr < runsLS.length; rr++) {
      if (remaining <= 0) break;
      if (checked >= LAST_SUCCESS_RUN_LOOKBACK) break;

      const runObj = runsLS[rr];
      const endUsecs = getEndUsecs(runObj);

      // strict scope: ignore completed runs beyond global as-of
      if (globalAsOfUsecs && endUsecs > globalAsOfUsecs) continue;

      checked++;
      const etTs = usecsToET(endUsecs).etTs;

      const objs = arr(runObj.objects);
      for (let oo = 0; oo < objs.length; oo++) {
        const robj = objs[oo] || {};
        const ro = robj.object || {};
        if (norm(ro.environment) !== "kAcropolis") continue;
        if (norm(ro.objectType) !== "kVirtualMachine") continue;

        const vm = norm(ro.name);
        if (!vm) continue;
        if (!Object.prototype.hasOwnProperty.call(lastSuccessMap, vm)) continue;
        if (lastSuccessMap[vm]) continue;

        if (!objFailed(robj)) {
          lastSuccessMap[vm] = etTs || "";
          remaining--;
        }
      }
    }

    // Emit VM rows from inventory run
    for (let ob = 0; ob < invObjs.length; ob++) {
      const x = invObjs[ob] || {};
      const o = x.object || {};
      if (norm(o.environment) !== "kAcropolis") continue;
      if (norm(o.objectType) !== "kVirtualMachine") continue;

      const vmName = norm(o.name);
      if (!vmName) continue;

      VMInventory.push({
        Cluster: pg.Cluster,
        ProtectionGroup: pg.ProtectionGroup,
        VMName: vmName,
        BackupStatus: objFailed(x) ? "üî¥" : "üü¢",
        "Last Successful Backup (Eastern Time)": lastSuccessMap[vmName] || ""
      });
    }
  }

  VMInventory.sort((a, b) =>
    cmpStr(a.Cluster, b.Cluster) ||
    cmpStr(a.ProtectionGroup, b.ProtectionGroup) ||
    cmpStr(a.VMName, b.VMName)
  );

  // ------------------------------
  // 10) Build Markdown + HTML
  // ------------------------------
  const strictNote =
    `**STRICT rule:** Trends shown only when Coverage = **100%** (completed runs). ` +
    `Otherwise values show **‚ö†Ô∏è baseline incomplete**.\n`;

  const coverageSummaryLine = (strictNet7dOkGlobal && strictDelta1dOkGlobal)
    ? `**Coverage:** ${covTodayGlobal.have}/${covTodayGlobal.total} (${covTodayGlobal.pct}%) ‚úÖ\n`
    : `**Coverage:** best ${bestCoveragePct}% (0/7 days at 100%) ‚Üí trends suppressed where incomplete.\n`;

  const headerMd =
    "## Cohesity AHV Inventory + Weekly Baseline\n\n" +
    `**Inventory As Of (Eastern Time): ${globalAsOfET || "<blank>"}**\n` +
    `**Baseline Window:** last ${DAYS} days (Eastern Time)\n` +
    "**Grouping rule:** Day buckets use **Run End Time (Eastern Time)**.\n" +
    strictNote +
    coverageSummaryLine +
    "\n";

  const sec1Cols = ["Cluster", "Active_PGs", "TotalVMs", "Œî VMs (1d)", "Net VMs (7d)", "Baseline Date (ET)", "Coverage"];
  const sec1Md =
    "### 1) Active Scope Today (Monitored) + Trend (STRICT)\n\n" +
    mdTable("", sec1Cols, clusterRows);

  const sec2Cols = ["Status", "Cluster", "ProtectionGroup", "Meaning"];
  const sec2Md =
    "### 2) PG State Changes (last 7 days ‚Äî changes only)\n\n" +
    mdTable("", sec2Cols, changes);

  const sec3Cols = ["Cluster", "ProtectionGroup", "Today_TotalVMs"].concat(dateList).concat(["Net VMs (7d)"]);
  const sec3Md =
    "### 3) VM Scope Trend (7 days) ‚Äî Active PGs only (STRICT + TOTAL validation)\n\n" +
    "**How to read:** each date column is **Œî vs previous day** (üü¢ increase / üî¥ decrease / 0 stable / ‚Äî no run).  \n" +
    "**TOTAL row** validates Section 1 trend values.\n\n" +
    mdTable("", sec3Cols, trendRows);

  const sec4Cols = ["Cluster", "ProtectionGroup", "VMName", "BackupStatus", "Last Successful Backup (Eastern Time)"];
  const sec4Md =
    "### 4) Current VM List (Latest inventory run only)\n\n" +
    mdTable("", sec4Cols, VMInventory) +
    `**Note:** ‚ÄúLast Successful Backup (Eastern Time)‚Äù is checked only for the last **${LAST_SUCCESS_RUN_LOOKBACK} completed runs**. If blank, check Helios for older success.\n`;

  const markdownAll = headerMd + sec1Md + sec2Md + sec3Md + sec4Md;

  // HTML
  const htmlHeader =
    `<h2 style="margin:0 0 8px 0;">Cohesity AHV Inventory + Weekly Baseline</h2>` +
    `<div style="font-family:Segoe UI,Arial,sans-serif;font-size:13px;margin-bottom:10px;">` +
    `<div><b>Inventory As Of (Eastern Time):</b> ${htmlEscape(globalAsOfET || "<blank>")}</div>` +
    `<div><b>Baseline Window:</b> last ${DAYS} days (Eastern Time)</div>` +
    `<div><b>Grouping rule:</b> Day buckets use <b>Run End Time (Eastern Time)</b>.</div>` +
    `<div><b>STRICT:</b> Trends shown only when Coverage = <b>100%</b> (completed runs).</div>` +
    `<div><b>Coverage:</b> ${htmlEscape(coverageSummaryLine.replace(/\*\*/g, ""))}</div>` +
    `</div>`;

  const html1 = htmlTable("1) Active Scope Today (Monitored) + Trend (STRICT)", sec1Cols, clusterRows, {
    highlightTotalRow: true,
    totalKey: "Cluster"
  });

  const html2 = htmlTable("2) PG State Changes (last 7 days ‚Äî changes only)", sec2Cols, changes);

  const html3 = htmlTable("3) VM Scope Trend (7 days) ‚Äî Active PGs only (STRICT + TOTAL validation)", sec3Cols, trendRows);

  const html4 = htmlTable("4) Current VM List (Latest inventory run only)", sec4Cols, VMInventory) +
    `<div style="margin-top:8px;font-family:Segoe UI,Arial,sans-serif;font-size:12px;">
      <b>Note:</b> ‚ÄúLast Successful Backup (Eastern Time)‚Äù is checked only for the last <b>${LAST_SUCCESS_RUN_LOOKBACK}</b> completed runs. If blank, check Helios for older success.
    </div>`;

  const htmlEmail = htmlHeader + html1 + html2 + html3 + html4;

  return {
    authMode,
    globalAsOfET: globalAsOfET,
    baselineDates: dateList,
    baselineDateGlobal: baselineDateGlobal || "",
    coverageTodayGlobal: covTodayGlobal,
    markdownAll,
    markdownEmail: markdownAll,
    htmlEmail
  };
}
