// -------------------------------------------------------------
// Cohesity Helios â€“ AHV (Acropolis) Inventory (Object-level)
// Dynatrace Workflow JS (GET-only) + Markdown tables
// -------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  var baseUrl = "https://helios.cohesity.com";
  var LAST_SUCCESS_RUN_LOOKBACK = 10;
  var MIN_RUNS_TO_PULL = 10;

  // ------------------------------
  // Credential vault (UNCHANGED)
  // ------------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId = "credentials_vault-312312";
  var apiKey = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    for (var i = 0; i < all.credentials.length; i++) {
      if (all.credentials[i].name === name) {
        var d = await credentialVaultClient.getCredentialsDetails({ id: all.credentials[i].id });
        return d.token || d.password;
      }
    }
    return null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error();
  } catch {
    var d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
    apiKey = d2.token || d2.password;
    authMode = "vault-id";
  }

  if (!apiKey) throw new Error("No Helios API key available");

  // ------------------------------
  // Helpers (UNCHANGED)
  // ------------------------------
  const arr = v => (Array.isArray(v) ? v : v ? [v] : []);
  const norm = v => (v == null ? "" : String(v).trim());

  async function getJson(url, headers) {
    const r = await fetch(url, { method: "GET", headers });
    if (!r.ok) throw new Error("HTTP " + r.status);
    return r.json();
  }

  function objFailed(o) {
    const fa = o?.localSnapshotInfo?.failedAttempts;
    return fa && arr(fa).length > 0;
  }

  function toET(usecs) {
    if (!usecs) return "";
    const ms = Math.floor(usecs / 1000);
    return new Intl.DateTimeFormat("en-CA", {
      timeZone: "America/New_York",
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      hour12: false
    }).format(new Date(ms)).replace(",", "");
  }

  function safe(v) {
    return String(v ?? "").replace(/\|/g, " ");
  }

  function mdTable(title, cols, rows) {
    const h = "| " + cols.join(" | ") + " |";
    const s = "| " + cols.map(() => "---").join(" | ") + " |";
    const b = rows.map(r => "| " + cols.map(c => safe(r[c])).join(" | ") + " |");
    return "### " + title + "\n\n" + [h, s].concat(b).join("\n") + "\n\n";
  }

  // ------------------------------
  // Data collection (UNCHANGED)
  // ------------------------------
  var PGInventory = [];
  var VMInventory = [];
  var inventoryTimes = [];

  const cluData = await getJson(
    baseUrl + "/v2/mcm/cluster-mgmt/info",
    { apiKey }
  );

  const clusters = arr(cluData.cohesityClusters)
    .sort((a, b) => norm(a.clusterName).localeCompare(norm(b.clusterName)));

  for (const c of clusters) {
    const headers = { apiKey, accessClusterId: c.clusterId };

    const pgData = await getJson(
      baseUrl + "/v2/data-protect/protection-groups?environments=kAcropolis&isDeleted=False&isActive=True&isPaused=False",
      headers
    );

    for (const pg of arr(pgData.protectionGroups)) {

      const runData = await getJson(
        baseUrl + `/v2/data-protect/protection-groups/${pg.id}/runs?numRuns=${Math.max(LAST_SUCCESS_RUN_LOOKBACK, MIN_RUNS_TO_PULL)}&includeObjectDetails=True`,
        headers
      );

      const runs = arr(runData.runs)
        .filter(r => r.objects && r.localBackupInfo?.[0]?.status !== "Running")
        .sort((a, b) => (b.localBackupInfo?.[0]?.endTimeUsecs || 0) - (a.localBackupInfo?.[0]?.endTimeUsecs || 0));

      if (!runs.length) continue;

      const invRun = runs[0];
      inventoryTimes.push(invRun.localBackupInfo[0].endTimeUsecs);

      const lastSuccess = {};
      for (const o of arr(invRun.objects)) {
        if (o.object?.objectType === "kVirtualMachine") {
          lastSuccess[o.object.name] = "";
        }
      }

      let checked = 0;
      for (const r of runs) {
        if (checked++ >= LAST_SUCCESS_RUN_LOOKBACK) break;
        const et = r.localBackupInfo?.[0]?.endTimeUsecs;
        for (const o of arr(r.objects)) {
          const vm = o.object?.name;
          if (vm && !lastSuccess[vm] && !objFailed(o)) {
            lastSuccess[vm] = toET(et);
          }
        }
      }

      let total = 0, failed = 0;
      for (const o of arr(invRun.objects)) {
        if (o.object?.objectType !== "kVirtualMachine") continue;
        total++;
        const f = objFailed(o);
        if (f) failed++;

        VMInventory.push({
          Cluster: c.clusterName,
          ProtectionGroup: pg.name,
          VMName: o.object.name,
          BackupStatus: f ? "ðŸ”´" : "ðŸŸ¢",
          Last_Successful_BKUP_ET: lastSuccess[o.object.name] || ""
        });
      }

      PGInventory.push({
        Cluster: c.clusterName,
        ProtectionGroup: pg.name,
        TotalVMs: total,
        BKUP_VM_SUCCESSFUL: total - failed,
        BKUP_VM_FAILED: failed
      });
    }
  }

  // ------------------------------
  // Summaries with CORRECT coloring
  // ------------------------------
  function colorFail(n) {
    return n > 0 ? `ðŸ”´ **${n}**` : `ðŸŸ¢ **0**`;
  }
  function colorSucc(n) {
    return `ðŸŸ¢ **${n}**`;
  }

  // Cluster Summary
  const clusterMap = {};
  PGInventory.forEach(r => {
    clusterMap[r.Cluster] ??= { Cluster: r.Cluster, PGs: 0, TotalVMs: 0, S: 0, F: 0 };
    clusterMap[r.Cluster].PGs++;
    clusterMap[r.Cluster].TotalVMs += r.TotalVMs;
    clusterMap[r.Cluster].S += r.BKUP_VM_SUCCESSFUL;
    clusterMap[r.Cluster].F += r.BKUP_VM_FAILED;
  });

  const ClusterSummary = Object.values(clusterMap).map(r => ({
    Cluster: r.Cluster,
    PGs: r.PGs,
    TotalVMs: r.TotalVMs,
    BKUP_VM_SUCCESSFUL: colorSucc(r.S),
    BKUP_VM_FAILED: colorFail(r.F)
  }));

  const ClusterTotal = {
    Cluster: "**â­ TOTAL**",
    PGs: `**${ClusterSummary.reduce((a, b) => a + b.PGs, 0)}**`,
    TotalVMs: `**${ClusterSummary.reduce((a, b) => a + Number(b.TotalVMs), 0)}**`,
    BKUP_VM_SUCCESSFUL: colorSucc(ClusterSummary.reduce((a, b) => a + Number(b.BKUP_VM_SUCCESSFUL.replace(/\D/g, "")), 0)),
    BKUP_VM_FAILED: colorFail(ClusterSummary.reduce((a, b) => a + Number(b.BKUP_VM_FAILED.replace(/\D/g, "")), 0))
  };

  // PG Summary
  const PGSummary = PGInventory.map(r => ({
    Cluster: r.Cluster,
    ProtectionGroup: r.ProtectionGroup,
    TotalVMs: r.TotalVMs,
    BKUP_VM_SUCCESSFUL: colorSucc(r.BKUP_VM_SUCCESSFUL),
    BKUP_VM_FAILED: colorFail(r.BKUP_VM_FAILED)
  }));

  const PGTotal = {
    Cluster: "**â­ TOTAL**",
    ProtectionGroup: "",
    TotalVMs: `**${PGInventory.reduce((a, b) => a + b.TotalVMs, 0)}**`,
    BKUP_VM_SUCCESSFUL: colorSucc(PGInventory.reduce((a, b) => a + b.BKUP_VM_SUCCESSFUL, 0)),
    BKUP_VM_FAILED: colorFail(PGInventory.reduce((a, b) => a + b.BKUP_VM_FAILED, 0))
  };

  // ------------------------------
  // Output
  // ------------------------------
  const markdownAll =
    `## Cohesity AHV Inventory\n\n` +
    `**Inventory As Of (ET):** ${toET(Math.max(...inventoryTimes))}\n\n` +
    mdTable("Summary 1: Cluster Summary",
      ["Cluster", "PGs", "TotalVMs", "BKUP_VM_SUCCESSFUL", "BKUP_VM_FAILED"],
      ClusterSummary.concat([ClusterTotal])
    ) +
    mdTable("Summary 2: Protection Group Summary",
      ["Cluster", "ProtectionGroup", "TotalVMs", "BKUP_VM_SUCCESSFUL", "BKUP_VM_FAILED"],
      PGSummary.concat([PGTotal])
    ) +
    mdTable("Full VM List",
      ["Cluster", "ProtectionGroup", "VMName", "BackupStatus", "Last_Successful_BKUP_ET"],
      VMInventory
    );

  return { markdownAll, markdownEmail: markdownAll };
}
