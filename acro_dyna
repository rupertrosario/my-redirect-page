// -------------------------------------------------------------
// Cohesity Helios ‚Äì AHV (Acropolis) Inventory (Object-level)
// Dynatrace Workflow JS (GET-only) + Markdown tables
//
// Visual Enhancements ONLY:
// - üü¢ / üî¥ radio-style BackupStatus
// - ‚≠ê TOTAL rows highlighted
// -------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  var baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // CONFIG
  // ------------------------------
  var LAST_SUCCESS_RUN_LOOKBACK = 10;
  var MIN_RUNS_TO_PULL = 10;
  var TARGET_CLUSTER_IDS = [];

  // ------------------------------
  // Credential vault (UNCHANGED)
  // ------------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId = "credentials_vault-312312";

  var apiKey = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    var found = null;
    for (var i = 0; i < all.credentials.length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;
    var detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    var d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
    apiKey = (d2 && (d2.token || d2.password)) || null;
    authMode = "vault-id";
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  // ------------------------------
  // Helpers (UNCHANGED)
  // ------------------------------
  function norm(v){ return v===null||v===undefined?"":String(v).trim(); }
  function toArrayMaybe(v){ return Array.isArray(v)?v:(v?[v]:[]); }

  async function getJson(url, headers){
    var r = await fetch(url,{method:"GET",headers});
    if(!r.ok) throw new Error("HTTP "+r.status);
    return r.json();
  }

  function lbiFirst(r){ return r?.localBackupInfo?.[0]||null; }
  function getEndUsecs(r){ return Number(lbiFirst(r)?.endTimeUsecs||0); }
  function getRunStatus(r){ return norm(lbiFirst(r)?.status); }

  function objFailed(o){
    var fa=o?.localSnapshotInfo?.failedAttempts;
    return fa && toArrayMaybe(fa).length>0;
  }

  function usecsToETString(u){
    if(!u) return "";
    var ms=Math.floor(Number(u)/1000);
    return new Intl.DateTimeFormat("en-CA",{
      timeZone:"America/New_York",
      year:"numeric",month:"2-digit",day:"2-digit",
      hour:"2-digit",minute:"2-digit",second:"2-digit",
      hour12:false
    }).format(new Date(ms)).replace(",","");
  }

  function safeCell(v){ return String(v||"").replace(/\|/g," "); }

  function toMarkdownTable(title, cols, rows){
    var h="| "+cols.join(" | ")+" |";
    var s="| "+cols.map(()=> "---").join(" | ")+" |";
    var b=rows.map(r=>"| "+cols.map(c=>safeCell(r[c])).join(" | ")+" |");
    return "### "+title+"\n\n"+[h,s].concat(b).join("\n")+"\n";
  }

  function sum(a){ return a.reduce((x,y)=>x+Number(y||0),0); }

  // ------------------------------
  // Inventory collection (UNCHANGED)
  // ------------------------------
  var PGInventory=[], VMInventory=[], inventoryAsOfUsecsAll=[];
  var clustersScanned=0, pgsScanned=0, vmsScanned=0;

  var cluData = await getJson(baseUrl+"/v2/mcm/cluster-mgmt/info",{apiKey});
  var clusters = toArrayMaybe(cluData.cohesityClusters)
    .sort((a,b)=>norm(a.clusterName).localeCompare(norm(b.clusterName)));

  for (var cl of clusters){
    clustersScanned++;
    var headers={apiKey,accessClusterId:cl.clusterId};

    var pgData = await getJson(
      baseUrl+"/v2/data-protect/protection-groups?environments=kAcropolis&isDeleted=False&isActive=True&isPaused=False",
      headers
    );

    for (var pg of toArrayMaybe(pgData.protectionGroups)){
      pgsScanned++;

      var runData = await getJson(
        baseUrl+"/v2/data-protect/protection-groups/"+pg.id+
        "/runs?numRuns="+Math.max(10,LAST_SUCCESS_RUN_LOOKBACK)+"&includeObjectDetails=True",
        headers
      );

      var runs = toArrayMaybe(runData.runs)
        .filter(r=>r.objects && getRunStatus(r)!=="Running")
        .sort((a,b)=>getEndUsecs(b)-getEndUsecs(a));

      if(!runs.length) continue;

      var invRun=runs[0];
      inventoryAsOfUsecsAll.push(getEndUsecs(invRun));

      var lastSuccess={}, invObjs=toArrayMaybe(invRun.objects);
      invObjs.forEach(o=>{
        if(o.object?.objectType==="kVirtualMachine")
          lastSuccess[o.object.name]="";
      });

      var checked=0;
      for(var r of runs){
        if(checked++>=LAST_SUCCESS_RUN_LOOKBACK) break;
        var et=getEndUsecs(r);
        toArrayMaybe(r.objects).forEach(o=>{
          var vm=o.object?.name;
          if(vm && !lastSuccess[vm] && !objFailed(o))
            lastSuccess[vm]=usecsToETString(et);
        });
      }

      var total=0, failed=0;
      invObjs.forEach(o=>{
        if(o.object?.objectType!=="kVirtualMachine") return;
        total++; vmsScanned++;
        var fail=objFailed(o); if(fail) failed++;
        VMInventory.push({
          Cluster:cl.clusterName,
          ProtectionGroup:pg.name,
          VMName:o.object.name,
          BackupStatus: fail ? "üî¥" : "üü¢",
          Last_Successful_BKUP_ET:lastSuccess[o.object.name]||""
        });
      });

      PGInventory.push({
        Cluster:cl.clusterName,
        ProtectionGroup:pg.name,
        TotalVMs:total,
        BKUP_VM_SUCCESSFUL:total-failed,
        BKUP_VM_FAILED:failed
      });
    }
  }

  // ------------------------------
  // Summaries + TOTAL highlight
  // ------------------------------
  var clusterMap={};
  PGInventory.forEach(r=>{
    clusterMap[r.Cluster]=clusterMap[r.Cluster]||{Cluster:r.Cluster,PGs:0,TotalVMs:0,BKUP_VM_SUCCESSFUL:0,BKUP_VM_FAILED:0};
    clusterMap[r.Cluster].PGs++;
    clusterMap[r.Cluster].TotalVMs+=r.TotalVMs;
    clusterMap[r.Cluster].BKUP_VM_SUCCESSFUL+=r.BKUP_VM_SUCCESSFUL;
    clusterMap[r.Cluster].BKUP_VM_FAILED+=r.BKUP_VM_FAILED;
  });

  var ClusterSummary=Object.values(clusterMap).sort((a,b)=>a.Cluster.localeCompare(b.Cluster));

  var ClusterTotalRow={
    Cluster:"‚≠ê TOTAL",
    PGs:sum(ClusterSummary.map(x=>x.PGs)),
    TotalVMs:sum(ClusterSummary.map(x=>x.TotalVMs)),
    BKUP_VM_SUCCESSFUL:"üü¢ "+sum(ClusterSummary.map(x=>x.BKUP_VM_SUCCESSFUL)),
    BKUP_VM_FAILED:"üî¥ "+sum(ClusterSummary.map(x=>x.BKUP_VM_FAILED))
  };

  ClusterSummary.forEach(r=>{
    r.BKUP_VM_SUCCESSFUL="üü¢ "+r.BKUP_VM_SUCCESSFUL;
    r.BKUP_VM_FAILED="üî¥ "+r.BKUP_VM_FAILED;
  });

  var markdownAll =
    "## Cohesity AHV Inventory\n\n" +
    "**Inventory As Of (ET):** "+usecsToETString(Math.max(...inventoryAsOfUsecsAll))+"\n\n"+
    toMarkdownTable(
      "Summary 1: Cluster Summary",
      ["Cluster","PGs","TotalVMs","BKUP_VM_SUCCESSFUL","BKUP_VM_FAILED"],
      ClusterSummary.concat([ClusterTotalRow])
    ) +
    toMarkdownTable(
      "Full VM List",
      ["Cluster","ProtectionGroup","VMName","BackupStatus","Last_Successful_BKUP_ET"],
      VMInventory
    );

  return { markdownAll, markdownEmail: markdownAll };
}
