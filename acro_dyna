// -------------------------------------------------------------
// Cohesity Helios ‚Äì AHV (Acropolis) Inventory + Weekly Baseline
// Dynatrace Workflow JS (GET-only) + Markdown + HTML tables
//
// Output:
// 1) Active Scope Today (Monitored) + Trend (Œî 1d, Net 7d)  [Cluster-level]
// 2) PG State Map (All AHV PGs across clusters ‚Äî failover-safe) [name grouped]
// 3) VM Scope Trend Matrix (7 days) ‚Äî Active PGs only         [PG-level deltas]
// 4) Current VM List (latest inventory run only)              [üü¢/üî¥ + last success]
//
// Notes:
// - Timezone is Eastern Time via Intl timeZone: America/New_York.
// - Day buckets use RUN END time (Eastern Time).
// - Last Successful Backup is searched only across last N runs (default 10).
// - Active scope = isDeleted=False, isActive=True, isPaused=False
// - State map lists Active/Paused/Deleted; FAILOVER READY means same PG name appears on >1 cluster (any state).
// -------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // CONFIG
  // ------------------------------
  const DAYS = 7;
  const NUM_RUNS_PULL = 60;            // enough to cover 7 days even with retries
  const LAST_SUCCESS_RUN_LOOKBACK = 10;

  // If empty => ALL clusters. Else restrict.
  // const TARGET_CLUSTER_IDS = ["12345", "67890"];
  const TARGET_CLUSTER_IDS = [];

  // ------------------------------
  // 1) Credential vault: name -> id -> manual (your working pattern)
  // ------------------------------
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312"; // optional fallback, keep if you have it

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    let found = null;
    for (let i = 0; i < (all.credentials || []).length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;

    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("‚úì Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
      console.log("‚úì Helios key from vault (id): " + (d2 && d2.name ? d2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("‚ö†Ô∏è Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  // ------------------------------
  // Helpers (sanity-safe)
  // ------------------------------
  const TZ = "America/New_York";

  function norm(v) {
    return v === null || v === undefined ? "" : String(v).trim();
  }

  function arr(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  function cmpStr(a, b) {
    a = a === null || a === undefined ? "" : String(a);
    b = b === null || b === undefined ? "" : String(b);
    return a.localeCompare(b);
  }

  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  function lbiFirst(runObj) {
    if (!runObj) return null;
    const lb = runObj.localBackupInfo;
    if (!lb) return null;
    return Array.isArray(lb) ? (lb.length ? lb[0] : null) : lb;
  }

  function getEndUsecs(runObj) {
    const info = lbiFirst(runObj);
    const v = info && info.endTimeUsecs;
    const n = Number(v || 0);
    return Number.isFinite(n) ? n : 0;
  }

  function getRunStatus(runObj) {
    const info = lbiFirst(runObj);
    return norm(info && info.status);
  }

  function objFailed(obj) {
    try {
      const fa = obj && obj.localSnapshotInfo && obj.localSnapshotInfo.failedAttempts;
      if (!fa) return false;
      return arr(fa).length > 0;
    } catch {
      return false;
    }
  }

  function usecsToET(usecs) {
    if (!usecs) return { etDate: "", etTs: "" };
    const ms = Math.floor(Number(usecs) / 1000);
    if (!Number.isFinite(ms) || ms <= 0) return { etDate: "", etTs: "" };
    const d = new Date(ms);

    try {
      const fmt = new Intl.DateTimeFormat("en-CA", {
        timeZone: TZ,
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit",
        hour12: false
      });
      const parts = fmt.formatToParts(d);
      const m = {};
      for (let i = 0; i < parts.length; i++) m[parts[i].type] = parts[i].value;

      const etDate = `${m.year}-${m.month}-${m.day}`;
      const etTs = `${etDate} ${m.hour}:${m.minute}:${m.second}`;
      return { etDate, etTs };
    } catch {
      const iso = d.toISOString().replace("T", " ").slice(0, 19);
      return { etDate: iso.slice(0, 10), etTs: iso };
    }
  }

  function countAHVVmsFromRun(runObj) {
    let total = 0;
    const objs = arr(runObj && runObj.objects);
    for (let i = 0; i < objs.length; i++) {
      const x = objs[i] || {};
      const o = x.object || {};
      if (norm(o.environment) !== "kAcropolis") continue;
      if (norm(o.objectType) !== "kVirtualMachine") continue;
      if (!norm(o.name)) continue;
      total++;
    }
    return total;
  }

  function deltaBadge(n) {
    if (n === null || n === undefined) return "‚Äî";
    const v = Number(n);
    if (!Number.isFinite(v)) return "‚Äî";
    if (v === 0) return "0";
    return v > 0 ? `üü¢ **+${v}**` : `üî¥ **-${Math.abs(v)}**`;
  }

  function mdTable(title, cols, rows) {
    if (!rows || rows.length === 0) {
      return `### ${title}\n\n‚úÖ No rows.\n\n`;
    }
    const header = `| ${cols.join(" | ")} |`;
    const sep = `| ${cols.map(() => "---").join(" | ")} |`;
    const body = rows.map(r => `| ${cols.map(c => safeCell(r[c])).join(" | ")} |`);
    return `### ${title}\n\n${[header, sep].concat(body).join("\n")}\n\n`;
  }

  function htmlEscape(s) {
    return String(s ?? "")
      .replace(/&/g, "&amp;").replace(/</g, "&lt;")
      .replace(/>/g, "&gt;").replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function htmlTable(title, cols, rows, opts = {}) {
    const { highlightTotalRow = false, totalKey = null } = opts;

    let h = `<h3 style="margin:14px 0 8px 0;">${htmlEscape(title)}</h3>`;
    if (!rows || rows.length === 0) return h + `<div>‚úÖ No rows.</div>`;

    h += `<table style="border-collapse:collapse;width:100%;font-family:Segoe UI,Arial,sans-serif;font-size:13px;">`;
    h += `<tr style="background:#e5e7eb;">` +
         cols.map(c => `<th style="text-align:left;padding:8px;border:1px solid #d1d5db;">${htmlEscape(c)}</th>`).join("") +
         `</tr>`;

    for (let i = 0; i < rows.length; i++) {
      const r = rows[i] || {};
      const isTotal = highlightTotalRow && totalKey && norm(r[totalKey]) === "‚≠ê TOTAL";
      const trStyle = isTotal ? `background:#fff7ed;font-weight:800;` : ``;

      h += `<tr style="${trStyle}">`;
      for (let j = 0; j < cols.length; j++) {
        const v = r[cols[j]];
        const raw = String(v ?? "");
        let tdStyle = `padding:8px;border:1px solid #d1d5db;`;

        // colorize deltas
        if (raw.includes("üü¢")) tdStyle += `color:#16a34a;font-weight:700;`;
        if (raw.includes("üî¥")) tdStyle += `color:#dc2626;font-weight:700;`;

        h += `<td style="${tdStyle}">${htmlEscape(v)}</td>`;
      }
      h += `</tr>`;
    }

    h += `</table>`;
    return h;
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  function buildQuery(params) {
    const usp = new URLSearchParams();
    for (const k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      const v = params[k];
      if (v === undefined || v === null) continue;
      if (Array.isArray(v)) {
        for (let i = 0; i < v.length; i++) usp.append(k, String(v[i]));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  // ------------------------------
  // 2) Get clusters
  // ------------------------------
  const commonHeaders = { accept: "application/json", apiKey: apiKey };

  const cluData = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, commonHeaders);
  let clusters = arr(cluData && cluData.cohesityClusters);

  clusters.sort((a, b) => cmpStr(a && a.clusterName, b && b.clusterName));

  if (TARGET_CLUSTER_IDS && TARGET_CLUSTER_IDS.length) {
    const allow = {};
    for (let i = 0; i < TARGET_CLUSTER_IDS.length; i++) allow[String(TARGET_CLUSTER_IDS[i])] = true;
    clusters = clusters.filter(c => allow[String(c && c.clusterId)]);
  }

  if (!clusters.length) {
    return { authMode, markdownAll: "‚ö†Ô∏è No clusters returned from /v2/mcm/cluster-mgmt/info" };
  }

  // ------------------------------
  // 3) PG listing per cluster (Active/Paused/Deleted + Inactive only for FAILOVER READY detection)
  // ------------------------------
  const pgByName = {}; // name -> {ActiveOn:Set, PausedOn:Set, DeletedOn:Set, SeenOn:Set}
  const activePGs = []; // [{clusterName,clusterId,pgId,pgName}]

  function ensurePG(name) {
    if (!pgByName[name]) {
      pgByName[name] = {
        ProtectionGroup: name,
        ActiveOn: new Set(),
        PausedOn: new Set(),
        DeletedOn: new Set(),
        SeenOn: new Set()
      };
    }
    return pgByName[name];
  }

  async function fetchPGs(clusterId, qp) {
    const headers = { accept: "application/json", apiKey: apiKey, accessClusterId: String(clusterId) };
    const url = `${baseUrl}/v2/data-protect/protection-groups?` +
      buildQuery(Object.assign({ environments: "kAcropolis" }, qp));
    const data = await getJson(url, headers);
    return arr(data && data.protectionGroups);
  }

  for (let ci = 0; ci < clusters.length; ci++) {
    const c = clusters[ci] || {};
    const clusterId = norm(c.clusterId);
    const clusterName = norm(c.clusterName);
    if (!clusterId) continue;

    let pActive = [], pPaused = [], pDeleted = [], pInactive = [];

    try { pActive = await fetchPGs(clusterId, { isDeleted: "False", isActive: "True", isPaused: "False" }); } catch {}
    try { pPaused = await fetchPGs(clusterId, { isDeleted: "False", isPaused: "True" }); } catch {}
    try { pDeleted = await fetchPGs(clusterId, { isDeleted: "True" }); } catch {}
    try { pInactive = await fetchPGs(clusterId, { isDeleted: "False", isActive: "False" }); } catch {}

    for (let i = 0; i < pActive.length; i++) {
      const pg = pActive[i] || {};
      const pgName = norm(pg.name);
      const pgId = norm(pg.id);
      if (!pgName || !pgId) continue;

      const e = ensurePG(pgName);
      e.ActiveOn.add(clusterName);
      e.SeenOn.add(clusterName);

      activePGs.push({ clusterId, clusterName, pgId, pgName });
    }

    for (let i = 0; i < pPaused.length; i++) {
      const pg = pPaused[i] || {};
      const pgName = norm(pg.name);
      if (!pgName) continue;

      const e = ensurePG(pgName);
      e.PausedOn.add(clusterName);
      e.SeenOn.add(clusterName);
    }

    for (let i = 0; i < pDeleted.length; i++) {
      const pg = pDeleted[i] || {};
      const pgName = norm(pg.name);
      if (!pgName) continue;

      const e = ensurePG(pgName);
      e.DeletedOn.add(clusterName);
      e.SeenOn.add(clusterName);
    }

    // inactive only to mark "seen across clusters" -> FAILOVER READY
    for (let i = 0; i < pInactive.length; i++) {
      const pg = pInactive[i] || {};
      const pgName = norm(pg.name);
      if (!pgName) continue;

      const e = ensurePG(pgName);
      e.SeenOn.add(clusterName);
    }
  }

  // ------------------------------
  // 4) For ACTIVE PGs: pull runs and compute:
  //    - global 7-day date list
  //    - per PG totals by date (latest run per date)
  //    - per PG drift deltas
  //    - current VM inventory rows + last success
  // ------------------------------
  const perPG = {}; // key cluster|pgName -> stats
  const VMInventory = [];
  const inventoryAsOfUsecsAll = [];
  const allDatesSet = new Set();

  async function fetchRuns(clusterId, pgId) {
    const headers = { accept: "application/json", apiKey: apiKey, accessClusterId: String(clusterId) };
    const url =
      `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs?` +
      buildQuery({ environments: "kAcropolis", numRuns: String(NUM_RUNS_PULL), includeObjectDetails: "True" });
    const data = await getJson(url, headers);
    return arr(data && data.runs);
  }

  for (let i = 0; i < activePGs.length; i++) {
    const p = activePGs[i];
    let runs = [];
    try { runs = await fetchRuns(p.clusterId, p.pgId); } catch { continue; }

    runs = runs
      .filter(r => r && r.objects && getRunStatus(r) !== "Running" && getEndUsecs(r) > 0)
      .sort((a, b) => getEndUsecs(b) - getEndUsecs(a));

    if (!runs.length) continue;

    const inventoryRun = runs[0];
    const invEndUsecs = getEndUsecs(inventoryRun);
    if (invEndUsecs > 0) inventoryAsOfUsecsAll.push(invEndUsecs);

    // latest completed run per ET date
    const byDate = {};
    for (let r = 0; r < runs.length; r++) {
      const endUsecs = getEndUsecs(runs[r]);
      const et = usecsToET(endUsecs);
      if (!et.etDate) continue;
      if (!byDate[et.etDate]) {
        byDate[et.etDate] = { run: runs[r], endUsecs, etTs: et.etTs };
        allDatesSet.add(et.etDate);
      }
    }

    const key = `${p.clusterName}|${p.pgName}`;
    perPG[key] = {
      Cluster: p.clusterName,
      ProtectionGroup: p.pgName,
      totalsByDate: {},
      deltasByDate: {}
    };

    for (const d in byDate) {
      perPG[key].totalsByDate[d] = countAHVVmsFromRun(byDate[d].run);
    }

    // last-success lookback map for VMs in inventory run
    const invObjs = arr(inventoryRun.objects);
    const inventoryVms = [];
    for (let oi = 0; oi < invObjs.length; oi++) {
      const obj = invObjs[oi] || {};
      const o = obj.object || {};
      if (norm(o.environment) !== "kAcropolis") continue;
      if (norm(o.objectType) !== "kVirtualMachine") continue;
      const name = norm(o.name);
      if (name) inventoryVms.push(name);
    }

    const lastSuccessMap = {};
    for (let v = 0; v < inventoryVms.length; v++) lastSuccessMap[inventoryVms[v]] = "";

    let remaining = inventoryVms.length;
    let checked = 0;

    for (let rr = 0; rr < runs.length; rr++) {
      if (remaining <= 0) break;
      if (checked >= LAST_SUCCESS_RUN_LOOKBACK) break;

      const runObj = runs[rr];
      const endUsecs = getEndUsecs(runObj);
      if (endUsecs <= 0) continue;

      checked++;
      const etTs = usecsToET(endUsecs).etTs;

      const robjs = arr(runObj.objects);
      for (let oo = 0; oo < robjs.length; oo++) {
        const robj = robjs[oo] || {};
        const ro = robj.object || {};
        if (norm(ro.environment) !== "kAcropolis") continue;
        if (norm(ro.objectType) !== "kVirtualMachine") continue;

        const vm = norm(ro.name);
        if (!vm) continue;
        if (!Object.prototype.hasOwnProperty.call(lastSuccessMap, vm)) continue;
        if (lastSuccessMap[vm]) continue;

        if (!objFailed(robj)) {
          lastSuccessMap[vm] = etTs || "";
          remaining--;
        }
      }
    }

    // Emit VM rows from inventory run
    for (let ob = 0; ob < invObjs.length; ob++) {
      const x = invObjs[ob] || {};
      const o = x.object || {};
      if (norm(o.environment) !== "kAcropolis") continue;
      if (norm(o.objectType) !== "kVirtualMachine") continue;

      const vmName = norm(o.name);
      if (!vmName) continue;

      VMInventory.push({
        Cluster: p.clusterName,
        ProtectionGroup: p.pgName,
        VMName: vmName,
        BackupStatus: objFailed(x) ? "üî¥" : "üü¢",
        "Last Successful Backup (Eastern Time)": lastSuccessMap[vmName] || ""
      });
    }
  }

  // build global date columns (newest -> oldest) from actual run end dates
  const allDates = Array.from(allDatesSet).sort((a, b) => b.localeCompare(a)).slice(0, DAYS);

  // ------------------------------
  // 5) VM Scope Trend matrix rows (active PGs only)
  // ------------------------------
  const trendRows = [];
  const activePGKeys = Object.keys(perPG);

  for (let i = 0; i < activePGKeys.length; i++) {
    const key = activePGKeys[i];
    const row = perPG[key];

    // pick "todayDate" for this PG: first date in global list where PG has a total
    let todayDate = null;
    for (let d = 0; d < allDates.length; d++) {
      if (Object.prototype.hasOwnProperty.call(row.totalsByDate, allDates[d])) { todayDate = allDates[d]; break; }
    }
    const todayTotal = todayDate ? row.totalsByDate[todayDate] : null;

    // delta(date) = total(date) - total(next date to the right)
    for (let di = 0; di < allDates.length; di++) {
      const d0 = allDates[di];
      const d1 = allDates[di + 1];
      if (!d1) { row.deltasByDate[d0] = "‚Äî"; continue; }

      if (!Object.prototype.hasOwnProperty.call(row.totalsByDate, d0) ||
          !Object.prototype.hasOwnProperty.call(row.totalsByDate, d1)) {
        row.deltasByDate[d0] = "‚Äî";
        continue;
      }
      const delta = Number(row.totalsByDate[d0]) - Number(row.totalsByDate[d1]);
      row.deltasByDate[d0] = delta === 0 ? "0" : (delta > 0 ? `üü¢ **+${delta}**` : `üî¥ **-${Math.abs(delta)}**`);
    }

    // Net (7d) vs oldest available day in window for that PG
    let oldestDate = null;
    for (let di = allDates.length - 1; di >= 0; di--) {
      if (Object.prototype.hasOwnProperty.call(row.totalsByDate, allDates[di])) { oldestDate = allDates[di]; break; }
    }

    let net7d = "‚Äî";
    if (todayDate && oldestDate) {
      const net = Number(row.totalsByDate[todayDate]) - Number(row.totalsByDate[oldestDate]);
      net7d = deltaBadge(net);
    }

    const out = {
      Cluster: row.Cluster,
      ProtectionGroup: row.ProtectionGroup,
      Today_TotalVMs: todayTotal === null ? "‚Äî" : String(todayTotal)
    };

    for (let di = 0; di < allDates.length; di++) out[allDates[di]] = row.deltasByDate[allDates[di]] || "‚Äî";
    out["Net (7d)"] = net7d;

    trendRows.push(out);
  }

  trendRows.sort((a, b) => cmpStr(a.Cluster, b.Cluster) || cmpStr(a.ProtectionGroup, b.ProtectionGroup));

  // ------------------------------
  // 6) Cluster Active Scope Today + Trend (Option C)
  // ------------------------------
  const clusterAgg = {}; // cluster -> { Active_PGs, totalsByDate:{} }

  for (let i = 0; i < activePGKeys.length; i++) {
    const key = activePGKeys[i];
    const p = perPG[key];
    const c = p.Cluster;

    if (!clusterAgg[c]) clusterAgg[c] = { Cluster: c, Active_PGs: 0, totalsByDate: {} };
    clusterAgg[c].Active_PGs += 1;

    for (let di = 0; di < allDates.length; di++) {
      const d = allDates[di];
      if (!Object.prototype.hasOwnProperty.call(p.totalsByDate, d)) continue;
      clusterAgg[c].totalsByDate[d] = Number(clusterAgg[c].totalsByDate[d] || 0) + Number(p.totalsByDate[d] || 0);
    }
  }

  const clusterRows = Object.keys(clusterAgg)
    .sort((a, b) => a.localeCompare(b))
    .map(c => {
      const x = clusterAgg[c];
      const d0 = allDates[0] || null;
      const d1 = allDates[1] || null;
      const dold = allDates[allDates.length - 1] || null;

      const has0 = d0 && Object.prototype.hasOwnProperty.call(x.totalsByDate, d0);
      const has1 = d1 && Object.prototype.hasOwnProperty.call(x.totalsByDate, d1);
      const hasOld = dold && Object.prototype.hasOwnProperty.call(x.totalsByDate, dold);

      const totalToday = has0 ? x.totalsByDate[d0] : null;

      let delta1d = "‚Äî";
      if (has0 && has1) delta1d = deltaBadge(Number(x.totalsByDate[d0]) - Number(x.totalsByDate[d1]));

      let net7d = "‚Äî";
      if (has0 && hasOld) net7d = deltaBadge(Number(x.totalsByDate[d0]) - Number(x.totalsByDate[dold]));

      return {
        Cluster: c,
        Active_PGs: String(x.Active_PGs),
        TotalVMs: totalToday === null ? "‚Äî" : String(totalToday),
        "Œî VMs (1d)": delta1d,
        "Net VMs (7d)": net7d
      };
    });

  function parseSignedNumFromBadge(s) {
    const m = String(s || "").match(/([+-]\d+)/);
    return m ? Number(m[1]) : null;
  }

  const totalRow = {
    Cluster: "‚≠ê TOTAL",
    Active_PGs: String(clusterRows.reduce((s, r) => s + Number(r.Active_PGs || 0), 0)),
    TotalVMs: String(clusterRows.reduce((s, r) => s + Number(r.TotalVMs === "‚Äî" ? 0 : (r.TotalVMs || 0)), 0)),
    "Œî VMs (1d)": "‚Äî",
    "Net VMs (7d)": "‚Äî"
  };

  // if we can sum the deltas, do it (else keep ‚Äî)
  let sum1d = 0, ok1d = false;
  for (let i = 0; i < clusterRows.length; i++) {
    const n = parseSignedNumFromBadge(clusterRows[i]["Œî VMs (1d)"]);
    if (n === null) continue;
    sum1d += n; ok1d = true;
  }
  totalRow["Œî VMs (1d)"] = ok1d ? deltaBadge(sum1d) : "‚Äî";

  let sum7d = 0, ok7d = false;
  for (let i = 0; i < clusterRows.length; i++) {
    const n = parseSignedNumFromBadge(clusterRows[i]["Net VMs (7d)"]);
    if (n === null) continue;
    sum7d += n; ok7d = true;
  }
  totalRow["Net VMs (7d)"] = ok7d ? deltaBadge(sum7d) : "‚Äî";

  const clusterRowsOut = clusterRows.concat([totalRow]);

  // ------------------------------
  // 7) PG State Map output rows (All AHV PGs across clusters ‚Äî failover-safe)
  // ------------------------------
  const pgStateRows = Object.keys(pgByName)
    .sort((a, b) => a.localeCompare(b))
    .map(name => {
      const e = pgByName[name];
      const activeOn = Array.from(e.ActiveOn).sort().join(", ");
      const pausedOn = Array.from(e.PausedOn).sort().join(", ");
      const deletedOn = Array.from(e.DeletedOn).sort().join(", ");

      const failoverReady = Array.from(e.SeenOn).length > 1;

      let flag = "";
      if (deletedOn) flag = "üóëÔ∏è **DELETED**";
      else if (pausedOn && !activeOn) flag = "‚è∏Ô∏è **PAUSED**";
      else if (failoverReady) flag = "üîµ **FAILOVER READY**";

      return {
        ProtectionGroup: name,
        "Active On": activeOn ? `**${activeOn}**` : "‚Äî",
        "Paused On": pausedOn || "‚Äî",
        "Deleted On": deletedOn ? `**${deletedOn}**` : "‚Äî",
        Flags: flag
      };
    });

  // NO RUNS (7d) for active PG names if we got no completed run dates in window
  const activeNames = new Set(activePGs.map(x => x.pgName));
  const nameHasRunsInWindow = {};

  for (let i = 0; i < activePGKeys.length; i++) {
    const key = activePGKeys[i];
    const pgName = key.split("|").slice(1).join("|");
    const obj = perPG[key];
    const hasAny = Object.keys(obj.totalsByDate).some(d => allDates.includes(d));
    if (!nameHasRunsInWindow[pgName]) nameHasRunsInWindow[pgName] = false;
    if (hasAny) nameHasRunsInWindow[pgName] = true;
  }

  for (let i = 0; i < pgStateRows.length; i++) {
    const r = pgStateRows[i];
    if (!activeNames.has(r.ProtectionGroup)) continue;

    const hasRuns = !!nameHasRunsInWindow[r.ProtectionGroup];
    if (!hasRuns) {
      const add = "üü† **NO RUNS (7d)**";
      r.Flags = r.Flags ? (r.Flags + " | " + add) : add;
    }
  }

  // ------------------------------
  // 8) Inventory As Of (Eastern Time)
  // ------------------------------
  let inventoryAsOfET = "";
  if (inventoryAsOfUsecsAll.length) {
    let max = 0;
    for (let i = 0; i < inventoryAsOfUsecsAll.length; i++) {
      const u = Number(inventoryAsOfUsecsAll[i] || 0);
      if (u > max) max = u;
    }
    inventoryAsOfET = usecsToET(max).etTs;
  }

  // ------------------------------
  // 9) Sort VM list (sanity-safe)
  // ------------------------------
  VMInventory.sort((a, b) =>
    cmpStr(a.Cluster, b.Cluster) ||
    cmpStr(a.ProtectionGroup, b.ProtectionGroup) ||
    cmpStr(a.VMName, b.VMName)
  );

  // ------------------------------
  // 10) Build Markdown
  // ------------------------------
  const header =
    "## Cohesity AHV Inventory + Weekly Baseline\n" +
    `**Inventory As Of (Eastern Time): ${inventoryAsOfET || "<blank>"}**\n` +
    `**Baseline Window: last ${DAYS} days (Eastern Time)**\n` +
    "**Grouping rule:** Day buckets use **Run End Time (Eastern Time)**.\n\n";

  const md1 =
    "### 1) Active Scope Today (Monitored) + Trend\n" +
    "**How to read:**  \n" +
    "- **Œî VMs (1d)** = change vs previous day (based on completed runs ending on that date)  \n" +
    `- **Net VMs (7d)** = change vs oldest available day in this ${DAYS}-day window  \n` +
    "- `‚Äî` means insufficient run history to compute that comparison\n\n" +
    mdTable("", ["Cluster", "Active_PGs", "TotalVMs", "Œî VMs (1d)", "Net VMs (7d)"], clusterRowsOut);

  const md2 =
    "### 2) PG State Map (All AHV PGs across clusters ‚Äî failover-safe)\n" +
    mdTable("", ["ProtectionGroup", "Active On", "Paused On", "Deleted On", "Flags"], pgStateRows);

  const dateCols = allDates.slice();
  const trendCols = ["Cluster", "ProtectionGroup", "Today_TotalVMs"].concat(dateCols).concat(["Net (7d)"]);

  const md3 =
    "### 3) VM Scope Trend (7 days) ‚Äî Active PGs only\n" +
    "**How to read:** each date column is **Œî vs previous day** (üü¢ increase / üî¥ decrease / 0 stable / ‚Äî no run).  \n" +
    "**Net (7d)** = Today_TotalVMs ‚àí oldest available day in window.\n\n" +
    mdTable("", trendCols, trendRows);

  const md4 =
    "### 4) Current VM List (Latest inventory run only)\n" +
    mdTable("", ["Cluster", "ProtectionGroup", "VMName", "BackupStatus", "Last Successful Backup (Eastern Time)"], VMInventory) +
    `**Note:** ‚ÄúLast Successful Backup (Eastern Time)‚Äù is checked only for the last **${LAST_SUCCESS_RUN_LOOKBACK} runs**. If blank, check Helios for older success.\n`;

  const markdownAll = header + md1 + md2 + md3 + md4;

  // ------------------------------
  // 11) HTML Email (TOTAL row highlighted + delta colors)
  // ------------------------------
  const htmlHeader =
    `<h2 style="margin:0 0 8px 0;">Cohesity AHV Inventory + Weekly Baseline</h2>` +
    `<div style="font-family:Segoe UI,Arial,sans-serif;font-size:13px;margin-bottom:10px;">` +
    `<div><b>Inventory As Of (Eastern Time):</b> ${htmlEscape(inventoryAsOfET || "<blank>")}</div>` +
    `<div><b>Baseline Window:</b> last ${DAYS} days (Eastern Time)</div>` +
    `<div><b>Grouping rule:</b> Day buckets use <b>Run End Time (Eastern Time)</b>.</div>` +
    `</div>`;

  const html1 = htmlTable(
    "1) Active Scope Today (Monitored) + Trend",
    ["Cluster", "Active_PGs", "TotalVMs", "Œî VMs (1d)", "Net VMs (7d)"],
    clusterRowsOut,
    { highlightTotalRow: true, totalKey: "Cluster" }
  );

  const html2 = htmlTable(
    "2) PG State Map (All AHV PGs across clusters ‚Äî failover-safe)",
    ["ProtectionGroup", "Active On", "Paused On", "Deleted On", "Flags"],
    pgStateRows
  );

  const html3 = htmlTable(
    "3) VM Scope Trend (7 days) ‚Äî Active PGs only",
    trendCols,
    trendRows
  );

  const html4 = htmlTable(
    "4) Current VM List (Latest inventory run only)",
    ["Cluster", "ProtectionGroup", "VMName", "BackupStatus", "Last Successful Backup (Eastern Time)"],
    VMInventory
  ) + `<div style="margin-top:8px;font-family:Segoe UI,Arial,sans-serif;font-size:12px;">
        <b>Note:</b> ‚ÄúLast Successful Backup (Eastern Time)‚Äù is checked only for the last <b>${LAST_SUCCESS_RUN_LOOKBACK} runs</b>. If blank, check Helios for older success.
      </div>`;

  const htmlAll = htmlHeader + html1 + html2 + html3 + html4;

  return {
    authMode,
    baselineDates: allDates,
    markdownAll,
    markdownEmail: markdownAll,
    htmlEmail: htmlAll
  };
}
