// -------------------------------------------------------------
// Cohesity Helios â€“ AHV Inventory (Object-level)
// FINAL LOGIC â€“ matches approved sample output EXACTLY
//
// Sections:
// 1) Active Scope Today (Monitored)
// 2) PG Trend (7-day) + PG State (Combined)
// 3) VM Backup Issues (FAILED + STALE only)
//
// Key Rules:
// - Completed runs only
// - 7-day window
// - Policy-based retention (7 / 14 / 35)
// - Total VMs = cumulative additions within window
// - Todayâ€™s Delta = sum of TODAY column
// -------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {

  const BASE = "https://helios.cohesity.com";
  const TZ = "America/New_York";
  const DAYS = 7;
  const MAX_RETENTION = 35;
  const LAST_SUCCESS_RUNS = 10;

  // -------------------------------------------------------------
  // Auth (Vault â†’ fallback)
  // -------------------------------------------------------------
  let apiKey = null;
  try {
    const all = await credentialVaultClient.getCredentials();
    const c = all.credentials.find(x => x.name === "Cohesity_API_Key");
    if (c) {
      const d = await credentialVaultClient.getCredentialsDetails({ id: c.id });
      apiKey = d.token || d.password;
    }
  } catch {}

  if (!apiKey) throw new Error("No Cohesity API key");

  const H = { accept: "application/json", apiKey };

  // -------------------------------------------------------------
  // Helpers
  // -------------------------------------------------------------
  const A = v => Array.isArray(v) ? v : (v ? [v] : []);
  const N = v => (v ?? "").toString().trim();

  function et(usecs) {
    const d = new Date(Math.floor(usecs / 1000));
    return new Intl.DateTimeFormat("en-CA", {
      timeZone: TZ,
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      hour12: false
    }).format(d).replace(",", "");
  }

  function day(usecs) {
    return et(usecs).slice(0, 10);
  }

  async function GET(url, headers) {
    const r = await fetch(url, { headers });
    if (!r.ok) throw new Error(`${r.status} ${url}`);
    return r.json();
  }

  function runOK(r) {
    const lb = A(r.localBackupInfo)[0];
    return lb && lb.status !== "Running" && lb.endTimeUsecs;
  }

  function vmCount(run) {
    return A(run.objects).filter(o =>
      o.object?.environment === "kAcropolis" &&
      o.object?.objectType === "kVirtualMachine"
    ).length;
  }

  function failed(obj) {
    return A(obj.localSnapshotInfo?.failedAttempts).length > 0;
  }

  function retentionFromDays(d) {
    if (!d || d <= 7) return 7;
    if (d <= 14) return 14;
    return 35;
  }

  // -------------------------------------------------------------
  // 1) Clusters
  // -------------------------------------------------------------
  const clusters = A((await GET(`${BASE}/v2/mcm/cluster-mgmt/info`, H)).cohesityClusters);

  // -------------------------------------------------------------
  // Data containers
  // -------------------------------------------------------------
  const pgRows = [];
  const vmIssues = [];
  const activeSummary = {};

  // -------------------------------------------------------------
  // 2) Per cluster â†’ PGs
  // -------------------------------------------------------------
  for (const c of clusters) {

    const CH = { ...H, accessClusterId: c.clusterId };

    const pgs = A((await GET(
      `${BASE}/v2/data-protect/protection-groups?environments=kAcropolis&isDeleted=False&isActive=True`,
      CH
    )).protectionGroups);

    for (const pg of pgs) {

      // --- Policy ---
      let retention = 7;
      if (pg.policyId) {
        try {
          const pol = await GET(
            `${BASE}/irisservices/api/v1/public/protectionPolicies/${pg.policyId}`,
            CH
          );
          retention = retentionFromDays(pol.daysToKeep);
        } catch {}
      }

      // --- Runs ---
      const runs = A((await GET(
        `${BASE}/v2/data-protect/protection-groups/${pg.id}/runs?numRuns=100&includeObjectDetails=True`,
        CH
      )).runs)
        .filter(runOK)
        .sort((a, b) =>
          A(b.localBackupInfo)[0].endTimeUsecs -
          A(a.localBackupInfo)[0].endTimeUsecs
        );

      if (!runs.length) continue;

      const todayRun = runs[0];
      const todayDay = day(A(todayRun.localBackupInfo)[0].endTimeUsecs);

      // --- Build daily snapshots ---
      const byDay = {};
      for (const r of runs) {
        const u = A(r.localBackupInfo)[0].endTimeUsecs;
        const d = day(u);
        if (!byDay[d]) byDay[d] = vmCount(r);
      }

      // --- Compute deltas ---
      const days = Object.keys(byDay).sort();
      let cumulative = 0;
      let todayDelta = 0;
      let lastKnownDelta = "";

      for (let i = 0; i < days.length; i++) {
        const cur = byDay[days[i]];
        const prev = byDay[days[i - 1]];
        if (prev !== undefined) {
          const delta = cur - prev;
          if (delta !== 0) {
            cumulative += delta;
            lastKnownDelta = `${delta > 0 ? "ðŸŸ¢ +" : "ðŸ”´ "}${delta} (${days[i]})`;
            if (days[i] === todayDay) todayDelta = delta;
          }
        }
      }

      // --- Total VMs = cumulative additions ---
      const totalVMs = cumulative > 0 ? cumulative : vmCount(todayRun);

      // --- PG row ---
      pgRows.push({
        Cluster: c.clusterName,
        ProtectionGroup: pg.name,
        TotalVMs: totalVMs,
        TodayDelta: todayDelta,
        LastKnownDelta: lastKnownDelta,
        LastCompleted: et(A(todayRun.localBackupInfo)[0].endTimeUsecs),
        PGState: "ðŸŸ¢ ACTIVE"
      });

      // --- Active summary ---
      activeSummary[c.clusterName] ??= { pgs: 0, vms: 0, delta: 0 };
      activeSummary[c.clusterName].pgs++;
      activeSummary[c.clusterName].vms += totalVMs;
      activeSummary[c.clusterName].delta += todayDelta;

      // ---------------------------------------------------------
      // 3) VM Issues (FAILED + STALE)
      // ---------------------------------------------------------
      const cutoff = Date.now() * 1000 - retention * 86400000000;

      for (const obj of A(todayRun.objects)) {
        if (obj.object?.objectType !== "kVirtualMachine") continue;

        let lastSuccess = "";
        for (const r of runs.slice(0, LAST_SUCCESS_RUNS)) {
          const u = A(r.localBackupInfo)[0].endTimeUsecs;
          if (u < cutoff) break;
          const o = A(r.objects).find(x => x.object?.name === obj.object.name);
          if (o && !failed(o)) {
            lastSuccess = et(u);
            break;
          }
        }

        if (failed(obj) || !lastSuccess) {
          vmIssues.push({
            Cluster: c.clusterName,
            PG: pg.name,
            VM: obj.object.name,
            Status: failed(obj) ? "ðŸ”´ FAILED" : "ðŸŸ  STALE",
            LastBackup: lastSuccess || `No backup within â‰¤${retention}d retention`
          });
        }
      }
    }
  }

  // -------------------------------------------------------------
  // Final return
  // -------------------------------------------------------------
  return {
    activeScope: activeSummary,
    pgTrend: pgRows,
    vmIssues
  };
}
