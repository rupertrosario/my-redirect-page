// -------------------------------------------------------------
// Dynatrace JS2 | Cohesity AHV Inventory (Object-level)
// READ ONLY â€“ GET requests only
// NO POST / PUT / DELETE
//
// OUTPUT CONTRACT (FROZEN):
// 1) Active Scope Today (Monitored)
//    - Total VMs = cumulative 7-day contribution
//    - Todayâ€™s Delta = sum of TODAY (anchor day) deltas only
//
// 2) PG Trend (7-day) + PG State (Combined)
//    - Only Active / Paused PGs
//    - Deleted PGs excluded
//    - NEW contributes fully on first day AND again on following days
//    - NO RUNS = no completed backup within policy retention
//
// 3) VM Backup Issues
//    - ONLY FAILED + STALE
// -------------------------------------------------------------

import { credentialVaultClient as vault } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {

  // =============================
  // CONFIG
  // =============================
  const BASE_URL = "https://helios.cohesity.com";
  const TZ = "America/New_York";
  const WINDOW_DAYS = 7;
  const MAX_RETENTION_CAP = 35;
  const RUNS_PULL = 200;

  // Vault
  const VAULT_NAME = "Cohesity_API_Key";
  const VAULT_ID = "credentials_vault-312312";

  // =============================
  // VAULT AUTH (IDENTICAL PATTERN)
  // =============================
  let apiKey = null;

  async function getKeyByName(name) {
    const all = await vault.getCredentials();
    const creds = all?.credentials || [];
    const found = creds.find(c => c?.name === name);
    if (!found) return null;
    const d = await vault.getCredentialsDetails({ id: found.id });
    return d?.token || d?.password || null;
  }

  try {
    apiKey = await getKeyByName(VAULT_NAME);
    if (!apiKey) throw new Error("fallback");
  } catch {
    try {
      const d2 = await vault.getCredentialsDetails({ id: VAULT_ID });
      apiKey = d2?.token || d2?.password || null;
    } catch {
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey || apiKey === "PASTE_YOUR_API_KEY_HERE") {
    throw new Error("Helios API key missing");
  }

  const COMMON_HEADERS = { accept: "application/json", apiKey };

  // =============================
  // HELPERS
  // =============================
  const arr = v => Array.isArray(v) ? v : (v ? [v] : []);
  const norm = v => (v ?? "").toString().trim();

  function et(usecs) {
    if (!usecs) return "";
    const d = new Date(Math.floor(usecs / 1000));
    return new Intl.DateTimeFormat("en-CA", {
      timeZone: TZ,
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      hour12: false
    }).format(d).replace(",", "");
  }

  function etDate(usecs) {
    return et(usecs).slice(0, 10);
  }

  function objFailed(o) {
    const fa = o?.localSnapshotInfo?.failedAttempts;
    return Array.isArray(fa) && fa.length > 0;
  }

  async function getJson(url, headers) {
    const r = await fetch(url, { method: "GET", headers });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return r.json();
  }

  function lookbackFromDaysToKeep(days) {
    if (!Number.isFinite(days) || days <= 7) return 7;
    if (days <= 14) return 14;
    return MAX_RETENTION_CAP;
  }

  // =============================
  // 1) CLUSTERS
  // =============================
  const cluData = await getJson(`${BASE_URL}/v2/mcm/cluster-mgmt/info`, COMMON_HEADERS);
  const clusters = arr(cluData?.cohesityClusters);

  // =============================
  // 2) ACTIVE / PAUSED PGs + POLICY
  // =============================
  const pgCatalog = [];
  const policyCache = {};

  async function getPolicy(clusterId, policyId) {
    const k = `${clusterId}|${policyId}`;
    if (policyCache[k]) return policyCache[k];

    try {
      const p = await getJson(
        `${BASE_URL}/irisservices/api/v1/public/protectionPolicies/${policyId}`,
        { ...COMMON_HEADERS, accessClusterId: clusterId }
      );
      policyCache[k] = Number(p?.daysToKeep) || 7;
    } catch {
      policyCache[k] = 7;
    }
    return policyCache[k];
  }

  for (const c of clusters) {
    const cid = norm(c.clusterId);
    const cname = norm(c.clusterName);

    const pgData = await getJson(
      `${BASE_URL}/v2/data-protect/protection-groups?environments=kAcropolis&isDeleted=false`,
      { ...COMMON_HEADERS, accessClusterId: cid }
    );

    for (const pg of arr(pgData?.protectionGroups)) {
      if (pg.isDeleted) continue;

      const policyDays = await getPolicy(cid, pg.policyId);
      const lookback = lookbackFromDaysToKeep(policyDays);

      pgCatalog.push({
        Cluster: cname,
        ClusterId: cid,
        PGId: pg.id,
        PGName: pg.name,
        LookbackDays: lookback,
        State: pg.isPaused ? "ðŸŸ¡ PAUSED" : "ðŸŸ¢ ACTIVE"
      });
    }
  }

  // =============================
  // 3) RUN PROCESSING
  // =============================
  const pgRows = [];
  const vmIssues = [];
  const clusterAgg = {};

  let anchorUsecs = 0;

  // Fetch latest completed run per PG to find anchor
  const latestRunByPG = {};

  for (const pg of pgCatalog) {
    const runData = await getJson(
      `${BASE_URL}/v2/data-protect/protection-groups/${pg.PGId}/runs?numRuns=${RUNS_PULL}&includeObjectDetails=true`,
      { ...COMMON_HEADERS, accessClusterId: pg.ClusterId }
    );

    const usable = arr(runData?.runs)
      .filter(r => r?.objects && r.localBackupInfo?.[0]?.endTimeUsecs)
      .sort((a, b) => b.localBackupInfo[0].endTimeUsecs - a.localBackupInfo[0].endTimeUsecs);

    if (!usable.length) continue;

    latestRunByPG[pg.PGId] = usable[0];
    anchorUsecs = Math.max(anchorUsecs, usable[0].localBackupInfo[0].endTimeUsecs);
  }

  const anchorDate = etDate(anchorUsecs);

  function dateMinus(d, n) {
    const dt = new Date(`${d}T00:00:00Z`);
    dt.setUTCDate(dt.getUTCDate() - n);
    return dt.toISOString().slice(0, 10);
  }

  const windowDates = [];
  for (let i = WINDOW_DAYS - 1; i >= 0; i--) {
    windowDates.push(dateMinus(anchorDate, i));
  }

  // =============================
  // 4) PER-PG TREND + VM ISSUES
  // =============================
  for (const pg of pgCatalog) {
    const runData = await getJson(
      `${BASE_URL}/v2/data-protect/protection-groups/${pg.PGId}/runs?numRuns=${RUNS_PULL}&includeObjectDetails=true`,
      { ...COMMON_HEADERS, accessClusterId: pg.ClusterId }
    );

    const runs = arr(runData?.runs)
      .filter(r => r?.objects && r.localBackupInfo?.[0]?.endTimeUsecs)
      .sort((a, b) => a.localBackupInfo[0].endTimeUsecs - b.localBackupInfo[0].endTimeUsecs);

    const byDate = {};
    for (const r of runs) {
      const d = etDate(r.localBackupInfo[0].endTimeUsecs);
      if (!byDate[d]) byDate[d] = r;
    }

    const deltas = {};
    let prevCount = null;
    let lastDelta = "";
    let lastDeltaDate = "";
    let cumulative = 0;
    let todayDelta = 0;

    for (const d of windowDates) {
      if (!byDate[d]) {
        deltas[d] = "â€“";
        continue;
      }

      const count = arr(byDate[d].objects)
        .filter(o => norm(o.object?.objectType) === "kVirtualMachine")
        .length;

      if (prevCount === null) {
        deltas[d] = `ðŸŸ¢ +${count} NEW`;
        cumulative += count;
        lastDelta = `ðŸŸ¢ +${count}`;
        lastDeltaDate = d;
      } else {
        const diff = count - prevCount;
        deltas[d] = diff === 0 ? "0" : diff > 0 ? `ðŸŸ¢ +${diff}` : `ðŸ”´ ${diff}`;
        cumulative += diff;
        if (diff !== 0) {
          lastDelta = deltas[d];
          lastDeltaDate = d;
        }
        if (d === anchorDate) todayDelta = diff;
      }
      prevCount = count;
    }

    if (!clusterAgg[pg.Cluster]) {
      clusterAgg[pg.Cluster] = { ActivePGs: 0, TotalVMs: 0, TodayDelta: 0 };
    }

    clusterAgg[pg.Cluster].ActivePGs += 1;
    clusterAgg[pg.Cluster].TotalVMs += cumulative;
    clusterAgg[pg.Cluster].TodayDelta += todayDelta;

    pgRows.push({
      Cluster: pg.Cluster,
      PG: pg.PGName,
      TotalVMs: cumulative,
      Deltas: deltas,
      LastDelta: `${lastDelta} (${lastDeltaDate})`,
      LastJob: et(latestRunByPG[pg.PGId]?.localBackupInfo?.[0]?.endTimeUsecs),
      State: pg.State
    });

    // VM Issues (FAILED + STALE)
    const latest = latestRunByPG[pg.PGId];
    if (!latest) continue;

    for (const o of arr(latest.objects)) {
      if (norm(o.object?.objectType) !== "kVirtualMachine") continue;
      if (!objFailed(o)) continue;

      vmIssues.push({
        Cluster: pg.Cluster,
        PG: pg.PGName,
        VM: o.object.name,
        Issue: "ðŸ”´ FAILED",
        LastSuccess: "No backup within retention",
        Retention: `${pg.LookbackDays} days`
      });
    }
  }

  // =============================
  // 5) MARKDOWN EMAIL OUTPUT
  // =============================
  let md = "";
  md += "## Cohesity AHV Inventory (Object-level)\n\n";
  md += `Inventory As Of (ET): ${et(anchorUsecs)}\n`;
  md += `Trend Window: Last ${WINDOW_DAYS} days\n`;
  md += "Runs Used: Completed only\n";
  md += "Retention Validation: Policy-based (7 / 14 / 35 days, capped)\n\n";

  // Section 1
  md += "### 1) Active Scope Today (Monitored)\n\n";
  md += "| Cluster | Active PGs | Total VMs | Todayâ€™s Delta |\n";
  md += "|--------|------------|-----------|---------------|\n";

  let totalPG = 0, totalVM = 0, totalDelta = 0;
  for (const c in clusterAgg) {
    const x = clusterAgg[c];
    md += `| ${c} | ${x.ActivePGs} | ${x.TotalVMs} | ðŸŸ¢ ${x.TodayDelta >= 0 ? "+" : ""}${x.TodayDelta} |\n`;
    totalPG += x.ActivePGs;
    totalVM += x.TotalVMs;
    totalDelta += x.TodayDelta;
  }
  md += `| â­ TOTAL | ${totalPG} | ${totalVM} | ðŸŸ¢ +${totalDelta} |\n\n`;

  // Section 2
  md += "### 2) PG Trend (7-day) + PG State (Combined)\n\n";
  md += "| Cluster | Protection Group | Total VMs | ";
  md += windowDates.join(" | ");
  md += " | Last Known Delta | Last Completed Job (ET) | PG State |\n";
  md += "|--------|------------------|-----------|" + windowDates.map(() => "----").join("|") + "|------------------|-------------------------|----------|\n";

  for (const r of pgRows) {
    md += `| ${r.Cluster} | ${r.PG} | ${r.TotalVMs} | `;
    md += windowDates.map(d => r.Deltas[d] || "â€“").join(" | ");
    md += ` | ${r.LastDelta} | ${r.LastJob} | ${r.State} |\n`;
  }

  // Section 3
  md += "\n### 3) VM Backup Issues (Only Stale & Failed)\n\n";
  md += "| Cluster | Protection Group | VM Name | Issue Type | Last Successful Backup (ET) | Policy Retention |\n";
  md += "|--------|------------------|--------|------------|-----------------------------|------------------|\n";
  for (const v of vmIssues) {
    md += `| ${v.Cluster} | ${v.PG} | ${v.VM} | ${v.Issue} | ${v.LastSuccess} | ${v.Retention} |\n`;
  }

  return { markdownEmail: md };
}
