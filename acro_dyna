// -------------------------------------------------------------
// Cohesity Helios ‚Äì AHV (Acropolis) Inventory (Object-level)
// Dynatrace Workflow JS (GET-only) + Markdown tables
//
// Output Markdown:
// 1) Cluster Summary:  PGs, TotalVMs, BKUP_VM_SUCCESSFUL, BKUP_VM_FAILED + TOTAL row
// 2) PG Summary:       TotalVMs, BKUP_VM_SUCCESSFUL, BKUP_VM_FAILED + TOTAL row
// 3) Full VM List:     VMName, BackupStatus, Last_Successful_BKUP_ET (per VM)
//
// NOTES:
// - Inventory As Of (ET): end time of the latest COMPLETED run used for inventory (per PG). Running runs are ignored.
// - Last_Successful_BKUP_ET is checked only for the last N runs (default N=10).
//   If blank: check Helios history for that VM (older than the last N runs).
//
// VISUAL ONLY (per your ask):
// - BackupStatus: üü¢ / üî¥
// - Totals in BOTH summaries: bold + ‚≠ê
// - Failures: üî¥ only when >0, else üü¢ 0
// -------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  var baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // CONFIG
  // ------------------------------
  var LAST_SUCCESS_RUN_LOOKBACK = 10; // same as PS
  var MIN_RUNS_TO_PULL = 10;

  // If empty => ALL clusters. Else use exact clusterIds.
  // Example: var TARGET_CLUSTER_IDS = ["12345", "67890"];
  var TARGET_CLUSTER_IDS = [];

  // ------------------------------
  // 1) Credential vault: name -> id -> manual
  // ------------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId = "credentials_vault-312312";

  var apiKey = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    var found = null;
    for (var i = 0; i < all.credentials.length; i++) {
      if (all.credentials[i].name === name) {
        found = all.credentials[i];
        break;
      }
    }
    if (!found) return null;

    var detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log("‚úì Helios key from vault (name): " + found.name);
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      var d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
      console.log("‚úì Helios key from vault (id): " + (d2 && d2.name ? d2.name : vaultId));
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
      console.log("‚ö†Ô∏è Using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  // ------------------------------
  // 2) Helpers
  // ------------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }

  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  // SAFE string comparator (fixes localeCompare failures)
  function cmpStr(a, b) {
    a = (a === null || a === undefined) ? "" : String(a);
    b = (b === null || b === undefined) ? "" : String(b);
    return a.localeCompare(b);
  }

  function buildQuery(params) {
    var usp = new URLSearchParams();
    for (var k in params) {
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      var v = params[k];
      if (v === undefined || v === null) continue;

      // arrays -> repeated params
      if (Array.isArray(v)) {
        for (var i = 0; i < v.length; i++) usp.append(k, String(v[i]));
      } else {
        usp.append(k, String(v));
      }
    }
    return usp.toString();
  }

  async function getJson(url, headers) {
    var resp = await fetch(url, { method: "GET", headers: headers });
    if (!resp.ok) {
      var txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function lbiFirst(runObj) {
    if (!runObj) return null;
    var lb = runObj.localBackupInfo;
    if (!lb) return null;
    return Array.isArray(lb) ? (lb.length ? lb[0] : null) : lb;
  }

  function getEndUsecs(runObj) {
    var info = lbiFirst(runObj);
    var v = info && info.endTimeUsecs;
    if (!v) return 0;
    var n = Number(v);
    return Number.isFinite(n) ? n : 0;
  }

  function getRunStatus(runObj) {
    var info = lbiFirst(runObj);
    return norm(info && info.status);
  }

  function objFailed(obj) {
    try {
      var fa = obj && obj.localSnapshotInfo && obj.localSnapshotInfo.failedAttempts;
      if (!fa) return false;
      var a = Array.isArray(fa) ? fa : [fa];
      return a.length > 0;
    } catch (e) {
      return false;
    }
  }

  function usecsToETString(usecs) {
    if (!usecs || usecs === 0) return "";
    var ms = Math.floor(Number(usecs) / 1000);
    if (!Number.isFinite(ms) || ms <= 0) return "";

    var d = new Date(ms);
    try {
      var fmt = new Intl.DateTimeFormat("en-CA", {
        timeZone: "America/New_York",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hour12: false
      });
      var parts = fmt.formatToParts(d);
      var map = {};
      for (var i = 0; i < parts.length; i++) map[parts[i].type] = parts[i].value;
      return map.year + "-" + map.month + "-" + map.day + " " + map.hour + ":" + map.minute + ":" + map.second;
    } catch (e) {
      return d.toISOString().replace("T", " ").slice(0, 19);
    }
  }

  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  function toMarkdownTable(title, columns, rows) {
    if (!rows || rows.length === 0) {
      return "### " + title + "\n\n‚úÖ No rows.\n";
    }
    var header = "| " + columns.join(" | ") + " |";
    var sep = "| " + columns.map(function () { return "---"; }).join(" | ") + " |";
    var body = rows.map(function (r) {
      var vals = [];
      for (var i = 0; i < columns.length; i++) vals.push(safeCell(r[columns[i]]));
      return "| " + vals.join(" | ") + " |";
    });
    return "### " + title + "\n\n" + [header, sep].concat(body).join("\n") + "\n";
  }

  function sum(nums) {
    var s = 0;
    for (var i = 0; i < nums.length; i++) s += Number(nums[i] || 0);
    return s;
  }

  // VISUAL formatting helpers (no math here)
  function fmtSucc(n) { return "üü¢ **" + Number(n || 0) + "**"; }
  function fmtFail(n) {
    var x = Number(n || 0);
    return x > 0 ? ("üî¥ **" + x + "**") : ("üü¢ **0**");
  }
  function fmtBold(v) { return "**" + String(v) + "**"; }

  // ------------------------------
  // 3) Get clusters
  // ------------------------------
  var commonHeaders = { accept: "application/json", apiKey: apiKey };

  var cluUrl = baseUrl + "/v2/mcm/cluster-mgmt/info";
  var cluData = await getJson(cluUrl, commonHeaders);
  var clusters = toArrayMaybe(cluData && cluData.cohesityClusters);

  if (!clusters.length) {
    return { authMode: authMode, markdownAll: "‚ö†Ô∏è No clusters returned from /v2/mcm/cluster-mgmt/info" };
  }

  clusters.sort(function (a, b) { return cmpStr(a && a.clusterName, b && b.clusterName); });

  if (TARGET_CLUSTER_IDS && TARGET_CLUSTER_IDS.length) {
    var allowed = {};
    for (var i = 0; i < TARGET_CLUSTER_IDS.length; i++) allowed[String(TARGET_CLUSTER_IDS[i])] = true;
    clusters = clusters.filter(function (c) { return allowed[String(c && c.clusterId)]; });
  }

  if (!clusters.length) {
    return { authMode: authMode, markdownAll: "‚ö†Ô∏è No clusters matched TARGET_CLUSTER_IDS." };
  }

  // ------------------------------
  // 4) Collect inventories
  // ------------------------------
  var PGInventory = [];
  var VMInventory = [];
  var inventoryAsOfUsecsAll = [];

  var clustersScanned = 0;
  var pgsScanned = 0;
  var vmsScanned = 0;

  for (var ci = 0; ci < clusters.length; ci++) {
    var clus = clusters[ci] || {};
    var clusterName = norm(clus.clusterName);
    var clusterId = norm(clus.clusterId);
    if (!clusterId) continue;

    clustersScanned++;

    var headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: clusterId
    };

    // --- Get Acropolis PGs (active only) ---
    var pgUrl =
      baseUrl +
      "/v2/data-protect/protection-groups?" +
      buildQuery({ environments: "kAcropolis", isDeleted: "False", isActive: "True", isPaused: "False" });

    var pgsData;
    try {
      pgsData = await getJson(pgUrl, headers);
    } catch (ePg) {
      console.log("‚ö†Ô∏è PG fetch failed for " + clusterName + " (" + clusterId + "): " + norm(ePg.message || ePg));
      continue;
    }

    var pgs = toArrayMaybe(pgsData && pgsData.protectionGroups);
    if (!pgs.length) continue;

    pgs.sort(function (a, b) { return cmpStr(a && a.name, b && b.name); });

    for (var pi = 0; pi < pgs.length; pi++) {
      var pg = pgs[pi] || {};
      var pgId = norm(pg.id);
      var pgName = norm(pg.name);
      if (!pgId || !pgName) continue;

      pgsScanned++;

      // --- Pull runs WITH object details ---
      var numRunsToPull = Math.max(LAST_SUCCESS_RUN_LOOKBACK, MIN_RUNS_TO_PULL);

      var runUrl =
        baseUrl +
        "/v2/data-protect/protection-groups/" +
        encodeURIComponent(pgId) +
        "/runs?" +
        buildQuery({ environments: "kAcropolis", numRuns: String(numRunsToPull), includeObjectDetails: "True" });

      var runData;
      try {
        runData = await getJson(runUrl, headers);
      } catch (eRun) {
        console.log("‚ö†Ô∏è Runs fetch failed for PG " + pgName + " on " + clusterName + ": " + norm(eRun.message || eRun));
        continue;
      }

      var runs = toArrayMaybe(runData && runData.runs);
      if (!runs.length) continue;

      runs.sort(function (a, b) { return getEndUsecs(b) - getEndUsecs(a); });

      // Inventory run = latest COMPLETED run with objects (exclude Running)
      var inventoryRun = null;
      for (var ri = 0; ri < runs.length; ri++) {
        var r = runs[ri] || {};
        if (!r.objects) continue;
        if (getRunStatus(r) === "Running") continue;
        if (getEndUsecs(r) <= 0) continue;
        inventoryRun = r;
        break;
      }
      if (!inventoryRun || !inventoryRun.objects) continue;

      var invEndUsecs = getEndUsecs(inventoryRun);
      if (invEndUsecs > 0) inventoryAsOfUsecsAll.push(invEndUsecs);

      // VMs in inventory run
      var inventoryVms = [];
      var invObjs = toArrayMaybe(inventoryRun.objects);
      for (var oi = 0; oi < invObjs.length; oi++) {
        var obj = invObjs[oi] || {};
        var o = obj.object || {};
        if (norm(o.environment) !== "kAcropolis") continue;
        if (norm(o.objectType) !== "kVirtualMachine") continue;
        var vmName = norm(o.name);
        if (!vmName) continue;
        inventoryVms.push(vmName);
      }
      if (!inventoryVms.length) continue;

      // Per-VM last success map (last N completed runs)
      var lastSuccessMap = {};
      for (var vi = 0; vi < inventoryVms.length; vi++) lastSuccessMap[inventoryVms[vi]] = "";

      var remaining = inventoryVms.length;
      var checkedRuns = 0;

      for (var rr = 0; rr < runs.length; rr++) {
        if (remaining <= 0) break;
        if (checkedRuns >= LAST_SUCCESS_RUN_LOOKBACK) break;

        var runObj = runs[rr] || {};
        if (!runObj.objects) continue;
        if (getRunStatus(runObj) === "Running") continue;

        var endUsecs = getEndUsecs(runObj);
        if (endUsecs <= 0) continue;

        checkedRuns++;

        var robjs = toArrayMaybe(runObj.objects);
        for (var oo = 0; oo < robjs.length; oo++) {
          var robj = robjs[oo] || {};
          var ro = robj.object || {};
          if (norm(ro.environment) !== "kAcropolis") continue;
          if (norm(ro.objectType) !== "kVirtualMachine") continue;

          var vm = norm(ro.name);
          if (!vm) continue;
          if (!Object.prototype.hasOwnProperty.call(lastSuccessMap, vm)) continue;
          if (lastSuccessMap[vm]) continue;

          if (!objFailed(robj)) {
            var et = usecsToETString(endUsecs);
            if (et) {
              lastSuccessMap[vm] = et;
              remaining--;
            }
          }
        }
      }

      // Object-level success/fail for the inventory run
      var pgTotalVMs = 0;
      var pgFailedVMs = 0;

      for (var ob2 = 0; ob2 < invObjs.length; ob2++) {
        var obj2 = invObjs[ob2] || {};
        var o2 = obj2.object || {};
        if (norm(o2.environment) !== "kAcropolis") continue;
        if (norm(o2.objectType) !== "kVirtualMachine") continue;

        var vmName2 = norm(o2.name);
        if (!vmName2) continue;

        pgTotalVMs++;
        vmsScanned++;

        var failedNow = objFailed(obj2);
        if (failedNow) pgFailedVMs++;

        VMInventory.push({
          Cluster: clusterName,
          ProtectionGroup: pgName,
          VMName: vmName2,
          BackupStatus: failedNow ? "üî¥" : "üü¢",
          Last_Successful_BKUP_ET: lastSuccessMap[vmName2] || ""
        });
      }

      var pgSuccVMs = pgTotalVMs - pgFailedVMs;

      PGInventory.push({
        Cluster: clusterName,
        ProtectionGroup: pgName,
        TotalVMs: pgTotalVMs,
        BKUP_VM_SUCCESSFUL: pgSuccVMs,
        BKUP_VM_FAILED: pgFailedVMs
      });
    }
  }

  if (!PGInventory.length) {
    return { authMode: authMode, clustersScanned: clustersScanned, markdownAll: "‚ö†Ô∏è No Acropolis inventory collected." };
  }

  // Global "as-of"
  var globalAsOfET = "";
  if (inventoryAsOfUsecsAll.length) {
    var maxUsecs = 0;
    for (var m = 0; m < inventoryAsOfUsecsAll.length; m++) {
      var x = Number(inventoryAsOfUsecsAll[m] || 0);
      if (x > maxUsecs) maxUsecs = x;
    }
    globalAsOfET = usecsToETString(maxUsecs);
  }

  // ------------------------------
  // 5) Cluster Summary + TOTAL row (safe sort + raw math)
  // ------------------------------
  var clusterMap = {};
  for (var i1 = 0; i1 < PGInventory.length; i1++) {
    var r1 = PGInventory[i1];
    var c = r1.Cluster;
    if (!clusterMap[c]) {
      clusterMap[c] = { Cluster: c, PGs: 0, TotalVMs: 0, S: 0, F: 0 };
    }
    clusterMap[c].PGs += 1;
    clusterMap[c].TotalVMs += Number(r1.TotalVMs || 0);
    clusterMap[c].S += Number(r1.BKUP_VM_SUCCESSFUL || 0);
    clusterMap[c].F += Number(r1.BKUP_VM_FAILED || 0);
  }

  var ClusterSummary = Object.keys(clusterMap)
    .sort(function (a, b) { return cmpStr(a, b); })
    .map(function (k) {
      return {
        Cluster: clusterMap[k].Cluster,
        PGs: clusterMap[k].PGs,
        TotalVMs: clusterMap[k].TotalVMs,
        BKUP_VM_SUCCESSFUL: fmtSucc(clusterMap[k].S),
        BKUP_VM_FAILED: fmtFail(clusterMap[k].F)
      };
    });

  var ClusterTotalRaw = { PGs: 0, TotalVMs: 0, S: 0, F: 0 };
  for (var ck = 0; ck < Object.keys(clusterMap).length; ck++) {
    var key = Object.keys(clusterMap)[ck];
    ClusterTotalRaw.PGs += clusterMap[key].PGs;
    ClusterTotalRaw.TotalVMs += clusterMap[key].TotalVMs;
    ClusterTotalRaw.S += clusterMap[key].S;
    ClusterTotalRaw.F += clusterMap[key].F;
  }

  var ClusterTotalRow = {
    Cluster: "**‚≠ê TOTAL**",
    PGs: fmtBold(ClusterTotalRaw.PGs),
    TotalVMs: fmtBold(ClusterTotalRaw.TotalVMs),
    BKUP_VM_SUCCESSFUL: fmtSucc(ClusterTotalRaw.S),
    BKUP_VM_FAILED: fmtFail(ClusterTotalRaw.F)
  };

  // ------------------------------
  // 6) PG Summary + TOTAL row (fixed comparator)
  // ------------------------------
  var PGSummary = PGInventory.slice().sort(function (a, b) {
    if (!a && !b) return 0;
    if (!a) return 1;
    if (!b) return -1;
    return cmpStr(a.Cluster, b.Cluster) || cmpStr(a.ProtectionGroup, b.ProtectionGroup);
  });

  // Convert to display formatted rows (visual only)
  var PGSummaryDisplay = PGSummary.map(function (r) {
    return {
      Cluster: r.Cluster,
      ProtectionGroup: r.ProtectionGroup,
      TotalVMs: r.TotalVMs,
      BKUP_VM_SUCCESSFUL: fmtSucc(r.BKUP_VM_SUCCESSFUL),
      BKUP_VM_FAILED: fmtFail(r.BKUP_VM_FAILED)
    };
  });

  var PGTotalRow = {
    Cluster: "**‚≠ê TOTAL**",
    ProtectionGroup: "",
    TotalVMs: fmtBold(sum(PGInventory.map(function (x) { return x.TotalVMs; }))),
    BKUP_VM_SUCCESSFUL: fmtSucc(sum(PGInventory.map(function (x) { return x.BKUP_VM_SUCCESSFUL; }))),
    BKUP_VM_FAILED: fmtFail(sum(PGInventory.map(function (x) { return x.BKUP_VM_FAILED; })))
  };

  // ------------------------------
  // 7) Full VM List (sorted; unchanged columns)
  // ------------------------------
  VMInventory.sort(function (a, b) {
    if (!a && !b) return 0;
    if (!a) return 1;
    if (!b) return -1;
    return cmpStr(a.Cluster, b.Cluster) ||
           cmpStr(a.ProtectionGroup, b.ProtectionGroup) ||
           cmpStr(a.VMName, b.VMName);
  });

  // ------------------------------
  // 8) Build Markdown
  // ------------------------------
  var note =
    "## Cohesity AHV Inventory (Object-level)\n\n" +
    "- Inventory As Of (ET): " + (globalAsOfET ? globalAsOfET : "<blank>") + "\n" +
    "- Last_Successful_BKUP_ET is checked only for the last " + LAST_SUCCESS_RUN_LOOKBACK +
    " runs. If blank, check Helios for older history.\n\n";

  var clusterMd = toMarkdownTable(
    "Summary 1: Cluster Summary",
    ["Cluster", "PGs", "TotalVMs", "BKUP_VM_SUCCESSFUL", "BKUP_VM_FAILED"],
    ClusterSummary.concat([ClusterTotalRow])
  );

  var pgMd = toMarkdownTable(
    "Summary 2: Protection Group Summary",
    ["Cluster", "ProtectionGroup", "TotalVMs", "BKUP_VM_SUCCESSFUL", "BKUP_VM_FAILED"],
    PGSummaryDisplay.concat([PGTotalRow])
  );

  var vmMd = toMarkdownTable(
    "Full VM List",
    ["Cluster", "ProtectionGroup", "VMName", "BackupStatus", "Last_Successful_BKUP_ET"],
    VMInventory
  );

  var markdownAll = note + clusterMd + "\n" + pgMd + "\n" + vmMd;

  return {
    authMode: authMode,
    clustersScanned: clustersScanned,
    pgsScanned: pgsScanned,
    vmsScanned: vmsScanned,
    globalAsOfET: globalAsOfET,
    clusterSummary: ClusterSummary,
    pgSummary: PGSummaryDisplay,
    vmInventory: VMInventory,
    markdownAll: markdownAll,
    markdownEmail: markdownAll
  };
}
