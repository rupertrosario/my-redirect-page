// -------------------------------------------------------------
// Cohesity Helios â€“ AHV (Acropolis) Inventory
// GET-only | Dynatrace Workflow JS
// Visual Enhancements ONLY:
// - â­ TOTAL rows highlighted
// - ðŸŸ¢ / ðŸ”´ radio-button style status
// -------------------------------------------------------------

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";
  const LAST_SUCCESS_RUN_LOOKBACK = 10;

  // ------------------------------
  // Credential Vault
  // ------------------------------
  let apiKey = null;
  try {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find(c => c.name === "Cohesity_API_Key");
    if (found) {
      const d = await credentialVaultClient.getCredentialsDetails({ id: found.id });
      apiKey = d.token || d.password;
    }
  } catch (_) {}

  if (!apiKey) throw new Error("No Helios API key available");

  const commonHeaders = { accept: "application/json", apiKey };

  // ------------------------------
  // Helpers
  // ------------------------------
  const toArr = v => (Array.isArray(v) ? v : v ? [v] : []);
  const norm = v => (v === null || v === undefined ? "" : String(v).trim());

  const toET = usecs => {
    if (!usecs) return "";
    const ms = Math.floor(Number(usecs) / 1000);
    const d = new Date(ms);
    return new Intl.DateTimeFormat("en-CA", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    }).format(d).replace(",", "");
  };

  const objFailed = o =>
    o?.localSnapshotInfo?.failedAttempts &&
    toArr(o.localSnapshotInfo.failedAttempts).length > 0;

  // ------------------------------
  // Fetch Clusters
  // ------------------------------
  const cluData = await fetch(
    `${baseUrl}/v2/mcm/cluster-mgmt/info`,
    { headers: commonHeaders }
  ).then(r => r.json());

  const clusters = toArr(cluData.cohesityClusters)
    .sort((a, b) => norm(a.clusterName).localeCompare(norm(b.clusterName)));

  const PGInventory = [];
  const VMInventory = [];
  const inventoryTimes = [];

  // ------------------------------
  // Main Collection Loop
  // ------------------------------
  for (const c of clusters) {
    const clusterName = norm(c.clusterName);
    const clusterId = norm(c.clusterId);

    const headers = { ...commonHeaders, accessClusterId: clusterId };

    const pgData = await fetch(
      `${baseUrl}/v2/data-protect/protection-groups?environments=kAcropolis&isDeleted=False&isActive=True&isPaused=False`,
      { headers }
    ).then(r => r.json()).catch(() => null);

    const pgs = toArr(pgData?.protectionGroups);

    for (const pg of pgs) {
      const pgId = pg.id;
      const pgName = pg.name;

      const runData = await fetch(
        `${baseUrl}/v2/data-protect/protection-groups/${pgId}/runs?numRuns=${Math.max(10, LAST_SUCCESS_RUN_LOOKBACK)}&includeObjectDetails=True`,
        { headers }
      ).then(r => r.json()).catch(() => null);

      const runs = toArr(runData?.runs)
        .filter(r => r.objects && r.localBackupInfo?.[0]?.status !== "Running")
        .sort((a, b) =>
          (b.localBackupInfo?.[0]?.endTimeUsecs || 0) -
          (a.localBackupInfo?.[0]?.endTimeUsecs || 0)
        );

      if (!runs.length) continue;

      const inventoryRun = runs[0];
      const invTime = inventoryRun.localBackupInfo?.[0]?.endTimeUsecs;
      if (invTime) inventoryTimes.push(invTime);

      const lastSuccess = {};
      const invVMs = [];

      for (const o of inventoryRun.objects) {
        if (o.object?.objectType === "kVirtualMachine") {
          invVMs.push(o.object.name);
          lastSuccess[o.object.name] = "";
        }
      }

      let checked = 0;
      for (const r of runs) {
        if (checked >= LAST_SUCCESS_RUN_LOOKBACK) break;
        checked++;

        const et = r.localBackupInfo?.[0]?.endTimeUsecs;
        for (const o of toArr(r.objects)) {
          const vm = o.object?.name;
          if (!vm || lastSuccess[vm]) continue;
          if (!objFailed(o)) lastSuccess[vm] = toET(et);
        }
      }

      let total = 0, failed = 0;

      for (const o of inventoryRun.objects) {
        if (o.object?.objectType !== "kVirtualMachine") continue;
        total++;

        const isFailed = objFailed(o);
        if (isFailed) failed++;

        VMInventory.push({
          Cluster: clusterName,
          ProtectionGroup: pgName,
          VMName: o.object.name,
          BackupStatus: isFailed ? "ðŸ”´" : "ðŸŸ¢",
          Last_Successful_BKUP_ET: lastSuccess[o.object.name] || ""
        });
      }

      PGInventory.push({
        Cluster: clusterName,
        ProtectionGroup: pgName,
        TotalVMs: total,
        BKUP_VM_SUCCESSFUL: total - failed,
        BKUP_VM_FAILED: failed
      });
    }
  }

  // ------------------------------
  // Summaries
  // ------------------------------
  const clusterMap = {};
  for (const r of PGInventory) {
    if (!clusterMap[r.Cluster])
      clusterMap[r.Cluster] = { PGs: 0, TotalVMs: 0, S: 0, F: 0 };

    clusterMap[r.Cluster].PGs++;
    clusterMap[r.Cluster].TotalVMs += r.TotalVMs;
    clusterMap[r.Cluster].S += r.BKUP_VM_SUCCESSFUL;
    clusterMap[r.Cluster].F += r.BKUP_VM_FAILED;
  }

  const clusterLines = Object.entries(clusterMap).map(
    ([k, v]) => `| ${k} | ${v.PGs} | ${v.TotalVMs} | ðŸŸ¢ ${v.S} | ðŸ”´ ${v.F} |`
  );

  const totals = Object.values(clusterMap).reduce(
    (a, b) => ({
      PGs: a.PGs + b.PGs,
      TotalVMs: a.TotalVMs + b.TotalVMs,
      S: a.S + b.S,
      F: a.F + b.F
    }),
    { PGs: 0, TotalVMs: 0, S: 0, F: 0 }
  );

  const markdown =
`## Cohesity AHV Backup Inventory

**Inventory As Of (ET):** ${inventoryTimes.length ? toET(Math.max(...inventoryTimes)) : "<blank>"}

### â­ TOTAL (All Clusters)
ðŸŸ¢ **${totals.S} Success**â€ƒâ€ƒðŸ”´ **${totals.F} Failure**â€ƒâ€ƒ**${totals.TotalVMs} VMs**

---

### Summary 1: Cluster Summary
| Cluster | PGs | TotalVMs | Success | Failure |
|--------|-----|----------|---------|---------|
${clusterLines.join("\n")}
| â­ **TOTAL** | **${totals.PGs}** | **${totals.TotalVMs}** | ðŸŸ¢ **${totals.S}** | ðŸ”´ **${totals.F}** |

---

### Summary 2: Protection Group Summary
| Cluster | Protection Group | TotalVMs | Success | Failure |
|--------|------------------|----------|---------|---------|
${PGInventory.map(p =>
  `| ${p.Cluster} | ${p.ProtectionGroup} | ${p.TotalVMs} | ðŸŸ¢ ${p.BKUP_VM_SUCCESSFUL} | ðŸ”´ ${p.BKUP_VM_FAILED} |`
).join("\n")}
| â­ **TOTAL** |  | **${totals.TotalVMs}** | ðŸŸ¢ **${totals.S}** | ðŸ”´ **${totals.F}** |

---

### Full VM List
| Cluster | Protection Group | VM Name | Backup Status | Last Successful Backup (ET) |
|--------|------------------|---------|---------------|-----------------------------|
${VMInventory.map(v =>
  `| ${v.Cluster} | ${v.ProtectionGroup} | ${v.VMName} | ${v.BackupStatus} | ${v.Last_Successful_BKUP_ET} |`
).join("\n")}
`;

  return {
    markdownEmail: markdown,
    markdown
  };
}
