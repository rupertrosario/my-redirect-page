import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // 1) Auth (vault name -> id -> manual)
  // ==============================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = (all && all.credentials) ? all.credentials : [];
    const found = creds.find(c => c && c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (_) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (_) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  // ==============================
  // 2) Helpers
  // ==============================
  const commonHeaders = { accept: "application/json", apiKey };

  const toArrayMaybe = (v) => Array.isArray(v) ? v : (v ? [v] : []);
  const norm = (v) => (v === null || v === undefined) ? "" : String(v).trim();
  const safeCell = (v) => (v === null || v === undefined) ? "" : String(v).replace(/\|/g, " ");

  function nowEtString() {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    }).formatToParts(new Date());
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day} ${m.hour}:${m.minute}`;
  }

  function dateKeyET(d) {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).formatToParts(d);
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day}`; // YYYY-MM-DD
  }

  function dayLabelFromETKey(etKey) {
    const day = Number(etKey.slice(8, 10));
    const suffix =
      day % 100 >= 11 && day % 100 <= 13 ? "th" :
      day % 10 === 1 ? "st" :
      day % 10 === 2 ? "nd" :
      day % 10 === 3 ? "rd" : "th";
    return `${day}${suffix}`;
  }

  function usecsFromDate(d) {
    return String(Math.floor(d.getTime() * 1000)); // microseconds
  }

  function getPGState(pg) {
    if (pg && pg.isDeleted) return "Deleted";
    if (pg && pg.isPaused) return "Paused";
    if (pg && pg.isActive) return "Active";
    return "Inactive";
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const err = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      err.httpStatus = resp.status;
      err.bodyText = txt;
      err.url = url;
      throw err;
    }
    return resp.json();
  }

  async function getJsonSafe(url, headers) {
    try {
      const data = await getJson(url, headers);
      return { ok: true, data, status: 200, bodyText: "", url };
    } catch (e) {
      return {
        ok: false,
        data: null,
        status: e && e.httpStatus ? e.httpStatus : 0,
        bodyText: e && e.bodyText ? e.bodyText : String(e || ""),
        url: e && e.url ? e.url : url
      };
    }
  }

  // v2 runs shape: run.localBackupInfo[0].{status,endTimeUsecs,runType,runId}
  function lbi(run) {
    const a = run && run.localBackupInfo;
    const x = Array.isArray(a) ? a[0] : a;
    return x || null;
  }

  function pickEndUsecsFromRun(run) {
    const i = lbi(run);
    return norm(i && i.endTimeUsecs) || "";
  }

  function pickStartUsecsFromRun(run) {
    const i = lbi(run);
    return norm(i && i.startTimeUsecs) || "";
  }

  function pickStatusFromRun(run) {
    const i = lbi(run);
    return norm(i && i.status) || "";
  }

  function isRunCompleted(run) {
    const s = pickStatusFromRun(run).toLowerCase();
    if (!s) return false;
    if (s === "running") return false;
    // treat everything non-running with endTimeUsecs as completed (Succeeded/Failed/Warning/Canceled)
    return !!pickEndUsecsFromRun(run);
  }

  function isRunOK(run) {
    const s = pickStatusFromRun(run).toLowerCase();
    return (s === "succeeded" || s === "succeededwithwarning" || s === "warning");
  }

  function extractVmName(obj) {
    // runs.objects element commonly has obj.object.{name,environment,objectType}
    return (
      norm(obj && obj.object && obj.object.name) ||
      norm(obj && obj.objectName) ||
      norm(obj && obj.name) ||
      ""
    );
  }

  function isAhvVmObject(obj) {
    const env = norm(obj && obj.object && obj.object.environment);
    const typ = norm(obj && obj.object && obj.object.objectType);
    return (env === "kAcropolis" && typ === "kVirtualMachine");
  }

  function objectIssueStatus(obj) {
    // best-effort: many tenants have failedAttempts or status-ish fields
    const fa = obj && obj.localSnapshotInfo && obj.localSnapshotInfo.failedAttempts;
    if (fa && Array.isArray(fa) && fa.length) return "FailedAttempt";
    const st = norm(obj && obj.status) || norm(obj && obj.runStatus) || norm(obj && obj.objectRunStatus);
    return st || "";
  }

  function isObjectIssue(obj) {
    const fa = obj && obj.localSnapshotInfo && obj.localSnapshotInfo.failedAttempts;
    if (fa && Array.isArray(fa) && fa.length) return true;

    const s = objectIssueStatus(obj).toLowerCase();
    if (!s) return false;

    // mark obvious non-success
    if (s === "ksuccess" || s === "success" || s === "succeeded" || s === "succeededwithwarning" || s === "kwarning" || s === "warning") return false;
    return true;
  }

  function mdTable(headers, rows) {
    const head = "| " + headers.join(" | ") + " |";
    const sep = "| " + headers.map(() => "---").join(" | ") + " |";
    const body = rows.map(r => "| " + headers.map(h => safeCell(r[h])).join(" | ") + " |");
    return [head, sep].concat(body).join("\n");
  }

  // ==============================
  // 3) 7-day ET window
  // ==============================
  const asOfEt = nowEtString();
  const now = new Date();

  const etKeys = [];
  for (let i = 6; i >= 0; i--) {
    const d = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
    etKeys.push(dateKeyET(d));
  }
  const dayLabels = etKeys.map(dayLabelFromETKey);

  const windowStart = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const windowStartUsecs = usecsFromDate(windowStart);
  const windowEndUsecs = usecsFromDate(now);

  // ==============================
  // 4) Get clusters
  // ==============================
  const errors = [];

  const cluResp = await getJsonSafe(baseUrl + "/v2/mcm/cluster-mgmt/info", commonHeaders);
  const clusters = toArrayMaybe(cluResp.ok && cluResp.data && cluResp.data.cohesityClusters);

  if (!cluResp.ok || !clusters.length) {
    return {
      authMode,
      totalClusters: 0,
      markdownEmail: "‚ö†Ô∏è No clusters returned from Helios or API call failed.",
      errors: cluResp.ok ? [] : [{ scope: "clusters", httpStatus: cluResp.status, url: cluResp.url, body: cluResp.bodyText }]
    };
  }

  // ==============================
  // 5) API probes
  // ==============================
  async function fetchAllPGsForCluster(clusterId) {
    const headers = { ...commonHeaders, accessClusterId: clusterId };

    const pgs = [];
    let pageToken = "";
    let safety = 0;

    while (safety < 200) {
      safety++;
      let url = baseUrl + "/v2/data-protect/protection-groups?environments=kAcropolis";
      if (pageToken) url += "&pageToken=" + encodeURIComponent(pageToken);

      const resp = await getJsonSafe(url, headers);
      if (!resp.ok) return { ok: false, pgs: [], err: resp };

      const data = resp.data || {};
      const batch = toArrayMaybe(data.protectionGroups);
      for (let i = 0; i < batch.length; i++) pgs.push(batch[i]);

      const next =
        norm(data.nextPageToken) ||
        norm(data.pageToken) ||
        norm(data.nextToken) ||
        norm(data.pagination && (data.pagination.nextPageToken || data.pagination.nextToken));

      if (!next || next === pageToken) break;
      pageToken = next;
    }

    return { ok: true, pgs, err: null };
  }

  async function fetchRunsWithObjects(clusterHeaders, pgId) {
    // You confirmed runs.objects exists ‚Üí lock to includeObjectDetails=true
    const id = encodeURIComponent(pgId);
    const url = `${baseUrl}/v2/data-protect/protection-groups/${id}/runs?numRuns=50&includeObjectDetails=true`;
    const r = await getJsonSafe(url, clusterHeaders);
    if (!r.ok) return { ok: false, runs: [], err: r, usedUrl: url };

    const d = r.data || {};
    const runs = toArrayMaybe(d.runs);
    return { ok: true, runs, err: null, usedUrl: url };
  }

  // ==============================
  // 6) Compute drift + build output sections
  // ==============================
  const pgRows = [];
  const issuesRows = [];
  const clusterSummary = {};
  let newlyDetectedPGs = 0;

  // NOTE: true ‚Äúremoved PGs‚Äù requires persistence/baseline; keep as 0 for evidence correctness
  const removedPGs = 0;

  let vmsAdded = 0;
  let vmsRemoved = 0;
  let grandTotalVMsToday = 0;

  for (let c = 0; c < clusters.length; c++) {
    const cl = clusters[c] || {};
    const clusterName = norm(cl.clusterName) || `Cluster-${c + 1}`;
    const clusterId = norm(cl.clusterId);
    if (!clusterId) continue;

    const headers = { ...commonHeaders, accessClusterId: clusterId };

    const pgRes = await fetchAllPGsForCluster(clusterId);
    if (!pgRes.ok) {
      errors.push({ scope: "protection-groups", clusterName, clusterId, httpStatus: pgRes.err.status, url: pgRes.err.url, body: pgRes.err.bodyText });
      continue;
    }

    const pgs = toArrayMaybe(pgRes.pgs);

    if (!clusterSummary[clusterName]) {
      clusterSummary[clusterName] = { ActivePGs: 0, TotalVMsToday: 0, NetDrift7d: 0 };
    }

    for (let p = 0; p < pgs.length; p++) {
      const pg = pgs[p] || {};
      const pgName = norm(pg.name);
      const state = getPGState(pg);
      if (!pgName) continue;

      // Active scope today only
      if (state !== "Active") continue;

      const pgId = norm(pg.id) || norm(pg.protectionGroupId) || norm(pg.groupId);
      if (!pgId) continue;

      const runRes = await fetchRunsWithObjects(headers, pgId);
      if (!runRes.ok) {
        errors.push({ scope: "pg-runs", clusterName, clusterId, protectionGroup: pgName, protectionGroupId: pgId, httpStatus: runRes.err.status, url: runRes.usedUrl, body: runRes.err.bodyText });
        continue;
      }

      const completed = runRes.runs
        .filter(isRunCompleted)
        .filter(r => Array.isArray(r.objects) && r.objects.length) // require evidence objects
        .sort((a, b) => Number(pickEndUsecsFromRun(b)) - Number(pickEndUsecsFromRun(a)));

      if (!completed.length) continue;

      // Map: ET day key -> latest completed run ending that day (ET)
      const dayToRun = {};
      for (let i = 0; i < completed.length; i++) {
        const endUsecs = pickEndUsecsFromRun(completed[i]);
        const endMs = Math.floor(Number(endUsecs) / 1000);
        if (!Number.isFinite(endMs)) continue;
        const key = dateKeyET(new Date(endMs));
        if (!dayToRun[key] || Number(endUsecs) > Number(pickEndUsecsFromRun(dayToRun[key]))) {
          dayToRun[key] = completed[i];
        }
      }

      // Build daily VM sets (null = not detected that day)
      const dayVmSets = {};
      for (let i = 0; i < etKeys.length; i++) dayVmSets[etKeys[i]] = null;

      for (let i = 0; i < etKeys.length; i++) {
        const key = etKeys[i];
        const r = dayToRun[key];
        if (!r) continue;

        const set = new Set();
        const objs = toArrayMaybe(r.objects);

        for (let o = 0; o < objs.length; o++) {
          const obj = objs[o];
          if (!isAhvVmObject(obj)) continue;
          const nm = extractVmName(obj);
          if (nm) set.add(nm);

          // issues table: only from TODAY‚Äôs completed run for noise control
          if (key === etKeys[etKeys.length - 1] && isObjectIssue(obj)) {
            issuesRows.push({
              Cluster: clusterName,
              ProtectionGroup: pgName,
              VMName: nm || "‚Äî",
              IssueType: objectIssueStatus(obj) || "Non-success",
              Notes: "Observed non-success object status in completed run"
            });
          }
        }

        dayVmSets[key] = set;
      }

      // Today evidence
      const todayKey = etKeys[etKeys.length - 1];
      const todaySet = dayVmSets[todayKey];
      const vmsToday = (todaySet && typeof todaySet.size === "number") ? todaySet.size : 0;

      // Compute daily delta strings + summary adds/removes
      const dayDelta = {};
      let prevSet = null;

      // Track first observed day for this PG in window
      let firstObservedKey = null;

      for (let i = 0; i < etKeys.length; i++) {
        const k = etKeys[i];
        const cur = dayVmSets[k];

        if (cur === null) {
          dayDelta[k] = "‚Äì";
          continue;
        }

        if (!firstObservedKey) firstObservedKey = k;

        if (prevSet === null) {
          // first observed day in window = NEW baseline
          dayDelta[k] = `üü¢ +${cur.size} NEW`;
          newlyDetectedPGs += 1;
          vmsAdded += cur.size;
        } else {
          let adds = 0, rems = 0;
          for (const x of cur) if (!prevSet.has(x)) adds++;
          for (const x of prevSet) if (!cur.has(x)) rems++;

          vmsAdded += adds;
          vmsRemoved += rems;

          if (adds === 0 && rems === 0) dayDelta[k] = "0";
          else if (adds > 0 && rems === 0) dayDelta[k] = `üü¢ +${adds}`;
          else if (rems > 0 && adds === 0) dayDelta[k] = `üî¥ -${rems}`;
          else dayDelta[k] = `üü¢ +${adds} / üî¥ -${rems}`;
        }

        prevSet = cur;
      }

      // Last known delta (latest non-0 / non-‚Äì in the window)
      let lastKnownDelta = "0";
      let lastKnownDeltaDay = "";

      for (let i = etKeys.length - 1; i >= 0; i--) {
        const k = etKeys[i];
        const v = dayDelta[k];
        if (v && v !== "0" && v !== "‚Äì") {
          lastKnownDelta = v.replace(" NEW", "");
          lastKnownDeltaDay = k;
          break;
        }
      }

      // Net drift for cluster summary: Today - first observed
      let netPgDrift = 0;
      if (firstObservedKey && dayVmSets[firstObservedKey] && todaySet) {
        netPgDrift = todaySet.size - dayVmSets[firstObservedKey].size;
      }

      // Last completed job status: use today‚Äôs run if present else latest completed in window
      let lastJob = "‚Äî";
      const todayRun = dayToRun[todayKey];
      if (todayRun) lastJob = isRunOK(todayRun) ? "OK" : "NOT OK";
      else lastJob = isRunOK(completed[0]) ? "OK" : "NOT OK";

      // Update cluster summary
      clusterSummary[clusterName].ActivePGs += 1;
      clusterSummary[clusterName].TotalVMsToday += vmsToday;
      clusterSummary[clusterName].NetDrift7d += netPgDrift;

      grandTotalVMsToday += vmsToday;

      // Build Section 2 row (PG detail)
      const row = {
        Cluster: clusterName,
        ProtectionGroup: pgName,
        TotalVMsToday: String(vmsToday),
        LastKnownDelta: lastKnownDeltaDay ? `${lastKnownDelta} (${lastKnownDeltaDay})` : "0",
        PGState: state,
        LastCompletedJob: lastJob
      };

      for (let i = 0; i < etKeys.length; i++) row[dayLabels[i]] = dayDelta[etKeys[i]];
      pgRows.push(row);
    }
  }

  // ==============================
  // 7) Build Markdown email output (Sections 1‚Äì4)
  // ==============================
  const clustersSorted = Object.keys(clusterSummary).sort();

  // Section 1
  const s1Rows = [];
  let totalActivePGs = 0;
  let totalNetDrift7d = 0;
  let totalVMs = 0;

  for (let i = 0; i < clustersSorted.length; i++) {
    const cn = clustersSorted[i];
    const s = clusterSummary[cn];

    totalActivePGs += s.ActivePGs;
    totalNetDrift7d += s.NetDrift7d;
    totalVMs += s.TotalVMsToday;

    const driftStr = (s.NetDrift7d > 0) ? `üü¢ +${s.NetDrift7d}` : (s.NetDrift7d < 0) ? `üî¥ ${s.NetDrift7d}` : "0";
    s1Rows.push({
      Cluster: cn,
      Active_PGs: String(s.ActivePGs),
      TotalVMs: String(s.TotalVMsToday),
      "Net Drift (7d)": driftStr
    });
  }

  const grandDriftStr = (totalNetDrift7d > 0) ? `üü¢ +${totalNetDrift7d}` : (totalNetDrift7d < 0) ? `üî¥ ${totalNetDrift7d}` : "0";
  s1Rows.push({
    Cluster: "‚≠ê TOTAL",
    Active_PGs: String(totalActivePGs),
    TotalVMs: String(totalVMs), // should equal grandTotalVMsToday
    "Net Drift (7d)": grandDriftStr
  });

  // Section 2
  const s2Headers = ["Cluster", "ProtectionGroup", "TotalVMsToday"]
    .concat(dayLabels)
    .concat(["LastKnownDelta", "PGState", "LastCompletedJob"]);

  const s2Rows = pgRows
    .sort((a, b) => (a.Cluster.localeCompare(b.Cluster) || a.ProtectionGroup.localeCompare(b.ProtectionGroup)))
    .map(r => {
      const out = {
        Cluster: r.Cluster,
        ProtectionGroup: r.ProtectionGroup,
        TotalVMsToday: r.TotalVMsToday
      };
      for (let i = 0; i < dayLabels.length; i++) out[dayLabels[i]] = r[dayLabels[i]];
      out.LastKnownDelta = r.LastKnownDelta;
      out.PGState = r.PGState;
      out.LastCompletedJob = r.LastCompletedJob;
      return out;
    });

  // single GRAND TOTAL row (your requirement)
  const grandRow = { Cluster: "‚≠ê GRAND TOTAL", ProtectionGroup: "‚Äî", TotalVMsToday: String(grandTotalVMsToday) };
  for (let i = 0; i < dayLabels.length; i++) grandRow[dayLabels[i]] = "";
  grandRow.LastKnownDelta = "";
  grandRow.PGState = "";
  grandRow.LastCompletedJob = "";
  s2Rows.push(grandRow);

  // Section 3
  const netChange = vmsAdded - vmsRemoved;
  const netStr = (netChange > 0) ? `üü¢ +${netChange}` : (netChange < 0) ? `üî¥ ${netChange}` : "0";

  const s3Rows = [
    { Area: "Protection Groups", Metric: "Newly detected", Value: String(newlyDetectedPGs) },
    { Area: "Protection Groups", Metric: "Removed", Value: String(removedPGs) },
    { Area: "Virtual Machines", Metric: "Added", Value: `+${vmsAdded}` },
    { Area: "Virtual Machines", Metric: "Removed", Value: `-${vmsRemoved}` },
    { Area: "Virtual Machines", Metric: "Net Drift", Value: netStr },
    { Area: "Evidence Scope", Metric: "Data source", Value: "Completed backup jobs only (runs.objects)" },
    { Area: "Evidence Scope", Metric: "Failed / partial runs", Value: "Excluded" }
  ];

  // Section 4 (issues) - cap for email size
  const s4Headers = ["Cluster", "ProtectionGroup", "VMName", "IssueType", "Notes"];
  const s4Rows = issuesRows
    .slice(0, 200)
    .map(r => ({
      Cluster: r.Cluster,
      ProtectionGroup: r.ProtectionGroup,
      VMName: r.VMName,
      IssueType: r.IssueType,
      Notes: r.Notes
    }));

  const markdownEmail = [
    "### Cohesity AHV Inventory Drift (Object-level)",
    "",
    `**Inventory As Of (ET):** ${asOfEt}`,
    "**Trend Window:** Last 7 days",
    "**Runs Used:** Completed only",
    "**Retention Validation:** Policy-based (7 / 14 / 35 days, capped)",
    "",
    "## 1) Active Scope Today (Monitored)",
    mdTable(["Cluster", "Active_PGs", "TotalVMs", "Net Drift (7d)"], s1Rows),
    "",
    "## 2) PG Trend (7-Day) + PG State (Combined)",
    "_Legend: üü¢ added | üî¥ removed | NEW first detected | 0 no change | ‚Äì not present_",
    mdTable(s2Headers, s2Rows),
    "",
    "## 3) 7-Day Inventory Summary (Evidence-ready)",
    mdTable(["Area", "Metric", "Value"], s3Rows),
    "",
    "## 4) Virtual Machines With Issues (Observed in Completed Runs)",
    (s4Rows.length ? mdTable(s4Headers, s4Rows) : "No VM issues detected in completed runs within the 7-day window."),
    "",
    "_Audit note: GRAND TOTAL VM count equals the Active Scope totals. Failed/partial runs are excluded._"
  ].join("\n");

  return {
    authMode,
    totalClusters: clusters.length,
    inventoryAsOfET: asOfEt,
    trendWindowDays: 7,
    dayLabels,
    grandTotalVMsToday,
    markdownEmail,
    markdownTable: markdownEmail,
    rows: {
      section1: s1Rows,
      section2: s2Rows,
      section3: s3Rows,
      section4: s4Rows
    },
    errors
  };
}
