import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {

  var baseUrl = "https://helios.cohesity.com";

  // ------------------------------
  // 1) Credential vault: name -> id -> manual
  // ------------------------------
  var vaultName = "Cohesity_API_Key";
  var vaultId   = "credentials_vault-312312";

  var apiKey = null;
  var authMode = "vault-name";

  async function getKeyByName(name) {
    var all = await credentialVaultClient.getCredentials();
    var found = null;
    for (var i = 0; i < all.credentials.length; i++) {
      if (all.credentials[i].name === name) { found = all.credentials[i]; break; }
    }
    if (!found) return null;
    var detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (e) {
    try {
      var d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (e2) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  var commonHeaders = { accept: "application/json", apiKey: apiKey };

  // ------------------------------
  // 2) Helpers (from your reference)
  // ------------------------------
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }

  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  async function getJson(url, headers) {
    var resp = await fetch(url, { method: "GET", headers: headers });
    if (!resp.ok) {
      var txt = "";
      try { txt = await resp.text(); } catch (e) {}
      throw new Error("GET " + url + " -> HTTP " + resp.status + " " + txt);
    }
    return resp.json();
  }

  function getPGState(pg) {
    if (pg.isDeleted) return "Deleted";
    if (pg.isPaused)  return "Paused";
    if (pg.isActive)  return "Active";
    return "Inactive";
  }

  // ------------------------------
  // 3) Get clusters (same as reference)
  // ------------------------------
  var cluUrl = baseUrl + "/v2/mcm/cluster-mgmt/info";
  var cluData = await getJson(cluUrl, commonHeaders);
  var clusters = toArrayMaybe(cluData && cluData.cohesityClusters);

  if (!clusters.length) {
    return {
      authMode: authMode,
      totalClusters: 0,
      totalPGs: 0,
      rows: [],
      markdownTable: "⚠️ No clusters returned from Helios",
      markdownEmail: "⚠️ No clusters returned from Helios"
    };
  }

  // ------------------------------
  // 4) Get Acropolis PGs per cluster
  //     (NO BODY, GET only)
  // ------------------------------
  var rows = [];

  for (var i = 0; i < clusters.length; i++) {
    var clus = clusters[i] || {};
    var clusterName = norm(clus.clusterName);
    var clusterId   = norm(clus.clusterId);
    if (!clusterId) continue;

    var headers = {
      accept: "application/json",
      apiKey: apiKey,
      accessClusterId: clusterId
    };

    var pgUrl = baseUrl + "/v2/data-protect/protection-groups?environments=kAcropolis";

    var pgData;
    try {
      pgData = await getJson(pgUrl, headers);
    } catch (e) {
      continue;
    }

    var pgs = toArrayMaybe(pgData && pgData.protectionGroups);

    for (var j = 0; j < pgs.length; j++) {
      var pg = pgs[j] || {};
      rows.push({
        ClusterName: clusterName,
        ClusterId: clusterId,
        ProtectionGroup: norm(pg.name),
        State: getPGState(pg),
        isActive: !!pg.isActive,
        isPaused: !!pg.isPaused,
        isDeleted: !!pg.isDeleted,
        isFailoverReady: !!pg.isFailoverReady,
        PolicyId: norm(pg.policyId)
      });
    }
  }

  // ------------------------------
  // 5) Stats
  // ------------------------------
  var states = { Active:0, Paused:0, Deleted:0, Inactive:0 };
  var failoverReady = 0;

  for (var k = 0; k < rows.length; k++) {
    states[ rows[k].State ]++;
    if (rows[k].isFailoverReady) failoverReady++;
  }

  // ------------------------------
  // 6) Markdown (reference style)
  // ------------------------------
  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  function toMarkdown(rows) {
    if (!rows || rows.length === 0) return "No Acropolis Protection Groups found.";

    var cols = ["ClusterName","ProtectionGroup","State","isFailoverReady","PolicyId"];
    var header = "| " + cols.join(" | ") + " |";
    var sep = "| " + cols.map(function(){return "---";}).join(" | ") + " |";

    var body = rows.map(function(r){
      return "| " + cols.map(function(c){ return safeCell(r[c]); }).join(" | ") + " |";
    });

    return [
      "### Cohesity AHV (Acropolis) Protection Groups — All States",
      "",
      "Clusters: " + clusters.length,
      "Total PGs: " + rows.length,
      "Active: " + states.Active + " | Paused: " + states.Paused + " | Deleted: " + states.Deleted + " | Inactive: " + states.Inactive,
      "Failover Ready: " + failoverReady,
      "",
      header, sep
    ].concat(body).join("\n");
  }

  var markdown = toMarkdown(rows);

  return {
    authMode: authMode,
    totalClusters: clusters.length,
    totalPGs: rows.length,
    states: states,
    failoverReadyCount: failoverReady,
    rows: rows,
    markdownTable: markdown,
    markdownEmail: markdown
  };
}
