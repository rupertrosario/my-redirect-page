import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // =========================
  // CONFIG
  // =========================
  const TREND_DAYS = 7;               // display last 7 ET days
  const ACTIVE_SCOPE_HOURS = 48;      // Active Scope snapshot window
  const RUNS_LOOKBACK = 120;          // enough to reliably cover 7 days across all PGs
  const ISSUES_CAP = 300;             // email size safety
  const ENV = "kAcropolis";
  const OBJTYPE = "kVirtualMachine";

  // =========================
  // 1) Auth (vault name -> id -> manual)
  // =========================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = (all && all.credentials) ? all.credentials : [];
    let found = null;
    for (let i = 0; i < creds.length; i++) {
      if (creds[i] && creds[i].name === name) { found = creds[i]; break; }
    }
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (_) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (_) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  // =========================
  // 2) Helpers
  // =========================
  const errors = [];

  function norm(v) { return (v === null || v === undefined) ? "" : String(v).trim(); }
  function arr(v) { return !v ? [] : (Array.isArray(v) ? v : [v]); }
  function safeCell(v) { return (v === null || v === undefined) ? "" : String(v).replace(/\|/g, " "); }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const e = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      e.httpStatus = resp.status;
      e.bodyText = txt;
      e.url = url;
      throw e;
    }
    return resp.json();
  }

  async function getJsonSafe(url, headers, scopeMeta) {
    try {
      const data = await getJson(url, headers);
      return { ok: true, data, status: 200, url };
    } catch (e) {
      errors.push({
        scope: scopeMeta && scopeMeta.scope ? scopeMeta.scope : "api",
        clusterName: scopeMeta && scopeMeta.clusterName,
        clusterId: scopeMeta && scopeMeta.clusterId,
        protectionGroup: scopeMeta && scopeMeta.protectionGroup,
        protectionGroupId: scopeMeta && scopeMeta.protectionGroupId,
        runId: scopeMeta && scopeMeta.runId,
        httpStatus: e && e.httpStatus ? e.httpStatus : 0,
        url: e && e.url ? e.url : url,
        body: e && e.bodyText ? e.bodyText : String(e || "")
      });
      return { ok: false, data: null, status: e && e.httpStatus ? e.httpStatus : 0, url };
    }
  }

  function nowEtString() {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    }).formatToParts(new Date());
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day} ${m.hour}:${m.minute}`;
  }

  function dateKeyET(d) {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).formatToParts(d);
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day}`;
  }

  function dayLabelFromETKey(etKey) {
    const day = Number(etKey.slice(8, 10));
    const suffix =
      day % 100 >= 11 && day % 100 <= 13 ? "th" :
      day % 10 === 1 ? "st" :
      day % 10 === 2 ? "nd" :
      day % 10 === 3 ? "rd" : "th";
    return `${day}${suffix}`;
  }

  function usecsFromDate(d) { return String(Math.floor(d.getTime() * 1000)); } // ms->usecs

  // Run fields (match your PS logic)
  function runEndUsecs(run) {
    const lbi = arr(run && run.localBackupInfo);
    const x = lbi.length ? lbi[0] : null;
    return norm(x && x.endTimeUsecs) ? String(x.endTimeUsecs) : "";
  }

  function runStatus(run) {
    const lbi = arr(run && run.localBackupInfo);
    const x = lbi.length ? lbi[0] : null;
    return norm(x && x.status);
  }

  function isCompleted(run) {
    // Your PS script effectively treats non-Running + has endTimeUsecs as ‚Äúcompleted enough‚Äù
    const st = runStatus(run);
    if (!st) return false;
    if (st.toLowerCase() === "running") return false;
    return !!runEndUsecs(run);
  }

  function runId(run) { return norm(run && (run.runId || run.id || run.instanceId)); }

  function isAhvVm(obj) {
    const o = obj && obj.object;
    return o && norm(o.environment) === ENV && norm(o.objectType) === OBJTYPE && !!norm(o.name);
  }

  function vmName(obj) { return norm(obj && obj.object && obj.object.name); }

  function failedAttempts(obj) {
    try { return arr(obj && obj.localSnapshotInfo && obj.localSnapshotInfo.failedAttempts); }
    catch (_) { return []; }
  }

  function vmFailed(obj) {
    const fa = failedAttempts(obj);
    return fa.length > 0;
  }

  function vmFailMessages(obj) {
    const fa = failedAttempts(obj);
    const msgs = [];
    for (let i = 0; i < fa.length; i++) {
      const m = norm(fa[i] && fa[i].message);
      if (m) msgs.push(m.replace(/[\r\n]+/g, " ").trim());
    }
    return msgs;
  }

  function vmSetFromObjects(objs) {
    const s = new Set();
    for (let i = 0; i < objs.length; i++) {
      if (!isAhvVm(objs[i])) continue;
      const n = vmName(objs[i]);
      if (n) s.add(n);
    }
    return s;
  }

  function diff(prev, cur) {
    let adds = 0, rems = 0;
    for (const x of cur) if (!prev.has(x)) adds++;
    for (const x of prev) if (!cur.has(x)) rems++;
    return { adds, rems };
  }

  function mdTable(headers, rows) {
    const head = "| " + headers.join(" | ") + " |";
    const sep = "| " + headers.map(() => "---").join(" | ") + " |";
    const body = rows.map(r => "| " + headers.map(h => safeCell(r[h])).join(" | ") + " |");
    return [head, sep].concat(body).join("\n");
  }

  // =========================
  // 3) Build ET keys
  // =========================
  const asOfEt = nowEtString();
  const now = new Date();

  const etKeys = [];
  for (let i = TREND_DAYS - 1; i >= 0; i--) {
    const d = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
    etKeys.push(dateKeyET(d));
  }
  const dayLabels = etKeys.map(dayLabelFromETKey);

  const activeScopeStart = new Date(now.getTime() - ACTIVE_SCOPE_HOURS * 60 * 60 * 1000);
  const activeScopeStartUsecs = Number(usecsFromDate(activeScopeStart));

  // =========================
  // 4) Clusters
  // =========================
  const cluUrl = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const cluResp = await getJsonSafe(cluUrl, { accept: "application/json", apiKey }, { scope: "clusters" });
  const clusters = arr(cluResp.ok && cluResp.data && cluResp.data.cohesityClusters);

  if (!clusters.length) {
    return {
      authMode,
      totalClusters: 0,
      markdownEmail: "‚ö†Ô∏è No clusters returned from Helios (or API failed).",
      errors
    };
  }

  // =========================
  // 5) API functions (PG list, runs, run objects fallback)
  // =========================
  async function fetchPGs(clusterHeaders, clusterMeta) {
    // IMPORTANT: JS fetch GET-body is unreliable; use query params.
    const url =
      `${baseUrl}/v2/data-protect/protection-groups` +
      `?environments=${encodeURIComponent(ENV)}` +
      `&isDeleted=false&isPaused=false&isActive=true`;
    const r = await getJsonSafe(url, clusterHeaders, { ...clusterMeta, scope: "protection-groups" });
    if (!r.ok) return [];
    return arr(r.data && r.data.protectionGroups);
  }

  async function fetchRuns(clusterHeaders, pgId, meta) {
    // Prefer query params like your PS script (numRuns + includeObjectDetails)
    const url =
      `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs` +
      `?numRuns=${encodeURIComponent(String(RUNS_LOOKBACK))}` +
      `&includeObjectDetails=true` +
      `&excludeNonRestorableRuns=false`;
    const r = await getJsonSafe(url, clusterHeaders, { ...meta, scope: "pg-runs", protectionGroupId: pgId });
    if (!r.ok) return [];
    return arr(r.data && r.data.runs);
  }

  async function fetchObjectsFallback(clusterHeaders, pgId, rId, meta) {
    const url =
      `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}` +
      `/runs/${encodeURIComponent(rId)}/objects?includeDetails=true`;
    const r = await getJsonSafe(url, clusterHeaders, { ...meta, scope: "run-objects", protectionGroupId: pgId, runId: rId });
    if (!r.ok) return [];
    const d = r.data || {};
    return arr(d.objects || d.runObjects || d.objectRuns || d.protectedObjects);
  }

  // =========================
  // 6) Compute: 7-day drift + Active Scope + Issues
  // =========================
  const clusterAgg = {};      // cluster -> { activePGs, vmsToday, adds7d, rems7d, net7d }
  const pgRows = [];          // section 2
  const issues = [];          // section 4

  let totalActivePGs = 0;
  let totalVMsToday = 0;
  let totalAdds7d = 0;
  let totalRems7d = 0;

  // Track global as-of (max end time used as ‚Äútoday inventory‚Äù)
  let globalAsOfUsecs = 0;

  for (let c = 0; c < clusters.length; c++) {
    const cl = clusters[c] || {};
    const clusterName = norm(cl.name) || norm(cl.clusterName) || norm(cl.displayName) || `Cluster-${c + 1}`;
    const clusterId = norm(cl.clusterId);
    if (!clusterId) continue;

    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };
    const meta = { clusterName, clusterId };

    const pgs = await fetchPGs(headers, meta);
    if (!pgs.length) continue;

    if (!clusterAgg[clusterName]) {
      clusterAgg[clusterName] = { activePGs: 0, vmsToday: 0, adds7d: 0, rems7d: 0, net7d: 0 };
    }

    for (let p = 0; p < pgs.length; p++) {
      const pg = pgs[p] || {};
      const pgName = norm(pg.name);
      const pgId = norm(pg.id) || norm(pg.protectionGroupId) || norm(pg.groupId);
      if (!pgName || !pgId) continue;

      const runsRaw = await fetchRuns(headers, pgId, { ...meta, protectionGroup: pgName });
      if (!runsRaw.length) continue;

      // Normalize + keep only completed runs with endTimeUsecs
      const runs = runsRaw
        .map(r => ({ raw: r, id: runId(r), endUsecs: Number(runEndUsecs(r)), completed: isCompleted(r) }))
        .filter(x => x.id && x.completed && x.endUsecs > 0)
        .sort((a, b) => b.endUsecs - a.endUsecs);

      if (!runs.length) continue;

      // Active Scope run: latest completed within last 48h
      let activeRun = null;
      for (let i = 0; i < runs.length; i++) {
        if (runs[i].endUsecs >= activeScopeStartUsecs) { activeRun = runs[i]; break; }
      }
      if (!activeRun) {
        // No Active Scope snapshot -> still allow trend (but management ‚Äútoday‚Äù totals should not count)
        activeRun = null;
      }

      // Build per-day snapshot: dayKey -> selected run (latest completed that ends in that ET day)
      const dayToRun = {};
      for (let i = 0; i < runs.length; i++) {
        const endMs = Math.floor(runs[i].endUsecs / 1000);
        if (!Number.isFinite(endMs)) continue;
        const k = dateKeyET(new Date(endMs));
        if (!dayToRun[k] || runs[i].endUsecs > dayToRun[k].endUsecs) dayToRun[k] = runs[i];
      }

      // For each day, get VM set (prefer inline objects; fallback call if missing)
      const daySets = {}; // dayKey -> Set|null
      for (let i = 0; i < etKeys.length; i++) daySets[etKeys[i]] = null;

      for (let i = 0; i < etKeys.length; i++) {
        const k = etKeys[i];
        const sel = dayToRun[k];
        if (!sel) continue;

        let objs = arr(sel.raw && sel.raw.objects);
        if (!objs.length) {
          // CRITICAL: fixes ‚Äúall 0 / No Run‚Äù on clusters that don‚Äôt inline objects
          objs = await fetchObjectsFallback(headers, pgId, sel.id, { ...meta, protectionGroup: pgName });
        }
        if (!objs.length) continue;

        daySets[k] = vmSetFromObjects(objs);
      }

      // Today inventory count should come from ACTIVE SCOPE run (management view of ‚Äútoday‚Äù)
      let vmsToday = "No Run";
      let todaySet = null;

      if (activeRun) {
        let objs = arr(activeRun.raw && activeRun.raw.objects);
        if (!objs.length) objs = await fetchObjectsFallback(headers, pgId, activeRun.id, { ...meta, protectionGroup: pgName });
        if (objs.length) {
          todaySet = vmSetFromObjects(objs);
          vmsToday = String(todaySet.size);
          if (activeRun.endUsecs > globalAsOfUsecs) globalAsOfUsecs = activeRun.endUsecs;

          // Issues from Active Scope snapshot: failedAttempts message(s)
          for (let o = 0; o < objs.length; o++) {
            if (!isAhvVm(objs[o])) continue;
            if (!vmFailed(objs[o])) continue;
            const n = vmName(objs[o]);
            const msgs = vmFailMessages(objs[o]);
            const msg = msgs.length ? msgs[0] : "Failed (no failedAttempts.message)";
            issues.push({
              Cluster: clusterName,
              ProtectionGroup: pgName,
              VMName: n,
              Issue: msg
            });
          }
        }
      }

      // Trend cells: compare to previous available snapshot (within the 7-day window)
      const cells = {};
      for (let i = 0; i < etKeys.length; i++) cells[dayLabels[i]] = "No Run";

      let adds7d = 0;
      let rems7d = 0;

      let prev = null;
      for (let i = 0; i < etKeys.length; i++) {
        const k = etKeys[i];
        const cur = daySets[k];
        const label = dayLabels[i];

        if (!cur) {
          cells[label] = "No Run";
          continue;
        }
        if (!prev) {
          // First snapshot in window: no delta baseline => 0 (not NEW)
          cells[label] = "0";
          prev = cur;
          continue;
        }
        const d = diff(prev, cur);
        adds7d += d.adds;
        rems7d += d.rems;

        if (d.adds === 0 && d.rems === 0) cells[label] = "0";
        else if (d.adds > 0 && d.rems === 0) cells[label] = `üü¢ +${d.adds}`;
        else if (d.rems > 0 && d.adds === 0) cells[label] = `üî¥ -${d.rems}`;
        else cells[label] = `üü¢ +${d.adds} / üî¥ -${d.rems}`;

        prev = cur;
      }

      const net7d = adds7d - rems7d;

      // Add PG row (only if it has Active Scope ‚Äútoday‚Äù snapshot OR at least one trend snapshot)
      const hasAnyTrend = etKeys.some(k => daySets[k]);
      if (activeRun || hasAnyTrend) {
        const row = {
          Cluster: clusterName,
          ProtectionGroup: pgName,
          VMsToday: vmsToday,
          Added7d: `+${adds7d}`,
          Removed7d: `-${rems7d}`,
          Net7d: net7d > 0 ? `üü¢ +${net7d}` : (net7d < 0 ? `üî¥ ${net7d}` : "0")
        };
        for (let i = 0; i < dayLabels.length; i++) row[dayLabels[i]] = cells[dayLabels[i]];
        pgRows.push(row);
      }

      // Cluster totals (only if Active Scope snapshot exists)
      if (todaySet) {
        clusterAgg[clusterName].activePGs += 1;
        clusterAgg[clusterName].vmsToday += todaySet.size;
        clusterAgg[clusterName].adds7d += adds7d;
        clusterAgg[clusterName].rems7d += rems7d;
        clusterAgg[clusterName].net7d += (adds7d - rems7d);

        totalActivePGs += 1;
        totalVMsToday += todaySet.size;
        totalAdds7d += adds7d;
        totalRems7d += rems7d;
      }
    }
  }

  // =========================
  // 7) Markdown output
  // =========================
  const globalAsOfEt = globalAsOfUsecs
    ? (() => {
        const ms = Math.floor(globalAsOfUsecs / 1000);
        const parts = new Intl.DateTimeFormat("en-US", {
          timeZone: "America/New_York",
          year: "numeric", month: "2-digit", day: "2-digit",
          hour: "2-digit", minute: "2-digit", second: "2-digit",
          hour12: false
        }).formatToParts(new Date(ms));
        const m = {}; for (const p of parts) m[p.type] = p.value;
        return `${m.year}-${m.month}-${m.day} ${m.hour}:${m.minute}:${m.second}`;
      })()
    : asOfEt;

  const s1Rows = Object.keys(clusterAgg).sort().map(cn => {
    const s = clusterAgg[cn];
    return {
      Cluster: cn,
      Active_PGs: String(s.activePGs),
      TotalVMs: String(s.vmsToday),
      Added7d: `+${s.adds7d}`,
      Removed7d: `-${s.rems7d}`,
      Net7d: s.net7d > 0 ? `üü¢ +${s.net7d}` : (s.net7d < 0 ? `üî¥ ${s.net7d}` : "0")
    };
  });

  const totalNet = totalAdds7d - totalRems7d;
  s1Rows.push({
    Cluster: "‚≠ê TOTAL",
    Active_PGs: String(totalActivePGs),
    TotalVMs: String(totalVMsToday),
    Added7d: `+${totalAdds7d}`,
    Removed7d: `-${totalRems7d}`,
    Net7d: totalNet > 0 ? `üü¢ +${totalNet}` : (totalNet < 0 ? `üî¥ ${totalNet}` : "0")
  });

  const s2Headers =
    ["Cluster", "ProtectionGroup", "VMsToday"]
      .concat(dayLabels)
      .concat(["Added7d", "Removed7d", "Net7d"]);

  const s2Rows = pgRows
    .sort((a, b) => a.Cluster.localeCompare(b.Cluster) || a.ProtectionGroup.localeCompare(b.ProtectionGroup))
    .map(r => {
      const out = { Cluster: r.Cluster, ProtectionGroup: r.ProtectionGroup, VMsToday: r.VMsToday };
      for (let i = 0; i < dayLabels.length; i++) out[dayLabels[i]] = r[dayLabels[i]];
      out.Added7d = r.Added7d;
      out.Removed7d = r.Removed7d;
      out.Net7d = r.Net7d;
      return out;
    });

  const s3Rows = [
    { Area: "Evidence Scope", Metric: "Runs used", Value: "Completed runs only (non-Running with endTimeUsecs)" },
    { Area: "Trend Cells", Metric: "0", Value: "Snapshot exists and no inventory change vs previous snapshot" },
    { Area: "Trend Cells", Metric: "No Run", Value: "No completed snapshot found for that ET day" },
    { Area: "Active Scope", Metric: "Definition", Value: `Latest completed snapshot per PG within last ${ACTIVE_SCOPE_HOURS}h` }
  ];

  const s4Headers = ["Cluster", "ProtectionGroup", "VMName", "Issue"];
  const s4Rows = issues.slice(0, ISSUES_CAP);

  const markdownEmail = [
    "### Cohesity AHV Inventory Drift (Retention-aware, Management view)",
    "",
    `**Inventory As Of (ET):** ${globalAsOfEt}`,
    `**Drift Window Displayed:** Last ${TREND_DAYS} ET days`,
    `**Active Scope:** Latest completed snapshot per PG within last ${ACTIVE_SCOPE_HOURS} hours`,
    "",
    "## 1) Active Scope Today (Monitored)",
    mdTable(["Cluster", "Active_PGs", "TotalVMs", "Added7d", "Removed7d", "Net7d"], s1Rows),
    "",
    "## 2) Protection Group Drift (7-Day) + Current State",
    "_Legend: üü¢ added | üî¥ removed | 0 no change | No Run = no completed snapshot that ET day_",
    (s2Rows.length ? mdTable(s2Headers, s2Rows) : "No PG snapshots available in scope."),
    "",
    "## 3) Notes (Evidence semantics)",
    mdTable(["Area", "Metric", "Value"], s3Rows),
    "",
    "## 4) Virtual Machines With Failures (from completed snapshots)",
    (s4Rows.length ? mdTable(s4Headers, s4Rows) : "No VM failures detected in Active Scope snapshots."),
    ""
  ].join("\n");

  return {
    authMode,
    totalClusters: clusters.length,
    inventoryAsOfET: globalAsOfEt,
    trendWindowDays: TREND_DAYS,
    activeScopeHours: ACTIVE_SCOPE_HOURS,
    dayLabels,
    markdownEmail,
    rows: {
      section1: s1Rows,
      section2: s2Rows,
      section3: s3Rows,
      section4: s4Rows
    },
    errors
  };
}
