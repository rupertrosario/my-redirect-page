import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // CONFIG
  // ==============================
  const ENV = "kHyperV";              // change to kAcropolis for AHV
  const TREND_DAYS = 7;               // show last 7 ET days (today inclusive)
  const ACTIVE_SCOPE_HOURS = 48;      // "Today" snapshot = latest COMPLETED run within last 48h
  const RUNS_LOOKBACK = 250;          // per-PG runs to pull (avoid time-window edge cases)
  const EMAIL_ISSUES_CAP = 300;

  // ==============================
  // 1) Auth (vault name -> id -> manual)
  // ==============================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = (all && all.credentials) ? all.credentials : [];
    let found = null;
    for (let i = 0; i < creds.length; i++) {
      if (creds[i] && creds[i].name === name) { found = creds[i]; break; }
    }
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (_) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (_) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");

  // ==============================
  // 2) Helpers
  // ==============================
  const errors = [];

  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }

  function arr(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ").replace(/\r?\n/g, " ").trim();
  }

  function nowEtString() {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    }).formatToParts(new Date());
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day} ${m.hour}:${m.minute}`;
  }

  function dateKeyET(d) {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).formatToParts(d);
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day}`; // YYYY-MM-DD
  }

  function dayLabelFromETKey(etKey) {
    const day = Number(etKey.slice(8, 10));
    const suffix =
      day % 100 >= 11 && day % 100 <= 13 ? "th" :
      day % 10 === 1 ? "st" :
      day % 10 === 2 ? "nd" :
      day % 10 === 3 ? "rd" : "th";
    return `${day}${suffix}`;
  }

  function usecsFromDate(d) {
    return String(Math.floor(d.getTime() * 1000)); // ms -> usecs
  }

  async function getJson(url, headers, meta) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      errors.push({
        scope: meta?.scope || "api",
        clusterName: meta?.clusterName,
        clusterId: meta?.clusterId,
        protectionGroup: meta?.protectionGroup,
        protectionGroupId: meta?.protectionGroupId,
        runId: meta?.runId,
        httpStatus: resp.status,
        url,
        body: txt
      });
      return null;
    }
    return resp.json();
  }

  // ------------------------------
  // Cohesity run parsing (v2 shape used in your PS)
  // ------------------------------
  function lbi0(run) {
    const lb = arr(run && run.localBackupInfo);
    return lb.length ? lb[0] : null;
  }

  function runStatus(run) {
    const i = lbi0(run);
    return norm(i && i.status) || norm(run && run.status) || norm(run && run.runStatus);
  }

  function runType(run) {
    const i = lbi0(run);
    return norm(i && i.runType) || norm(run && run.runType);
  }

  function runEndUsecs(run) {
    const i = lbi0(run);
    return norm(i && i.endTimeUsecs) || norm(run && run.endTimeUsecs) || "";
  }

  function runStartUsecs(run) {
    const i = lbi0(run);
    return norm(i && i.startTimeUsecs) || norm(run && run.startTimeUsecs) || "";
  }

  function isCompletedRun(run) {
    const s = runStatus(run).toLowerCase();
    const end = Number(runEndUsecs(run) || 0);
    if (!end || !Number.isFinite(end)) return false;
    // treat "Running" as not completed; everything else is a completed snapshot we can evidence
    if (s === "running") return false;
    return true;
  }

  function isVmObject(obj) {
    const o = obj && obj.object;
    return (
      norm(o && o.environment) === ENV &&
      norm(o && o.objectType) === "kVirtualMachine" &&
      !!norm(o && o.name)
    );
  }

  function vmName(obj) {
    return norm(obj && obj.object && obj.object.name);
  }

  function failedAttempts(obj) {
    const fa = obj && obj.localSnapshotInfo && obj.localSnapshotInfo.failedAttempts;
    return arr(fa);
  }

  function failureMessages(obj) {
    const fa = failedAttempts(obj);
    if (!fa.length) return [];
    const out = [];
    for (let i = 0; i < fa.length; i++) {
      const m = norm(fa[i] && fa[i].message);
      if (m) out.push(m);
    }
    return out;
  }

  // ==============================
  // 3) Build ET day keys (last 7 days incl today)
  // ==============================
  const asOfEt = nowEtString();
  const now = new Date();

  const etKeys = [];
  for (let i = TREND_DAYS - 1; i >= 0; i--) {
    const d = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
    etKeys.push(dateKeyET(d));
  }
  const dayLabels = etKeys.map(dayLabelFromETKey);

  const trendStart = new Date(now.getTime() - TREND_DAYS * 24 * 60 * 60 * 1000);
  const trendStartUsecs = Number(usecsFromDate(trendStart));
  const trendEndUsecs = Number(usecsFromDate(now));

  const activeScopeStart = new Date(now.getTime() - ACTIVE_SCOPE_HOURS * 60 * 60 * 1000);
  const activeScopeStartUsecs = Number(usecsFromDate(activeScopeStart));

  // ==============================
  // 4) Clusters
  // ==============================
  const commonHeaders = { accept: "application/json", apiKey };

  const cluUrl = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const cluData = await getJson(cluUrl, commonHeaders, { scope: "clusters" });
  const clusters = arr(cluData && cluData.cohesityClusters);

  if (!clusters.length) {
    return {
      authMode,
      totalClusters: 0,
      markdownEmail: "‚ö†Ô∏è No clusters returned from Helios.",
      errors
    };
  }

  // ==============================
  // 5) GET-only API helpers (NO POST)
  // ==============================
  async function fetchPGs(clusterHeaders, clusterMeta) {
    // IMPORTANT: JS must use query params. PowerShell used GET with body which is not reliable in JS.
    const url =
      `${baseUrl}/v2/data-protect/protection-groups` +
      `?environments=${encodeURIComponent(ENV)}` +
      `&isDeleted=false&isPaused=false&isActive=true`;

    const d = await getJson(url, clusterHeaders, { ...clusterMeta, scope: "protection-groups" });
    return arr(d && d.protectionGroups);
  }

  async function fetchRuns(clusterHeaders, pgId, meta) {
    // Pull enough history then filter by endTimeUsecs + ET day key (avoids missing ‚Äúfirst day‚Äù)
    const url =
      `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}/runs` +
      `?numRuns=${encodeURIComponent(String(RUNS_LOOKBACK))}` +
      `&excludeNonRestorableRuns=false&includeObjectDetails=true`;

    const d = await getJson(url, clusterHeaders, { ...meta, scope: "pg-runs", protectionGroupId: pgId });
    return arr(d && d.runs);
  }

  async function fetchObjectsForRun(clusterHeaders, pgId, runId, meta) {
    // GET-only fallback when runs[] does not embed objects
    const url =
      `${baseUrl}/v2/data-protect/protection-groups/${encodeURIComponent(pgId)}` +
      `/runs/${encodeURIComponent(runId)}/objects?includeDetails=true`;

    const d = await getJson(url, clusterHeaders, { ...meta, scope: "run-objects", protectionGroupId: pgId, runId });
    const objs =
      arr(d && d.objects).length ? arr(d.objects) :
      arr(d && d.runObjects).length ? arr(d.runObjects) :
      arr(d && d.objectRuns).length ? arr(d.objectRuns) :
      arr(d && d.protectedObjects).length ? arr(d.protectedObjects) :
      [];
    return objs;
  }

  function extractObjectsInline(run) {
    const o =
      arr(run && run.objects).length ? arr(run.objects) :
      arr(run && run.runObjects).length ? arr(run.runObjects) :
      arr(run && run.objectRuns).length ? arr(run.objectRuns) :
      [];
    return o.length ? o : null;
  }

  // ==============================
  // 6) Compute (management-friendly)
  //    - No PG "NEW"
  //    - Day cells are deltas vs previous available snapshot
  //    - Missing day snapshot => "No run"
  //    - 0 => no add/remove between snapshots
  //    - Today counts are from Active Scope snapshot (48h) per PG
  // ==============================
  const clusterAgg = {};      // cluster -> { activePGs,totalVMs,added,removed,net }
  const pgRows = [];          // section 2
  const issuesRows = [];      // section 4 (failed VMs w/ message)

  const clustersSorted = clusters
    .map((c) => ({
      clusterId: norm(c.clusterId),
      clusterName: norm(c.name) || norm(c.clusterName) || norm(c.displayName) || `Unknown-${norm(c.clusterId)}`
    }))
    .filter((c) => c.clusterId)
    .sort((a, b) => a.clusterName.localeCompare(b.clusterName));

  for (let ci = 0; ci < clustersSorted.length; ci++) {
    const { clusterId, clusterName } = clustersSorted[ci];

    const clusterHeaders = { accept: "application/json", apiKey, accessClusterId: clusterId };

    if (!clusterAgg[clusterName]) {
      clusterAgg[clusterName] = { activePGs: 0, totalVMs: 0, added: 0, removed: 0, net: 0 };
    }

    const pgs = await fetchPGs(clusterHeaders, { clusterName, clusterId });
    if (!pgs.length) continue;

    for (let pi = 0; pi < pgs.length; pi++) {
      const pg = pgs[pi] || {};
      const pgName = norm(pg.name);
      const pgId = norm(pg.id) || norm(pg.protectionGroupId) || norm(pg.groupId);
      if (!pgName || !pgId) continue;

      const runsRaw = await fetchRuns(clusterHeaders, pgId, { clusterName, clusterId, protectionGroup: pgName });
      if (!runsRaw.length) continue;

      // Keep completed runs, with usable endTimeUsecs
      const runs = runsRaw
        .filter((r) => isCompletedRun(r))
        .map((r) => ({
          raw: r,
          endUsecs: Number(runEndUsecs(r)),
          startUsecs: Number(runStartUsecs(r)),
          status: runStatus(r),
          runType: runType(r)
        }))
        .filter((x) => Number.isFinite(x.endUsecs) && x.endUsecs > 0)
        .sort((a, b) => b.endUsecs - a.endUsecs);

      if (!runs.length) continue;

      // Build ET-day -> latest completed run
      const dayToRun = {};
      for (let i = 0; i < runs.length; i++) {
        // Filter to drift window by endUsecs (hard fence) but with enough lookback to fill day keys
        if (runs[i].endUsecs < trendStartUsecs || runs[i].endUsecs > trendEndUsecs) continue;
        const key = dateKeyET(new Date(Math.floor(runs[i].endUsecs / 1000)));
        if (!dayToRun[key] || runs[i].endUsecs > dayToRun[key].endUsecs) dayToRun[key] = runs[i];
      }

      // Get per-day VM sets (unique VM names)
      const dayVmSets = {};
      for (let i = 0; i < etKeys.length; i++) dayVmSets[etKeys[i]] = null;

      for (let di = 0; di < etKeys.length; di++) {
        const k = etKeys[di];
        const pick = dayToRun[k];
        if (!pick) continue;

        let objs = extractObjectsInline(pick.raw);
        if (!objs) {
          // fallback GET to objects endpoint
          const runId = norm(pick.raw && (pick.raw.id || pick.raw.runId || pick.raw.protectionGroupRunId || pick.raw.instanceId));
          if (runId) {
            objs = await fetchObjectsForRun(clusterHeaders, pgId, runId, { clusterName, clusterId, protectionGroup: pgName });
          } else {
            objs = [];
          }
        }

        const vmSet = new Set();
        for (let oi = 0; oi < objs.length; oi++) {
          const o = objs[oi];
          if (!isVmObject(o)) continue;
          vmSet.add(vmName(o));
        }
        dayVmSets[k] = vmSet;
      }

      // Active Scope snapshot: latest completed run within last 48h (by endUsecs)
      let activeRun = null;
      for (let i = 0; i < runs.length; i++) {
        if (runs[i].endUsecs >= activeScopeStartUsecs) { activeRun = runs[i]; break; }
      }
      if (!activeRun) continue; // PG not in ‚Äútoday‚Äù scope

      // Load activeRun objects (prefer inline; else fallback)
      let activeObjs = extractObjectsInline(activeRun.raw);
      if (!activeObjs) {
        const runId = norm(activeRun.raw && (activeRun.raw.id || activeRun.raw.runId || activeRun.raw.protectionGroupRunId || activeRun.raw.instanceId));
        if (runId) {
          activeObjs = await fetchObjectsForRun(clusterHeaders, pgId, runId, { clusterName, clusterId, protectionGroup: pgName });
        } else {
          activeObjs = [];
        }
      }

      // Today counts MUST be from ALL VM objects (not just failed ones)
      const todayVmSet = new Set();
      let todayFailed = 0;

      for (let oi = 0; oi < activeObjs.length; oi++) {
        const o = activeObjs[oi];
        if (!isVmObject(o)) continue;

        const name = vmName(o);
        todayVmSet.add(name);

        const fa = failedAttempts(o);
        if (fa.length) {
          todayFailed += 1;

          const msgs = failureMessages(o);
          const msg = msgs.length ? msgs[0] : "Failed (no failedAttempts message)";
          issuesRows.push({
            Cluster: clusterName,
            ProtectionGroup: pgName,
            VMName: name,
            FailedMessage: msg
          });
        }
      }

      const todayTotal = todayVmSet.size;
      const todaySuccess = Math.max(0, todayTotal - todayFailed);

      // Per-day delta cells (vs previous available snapshot)
      const dayCells = {};
      let prevSet = null;

      for (let di = 0; di < etKeys.length; di++) {
        const k = etKeys[di];
        const curSet = dayVmSets[k];

        if (curSet === null) {
          dayCells[k] = "No run";
          continue;
        }

        if (prevSet === null) {
          // First available snapshot in the 7-day display window: show 0 (no baseline inference)
          dayCells[k] = "0";
          prevSet = curSet;
          continue;
        }

        let adds = 0, rems = 0;
        for (const x of curSet) if (!prevSet.has(x)) adds++;
        for (const x of prevSet) if (!curSet.has(x)) rems++;

        if (adds === 0 && rems === 0) dayCells[k] = "0";
        else if (adds > 0 && rems === 0) dayCells[k] = `üü¢ +${adds}`;
        else if (rems > 0 && adds === 0) dayCells[k] = `üî¥ -${rems}`;
        else dayCells[k] = `üü¢ +${adds} / üî¥ -${rems}`;

        prevSet = curSet;
      }

      // PG drift for summary: compare first available snapshot vs last available snapshot (within 7-day window)
      let firstSnap = null;
      let lastSnap = null;

      for (let di = 0; di < etKeys.length; di++) {
        const k = etKeys[di];
        if (dayVmSets[k] !== null) { firstSnap = dayVmSets[k]; break; }
      }
      for (let di = etKeys.length - 1; di >= 0; di--) {
        const k = etKeys[di];
        if (dayVmSets[k] !== null) { lastSnap = dayVmSets[k]; break; }
      }

      let pgAdded = 0, pgRemoved = 0, pgNet = 0;
      if (firstSnap && lastSnap) {
        for (const x of lastSnap) if (!firstSnap.has(x)) pgAdded++;
        for (const x of firstSnap) if (!lastSnap.has(x)) pgRemoved++;
        pgNet = lastSnap.size - firstSnap.size;
      }

      // Update cluster aggregates
      clusterAgg[clusterName].activePGs += 1;
      clusterAgg[clusterName].totalVMs += todayTotal;
      clusterAgg[clusterName].added += pgAdded;
      clusterAgg[clusterName].removed += pgRemoved;
      clusterAgg[clusterName].net += pgNet;

      // Section 2 row
      const row = {
        Cluster: clusterName,
        ProtectionGroup: pgName,
        VMsToday: String(todayTotal),
        SuccessfulToday: String(todaySuccess),
        FailedToday: String(todayFailed)
      };
      for (let di = 0; di < etKeys.length; di++) row[dayLabels[di]] = dayCells[etKeys[di]];
      pgRows.push(row);
    }
  }

  // ==============================
  // 7) Markdown output
  // ==============================
  function mdTable(headers, rows) {
    const head = "| " + headers.join(" | ") + " |";
    const sep = "| " + headers.map(() => "---").join(" | ") + " |";
    const body = rows.map((r) => "| " + headers.map((h) => safeCell(r[h])).join(" | ") + " |");
    return [head, sep].concat(body).join("\n");
  }

  const s1Headers = ["Cluster", "Active_PGs", "TotalVMsToday", "Added(7d)", "Removed(7d)", "Net(7d)"];
  const s1Rows = [];
  let gActive = 0, gTotal = 0, gAdd = 0, gRem = 0, gNet = 0;

  const clusterNames = Object.keys(clusterAgg).sort();
  for (let i = 0; i < clusterNames.length; i++) {
    const cn = clusterNames[i];
    const x = clusterAgg[cn];
    if (!x.activePGs) continue;

    gActive += x.activePGs;
    gTotal += x.totalVMs;
    gAdd += x.added;
    gRem += x.removed;
    gNet += x.net;

    const netStr = x.net > 0 ? `üü¢ +${x.net}` : x.net < 0 ? `üî¥ ${x.net}` : "0";
    s1Rows.push({
      Cluster: cn,
      Active_PGs: String(x.activePGs),
      TotalVMsToday: String(x.totalVMs),
      "Added(7d)": `+${x.added}`,
      "Removed(7d)": `-${x.removed}`,
      "Net(7d)": netStr
    });
  }

  const gNetStr = gNet > 0 ? `üü¢ +${gNet}` : gNet < 0 ? `üî¥ ${gNet}` : "0";
  s1Rows.push({
    Cluster: "‚≠ê TOTAL",
    Active_PGs: String(gActive),
    TotalVMsToday: String(gTotal),
    "Added(7d)": `+${gAdd}`,
    "Removed(7d)": `-${gRem}`,
    "Net(7d)": gNetStr
  });

  const s2Headers = ["Cluster", "ProtectionGroup", "VMsToday", "SuccessfulToday", "FailedToday"]
    .concat(dayLabels);

  const s2Rows = pgRows
    .sort((a, b) => a.Cluster.localeCompare(b.Cluster) || a.ProtectionGroup.localeCompare(b.ProtectionGroup))
    .map((r) => {
      const o = {
        Cluster: r.Cluster,
        ProtectionGroup: r.ProtectionGroup,
        VMsToday: r.VMsToday,
        SuccessfulToday: r.SuccessfulToday,
        FailedToday: r.FailedToday
      };
      for (let i = 0; i < dayLabels.length; i++) o[dayLabels[i]] = r[dayLabels[i]];
      return o;
    });

  const s4Headers = ["Cluster", "ProtectionGroup", "VMName", "FailedMessage"];
  const s4Rows = issuesRows
    .slice(0, EMAIL_ISSUES_CAP)
    .map((r) => ({
      Cluster: r.Cluster,
      ProtectionGroup: r.ProtectionGroup,
      VMName: r.VMName,
      FailedMessage: r.FailedMessage
    }));

  const markdownEmail = [
    `### Cohesity ${ENV} Inventory Drift (VM-level)`,
    "",
    `**Inventory As Of (ET):** ${asOfEt}`,
    `**Drift Window:** Last ${TREND_DAYS} days (ET display)`,
    `**Evidence Source:** Completed backup snapshots only`,
    `**Today Definition (Active Scope):** Latest completed run per PG within last ${ACTIVE_SCOPE_HOURS} hours`,
    "",
    "## 1) Active Scope (Today) ‚Äî Management Summary",
    mdTable(s1Headers, s1Rows),
    "",
    "## 2) Protection Group Drift (7-Day Display) + Today State",
    "_Legend: 0 = no add/remove between snapshots | No run = no completed snapshot selected for that ET day_",
    mdTable(s2Headers, s2Rows),
    "",
    "## 3) Failed VMs (from Today snapshots)",
    (s4Rows.length ? mdTable(s4Headers, s4Rows) : "No failed VMs detected in the Active Scope snapshots."),
    "",
    "_Notes:_",
    "- _VM counts are computed from **all VM objects** in the selected snapshot (not from failures only)._",
    "- _Added/Removed/Net are computed by comparing the first vs last available completed snapshots **within the 7-day display window** (no baseline inference beyond the window)._"
  ].join("\n");

  return {
    authMode,
    environment: ENV,
    totalClusters: clustersSorted.length,
    inventoryAsOfET: asOfEt,
    trendWindowDays: TREND_DAYS,
    activeScopeHours: ACTIVE_SCOPE_HOURS,
    dayLabels,
    markdownEmail,
    markdownTable: markdownEmail,
    rows: {
      section1: s1Rows,
      section2: s2Rows,
      section3_failedVMs: s4Rows
    },
    errors
  };
}
