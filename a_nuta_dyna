import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==============================
  // CONFIG
  // ==============================
  const TREND_DAYS = 7;
  const ACTIVE_SCOPE_HOURS = 48;
  const RUNS_TO_PULL = 60;
  const EMAIL_ISSUES_CAP = 300;

  // ==============================
  // 1) AUTH
  // ==============================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = (all && all.credentials) ? all.credentials : [];
    let found = null;
    for (let i = 0; i < creds.length; i++) {
      if (creds[i] && creds[i].name === name) { found = creds[i]; break; }
    }
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (_) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (_) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");
  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // 2) HELPERS
  // ==============================
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }
  function toArrayMaybe(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }
  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  function nowEtString() {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    }).formatToParts(new Date());
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day} ${m.hour}:${m.minute}`;
  }

  function dateKeyET(d) {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).formatToParts(d);
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day}`;
  }

  function dayLabelFromETKey(etKey) {
    const day = Number(etKey.slice(8, 10));
    const suffix =
      day % 100 >= 11 && day % 100 <= 13 ? "th" :
      day % 10 === 1 ? "st" :
      day % 10 === 2 ? "nd" :
      day % 10 === 3 ? "rd" : "th";
    return `${day}${suffix}`;
  }

  function usecsFromDate(d) {
    return String(Math.floor(d.getTime() * 1000));
  }

  function usecsToEtString(usecs) {
    if (!usecs) return "";
    const ms = Math.floor(Number(usecs) / 1000);
    if (!Number.isFinite(ms)) return "";
    return new Date(ms).toLocaleString("en-US", { timeZone: "America/New_York" });
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const err = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      err.httpStatus = resp.status;
      err.bodyText = txt;
      err.url = url;
      throw err;
    }
    return resp.json();
  }

  async function getJsonSafe(url, headers) {
    try {
      const data = await getJson(url, headers);
      return { ok: true, data, status: 200, bodyText: "", url };
    } catch (e) {
      return {
        ok: false,
        data: null,
        status: e && e.httpStatus ? e.httpStatus : 0,
        bodyText: e && e.bodyText ? e.bodyText : String(e || ""),
        url: e && e.url ? e.url : url
      };
    }
  }

  // --- Run parsing (PowerShell-aligned: localBackupInfo[0]) ---
  function lbi0(run) {
    const v = run && run.localBackupInfo;
    if (!v) return null;
    return Array.isArray(v) ? (v[0] || null) : v;
  }
  function pickRunEndUsecs(run) {
    const l = lbi0(run);
    return norm(l && l.endTimeUsecs) || norm(run && run.endTimeUsecs) || "";
  }
  function pickRunStatus(run) {
    const l = lbi0(run);
    return norm(l && l.status) || norm(run && run.status) || norm(run && run.runStatus) || "";
  }
  function isRunFinished(run) {
    const x = pickRunStatus(run).toLowerCase();
    return x && x !== "running" && x !== "krunning";
  }
  function pickRunId(run) {
    return norm(run && run.runId) || norm(run && run.id) || norm(run && run.instanceId) || "";
  }
  function extractObjectsFromRun(runRaw) {
    return toArrayMaybe(runRaw && runRaw.objects); // needs includeObjectDetails=true
  }

  // --- Object parsing (failure = localSnapshotInfo.failedAttempts exists) ---
  function isAhvVm(obj) {
    const env = norm(obj && obj.object && obj.object.environment);
    const typ = norm(obj && obj.object && obj.object.objectType);
    return (env === "kAcropolis" && typ === "kVirtualMachine");
  }
  function extractVmName(obj) {
    return norm(obj && obj.object && obj.object.name) || "";
  }
  function failedAttempts(obj) {
    return toArrayMaybe(obj && obj.localSnapshotInfo && obj.localSnapshotInfo.failedAttempts);
  }
  function isVmFailed(obj) {
    return failedAttempts(obj).length > 0;
  }

  // Best-effort failure detail: pick the first populated field; else show failedAttempts count.
  function failureDetail(obj) {
    const candidates = [
      norm(obj && obj.localSnapshotInfo && obj.localSnapshotInfo.errorMessage),
      norm(obj && obj.localSnapshotInfo && obj.localSnapshotInfo.error),
      norm(obj && obj.localSnapshotInfo && obj.localSnapshotInfo.failureReason),
      norm(obj && obj.localSnapshotInfo && obj.localSnapshotInfo.reason),
      norm(obj && obj.failureReason),
      norm(obj && obj.errorMessage),
      norm(obj && obj.error)
    ].filter(Boolean);

    if (candidates.length) return candidates[0];

    const fa = failedAttempts(obj);
    if (fa.length) {
      // Sometimes failedAttempts elements contain message/reason; try pull a string
      const first = fa[0];
      const msg =
        norm(first && first.errorMessage) ||
        norm(first && first.failureReason) ||
        norm(first && first.reason) ||
        norm(first && first.message) ||
        norm(first);
      return msg || `failedAttempts=${fa.length}`;
    }
    return "Failed (details not exposed in object payload)";
  }

  // ==============================
  // 3) ET WINDOW
  // ==============================
  const asOfEtNow = nowEtString();
  const now = new Date();

  const etKeys = [];
  for (let i = TREND_DAYS - 1; i >= 0; i--) {
    const d = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
    etKeys.push(dateKeyET(d));
  }
  const dayLabels = etKeys.map(dayLabelFromETKey);

  const activeScopeStart = new Date(now.getTime() - ACTIVE_SCOPE_HOURS * 60 * 60 * 1000);
  const activeScopeStartUsecs = usecsFromDate(activeScopeStart);

  // ==============================
  // 4) CLUSTERS
  // ==============================
  const errors = [];
  const cluResp = await getJsonSafe(baseUrl + "/v2/mcm/cluster-mgmt/info", commonHeaders);
  const clusters = toArrayMaybe(cluResp.ok && cluResp.data && cluResp.data.cohesityClusters);

  if (!cluResp.ok || !clusters.length) {
    return {
      authMode,
      totalClusters: 0,
      markdownEmail: "‚ö†Ô∏è No clusters returned from Helios or API call failed.",
      errors: cluResp.ok ? [] : [{ scope: "clusters", httpStatus: cluResp.status, url: cluResp.url, body: cluResp.bodyText }]
    };
  }

  // ==============================
  // 5) API HELPERS
  // ==============================
  async function fetchAllAHVActivePGs(clusterId) {
    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };

    const pgs = [];
    let pageToken = "";
    let safety = 0;

    while (safety < 200) {
      safety++;
      let url = baseUrl + "/v2/data-protect/protection-groups?environments=kAcropolis&isDeleted=false&isActive=true&isPaused=false";
      if (pageToken) url += "&pageToken=" + encodeURIComponent(pageToken);

      const resp = await getJsonSafe(url, headers);
      if (!resp.ok) return { ok: false, pgs: [], err: resp };

      const data = resp.data || {};
      const batch = toArrayMaybe(data.protectionGroups);
      for (let i = 0; i < batch.length; i++) pgs.push(batch[i]);

      const next =
        norm(data.nextPageToken) ||
        norm(data.pageToken) ||
        norm(data.nextToken) ||
        norm(data.pagination && (data.pagination.nextPageToken || data.pagination.nextToken));

      if (!next || next === pageToken) break;
      pageToken = next;
    }

    return { ok: true, pgs, err: null };
  }

  async function fetchRunsWithObjects(clusterHeaders, pgId, numRuns) {
    const id = encodeURIComponent(pgId);
    const url = `${baseUrl}/v2/data-protect/protection-groups/${id}/runs?numRuns=${encodeURIComponent(String(numRuns))}&includeObjectDetails=true`;
    const r = await getJsonSafe(url, clusterHeaders);
    if (!r.ok) return { ok: false, runs: [], err: r, usedUrl: url };
    const d = r.data || {};
    return { ok: true, runs: toArrayMaybe(d.runs), usedUrl: url };
  }

  // ==============================
  // 6) COMPUTE (no "Last run OK/Failed" at PG level)
  //   - Issues table lists FAILED VMs from the Active Scope snapshot
  // ==============================
  const pgRows = [];
  const issuesRows = [];
  const clusterSummary = {}; // Active_PGs, TotalVMs, Added7d, Removed7d, NetDrift7d, FailedVMsToday

  let grandTotalVMsActiveScope = 0;
  let totalActivePGs = 0;
  let grandFailedVMsToday = 0;
  let globalLatestInventoryUsecs = 0;

  for (let c = 0; c < clusters.length; c++) {
    const cl = clusters[c] || {};
    const clusterName = norm(cl.clusterName) || `Cluster-${c + 1}`;
    const clusterId = norm(cl.clusterId);
    if (!clusterId) continue;

    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };

    const pgRes = await fetchAllAHVActivePGs(clusterId);
    if (!pgRes.ok) {
      errors.push({
        scope: "protection-groups",
        clusterName,
        clusterId,
        httpStatus: pgRes.err.status,
        url: pgRes.err.url,
        body: pgRes.err.bodyText
      });
      continue;
    }

    if (!clusterSummary[clusterName]) {
      clusterSummary[clusterName] = { Active_PGs: 0, TotalVMs: 0, Added7d: 0, Removed7d: 0, NetDrift7d: 0, FailedVMsToday: 0 };
    }

    const pgs = toArrayMaybe(pgRes.pgs);

    for (let p = 0; p < pgs.length; p++) {
      const pg = pgs[p] || {};
      const pgName = norm(pg.name);
      if (!pgName) continue;

      const pgId = norm(pg.id) || norm(pg.protectionGroupId) || norm(pg.groupId) || norm(pg.protectionJobId);
      if (!pgId) continue;

      const runRes = await fetchRunsWithObjects(headers, pgId, RUNS_TO_PULL);
      if (!runRes.ok) {
        errors.push({
          scope: "pg-runs",
          clusterName,
          clusterId,
          protectionGroup: pgName,
          protectionGroupId: pgId,
          httpStatus: runRes.err.status,
          url: runRes.err.url || runRes.usedUrl,
          body: runRes.err.bodyText
        });
        continue;
      }

      const finishedRuns = runRes.runs
        .map((r) => ({
          raw: r,
          runId: pickRunId(r),
          endUsecs: pickRunEndUsecs(r),
          finished: isRunFinished(r),
          objects: extractObjectsFromRun(r)
        }))
        .filter((x) => x.runId && x.endUsecs && x.finished && x.objects && x.objects.length)
        .sort((a, b) => Number(b.endUsecs) - Number(a.endUsecs));

      if (!finishedRuns.length) continue;

      // day -> latest completed run that ended on that ET day
      const dayToRun = {};
      for (let i = 0; i < finishedRuns.length; i++) {
        const endMs = Math.floor(Number(finishedRuns[i].endUsecs) / 1000);
        if (!Number.isFinite(endMs)) continue;
        const key = dateKeyET(new Date(endMs));
        if (!dayToRun[key] || Number(finishedRuns[i].endUsecs) > Number(dayToRun[key].endUsecs)) {
          dayToRun[key] = finishedRuns[i];
        }
      }

      // day -> VM set (null => No Run)
      const dayVmSets = {};
      for (let i = 0; i < etKeys.length; i++) dayVmSets[etKeys[i]] = null;

      for (let i = 0; i < etKeys.length; i++) {
        const k = etKeys[i];
        const sel = dayToRun[k];
        if (!sel) continue;

        const set = new Set();
        const objs = sel.objects;
        for (let o = 0; o < objs.length; o++) {
          if (!isAhvVm(objs[o])) continue;
          const nm = extractVmName(objs[o]);
          if (nm) set.add(nm);
        }
        dayVmSets[k] = set;
      }

      // Active Scope run: latest completed within last N hours
      let activeScopeRun = null;
      for (let i = 0; i < finishedRuns.length; i++) {
        if (Number(finishedRuns[i].endUsecs) >= Number(activeScopeStartUsecs)) {
          activeScopeRun = finishedRuns[i];
          break;
        }
      }
      if (!activeScopeRun) continue;

      if (Number(activeScopeRun.endUsecs) > globalLatestInventoryUsecs) {
        globalLatestInventoryUsecs = Number(activeScopeRun.endUsecs);
      }

      // Active Scope VM set + FAILED VM extraction (this fixes your complaint)
      const activeSet = new Set();
      let failedVmCountThisPg = 0;

      for (let o = 0; o < activeScopeRun.objects.length; o++) {
        const obj = activeScopeRun.objects[o];
        if (!isAhvVm(obj)) continue;

        const vm = extractVmName(obj);
        if (vm) activeSet.add(vm);

        if (vm && isVmFailed(obj)) {
          failedVmCountThisPg++;
          issuesRows.push({
            Cluster: clusterName,
            ProtectionGroup: pgName,
            VMName: vm,
            IssueType: "Failed",
            Notes: failureDetail(obj)
          });
        }
      }

      const activeScopeVmCount = activeSet.size;

      // Drift deltas (‚Äì = No Run, 0 = baseline/no-change)
      const dayDelta = {};
      for (let i = 0; i < etKeys.length; i++) dayDelta[etKeys[i]] = "‚Äì";

      let prevSet = null;
      let pgAdds = 0;
      let pgRems = 0;

      for (let i = 0; i < etKeys.length; i++) {
        const k = etKeys[i];
        const cur = dayVmSets[k];

        if (cur === null) { dayDelta[k] = "‚Äì"; continue; }

        if (prevSet === null) {
          dayDelta[k] = "0";
          prevSet = cur;
          continue;
        }

        let adds = 0, rems = 0;
        for (const x of cur) if (!prevSet.has(x)) adds++;
        for (const x of prevSet) if (!cur.has(x)) rems++;

        pgAdds += adds;
        pgRems += rems;

        if (adds === 0 && rems === 0) dayDelta[k] = "0";
        else if (adds > 0 && rems === 0) dayDelta[k] = `üü¢ +${adds}`;
        else if (rems > 0 && adds === 0) dayDelta[k] = `üî¥ -${rems}`;
        else dayDelta[k] = `üü¢ +${adds} / üî¥ -${rems}`;

        prevSet = cur;
      }

      let lastKnownDelta = "‚Äì";
      for (let i = etKeys.length - 1; i >= 0; i--) {
        const k = etKeys[i];
        if (dayDelta[k] !== "‚Äì") { lastKnownDelta = `${dayDelta[k]} (${k})`; break; }
      }

      // Roll to cluster totals
      clusterSummary[clusterName].Active_PGs += 1;
      clusterSummary[clusterName].TotalVMs += activeScopeVmCount;
      clusterSummary[clusterName].FailedVMsToday += failedVmCountThisPg;

      clusterSummary[clusterName].Added7d += pgAdds;
      clusterSummary[clusterName].Removed7d += pgRems;

      totalActivePGs += 1;
      grandTotalVMsActiveScope += activeScopeVmCount;
      grandFailedVMsToday += failedVmCountThisPg;

      // PG row (NO LastCompletedJob column)
      const row = {
        Cluster: clusterName,
        ProtectionGroup: pgName,
        TotalVMsToday: String(activeScopeVmCount),
        FailedVMsToday: String(failedVmCountThisPg),
        LastKnownDelta: lastKnownDelta,
        PGState: "Active"
      };
      for (let i = 0; i < etKeys.length; i++) row[dayLabels[i]] = dayDelta[etKeys[i]];
      pgRows.push(row);
    }
  }

  // Finalize NetDrift7d per cluster
  const clusterNames = Object.keys(clusterSummary);
  for (let i = 0; i < clusterNames.length; i++) {
    const cn = clusterNames[i];
    const s = clusterSummary[cn];
    s.NetDrift7d = s.Added7d - s.Removed7d;
  }

  // ==============================
  // 7) MARKDOWN
  // ==============================
  function mdTable(headers, rows) {
    const head = "| " + headers.join(" | ") + " |";
    const sep = "| " + headers.map(() => "---").join(" | ") + " |";
    const body = rows.map((r) => "| " + headers.map((h) => safeCell(r[h])).join(" | ") + " |");
    return [head, sep].concat(body).join("\n");
  }

  const clustersSorted = Object.keys(clusterSummary).sort();

  let inventoryAsOfET = asOfEtNow;
  if (globalLatestInventoryUsecs && Number.isFinite(globalLatestInventoryUsecs)) {
    inventoryAsOfET = usecsToEtString(globalLatestInventoryUsecs) || asOfEtNow;
  }

  // Section 1 (Added/Removed/Net + FailedVMsToday)
  const s1Rows = [];
  let sumAdded = 0;
  let sumRemoved = 0;
  let sumNet = 0;

  for (let i = 0; i < clustersSorted.length; i++) {
    const cn = clustersSorted[i];
    const s = clusterSummary[cn];

    sumAdded += s.Added7d;
    sumRemoved += s.Removed7d;
    sumNet += s.NetDrift7d;

    const netStr = (s.NetDrift7d > 0) ? `üü¢ +${s.NetDrift7d}` : (s.NetDrift7d < 0) ? `üî¥ ${s.NetDrift7d}` : "0";

    s1Rows.push({
      Cluster: cn,
      Active_PGs: String(s.Active_PGs),
      TotalVMs: String(s.TotalVMs),
      "Failed VMs (Today)": String(s.FailedVMsToday),
      "Added (7d)": `+${s.Added7d}`,
      "Removed (7d)": `-${s.Removed7d}`,
      "Net Drift (7d)": netStr
    });
  }

  const sumNetStr = (sumNet > 0) ? `üü¢ +${sumNet}` : (sumNet < 0) ? `üî¥ ${sumNet}` : "0";
  s1Rows.push({
    Cluster: "‚≠ê TOTAL",
    Active_PGs: String(totalActivePGs),
    TotalVMs: String(grandTotalVMsActiveScope),
    "Failed VMs (Today)": String(grandFailedVMsToday),
    "Added (7d)": `+${sumAdded}`,
    "Removed (7d)": `-${sumRemoved}`,
    "Net Drift (7d)": sumNetStr
  });

  // Section 2 headers (PG table)
  const s2Headers = ["Cluster", "ProtectionGroup", "TotalVMsToday", "FailedVMsToday"]
    .concat(dayLabels)
    .concat(["LastKnownDelta", "PGState"]);

  const s2Rows = pgRows
    .sort((a, b) => (a.Cluster.localeCompare(b.Cluster) || a.ProtectionGroup.localeCompare(b.ProtectionGroup)))
    .map((r) => {
      const out = {
        Cluster: r.Cluster,
        ProtectionGroup: r.ProtectionGroup,
        TotalVMsToday: r.TotalVMsToday,
        FailedVMsToday: r.FailedVMsToday
      };
      for (let i = 0; i < dayLabels.length; i++) out[dayLabels[i]] = r[dayLabels[i]];
      out.LastKnownDelta = r.LastKnownDelta;
      out.PGState = r.PGState;
      return out;
    });

  const grandRow = { Cluster: "‚≠ê GRAND TOTAL", ProtectionGroup: "‚Äî", TotalVMsToday: String(grandTotalVMsActiveScope), FailedVMsToday: String(grandFailedVMsToday) };
  for (let i = 0; i < dayLabels.length; i++) grandRow[dayLabels[i]] = "";
  grandRow.LastKnownDelta = "";
  grandRow.PGState = "";
  s2Rows.push(grandRow);

  // Issues table: ONLY failed VMs from Active Scope snapshot
  const s4Headers = ["Cluster", "ProtectionGroup", "VMName", "IssueType", "Notes"];
  const s4Rows = issuesRows
    .map((r) => ({
      Cluster: r.Cluster,
      ProtectionGroup: r.ProtectionGroup,
      VMName: r.VMName,
      IssueType: r.IssueType,
      Notes: r.Notes
    }))
    .slice(0, EMAIL_ISSUES_CAP);

  const markdownEmail = [
    "### Cohesity AHV Inventory Drift ‚Äî 7-Day (Retention-Aware)",
    "",
    `**Inventory As Of (ET):** ${inventoryAsOfET}`,
    `**Drift Window:** Last ${TREND_DAYS} days (ET)`,
    "**Retention Context:** Policy-based (7 / 14 / 35 / 6mo; used for validation only)",
    "**Evidence Source:** Completed backup jobs only",
    "",
    "## 1) Active Scope (Today)",
    mdTable(["Cluster", "Active_PGs", "TotalVMs", "Failed VMs (Today)", "Added (7d)", "Removed (7d)", "Net Drift (7d)"], s1Rows),
    "",
    "## 2) Protection Group Drift (7-Day) + Current State",
    "_Legend: üü¢ added | üî¥ removed | 0 baseline/no-change | ‚Äì No Run (no completed snapshot that ET day)_",
    mdTable(s2Headers, s2Rows),
    "",
    "## 3) Failed Virtual Machines (From Latest Completed Snapshot per PG)",
    (s4Rows.length ? mdTable(s4Headers, s4Rows) : "No failed VMs detected in the Active Scope completed snapshots."),
    "",
    "_Audit note: Failed VMs are derived from object-level evidence (localSnapshotInfo.failedAttempts) in completed runs, not from the run‚Äôs overall status._"
  ].join("\n");

  return {
    authMode,
    totalClusters: clusters.length,
    inventoryAsOfET,
    trendWindowDays: TREND_DAYS,
    activeScopeHours: ACTIVE_SCOPE_HOURS,
    dayLabels,
    grandTotalVMsActiveScope,
    grandFailedVMsToday,
    markdownEmail,
    markdownTable: markdownEmail,
    rows: {
      section1: s1Rows,
      section2: s2Rows,
      failedVMs: s4Rows
    },
    errors
  };
}
