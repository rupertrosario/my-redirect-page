import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity AHV Inventory Drift ‚Äî 7-Day (Retention-aware, Completed runs only)
 *
 * What mgmt gets:
 * 1) Active Scope Today (per cluster): Active PGs, Total VMs, Net Drift (7d)
 * 2) PG Drift (7-day): per-day delta, VMs Today, Last Drift, PG State, Last Completed Job
 * 3) Drift Summary (Evidence-ready)
 * 4) VM Issues (visibility; NOT counted as removed unless retention-confirmed)
 *
 * Design choices (matches your PowerShell reality):
 * - Uses ONLY APIs you already have working:
 *   - /v2/mcm/cluster-mgmt/info
 *   - /v2/data-protect/protection-groups?... (kAcropolis + active filters)
 *   - /v2/data-protect/protection-groups/{pgId}/runs?numRuns=N&includeObjectDetails=True
 * - Uses run.localBackupInfo[0].endTimeUsecs + status to identify completed runs
 * - Prefers embedded run.objects (no /runs/{id}/objects dependency)
 */
export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // =========================
  // CONFIG (safe defaults)
  // =========================
  const TREND_DAYS = 7;              // drift window (ET days)
  const ACTIVE_SCOPE_HOURS = 48;     // ‚ÄúToday‚Äù uses latest completed run within last 48h
  const LAST_SUCCESS_RUN_LOOKBACK = 10; // per-VM last success scan (like your PS)
  const MAX_RUNS_PULL = Math.max(LAST_SUCCESS_RUN_LOOKBACK, 20); // enough for window + last success scan
  const EMAIL_ISSUES_CAP = 200;      // cap issues rows for email size safety
  const USE_POLICY_RETENTION_VALIDATION = false; // set true only if you later add policy lookups

  // =========================
  // AUTH (vault name -> id -> manual)
  // =========================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = (all && all.credentials) ? all.credentials : [];
    let found = null;
    for (let i = 0; i < creds.length; i++) {
      if (creds[i] && creds[i].name === name) { found = creds[i]; break; }
    }
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (_) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (_) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");
  const commonHeaders = { accept: "application/json", apiKey };

  // =========================
  // HELPERS (robust parsing)
  // =========================
  function norm(v) { return (v === null || v === undefined) ? "" : String(v).trim(); }
  function toArray(v) { return Array.isArray(v) ? v : (v ? [v] : []); }
  function safeCell(v) { return (v === null || v === undefined) ? "" : String(v).replace(/\|/g, " "); }

  function nowEtString() {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      hour12: false
    }).formatToParts(new Date());
    const m = {}; for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day} ${m.hour}:${m.minute}:${m.second}`;
  }

  function dateKeyET(d) {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric", month: "2-digit", day: "2-digit"
    }).formatToParts(d);
    const m = {}; for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day}`; // YYYY-MM-DD
  }

  function dayLabelFromETKey(etKey) {
    const day = Number(etKey.slice(8, 10));
    const suffix =
      day % 100 >= 11 && day % 100 <= 13 ? "th" :
      day % 10 === 1 ? "st" :
      day % 10 === 2 ? "nd" :
      day % 10 === 3 ? "rd" : "th";
    return `${day}${suffix}`;
  }

  function usecsFromDate(d) { return String(Math.floor(d.getTime() * 1000)); }
  function etStringFromUsecs(usecs) {
    const ms = Math.floor(Number(usecs) / 1000);
    if (!Number.isFinite(ms)) return "";
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric", month: "2-digit", day: "2-digit",
      hour: "2-digit", minute: "2-digit", second: "2-digit",
      hour12: false
    }).formatToParts(new Date(ms));
    const m = {}; for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day} ${m.hour}:${m.minute}:${m.second}`;
  }

  function getPGState(pg) {
    if (pg && pg.isDeleted) return "Deleted";
    if (pg && pg.isPaused) return "Paused";
    if (pg && pg.isActive) return "Active";
    return "Inactive";
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const err = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      err.httpStatus = resp.status;
      err.bodyText = txt;
      err.url = url;
      throw err;
    }
    return resp.json();
  }

  async function getJsonSafe(url, headers) {
    try {
      const data = await getJson(url, headers);
      return { ok: true, data, status: 200, bodyText: "", url };
    } catch (e) {
      return {
        ok: false,
        data: null,
        status: e && e.httpStatus ? e.httpStatus : 0,
        bodyText: e && e.bodyText ? e.bodyText : String(e || ""),
        url: e && e.url ? e.url : url
      };
    }
  }

  // ----- Cohesity run schema (PowerShell-equivalent) -----
  function lbiFirst(run) {
    const lb = toArray(run && run.localBackupInfo);
    return lb.length ? lb[0] : null;
  }
  function runEndUsecs(run) {
    const info = lbiFirst(run);
    const v = norm(info && info.endTimeUsecs);
    return v ? Number(v) : 0;
  }
  function runStatus(run) {
    const info = lbiFirst(run);
    return norm(info && info.status); // Running / Succeeded / Failed (varies)
  }
  function runIsRunning(run) {
    return runStatus(run).toLowerCase() === "running";
  }
  function runIsCompleted(run) {
    // Completed = has end time and not Running (matches your PS inventory selection)
    const end = runEndUsecs(run);
    if (!end) return false;
    if (runIsRunning(run)) return false;
    return true;
  }
  function runIsOk(run) {
    const s = runStatus(run).toLowerCase();
    // Keep tolerant: "Succeeded", "kSuccess", "Success", "Warning" are considered OK
    return (s.includes("success") || s.includes("succeed") || s.includes("warning"));
  }

  function objIsAhvVm(obj) {
    const o = obj && obj.object;
    return (
      norm(o && o.environment) === "kAcropolis" &&
      norm(o && o.objectType) === "kVirtualMachine" &&
      !!norm(o && o.name)
    );
  }
  function objVmName(obj) { return norm(obj && obj.object && obj.object.name); }

  function objFailedAttemptsCount(obj) {
    try {
      const fa = obj && obj.localSnapshotInfo && obj.localSnapshotInfo.failedAttempts;
      const arr = toArray(fa);
      return arr.length;
    } catch (_) {
      return 0;
    }
  }
  function objBackupStatus(obj) {
    // PowerShell logic: failedAttempts exists => Failed else Succeeded
    return objFailedAttemptsCount(obj) > 0 ? "Failed" : "Succeeded";
  }

  // =========================
  // BUILD TREND WINDOW (ET days)
  // =========================
  const asOfEtNow = nowEtString();
  const now = new Date();

  const etKeys = [];
  for (let i = TREND_DAYS - 1; i >= 0; i--) {
    etKeys.push(dateKeyET(new Date(now.getTime() - i * 24 * 60 * 60 * 1000)));
  }
  const dayLabels = etKeys.map(dayLabelFromETKey);

  const activeScopeStart = new Date(now.getTime() - ACTIVE_SCOPE_HOURS * 60 * 60 * 1000);
  const activeScopeStartUsecs = Number(usecsFromDate(activeScopeStart));

  // =========================
  // 1) CLUSTERS
  // =========================
  const errors = [];
  const diag = {
    authMode,
    clustersReturned: 0,
    clustersProcessed: 0,
    pgsReturned: 0,
    pgsProcessed: 0,
    runsReturned: 0,
    runsCompletedWithObjects: 0,
    inventoryRunsPicked: 0
  };

  const cluUrl = baseUrl + "/v2/mcm/cluster-mgmt/info";
  const cluResp = await getJsonSafe(cluUrl, commonHeaders);
  const clusters = toArray(cluResp.ok && cluResp.data && cluResp.data.cohesityClusters);
  diag.clustersReturned = clusters.length;

  if (!cluResp.ok || !clusters.length) {
    return {
      authMode,
      totalClusters: 0,
      markdownEmail: "‚ö†Ô∏è No clusters returned from Helios or API call failed.",
      errors: cluResp.ok ? [] : [{ scope: "clusters", httpStatus: cluResp.status, url: cluResp.url, body: cluResp.bodyText }],
      diag
    };
  }

  // =========================
  // 2) API CALLS (PGs + runs with includeObjectDetails)
  // =========================
  async function fetchActiveAhvPGs(clusterId) {
    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };

    // Use query params (GET). Avoid GET body ambiguity.
    const url =
      `${baseUrl}/v2/data-protect/protection-groups` +
      `?environments=kAcropolis&isDeleted=false&isActive=true&isPaused=false`;

    const r = await getJsonSafe(url, headers);
    if (!r.ok) return { ok: false, pgs: [], err: r, usedUrl: url };
    const pgs = toArray(r.data && r.data.protectionGroups);
    return { ok: true, pgs, err: null, usedUrl: url };
  }

  async function fetchRunsWithObjects(clusterHeaders, pgId) {
    // Matches your PS: numRuns + includeObjectDetails=True
    const id = encodeURIComponent(pgId);
    const url =
      `${baseUrl}/v2/data-protect/protection-groups/${id}/runs` +
      `?numRuns=${encodeURIComponent(String(MAX_RUNS_PULL))}&includeObjectDetails=true`;
    const r = await getJsonSafe(url, clusterHeaders);
    if (!r.ok) return { ok: false, runs: [], err: r, usedUrl: url };
    const runs = toArray(r.data && r.data.runs);
    return { ok: true, runs, err: null, usedUrl: url };
  }

  // =========================
  // 3) COMPUTE: drift + today + issues
  // =========================
  const clusterSummary = {}; // name -> {ActivePGs, TotalVMs, NetDrift7d}
  const pgRows = [];         // section 2
  const issuesRows = [];     // section 4

  let vmsAdded = 0;
  let vmsRemoved = 0;
  let newlyDetectedPGs = 0;
  let removedPGs = 0; // no baseline => keep 0 unless you later persist baseline
  let grandTotalVMsActiveScope = 0;
  let totalActivePGs = 0;

  // global as-of (max end time among inventory runs used)
  let globalAsOfUsecs = 0;

  for (let c = 0; c < clusters.length; c++) {
    const cl = clusters[c] || {};
    const clusterName = norm(cl.clusterName) || `Cluster-${c + 1}`;
    const clusterId = norm(cl.clusterId);
    if (!clusterId) continue;

    diag.clustersProcessed++;

    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };

    const pgRes = await fetchActiveAhvPGs(clusterId);
    if (!pgRes.ok) {
      errors.push({
        scope: "protection-groups",
        clusterName,
        clusterId,
        httpStatus: pgRes.err.status,
        url: pgRes.usedUrl,
        body: pgRes.err.bodyText
      });
      continue;
    }

    const pgs = toArray(pgRes.pgs);
    diag.pgsReturned += pgs.length;

    if (!clusterSummary[clusterName]) {
      clusterSummary[clusterName] = { ActivePGs: 0, TotalVMs: 0, NetDrift7d: 0 };
    }

    for (let p = 0; p < pgs.length; p++) {
      const pg = pgs[p] || {};
      const pgName = norm(pg.name);
      const pgId = norm(pg.id);
      if (!pgName || !pgId) continue;

      diag.pgsProcessed++;

      const pgState = getPGState(pg); // should be Active due to filter, but keep robust
      const countsAsActive = (pgState === "Active");

      const runRes = await fetchRunsWithObjects(headers, pgId);
      if (!runRes.ok) {
        errors.push({
          scope: "pg-runs",
          clusterName,
          clusterId,
          protectionGroup: pgName,
          protectionGroupId: pgId,
          httpStatus: runRes.err.status,
          url: runRes.usedUrl,
          body: runRes.err.bodyText
        });
        continue;
      }

      const runs = toArray(runRes.runs);
      diag.runsReturned += runs.length;

      // Keep only runs that have objects AND are completed (end time + not running)
      const completed = runs
        .filter((r) => r && toArray(r.objects).length && runIsCompleted(r))
        .sort((a, b) => runEndUsecs(b) - runEndUsecs(a));

      if (!completed.length) continue;

      diag.runsCompletedWithObjects += completed.length;

      // Build day -> latest completed run ending on that ET day
      const dayToRun = {};
      for (let i = 0; i < completed.length; i++) {
        const end = runEndUsecs(completed[i]);
        if (!end) continue;
        const key = dateKeyET(new Date(Math.floor(end / 1000)));
        // keep latest for that day
        if (!dayToRun[key] || runEndUsecs(dayToRun[key]) < end) dayToRun[key] = completed[i];
      }

      // Trend snapshots: dayKey -> Set(VMs) or null
      const dayVmSets = {};
      for (let i = 0; i < etKeys.length; i++) dayVmSets[etKeys[i]] = null;

      for (let i = 0; i < etKeys.length; i++) {
        const k = etKeys[i];
        const r = dayToRun[k];
        if (!r) continue;
        const objs = toArray(r.objects).filter(objIsAhvVm);
        const s = new Set();
        for (let j = 0; j < objs.length; j++) s.add(objVmName(objs[j]));
        dayVmSets[k] = s;
      }

      // Pick inventory ‚Äútoday‚Äù snapshot for Active Scope = latest completed run within last 48h
      let activeScopeRun = null;
      for (let i = 0; i < completed.length; i++) {
        const end = runEndUsecs(completed[i]);
        if (end >= activeScopeStartUsecs) { activeScopeRun = completed[i]; break; }
      }

      // If no active-scope run exists, we still keep drift table based on dayToRun,
      // but ‚ÄúVMs Today‚Äù will be blank and the PG won‚Äôt contribute to Active Scope totals.
      let activeScopeVmSet = null;
      let activeScopeVmCount = null;

      if (activeScopeRun) {
        const end = runEndUsecs(activeScopeRun);
        if (end > globalAsOfUsecs) globalAsOfUsecs = end;

        diag.inventoryRunsPicked++;

        const objs = toArray(activeScopeRun.objects).filter(objIsAhvVm);
        activeScopeVmSet = new Set();
        for (let j = 0; j < objs.length; j++) activeScopeVmSet.add(objVmName(objs[j]));
        activeScopeVmCount = activeScopeVmSet.size;

        // Issues (from active-scope completed snapshot evidence)
        for (let j = 0; j < objs.length; j++) {
          const vm = objVmName(objs[j]);
          const st = objBackupStatus(objs[j]);
          if (!vm) continue;
          if (st !== "Failed") continue;
          issuesRows.push({
            Cluster: clusterName,
            ProtectionGroup: pgName,
            VMName: vm,
            IssueType: "Failed (object-level)",
            Notes: "FailedAttempts present in localSnapshotInfo (completed Active Scope snapshot)"
          });
        }

        if (countsAsActive) {
          clusterSummary[clusterName].ActivePGs += 1;
          clusterSummary[clusterName].TotalVMs += activeScopeVmCount;
          totalActivePGs += 1;
          grandTotalVMsActiveScope += activeScopeVmCount;
        }
      }

      // Last completed job status (from most recent completed run)
      const lastCompletedJob = runIsOk(completed[0]) ? "OK" : "NOT OK";

      // Per-day deltas (within 7-day window)
      const dayDelta = {};
      for (let i = 0; i < etKeys.length; i++) dayDelta[etKeys[i]] = "‚Äì";

      let prevSet = null;
      let prevKey = "";

      for (let i = 0; i < etKeys.length; i++) {
        const k = etKeys[i];
        const cur = dayVmSets[k];
        if (cur === null) continue;

        if (prevSet === null) {
          // First observed snapshot within window => NEW
          newlyDetectedPGs += 1;
          dayDelta[k] = `NEW`;
          prevSet = cur;
          prevKey = k;
          continue;
        }

        let adds = 0, rems = 0;
        for (const x of cur) if (!prevSet.has(x)) adds++;
        for (const x of prevSet) if (!cur.has(x)) rems++;

        vmsAdded += adds;
        vmsRemoved += rems;

        if (adds === 0 && rems === 0) dayDelta[k] = "0";
        else if (adds > 0 && rems === 0) dayDelta[k] = `üü¢ +${adds}`;
        else if (rems > 0 && adds === 0) dayDelta[k] = `üî¥ ‚àí${rems}`;
        else dayDelta[k] = `üü¢ +${adds} / üî¥ ‚àí${rems}`;

        prevSet = cur;
        prevKey = k;
      }

      // Net drift (7d) = last available snapshot size - first available snapshot size
      let firstSnap = null;
      let lastSnap = null;
      for (let i = 0; i < etKeys.length; i++) { if (dayVmSets[etKeys[i]] !== null) { firstSnap = dayVmSets[etKeys[i]]; break; } }
      for (let i = etKeys.length - 1; i >= 0; i--) { if (dayVmSets[etKeys[i]] !== null) { lastSnap = dayVmSets[etKeys[i]]; break; } }
      const netPgDrift = (firstSnap && lastSnap) ? (lastSnap.size - firstSnap.size) : 0;

      if (countsAsActive) clusterSummary[clusterName].NetDrift7d += netPgDrift;

      // Last drift (most recent day with non "‚Äì")
      let lastDriftText = "0";
      let lastDriftDay = "";
      for (let i = etKeys.length - 1; i >= 0; i--) {
        const k = etKeys[i];
        const v = dayDelta[k];
        if (v !== "‚Äì" && v !== "0") { lastDriftText = v; lastDriftDay = k; break; }
      }
      const lastDrift = lastDriftDay ? `${lastDriftText} (${lastDriftDay})` : "0";

      // VMs Today: use active-scope count if available; else ‚Äú‚Äî‚Äù
      const vmsToday = (activeScopeVmCount === null) ? "‚Äî" : String(activeScopeVmCount);

      // Section 2 row (Active PGs only)
      if (countsAsActive) {
        const r = {
          Cluster: clusterName,
          ProtectionGroup: pgName,
          VMsToday: vmsToday
        };
        for (let i = 0; i < etKeys.length; i++) r[dayLabels[i]] = dayDelta[etKeys[i]];
        r.LastDrift = lastDrift;
        r.PGState = pgState;
        r.LastCompletedJob = activeScopeRun ? (runIsOk(activeScopeRun) ? "OK" : "NOT OK") : lastCompletedJob;
        pgRows.push(r);
      }
    }
  }

  // =========================
  // MARKDOWN BUILD
  // =========================
  function mdTable(headers, rows) {
    const head = "| " + headers.join(" | ") + " |";
    const sep = "| " + headers.map(() => "---").join(" | ") + " |";
    const body = rows.map((r) => "| " + headers.map((h) => safeCell(r[h])).join(" | ") + " |");
    return [head, sep].concat(body).join("\n");
  }

  const clustersSorted = Object.keys(clusterSummary).sort();

  // Section 1
  const s1Rows = [];
  let netAll = 0;
  for (let i = 0; i < clustersSorted.length; i++) {
    const cn = clustersSorted[i];
    const s = clusterSummary[cn];
    netAll += s.NetDrift7d;
    const driftStr = s.NetDrift7d > 0 ? `üü¢ +${s.NetDrift7d}` : s.NetDrift7d < 0 ? `üî¥ ${s.NetDrift7d}` : "0";
    s1Rows.push({
      Cluster: cn,
      ActivePGs: String(s.ActivePGs),
      TotalVMs: String(s.TotalVMs),
      "Net Drift (7d)": driftStr
    });
  }
  const grandDriftStr = netAll > 0 ? `üü¢ +${netAll}` : netAll < 0 ? `üî¥ ${netAll}` : "0";
  s1Rows.push({
    Cluster: "‚≠ê TOTAL",
    ActivePGs: String(totalActivePGs),
    TotalVMs: String(grandTotalVMsActiveScope),
    "Net Drift (7d)": grandDriftStr
  });

  // Section 2
  const s2Headers = ["Cluster", "ProtectionGroup", "VMsToday"]
    .concat(dayLabels)
    .concat(["LastDrift", "PGState", "LastCompletedJob"]);

  const s2Rows = pgRows
    .sort((a, b) => a.Cluster.localeCompare(b.Cluster) || a.ProtectionGroup.localeCompare(b.ProtectionGroup))
    .map((r) => {
      const out = { Cluster: r.Cluster, ProtectionGroup: r.ProtectionGroup, VMsToday: r.VMsToday };
      for (let i = 0; i < dayLabels.length; i++) out[dayLabels[i]] = r[dayLabels[i]];
      out.LastDrift = r.LastDrift;
      out.PGState = r.PGState;
      out.LastCompletedJob = r.LastCompletedJob;
      return out;
    });

  const grandRow = { Cluster: "‚≠ê GRAND TOTAL", ProtectionGroup: "‚Äî", VMsToday: String(grandTotalVMsActiveScope) };
  for (let i = 0; i < dayLabels.length; i++) grandRow[dayLabels[i]] = "";
  grandRow.LastDrift = "";
  grandRow.PGState = "";
  grandRow.LastCompletedJob = "";
  s2Rows.push(grandRow);

  // Section 3 summary (Evidence-ready)
  const netVm = vmsAdded - vmsRemoved;
  const netVmStr = netVm > 0 ? `üü¢ +${netVm}` : netVm < 0 ? `üî¥ ${netVm}` : "0";

  const s3Rows = [
    { Area: "Protection Groups", Metric: "Newly detected (in 7d window)", Value: String(newlyDetectedPGs) },
    { Area: "Protection Groups", Metric: "Removed (baseline required)", Value: String(removedPGs) },
    { Area: "Virtual Machines", Metric: "Added (day-to-day deltas)", Value: `+${vmsAdded}` },
    { Area: "Virtual Machines", Metric: "Removed (day-to-day deltas)", Value: `‚àí${vmsRemoved}` },
    { Area: "Virtual Machines", Metric: "Net Drift (computed)", Value: netVmStr },
    { Area: "Evidence Scope", Metric: "Data source", Value: "Completed backup jobs only" },
    { Area: "Evidence Scope", Metric: "Failed / partial runs", Value: "Excluded" }
  ];

  // Section 4 issues
  const s4Headers = ["Cluster", "ProtectionGroup", "VMName", "IssueType", "Notes"];
  const s4Rows = issuesRows
    .slice(0, EMAIL_ISSUES_CAP)
    .map((r) => ({
      Cluster: r.Cluster,
      ProtectionGroup: r.ProtectionGroup,
      VMName: r.VMName,
      IssueType: r.IssueType,
      Notes: r.Notes
    }));

  const inventoryAsOfEt = globalAsOfUsecs ? etStringFromUsecs(globalAsOfUsecs) : asOfEtNow;

  const markdownEmail = [
    "### Cohesity AHV Inventory Drift ‚Äî 7-Day (Retention-aware)",
    "",
    `**Inventory As Of (ET):** ${inventoryAsOfEt}`,
    `**Drift Window:** Last ${TREND_DAYS} days (ET)`,
    "**Evidence Source:** Completed backup jobs only",
    `**Active Scope:** Latest completed snapshot per Active PG within last ${ACTIVE_SCOPE_HOURS} hours`,
    (USE_POLICY_RETENTION_VALIDATION ? "**Retention Context:** Policy-based validation enabled" : "**Retention Context:** Policy-based validation not enabled in this script"),
    "",
    "## 1) Active Scope (Today)",
    mdTable(["Cluster", "ActivePGs", "TotalVMs", "Net Drift (7d)"], s1Rows),
    "",
    "## 2) Protection Group Drift (7-Day) + Current State",
    "_Legend: üü¢ added | üî¥ removed | NEW first detected | 0 no change | ‚Äì not present_",
    mdTable(s2Headers, s2Rows),
    "",
    "## 3) 7-Day Inventory Drift Summary (Evidence-Ready)",
    mdTable(["Area", "Metric", "Value"], s3Rows),
    "",
    "## 4) Virtual Machines With Observed Issues (Non-Drift)",
    (s4Rows.length ? mdTable(s4Headers, s4Rows) : "No VM issues detected in completed snapshots within the report scope."),
    "",
    "_Audit note: Drift is computed only from completed snapshots. ‚ÄúRemoved PGs‚Äù requires a persisted baseline; this script does not delete/modify anything (GET-only)._"
  ].join("\n");

  return {
    authMode,
    totalClusters: clusters.length,
    inventoryAsOfET: inventoryAsOfEt,
    driftWindowDays: TREND_DAYS,
    activeScopeHours: ACTIVE_SCOPE_HOURS,
    dayLabels,
    grandTotalVMsActiveScope,
    markdownEmail,
    rows: {
      section1: s1Rows,
      section2: s2Rows,
      section3: s3Rows,
      section4: s4Rows
    },
    errors,
    diag
  };
}
