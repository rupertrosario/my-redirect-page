import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {

  const baseUrl = "https://helios.cohesity.com";
  const vaultName = "Cohesity_API_Key";
  const LOOKBACK_DAYS_CAP = 35;

  /* ---------------- AUTH ---------------- */
  const all = await credentialVaultClient.getCredentials();
  const cred = all.credentials.find(c => c.name === vaultName);
  if (!cred) throw new Error("API key not found");

  const det = await credentialVaultClient.getCredentialsDetails({ id: cred.id });
  const apiKey = det.token || det.password;
  if (!apiKey) throw new Error("Empty API key");

  const commonHeaders = { apiKey, accept: "application/json" };

  /* ---------------- HELPERS ---------------- */
  const toArr = v => Array.isArray(v) ? v : (v ? [v] : []);
  const norm = v => v ? String(v).trim() : "";
  const dayMs = 86400000;

  async function getJson(url, headers) {
    const r = await fetch(url, { method: "GET", headers });
    if (!r.ok) throw new Error(`${r.status} ${await r.text()}`);
    return r.json();
  }

  function getCompletedRuns(runs) {
    return runs.filter(r =>
      r.localBackupInfo &&
      r.localBackupInfo[0] &&
      r.localBackupInfo[0].status !== "Running" &&
      r.localBackupInfo[0].endTimeUsecs
    );
  }

  function extractVMSet(run) {
    const set = new Set();
    if (!run.objects) return set;
    for (const o of run.objects) {
      if (
        o.object?.environment === "kAcropolis" &&
        o.object?.objectType === "kVirtualMachine" &&
        o.object?.name
      ) {
        set.add(o.object.name);
      }
    }
    return set;
  }

  function diffSets(today, baseline) {
    const added = [...today].filter(x => !baseline.has(x));
    const removed = [...baseline].filter(x => !today.has(x));
    return { added, removed };
  }

  /* ---------------- CLUSTERS ---------------- */
  const clu = await getJson(
    `${baseUrl}/v2/mcm/cluster-mgmt/info`,
    commonHeaders
  );

  const clusters = toArr(clu.cohesityClusters);
  const driftRows = [];
  let globalAdded = 0;
  let globalRemoved = 0;
  let totalVMsToday = 0;

  /* ---------------- PROCESS ---------------- */
  for (const c of clusters) {

    const clusterName = norm(c.clusterName);
    const clusterId = norm(c.clusterId);
    if (!clusterId) continue;

    const headers = { ...commonHeaders, accessClusterId: clusterId };

    const pgData = await getJson(
      `${baseUrl}/v2/data-protect/protection-groups?environments=kAcropolis&isActive=true`,
      headers
    );

    const pgs = toArr(pgData.protectionGroups);

    for (const pg of pgs) {

      const pgId = pg.id;
      const pgName = pg.name;

      const runsData = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups/${pgId}/runs?numRuns=50&includeObjectDetails=true`,
        headers
      );

      const completed = getCompletedRuns(toArr(runsData.runs));
      if (completed.length < 2) continue;

      const todayRun = completed[0];
      const todayTime = todayRun.localBackupInfo[0].endTimeUsecs / 1000;
      const todaySet = extractVMSet(todayRun);

      totalVMsToday += todaySet.size;

      let baselineRun = null;
      for (let i = 1; i < completed.length; i++) {
        const t = completed[i].localBackupInfo[0].endTimeUsecs / 1000;
        if ((todayTime - t) / dayMs <= LOOKBACK_DAYS_CAP) {
          baselineRun = completed[i];
          break;
        }
      }

      if (!baselineRun) continue;

      const baselineSet = extractVMSet(baselineRun);
      const { added, removed } = diffSets(todaySet, baselineSet);

      globalAdded += added.length;
      globalRemoved += removed.length;

      driftRows.push({
        Cluster: clusterName,
        ProtectionGroup: pgName,
        VMsToday: todaySet.size,
        Added: added.length,
        Removed: removed.length,
        Net: added.length - removed.length,
        LastCompletedET: new Date(todayTime).toISOString().replace("T", " ").slice(0, 19)
      });
    }
  }

  /* ---------------- OUTPUT ---------------- */
  const netDrift = globalAdded - globalRemoved;

  const markdownEmail = [
    "## Cohesity AHV Inventory Drift (Object-level)",
    "",
    `**Drift Window:** Policy-bounded (‚â§ ${LOOKBACK_DAYS_CAP} days)`,
    `**Total VMs Today:** ${totalVMsToday}`,
    "",
    "### Global Drift Summary",
    `- VMs Added: **+${globalAdded}**`,
    `- VMs Removed: **‚àí${globalRemoved}**`,
    `- **Net Drift:** ${netDrift >= 0 ? "üü¢ +" : "üî¥ "}${netDrift}`,
    "",
    "### PG-Level Drift",
    "| Cluster | ProtectionGroup | VMs Today | Added | Removed | Net | Last Completed Run |",
    "| --- | --- | --- | --- | --- | --- | --- |",
    ...driftRows.map(r =>
      `| ${r.Cluster} | ${r.ProtectionGroup} | ${r.VMsToday} | +${r.Added} | ‚àí${r.Removed} | ${r.Net >= 0 ? "üü¢ +" : "üî¥ "}${r.Net} | ${r.LastCompletedET} |`
    ),
    "",
    "### Reconciliation",
    `Computed Net Drift = ${netDrift}`,
    `Reconciliation Result: ${netDrift === (totalVMsToday - (totalVMsToday - netDrift)) ? "‚úÖ MATCH" : "‚ùå MISMATCH"}`
  ].join("\n");

  return {
    totalVMsToday,
    added: globalAdded,
    removed: globalRemoved,
    netDrift,
    rows: driftRows,
    markdownEmail,
    markdownTable: markdownEmail
  };
}
