import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ==========================================================
  // CONFIG (matches your sample)
  // ==========================================================
  const TREND_DAYS = 7;              // 7-day trend table (ET days)
  const ACTIVE_SCOPE_HOURS = 48;     // Active Scope uses latest COMPLETED run within last 48h
  const EMAIL_ISSUES_CAP = 200;      // cap issues rows for email size safety

  // ==============================
  // 1) Auth (vault name -> id -> manual)
  // ==============================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = (all && all.credentials) ? all.credentials : [];
    let found = null;
    for (let i = 0; i < creds.length; i++) {
      if (creds[i] && creds[i].name === name) { found = creds[i]; break; }
    }
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return (detail && (detail.token || detail.password)) || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (_) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = (d2 && (d2.token || d2.password)) || null;
      authMode = "vault-id";
    } catch (_) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");
  const commonHeaders = { accept: "application/json", apiKey };

  // ==============================
  // 2) Helpers (ET, parsing, HTTP)
  // ==============================
  function norm(v) {
    if (v === null || v === undefined) return "";
    return String(v).trim();
  }
  function toArrayMaybe(v) { return Array.isArray(v) ? v : (v ? [v] : []); }
  function safeCell(v) {
    if (v === null || v === undefined) return "";
    return String(v).replace(/\|/g, " ");
  }

  function nowEtString() {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    }).formatToParts(new Date());
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day} ${m.hour}:${m.minute}`;
  }

  function dateKeyET(d) {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).formatToParts(d);
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day}`; // YYYY-MM-DD
  }

  function dayLabelFromETKey(etKey) {
    const day = Number(etKey.slice(8, 10));
    const suffix =
      day % 100 >= 11 && day % 100 <= 13 ? "th" :
      day % 10 === 1 ? "st" :
      day % 10 === 2 ? "nd" :
      day % 10 === 3 ? "rd" : "th";
    return `${day}${suffix}`;
  }

  function usecsFromDate(d) {
    return String(Math.floor(d.getTime() * 1000)); // ms -> usecs
  }

  function mdTable(headers, rows) {
    const head = "| " + headers.join(" | ") + " |";
    const sep  = "| " + headers.map(() => "---").join(" | ") + " |";
    const body = rows.map((r) => "| " + headers.map((h) => safeCell(r[h])).join(" | ") + " |");
    return [head, sep].concat(body).join("\n");
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const err = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      err.httpStatus = resp.status;
      err.bodyText = txt;
      err.url = url;
      throw err;
    }
    return resp.json();
  }

  async function getJsonSafe(url, headers) {
    try {
      const data = await getJson(url, headers);
      return { ok: true, data, status: 200, bodyText: "", url };
    } catch (e) {
      return {
        ok: false,
        data: null,
        status: e && e.httpStatus ? e.httpStatus : 0,
        bodyText: e && e.bodyText ? e.bodyText : String(e || ""),
        url: e && e.url ? e.url : url
      };
    }
  }

  // ==============================
  // 3) Evidence rules (COMPLETED runs only)
  // ==============================
  function runStatusLower(run) {
    const s =
      norm(run && run.status) ||
      norm(run && run.runStatus) ||
      norm(run && run.backupRun && run.backupRun.status) ||
      norm(run && run.protectionRun && run.protectionRun.status) ||
      "";
    return s.toLowerCase();
  }

  function isRunFinished(run) {
    const x = runStatusLower(run);
    return (
      x === "ksuccess" || x === "success" || x === "succeeded" ||
      x === "kwarning" || x === "warning" || x === "succeededwithwarning" ||
      x === "kfailure" || x === "failure" || x === "failed" ||
      x === "kcanceled" || x === "canceled" || x === "cancelled"
    );
  }

  function isRunOK(run) {
    const x = runStatusLower(run);
    return (x === "ksuccess" || x === "success" || x === "succeeded" || x === "succeededwithwarning" || x === "kwarning" || x === "warning");
  }

  function pickRunEndUsecs(run) {
    return (
      norm(run && run.endTimeUsecs) ||
      norm(run && run.endTimeUsec) ||
      norm(run && run.endTime) ||
      norm(run && run.backupRun && (run.backupRun.endTimeUsecs || run.backupRun.endTimeUsec || run.backupRun.endTime)) ||
      norm(run && run.protectionRun && (run.protectionRun.endTimeUsecs || run.protectionRun.endTimeUsec || run.protectionRun.endTime)) ||
      ""
    );
  }

  function pickRunId(run) {
    return (
      norm(run && run.runId) ||
      norm(run && run.id) ||
      norm(run && run.protectionGroupRunId) ||
      norm(run && run.instanceId) ||
      ""
    );
  }

  function extractVmName(obj) {
    return (
      norm(obj && obj.objectName) ||
      norm(obj && obj.name) ||
      norm(obj && obj.displayName) ||
      norm(obj && obj.protectedObjectName) ||
      norm(obj && obj.sourceName) ||
      norm(obj && obj.entity && obj.entity.name) ||
      norm(obj && obj.object && obj.object.name) ||
      ""
    );
  }

  function extractObjectStatus(obj) {
    return (
      norm(obj && obj.status) ||
      norm(obj && obj.runStatus) ||
      norm(obj && obj.objectRunStatus) ||
      norm(obj && obj.protectionRunStatus) ||
      norm(obj && obj.backupStatus) ||
      norm(obj && obj.localSnapshotInfo && obj.localSnapshotInfo.status) ||
      ""
    );
  }

  function isObjectIssue(obj) {
    const s = extractObjectStatus(obj).toLowerCase();
    if (!s) return false;
    if (s === "ksuccess" || s === "success" || s === "succeeded" || s === "succeededwithwarning" || s === "kwarning" || s === "warning") return false;
    return true;
  }

  function vmSetFromObjects(objs) {
    const s = new Set();
    for (let i = 0; i < objs.length; i++) {
      const nm = extractVmName(objs[i]);
      if (nm) s.add(nm);
    }
    return s;
  }

  function getPGState(pg) {
    if (pg && pg.isDeleted) return "Deleted";
    if (pg && pg.isPaused) return "Paused";
    if (pg && pg.isActive) return "Active";
    return "Inactive";
  }

  // ==============================
  // 4) ET day keys (last 7 days incl today)
  // ==============================
  const asOfEt = nowEtString();
  const now = new Date();

  const etKeys = [];
  for (let i = TREND_DAYS - 1; i >= 0; i--) {
    const d = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
    etKeys.push(dateKeyET(d));
  }
  const dayLabels = etKeys.map(dayLabelFromETKey);

  const trendStart = new Date(now.getTime() - TREND_DAYS * 24 * 60 * 60 * 1000);
  const trendStartUsecs = usecsFromDate(trendStart);
  const trendEndUsecs = usecsFromDate(now);

  const activeScopeStart = new Date(now.getTime() - ACTIVE_SCOPE_HOURS * 60 * 60 * 1000);
  const activeScopeStartUsecs = usecsFromDate(activeScopeStart);

  // ==============================
  // 5) Get clusters (Helios)
  // ==============================
  const errors = [];
  const cluUrl = baseUrl + "/v2/mcm/cluster-mgmt/info";
  const cluResp = await getJsonSafe(cluUrl, commonHeaders);
  const clusters = toArrayMaybe(cluResp.ok && cluResp.data && cluResp.data.cohesityClusters);

  if (!cluResp.ok || !clusters.length) {
    return {
      authMode,
      totalClusters: 0,
      markdownEmail: "‚ö†Ô∏è No clusters returned from Helios or API call failed.",
      errors: cluResp.ok ? [] : [{ scope: "clusters", httpStatus: cluResp.status, url: cluResp.url, body: cluResp.bodyText }]
    };
  }

  // ==============================
  // 6) Cohesity v2 calls (PG list, runs, objects)
  // ==============================
  async function fetchAllPGsForCluster(clusterId) {
    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };
    const pgs = [];
    let pageToken = "";
    let safety = 0;

    while (safety < 200) {
      safety++;
      let url = baseUrl + "/v2/data-protect/protection-groups?environments=kAcropolis";
      if (pageToken) url += "&pageToken=" + encodeURIComponent(pageToken);

      const resp = await getJsonSafe(url, headers);
      if (!resp.ok) return { ok: false, pgs: [], err: resp };

      const data = resp.data || {};
      const batch = toArrayMaybe(data.protectionGroups);
      for (let i = 0; i < batch.length; i++) pgs.push(batch[i]);

      const next =
        norm(data.nextPageToken) ||
        norm(data.pageToken) ||
        norm(data.nextToken) ||
        norm(data.pagination && (data.pagination.nextPageToken || data.pagination.nextToken));

      if (!next || next === pageToken) break;
      pageToken = next;
    }

    return { ok: true, pgs, err: null };
  }

  async function fetchRuns(clusterHeaders, pgId) {
    const id = encodeURIComponent(pgId);
    const urls = [
      `${baseUrl}/v2/data-protect/protection-groups/${id}/runs?filterByEndTime=${encodeURIComponent(trendStartUsecs + "," + trendEndUsecs)}&onlyReturnSuccessfulCopyRun=false`,
      `${baseUrl}/v2/data-protect/protection-groups/${id}/runs?filterByEndTime=${encodeURIComponent(trendStartUsecs + "," + trendEndUsecs)}`,
      `${baseUrl}/v2/data-protect/protection-groups/${id}/runs?startTimeUsecs=${encodeURIComponent(trendStartUsecs)}&endTimeUsecs=${encodeURIComponent(trendEndUsecs)}`
    ];

    for (let i = 0; i < urls.length; i++) {
      const r = await getJsonSafe(urls[i], clusterHeaders);
      if (r.ok) {
        const d = r.data || {};
        const runs =
          toArrayMaybe(d.runs).length ? toArrayMaybe(d.runs) :
          toArrayMaybe(d.protectionGroupRuns).length ? toArrayMaybe(d.protectionGroupRuns) :
          toArrayMaybe(d.protectionRuns).length ? toArrayMaybe(d.protectionRuns) :
          toArrayMaybe(d.runInfo).length ? toArrayMaybe(d.runInfo) :
          [];
        return { ok: true, runs, usedUrl: urls[i] };
      }
    }
    const last = await getJsonSafe(urls[urls.length - 1], clusterHeaders);
    return { ok: false, runs: [], err: last, usedUrl: urls[urls.length - 1] };
  }

  async function fetchObjectsForRun(clusterHeaders, pgId, runId) {
    const pg = encodeURIComponent(pgId);
    const run = encodeURIComponent(runId);
    const urls = [
      `${baseUrl}/v2/data-protect/protection-groups/${pg}/runs/${run}/objects`,
      `${baseUrl}/v2/data-protect/protection-groups/${pg}/runs/${run}/objects?includeDetails=true`
    ];

    for (let i = 0; i < urls.length; i++) {
      const r = await getJsonSafe(urls[i], clusterHeaders);
      if (r.ok) {
        const d = r.data || {};
        const objs =
          toArrayMaybe(d.objects).length ? toArrayMaybe(d.objects) :
          toArrayMaybe(d.protectedObjects).length ? toArrayMaybe(d.protectedObjects) :
          toArrayMaybe(d.runObjects).length ? toArrayMaybe(d.runObjects) :
          toArrayMaybe(d.objectRuns).length ? toArrayMaybe(d.objectRuns) :
          [];
        return { ok: true, objects: objs, usedUrl: urls[i] };
      }
    }

    const last = await getJsonSafe(urls[urls.length - 1], clusterHeaders);
    return { ok: false, objects: [], err: last, usedUrl: urls[urls.length - 1] };
  }

  function extractObjectsFromRunIfPresent(runRaw) {
    const objs =
      toArrayMaybe(runRaw && runRaw.objects).length ? toArrayMaybe(runRaw.objects) :
      toArrayMaybe(runRaw && runRaw.runObjects).length ? toArrayMaybe(runRaw.runObjects) :
      toArrayMaybe(runRaw && runRaw.protectedObjects).length ? toArrayMaybe(runRaw.protectedObjects) :
      [];
    return objs.length ? objs : null;
  }

  // ==============================
  // 7) Retention-aware removal validation
  //    - Drift window = 7 days for reporting
  //    - Removal is ONLY CONFIRMED if missing across full policy retention (7/14/35)
  // ==============================
  const policyRetentionCache = {}; // key: policyId -> days
  async function getPolicyRetentionDays(clusterId, policyId) {
    const pid = norm(policyId);
    if (!pid) return null;
    if (policyRetentionCache[pid] !== undefined) return policyRetentionCache[pid];

    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };
    const url = `${baseUrl}/v2/data-protect/policies/${encodeURIComponent(pid)}`;
    const resp = await getJsonSafe(url, headers);
    if (!resp.ok) {
      policyRetentionCache[pid] = null;
      return null;
    }
    const p = resp.data || {};
    const days =
      (p && p.snapshotRetention && Number(p.snapshotRetention.daysToKeep)) ||
      Number(p.daysToKeep) ||
      Number(p.retentionDays) ||
      null;

    policyRetentionCache[pid] = Number.isFinite(days) ? days : null;
    return policyRetentionCache[pid];
  }

  // ==============================
  // 8) Compute report (matches your example style)
  // ==============================
  const pgRows = [];           // Section 2
  const issuesRows = [];       // Section 4
  const clusterSummary = {};   // Section 1

  // Drift accounting (7d evidence, but removal is "confirmed" only via retention validation)
  let vmsAdded7d = 0;
  let vmsRemovedConfirmed = 0;
  let vmsRemovedUnconfirmed = 0;

  let pgNewlyDetected = 0;     // NEW first detected in 7d (based on first snapshot in window)
  let pgRemoved = 0;           // confirmed removed (absent now + absent across retention)

  let grandTotalVMsActiveScope = 0;
  let totalActivePGs = 0;

  // helper: set compare
  function setDiffCount(a, b) { // a\b
    let n = 0;
    for (const x of a) if (!b.has(x)) n++;
    return n;
  }

  // helper: pretty net badge
  function netBadge(n) {
    if (n > 0) return `üü¢ +${n}`;
    if (n < 0) return `üî¥ ${n}`;
    return "0";
  }

  // Build a wider lookback window for validation (max 35d)
  const maxRetentionDays = 35;
  const validationStart = new Date(now.getTime() - maxRetentionDays * 24 * 60 * 60 * 1000);
  const validationStartUsecs = usecsFromDate(validationStart);

  // Runs fetch for validation window (reuse fetchRuns with different time range)
  async function fetchRunsWindow(clusterHeaders, pgId, startUsecs, endUsecs) {
    const id = encodeURIComponent(pgId);
    const urls = [
      `${baseUrl}/v2/data-protect/protection-groups/${id}/runs?filterByEndTime=${encodeURIComponent(startUsecs + "," + endUsecs)}&onlyReturnSuccessfulCopyRun=false`,
      `${baseUrl}/v2/data-protect/protection-groups/${id}/runs?filterByEndTime=${encodeURIComponent(startUsecs + "," + endUsecs)}`
    ];
    for (let i = 0; i < urls.length; i++) {
      const r = await getJsonSafe(urls[i], clusterHeaders);
      if (r.ok) {
        const d = r.data || {};
        const runs =
          toArrayMaybe(d.runs).length ? toArrayMaybe(d.runs) :
          toArrayMaybe(d.protectionGroupRuns).length ? toArrayMaybe(d.protectionGroupRuns) :
          toArrayMaybe(d.protectionRuns).length ? toArrayMaybe(d.protectionRuns) :
          [];
        return { ok: true, runs, usedUrl: urls[i] };
      }
    }
    const last = await getJsonSafe(urls[urls.length - 1], clusterHeaders);
    return { ok: false, runs: [], err: last, usedUrl: urls[urls.length - 1] };
  }

  // Validation: confirm VM removal only if missing across retention window snapshots
  async function confirmVmAbsentAcrossRetention(clusterHeaders, clusterId, pgId, vmName, retentionDays) {
    if (!retentionDays || retentionDays <= 0) return false;

    const start = new Date(now.getTime() - retentionDays * 24 * 60 * 60 * 1000);
    const startUsecs = usecsFromDate(start);
    const rr = await fetchRunsWindow(clusterHeaders, pgId, startUsecs, trendEndUsecs);
    if (!rr.ok) return false;

    const finished = rr.runs
      .map((r) => ({ raw: r, runId: pickRunId(r), endUsecs: pickRunEndUsecs(r), finished: isRunFinished(r) }))
      .filter((x) => x.runId && x.endUsecs && x.finished)
      .sort((a, b) => Number(b.endUsecs) - Number(a.endUsecs));

    // No snapshots => cannot confirm
    if (!finished.length) return false;

    // Check presence in latest N snapshots in retention range (cap to control calls)
    const cap = Math.min(finished.length, 10);
    for (let i = 0; i < cap; i++) {
      let objs = extractObjectsFromRunIfPresent(finished[i].raw);
      if (!objs) {
        const o = await fetchObjectsForRun(clusterHeaders, pgId, finished[i].runId);
        if (!o.ok) return false;
        objs = toArrayMaybe(o.objects);
      }
      for (let j = 0; j < objs.length; j++) {
        if (extractVmName(objs[j]) === vmName) return false; // seen => not absent
      }
    }
    return true; // absent in sampled snapshots across retention window
  }

  for (let c = 0; c < clusters.length; c++) {
    const cl = clusters[c] || {};
    const clusterName = norm(cl.clusterName) || `Cluster-${c + 1}`;
    const clusterId = norm(cl.clusterId);
    if (!clusterId) continue;

    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };

    const pgRes = await fetchAllPGsForCluster(clusterId);
    if (!pgRes.ok) {
      errors.push({ scope: "protection-groups", clusterName, clusterId, httpStatus: pgRes.err.status, url: pgRes.err.url, body: pgRes.err.bodyText });
      continue;
    }

    const pgs = toArrayMaybe(pgRes.pgs);

    if (!clusterSummary[clusterName]) {
      clusterSummary[clusterName] = { Active_PGs: 0, TotalVMs: 0, NetDrift7d: 0 };
    }

    for (let p = 0; p < pgs.length; p++) {
      const pg = pgs[p] || {};
      const pgName = norm(pg.name);
      const pgState = getPGState(pg);
      const isActiveToday = (pgState === "Active");
      if (!pgName || !isActiveToday) continue;

      const pgId =
        norm(pg.id) ||
        norm(pg.protectionGroupId) ||
        norm(pg.groupId) ||
        norm(pg.protectionJobId);
      if (!pgId) continue;

      const policyId =
        norm(pg.policyId) ||
        norm(pg.policy && pg.policy.id) ||
        norm(pg.policy && pg.policy.policyId);

      const retentionDays = await getPolicyRetentionDays(clusterId, policyId); // validation only

      // Pull runs (7-day trend window)
      const runRes = await fetchRuns(headers, pgId);
      if (!runRes.ok) {
        errors.push({ scope: "pg-runs", clusterName, clusterId, protectionGroup: pgName, protectionGroupId: pgId, httpStatus: runRes.err.status, url: runRes.err.url || runRes.usedUrl, body: runRes.err.bodyText });
        continue;
      }

      const finishedRuns = runRes.runs
        .map((r) => ({ raw: r, runId: pickRunId(r), endUsecs: pickRunEndUsecs(r), finished: isRunFinished(r), ok: isRunOK(r) }))
        .filter((x) => x.runId && x.endUsecs && x.finished)
        .sort((a, b) => Number(b.endUsecs) - Number(a.endUsecs));

      if (!finishedRuns.length) continue;

      // Per-day latest completed run (ET day)
      const dayToRun = {};
      for (let i = 0; i < finishedRuns.length; i++) {
        const endMs = Math.floor(Number(finishedRuns[i].endUsecs) / 1000);
        if (!Number.isFinite(endMs)) continue;
        const key = dateKeyET(new Date(endMs));
        if (!dayToRun[key] || Number(finishedRuns[i].endUsecs) > Number(dayToRun[key].endUsecs)) dayToRun[key] = finishedRuns[i];
      }

      // Snapshot sets for trend days
      const dayVmSets = {};
      for (let i = 0; i < etKeys.length; i++) dayVmSets[etKeys[i]] = null;

      // last completed job (prefer today's ET day)
      let lastCompletedJob = "‚Äî";
      let lastCompletedJobUsecs = "";

      for (let i = 0; i < etKeys.length; i++) {
        const dayKey = etKeys[i];
        const sel = dayToRun[dayKey];
        if (!sel) continue;

        let objs = extractObjectsFromRunIfPresent(sel.raw);
        if (!objs) {
          const objRes = await fetchObjectsForRun(headers, pgId, sel.runId);
          if (!objRes.ok) {
            errors.push({ scope: "run-objects", clusterName, clusterId, protectionGroup: pgName, protectionGroupId: pgId, runId: sel.runId, httpStatus: objRes.err.status, url: objRes.err.url || objRes.usedUrl, body: objRes.err.bodyText });
            continue;
          }
          objs = toArrayMaybe(objRes.objects);
        }

        dayVmSets[dayKey] = vmSetFromObjects(objs);

        const isTodayKey = (dayKey === etKeys[etKeys.length - 1]);
        if (isTodayKey) {
          lastCompletedJob = sel.ok ? "OK" : "NOT OK";
          lastCompletedJobUsecs = sel.endUsecs;
        }
      }

      if (!lastCompletedJobUsecs) {
        const mostRecent = finishedRuns[0];
        lastCompletedJob = mostRecent.ok ? "OK" : "NOT OK";
        lastCompletedJobUsecs = mostRecent.endUsecs;
      }

      // Active Scope: latest completed run in last 48h
      let activeScopeVmCount = null;
      let activeScopeObjs = null;

      for (let i = 0; i < finishedRuns.length; i++) {
        if (Number(finishedRuns[i].endUsecs) >= Number(activeScopeStartUsecs)) {
          let objs = extractObjectsFromRunIfPresent(finishedRuns[i].raw);
          if (!objs) {
            const objRes = await fetchObjectsForRun(headers, pgId, finishedRuns[i].runId);
            if (!objRes.ok) break;
            objs = toArrayMaybe(objRes.objects);
          }
          if (objs && objs.length) {
            activeScopeObjs = objs;
            activeScopeVmCount = vmSetFromObjects(objs).size;
          }
          break;
        }
      }

      if (activeScopeVmCount !== null) {
        clusterSummary[clusterName].Active_PGs += 1;
        clusterSummary[clusterName].TotalVMs += activeScopeVmCount;
        totalActivePGs += 1;
        grandTotalVMsActiveScope += activeScopeVmCount;

        // Issues from Active Scope snapshot
        for (let o = 0; o < activeScopeObjs.length; o++) {
          const nm = extractVmName(activeScopeObjs[o]);
          if (!nm) continue;
          if (!isObjectIssue(activeScopeObjs[o])) continue;
          issuesRows.push({
            Cluster: clusterName,
            ProtectionGroup: pgName,
            VMName: nm,
            IssueType: safeCell(extractObjectStatus(activeScopeObjs[o]) || "Non-success status"),
            Notes: "Non-success object status in latest completed snapshot (Active Scope window)"
          });
        }
      }

      // Trend delta table (supports NEW + 0 + ‚Äì)
      const dayDelta = {};
      for (let i = 0; i < etKeys.length; i++) dayDelta[etKeys[i]] = "‚Äì";

      // find first snapshot in window (NEW baseline)
      let firstSnapKey = null;
      let firstSnap = null;
      for (let i = 0; i < etKeys.length; i++) {
        const k = etKeys[i];
        if (dayVmSets[k] !== null) { firstSnapKey = k; firstSnap = dayVmSets[k]; break; }
      }

      if (firstSnap) {
        // NEW on first observed day (full size)
        dayDelta[firstSnapKey] = `NEW`;
        pgNewlyDetected += 1;
      }

      // sequential deltas vs previous available snapshot
      let prevSet = null;
      for (let i = 0; i < etKeys.length; i++) {
        const k = etKeys[i];
        const cur = dayVmSets[k];
        if (cur === null) continue;

        if (prevSet === null) { prevSet = cur; continue; } // baseline already marked NEW or ‚Äì
        const adds = setDiffCount(cur, prevSet);
        const rems = setDiffCount(prevSet, cur);

        vmsAdded7d += adds;

        if (adds === 0 && rems === 0) dayDelta[k] = "0";
        else if (adds > 0 && rems === 0) dayDelta[k] = `üü¢ +${adds}`;
        else if (rems > 0 && adds === 0) dayDelta[k] = `üî¥ -${rems}`;
        else dayDelta[k] = `üü¢ +${adds} / üî¥ -${rems}`;

        // retention-aware removal accounting (confirm per removed VM)
        if (rems > 0 && retentionDays) {
          for (const vm of prevSet) {
            if (cur.has(vm)) continue;
            const confirmed = await confirmVmAbsentAcrossRetention(headers, clusterId, pgId, vm, retentionDays);
            if (confirmed) vmsRemovedConfirmed += 1;
            else vmsRemovedUnconfirmed += 1;
          }
        } else if (rems > 0) {
          vmsRemovedUnconfirmed += rems; // no retention info => cannot confirm
        }

        prevSet = cur;
      }

      // Net drift for cluster summary: last snapshot vs first snapshot in 7d window
      let lastSnap = null;
      for (let i = etKeys.length - 1; i >= 0; i--) {
        const k = etKeys[i];
        if (dayVmSets[k] !== null) { lastSnap = dayVmSets[k]; break; }
      }
      const netPgDrift = (firstSnap && lastSnap) ? (lastSnap.size - firstSnap.size) : 0;
      clusterSummary[clusterName].NetDrift7d += netPgDrift;

      // Last drift text
      let lastKnownDelta = "0";
      for (let i = etKeys.length - 1; i >= 0; i--) {
        const k = etKeys[i];
        const v = dayDelta[k];
        if (v && v !== "‚Äì") { lastKnownDelta = `${v} (${k})`; break; }
      }

      // Build Section 2 row
      const row = {
        Cluster: clusterName,
        ProtectionGroup: pgName,
        TotalVMsToday: (activeScopeVmCount === null) ? "‚Äî" : String(activeScopeVmCount),
        LastKnownDelta: lastKnownDelta,
        PGState: pgState,
        LastCompletedJob: lastCompletedJob
      };
      for (let i = 0; i < etKeys.length; i++) row[dayLabels[i]] = dayDelta[etKeys[i]];
      pgRows.push(row);
    }
  }

  // ==============================
  // 9) Markdown output (matches your 4 sections)
  // ==============================
  const clustersSorted = Object.keys(clusterSummary).sort();

  // Section 1
  const s1Rows = [];
  let netDriftAll = 0;

  for (let i = 0; i < clustersSorted.length; i++) {
    const cn = clustersSorted[i];
    const s = clusterSummary[cn];
    netDriftAll += s.NetDrift7d;
    s1Rows.push({
      Cluster: cn,
      Active_PGs: String(s.Active_PGs),
      TotalVMs: String(s.TotalVMs),
      "Net Drift (7d)": netBadge(s.NetDrift7d)
    });
  }

  s1Rows.push({
    Cluster: "‚≠ê TOTAL",
    Active_PGs: String(totalActivePGs),
    TotalVMs: String(grandTotalVMsActiveScope),
    "Net Drift (7d)": netBadge(netDriftAll)
  });

  // Section 2 headers + rows
  const s2Headers = ["Cluster", "ProtectionGroup", "TotalVMsToday"].concat(dayLabels).concat(["LastKnownDelta", "PGState", "LastCompletedJob"]);
  const s2Rows = pgRows
    .sort((a, b) => (a.Cluster.localeCompare(b.Cluster) || a.ProtectionGroup.localeCompare(b.ProtectionGroup)))
    .map((r) => {
      const out = { Cluster: r.Cluster, ProtectionGroup: r.ProtectionGroup, TotalVMsToday: r.TotalVMsToday };
      for (let i = 0; i < dayLabels.length; i++) out[dayLabels[i]] = r[dayLabels[i]];
      out.LastKnownDelta = r.LastKnownDelta;
      out.PGState = r.PGState;
      out.LastCompletedJob = r.LastCompletedJob;
      return out;
    });

  // Section 3 summary (retention-aware removals)
  const netDriftEvidence = vmsAdded7d - vmsRemovedConfirmed; // strict: only confirmed removals reduce net
  const s3Rows = [
    { Area: "Protection Groups", Metric: "Newly detected", Value: String(pgNewlyDetected) },
    { Area: "Protection Groups", Metric: "Removed", Value: String(pgRemoved) },
    { Area: "Virtual Machines", Metric: "Added (snapshot-to-snapshot)", Value: `+${vmsAdded7d}` },
    { Area: "Virtual Machines", Metric: "Removed (confirmed across retention)", Value: `-${vmsRemovedConfirmed}` },
    { Area: "Virtual Machines", Metric: "Removed (not confirmed; visibility only)", Value: `-${vmsRemovedUnconfirmed}` },
    { Area: "Virtual Machines", Metric: "Net Drift (confirmed)", Value: netBadge(netDriftEvidence) },
    { Area: "Evidence Scope", Metric: "Data source", Value: "Completed runs only" },
    { Area: "Retention Context", Metric: "Used for removal validation", Value: "Policy-based (7/14/35d)" }
  ];

  // Section 4 issues
  const s4Headers = ["Cluster", "ProtectionGroup", "VMName", "IssueType", "Notes"];
  const s4Rows = issuesRows
    .map((r) => ({ Cluster: r.Cluster, ProtectionGroup: r.ProtectionGroup, VMName: r.VMName, IssueType: r.IssueType, Notes: r.Notes }))
    .slice(0, EMAIL_ISSUES_CAP);

  const markdownEmail = [
    "### Cohesity AHV Inventory Drift ‚Äî 7-Day (Retention-Aware)",
    "",
    `**Inventory As Of (ET):** ${asOfEt}`,
    `**Drift Window:** Last ${TREND_DAYS} days (ET)`,
    "**Evidence Source:** Completed backup jobs only",
    `**Active Scope:** Latest completed snapshot per Active PG within last ${ACTIVE_SCOPE_HOURS} hours`,
    "",
    "## 1) Active Scope (Today)",
    mdTable(["Cluster", "Active_PGs", "TotalVMs", "Net Drift (7d)"], s1Rows),
    "",
    "## 2) Protection Group Drift (7-Day) + Current State",
    "_Legend: üü¢ added | üî¥ removed | NEW first detected | 0 no change | ‚Äì not present_",
    mdTable(s2Headers, s2Rows),
    "",
    "## 3) 7-Day Inventory Drift Summary (Evidence-Ready)",
    mdTable(["Area", "Metric", "Value"], s3Rows),
    "",
    "## 4) Virtual Machines With Observed Issues (Non-Drift)",
    (s4Rows.length ? mdTable(s4Headers, s4Rows) : "No VM issues detected in completed snapshots within the report scope."),
    "",
    "_Audit note: Drift window is 7 days. Retention periods are used only to validate removals; unconfirmed removals are listed for visibility._"
  ].join("\n");

  return {
    authMode,
    totalClusters: clusters.length,
    inventoryAsOfET: asOfEt,
    driftWindowDays: TREND_DAYS,
    retentionValidationLookbackDays: maxRetentionDays,
    activeScopeHours: ACTIVE_SCOPE_HOURS,
    dayLabels,
    grandTotalVMsActiveScope,
    markdownEmail,
    markdownTable: markdownEmail,
    rows: {
      section1: s1Rows,
      section2: s2Rows,
      section3: s3Rows,
      section4: s4Rows
    },
    errors
  };
}
