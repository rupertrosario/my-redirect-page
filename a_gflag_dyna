import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios GFlags — Defaults vs Overrides (Single Message)
 *
 * Output:
 * 1) Global Defaults (applied to all clusters)
 * 2) Cluster-Specific Overrides
 *
 * Columns:
 * - Defaults: Service | GFlag | Value | Reason
 * - Overrides: Cluster | Service | GFlag | Value | Reason | AppliedAtET
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ======================
  // AUTH (same pattern)
  // ======================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = all?.credentials || [];
    const found = creds.find(c => c?.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return detail?.token || detail?.password || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error();
  } catch {
    const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
    apiKey = d2?.token || d2?.password || null;
  }

  if (!apiKey) throw new Error("No Cohesity API key available");

  const commonHeaders = { accept: "application/json", apiKey };

  // ======================
  // HELPERS
  // ======================
  const norm = v => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = v => (!v ? [] : Array.isArray(v) ? v : [v]);

  const safeCell = v =>
    v === null || v === undefined
      ? ""
      : String(v).replace(/\|/g, " ").replace(/[\r\n]+/g, " ");

  function epochSecToET(sec) {
    if (!sec) return "";
    const ms = Number(sec) * 1000;
    if (!Number.isFinite(ms)) return "";
    return new Date(ms).toLocaleString("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    });
  }

  function mdTable(headers, rows) {
    const head = "| " + headers.join(" | ") + " |";
    const sep = "| " + headers.map(() => "---").join(" | ") + " |";
    const body = rows.map(r =>
      "| " + headers.map(h => safeCell(r[h])).join(" | ") + " |"
    );
    return [head, sep, ...body].join("\n");
  }

  function isDefaultReason(reason) {
    const r = (reason || "").toLowerCase();
    return r.includes("auto set by cohesity") || r.includes("default");
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error(`GET ${url} -> ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // ======================
  // CLUSTERS
  // ======================
  const cluUrl = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const cluData = await getJson(cluUrl, commonHeaders);
  const clusters = toArray(cluData?.cohesityClusters);
  const clusterCount = clusters.length;

  // ======================
  // COLLECT ALL FLAGS
  // ======================
  const allRows = [];
  const globalIndex = {}; // key -> { clusters:Set, row }

  function indexGlobal(row) {
    const key = `${row.Service}||${row.GFlag}||${row.Value}`;
    if (!globalIndex[key]) {
      globalIndex[key] = { clusters: new Set(), row };
    }
    globalIndex[key].clusters.add(row.Cluster);
  }

  for (const cl of clusters) {
    const clusterId = norm(cl?.clusterId);
    if (!clusterId) continue;

    const clusterName = norm(cl?.clusterName) || `Cluster-${clusterId}`;
    const headers = { ...commonHeaders, accessClusterId: clusterId };

    const gUrl = `${baseUrl}/v2/clusters/gflag`;
    const data = await getJson(gUrl, headers);

    const services = Array.isArray(data) ? data : toArray(data?.items);

    for (const s of services) {
      const serviceName = norm(s?.serviceName) || "UNKNOWN_SERVICE";
      const gflags = toArray(s?.gflags);

      for (const f of gflags) {
        const flagName = norm(f?.name);
        if (!flagName) continue;

        let valueStr;
        try {
          valueStr = typeof f?.value === "string"
            ? f.value
            : JSON.stringify(f?.value ?? "");
        } catch {
          valueStr = String(f?.value ?? "");
        }

        const reason = norm(f?.reason) || "default";
        const appliedAtET = epochSecToET(f?.timestamp);

        const row = {
          Cluster: clusterName,
          Service: serviceName,
          GFlag: flagName,
          Value: valueStr,
          Reason: reason,
          AppliedAtET: appliedAtET
        };

        indexGlobal(row);
        allRows.push(row);
      }
    }
  }

  // ======================
  // SPLIT DEFAULTS vs OVERRIDES
  // ======================
  const globalDefaults = [];
  const globalKeys = new Set();

  for (const entry of Object.values(globalIndex)) {
    if (
      isDefaultReason(entry.row.Reason) &&
      entry.clusters.size === clusterCount
    ) {
      const k = `${entry.row.Service}||${entry.row.GFlag}||${entry.row.Value}`;
      globalKeys.add(k);
      globalDefaults.push({
        Service: entry.row.Service,
        GFlag: entry.row.GFlag,
        Value: entry.row.Value,
        Reason: entry.row.Reason
      });
    }
  }

  const overrides = allRows.filter(r => {
    const k = `${r.Service}||${r.GFlag}||${r.Value}`;
    return !globalKeys.has(k);
  });

  // ======================
  // SORT
  // ======================
  globalDefaults.sort((a,b)=>
    a.Service.localeCompare(b.Service) ||
    a.GFlag.localeCompare(b.GFlag)
  );

  overrides.sort((a,b)=>
    a.Cluster.localeCompare(b.Cluster) ||
    a.Service.localeCompare(b.Service) ||
    a.GFlag.localeCompare(b.GFlag)
  );

  // ======================
  // MARKDOWN
  // ======================
  const markdownEmail = [
    "### Cohesity GFlags — Defaults vs Overrides",
    "",
    "## 1) Global Defaults (Applied to All Clusters)",
    globalDefaults.length
      ? mdTable(
          ["Service", "GFlag", "Value", "Reason"],
          globalDefaults
        )
      : "_None_",
    "",
    "## 2) Cluster-Specific Overrides",
    overrides.length
      ? mdTable(
          ["Cluster", "Service", "GFlag", "Value", "Reason", "AppliedAtET"],
          overrides
        )
      : "_None_",
    "",
    "_Note: Defaults are auto-set and identical across all clusters. Overrides represent intentional or case-driven changes._"
  ].join("\n");

  return {
    clusterCount,
    totalFlags: allRows.length,
    defaultCount: globalDefaults.length,
    overrideCount: overrides.length,
    markdownEmail
  };
}
