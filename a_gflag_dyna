import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Helios GFlags — Flat, Readable Report
 * Columns (FINAL):
 * Cluster | Service | GFlag | Value | Reason | AppliedAtET
 *
 * Facts locked from screenshot:
 * - Timestamp field name: `timestamp`
 * - Unit: epoch SECONDS
 * - Meaning: when the gflag was applied
 *
 * Behavior:
 * - GET-only
 * - No truncation
 * - Sorted by Cluster → Service → GFlag
 */
export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ======================
  // CONFIG
  // ======================
  const MAX_ROWS = 20000; // guardrail for workflow/email limits

  // ==============================
  // 1) Auth (vault name -> id -> manual)
  // ==============================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";

  let apiKey = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = all?.credentials || [];
    const found = creds.find((c) => c?.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return detail?.token || detail?.password || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch (_) {
    try {
      const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = d2?.token || d2?.password || null;
      authMode = "vault-id";
    } catch (_) {
      authMode = "manual";
      apiKey = "PASTE_YOUR_API_KEY_HERE";
    }
  }

  if (!apiKey) throw new Error("No Helios API key available.");
  const commonHeaders = { accept: "application/json", apiKey };

  // ======================
  // 2) Helpers
  // ======================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);

  const safeCell = (v) =>
    v === null || v === undefined
      ? ""
      : String(v).replace(/\|/g, " ").replace(/[\r\n]+/g, " ");

  function epochSecondsToEt(sec) {
    if (!sec) return "";
    const ms = Number(sec) * 1000;
    if (!Number.isFinite(ms)) return "";
    return new Date(ms).toLocaleString("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    });
  }

  function nowEtString() {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    }).formatToParts(new Date());
    const m = {};
    for (const p of parts) m[p.type] = p.value;
    return `${m.year}-${m.month}-${m.day} ${m.hour}:${m.minute}`;
  }

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      const err = new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
      err.httpStatus = resp.status;
      err.bodyText = txt;
      err.url = url;
      throw err;
    }
    return resp.json();
  }

  async function getJsonSafe(url, headers) {
    try {
      const data = await getJson(url, headers);
      return { ok: true, data, status: 200, bodyText: "", url };
    } catch (e) {
      return {
        ok: false,
        data: null,
        status: e?.httpStatus || 0,
        bodyText: e?.bodyText || String(e || ""),
        url: e?.url || url
      };
    }
  }

  function mdTable(headers, rows) {
    const head = "| " + headers.join(" | ") + " |";
    const sep = "| " + headers.map(() => "---").join(" | ") + " |";
    const body = rows.map((r) => "| " + headers.map((h) => safeCell(r[h])).join(" | ") + " |");
    return [head, sep].concat(body).join("\n");
  }

  function normalizeGflagItem(f) {
    const flagName = norm(f?.name);
    const valueStr =
      typeof f?.value === "string" ? f.value : JSON.stringify(f?.value ?? "");
    const reason = norm(f?.reason) || "default / unknown";
    const appliedAtET = epochSecondsToEt(f?.timestamp); // confirmed from screenshot

    return { flagName, valueStr, reason, appliedAtET };
  }

  // ======================
  // 3) Fetch clusters
  // ======================
  const errors = [];
  const cluUrl = `${baseUrl}/v2/mcm/cluster-mgmt/info`;
  const cluResp = await getJsonSafe(cluUrl, commonHeaders);
  const clusters = toArray(cluResp?.data?.cohesityClusters);

  if (!cluResp.ok || !clusters.length) {
    return {
      authMode,
      totalClusters: 0,
      markdownEmail: "⚠️ No clusters returned from Helios or API call failed.",
      errors: cluResp.ok ? [] : [{ scope: "clusters", httpStatus: cluResp.status, url: cluResp.url, body: cluResp.bodyText }]
    };
  }

  // ======================
  // 4) Per-cluster gflags → rows
  // ======================
  const rows = [];

  for (const cl of clusters) {
    const clusterId = norm(cl?.clusterId);
    if (!clusterId) continue;

    const clusterName = norm(cl?.clusterName) || norm(cl?.name) || `Cluster-${clusterId}`;
    const headers = { accept: "application/json", apiKey, accessClusterId: clusterId };

    const gUrl = `${baseUrl}/v2/clusters/gflag`;
    const gResp = await getJsonSafe(gUrl, headers);

    if (!gResp.ok) {
      errors.push({ scope: "gflags", clusterName, clusterId, httpStatus: gResp.status, url: gResp.url, body: gResp.bodyText });
      continue;
    }

    // Expected shape: [{ serviceName, gflags: [...] }]
    const services = Array.isArray(gResp.data)
      ? gResp.data
      : toArray(gResp.data?.items || gResp.data?.services);

    for (const s of services) {
      const serviceName = norm(s?.serviceName) || "UNKNOWN_SERVICE";
      const gflags = toArray(s?.gflags);

      for (const f of gflags) {
        const nf = normalizeGflagItem(f);
        if (!nf.flagName) continue;

        rows.push({
          Cluster: clusterName,
          Service: serviceName,
          GFlag: nf.flagName,
          Value: nf.valueStr,
          Reason: nf.reason,
          AppliedAtET: nf.appliedAtET
        });

        if (rows.length >= MAX_ROWS) break;
      }
      if (rows.length >= MAX_ROWS) break;
    }
    if (rows.length >= MAX_ROWS) break;
  }

  // ======================
  // 5) Sort (Cluster → Service → GFlag)
  // ======================
  rows.sort((a, b) =>
    a.Cluster.localeCompare(b.Cluster) ||
    a.Service.localeCompare(b.Service) ||
    a.GFlag.localeCompare(b.GFlag)
  );

  // ======================
  // 6) Markdown output
  // ======================
  const asOfEt = nowEtString();
  const headers = ["Cluster", "Service", "GFlag", "Value", "Reason", "AppliedAtET"];

  const markdownEmail = [
    "### Cohesity GFlags — Cluster / Service View",
    "",
    `**Inventory As Of (ET):** ${asOfEt}`,
    `**Rows:** ${rows.length}`,
    "",
    rows.length ? mdTable(headers, rows) : "No gflags returned."
  ].join("\n");

  return {
    authMode,
    totalClusters: clusters.length,
    inventoryAsOfET: asOfEt,
    rowCount: rows.length,
    markdownEmail,
    rows,
    errors
  };
}
