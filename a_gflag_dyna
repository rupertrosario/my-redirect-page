import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * Cohesity Cluster GFlag Report — dated (ET)
 *
 * Output per cluster:
 * **N. ClusterName**
 * | Service | GFlag | Value | Reason | AppliedAtET |
 *
 * Characteristics:
 * - GET-only (non-destructive)
 * - NO HTML
 * - Markdown-only (email-safe)
 * - Long values are wrapped (not truncated) to avoid email clipping
 * - Clusters sorted alphabetically and numbered
 * - Rows sorted Service -> GFlag
 * - 502-safe (continues per cluster)
 */

export default async function () {
  const baseUrl = "https://helios.cohesity.com";

  // ======================
  // SAFETY (email size)
  // ======================
  const MAX_ROWS_TOTAL = 6000;

  // ======================
  // AUTH (READ-ONLY)
  // ======================
  const vaultName = "Cohesity_API_Key";
  const vaultId = "credentials_vault-312312";
  let apiKey = null;

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const creds = all?.credentials || [];
    const found = creds.find((c) => c?.name === name);
    if (!found) return null;
    const d = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    return d?.token || d?.password || null;
  }

  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error();
  } catch {
    const d = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
    apiKey = d?.token || d?.password || null;
  }

  if (!apiKey) return { error: "No Cohesity API key available" };
  const commonHeaders = { accept: "application/json", apiKey };

  // ======================
  // HELPERS
  // ======================
  const norm = (v) => (v === null || v === undefined ? "" : String(v).trim());
  const toArray = (v) => (!v ? [] : Array.isArray(v) ? v : [v]);

  // Markdown-safe cell (no truncation)
  const safeCell = (v) =>
    v === null || v === undefined
      ? ""
      : String(v).replace(/\|/g, " ").replace(/\r?\n/g, " ");

  function mdTable(headers, rows) {
    const head = "| " + headers.join(" | ") + " |";
    const sep = "| " + headers.map(() => "---").join(" | ") + " |";
    const body = rows.map(
      (r) => "| " + headers.map((h) => safeCell(r[h])).join(" | ") + " |"
    );
    return [head, sep, ...body].join("\n");
  }

  // Compact Reason so it fits in email
  function normalizeReason(reason) {
    const raw = norm(reason);
    if (!raw) return "";

    const s = raw.toLowerCase();
    if (s.includes("auto set by cohesity")) return "Auto (Cohesity)";
    if (s.includes("don't update manually") || s.includes("do not update")) return "System Managed";
    if (s.includes("default")) return "Default";

    const m = raw.match(/case#\s*\d+/i);
    if (m) return m[0].replace(/\s+/g, "");

    return raw.split(/[.;]/)[0].trim();
  }

  // Insert line breaks into long values (display only, not truncation)
  function wrapValueForEmail(v) {
    const s = String(v ?? "");
    if (s.length < 120) return s;

    return s
      .replace(/\s+/g, " ")
      .replace(/,/g, ",\n")
      .replace(/;/g, ";\n")
      .replace(/\|/g, " ")
      .replace(/}/g, "}\n")
      .replace(/]/g, "]\n")
      .replace(/:/g, ":\n")
      .trim();
  }

  // Epoch seconds -> ET human-readable
  function toEtHumanTime(epochSeconds) {
    if (!epochSeconds) return "";
    const n = Number(epochSeconds);
    if (!Number.isFinite(n)) return "";

    return new Date(n * 1000).toLocaleString("en-US", {
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false
    });
  }

  async function getJsonSafe(url, headers) {
    try {
      const resp = await fetch(url, { method: "GET", headers });
      if (!resp.ok) {
        let txt = "";
        try { txt = await resp.text(); } catch {}
        return { ok: false, status: resp.status, error: txt, data: null };
      }
      return { ok: true, status: 200, data: await resp.json() };
    } catch (e) {
      return { ok: false, status: 0, error: String(e), data: null };
    }
  }

  // ======================
  // FETCH CLUSTERS
  // ======================
  const cluRes = await getJsonSafe(
    `${baseUrl}/v2/mcm/cluster-mgmt/info`,
    commonHeaders
  );
  if (!cluRes.ok) {
    return {
      error: "Failed to fetch clusters",
      status: cluRes.status,
      details: cluRes.error
    };
  }

  const clusters = toArray(cluRes.data?.cohesityClusters);

  // ======================
  // COLLECT PER-CLUSTER
  // ======================
  const byCluster = {}; // clusterName -> row[]
  const errors = [];
  let totalRows = 0;

  for (const cl of clusters) {
    const clusterId = norm(cl?.clusterId);
    if (!clusterId) continue;

    const clusterName = norm(cl?.clusterName) || `Cluster-${clusterId}`;
    const headers = { ...commonHeaders, accessClusterId: clusterId };

    const gRes = await getJsonSafe(`${baseUrl}/v2/clusters/gflag`, headers);
    if (!gRes.ok) {
      errors.push({
        scope: "gflags",
        cluster: clusterName,
        status: gRes.status,
        error: gRes.error
      });
      continue;
    }

    const services = Array.isArray(gRes.data)
      ? gRes.data
      : toArray(gRes.data?.items);

    const rows = [];

    for (const s of services) {
      const serviceName = norm(s?.serviceName) || "UNKNOWN_SERVICE";
      const gflags = toArray(s?.gflags);

      for (const f of gflags) {
        const flagName = norm(f?.name);
        if (!flagName) continue;

        let valueStr;
        try {
          valueStr =
            typeof f?.value === "string"
              ? f.value
              : JSON.stringify(f?.value ?? "");
        } catch {
          valueStr = String(f?.value ?? "");
        }

        rows.push({
          Service: serviceName,
          GFlag: flagName,
          Value: wrapValueForEmail(valueStr),
          Reason: normalizeReason(f?.reason),
          AppliedAtET: toEtHumanTime(f?.timestamp)
        });

        totalRows++;
        if (totalRows >= MAX_ROWS_TOTAL) break;
      }
      if (totalRows >= MAX_ROWS_TOTAL) break;
    }

    rows.sort(
      (a, b) => a.Service.localeCompare(b.Service) || a.GFlag.localeCompare(b.GFlag)
    );
    byCluster[clusterName] = rows;

    if (totalRows >= MAX_ROWS_TOTAL) break;
  }

  // ======================
  // MARKDOWN OUTPUT
  // ======================
  const clusterNames = Object.keys(byCluster).sort((a, b) =>
    a.localeCompare(b, undefined, { sensitivity: "base" })
  );

  const sections = [];
  const tableHeaders = ["Service", "GFlag", "Value", "Reason", "AppliedAtET"];

  let idx = 1;
  for (const cn of clusterNames) {
    const r = byCluster[cn] || [];
    sections.push(`**${idx}. ${safeCell(cn)}**`);
    sections.push("");
    sections.push(r.length ? mdTable(tableHeaders, r) : "_No gflags returned._");
    sections.push("\n---\n");
    idx++;
  }

  const title = `### Cohesity Cluster GFlag Report — ${new Date().toLocaleDateString("en-US", {
    timeZone: "America/New_York",
    year: "numeric",
    month: "short",
    day: "2-digit"
  })}`;

  const markdownEmail = [
    title,
    "",
    ...sections,
    totalRows >= MAX_ROWS_TOTAL ? `_Note: Capped at ${MAX_ROWS_TOTAL} rows to fit email._` : "",
    errors.length ? `_Errors captured for some clusters (see returned errors[])._` : ""
  ]
    .filter(Boolean)
    .join("\n");

  return {
    clusterCount: clusters.length,
    renderedClusters: clusterNames.length,
    rowCount: totalRows,
    errors,
    markdownEmail
  };
}
