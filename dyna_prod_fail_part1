import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

/**
 * PART 1 (FAST): Clusters + Active PG Index (NO policy calls, NO runs calls)
 * Output -> Part 2:
 * {
 *   baseUrl, apiKey, commonHeaders,
 *   daysToKeepMin, numRuns,
 *   clusters,
 *   pgIndex: [{ clusterId, clusterName, pgId, pgName, pgEnv, policyId }]
 * }
 */
export default async function () {
  const baseUrl = "https://helios.cohesity.com";
  const daysToKeepMin = 35;
  const numRuns = 5;

  // AUTH (same as your alerts script)
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // 1) clusters
  const clu = await getJson(`${baseUrl}/v2/mcm/cluster-mgmt/info`, { ...commonHeaders, Accept: "application/json" });
  const clusters = Array.isArray(clu?.cohesityClusters) ? clu.cohesityClusters : [];
  if (!clusters.length) throw new Error("No clusters returned from /v2/mcm/cluster-mgmt/info");

  // 2) active PG index (per cluster) â€” minimal fields only
  const pgIndex = [];

  for (const cl of clusters) {
    const clusterId = cl?.clusterId;
    const clusterName =
      String(cl?.name || cl?.clusterName || cl?.displayName || "").trim() || `Unknown-${clusterId}`;
    if (!clusterId) continue;

    const headers = { ...commonHeaders, Accept: "application/json", accessClusterId: String(clusterId) };

    let pgJson;
    try {
      pgJson = await getJson(
        `${baseUrl}/v2/data-protect/protection-groups?isDeleted=false&isPaused=false&isActive=true`,
        headers
      );
    } catch (_) {
      continue; // fail-open per cluster
    }

    const pgs = Array.isArray(pgJson?.protectionGroups) ? pgJson.protectionGroups : [];
    if (!pgs.length) continue;

    for (const pg of pgs) {
      const pgId = pg?.id;
      const pgName = pg?.name || "";
      const policyId = pg?.policyId ? String(pg.policyId) : "";
      if (!pgId || !policyId) continue;

      const pgEnv =
        (pg.environment && String(pg.environment)) ||
        (pg.environments && String(pg.environments)) ||
        (Array.isArray(pg.environmentTypes) ? pg.environmentTypes.join(",") : "") ||
        "UnknownEnv";

      pgIndex.push({
        clusterId: String(clusterId),
        clusterName,
        pgId: String(pgId),
        pgName,
        pgEnv,
        policyId,
      });
    }
  }

  return { baseUrl, apiKey, commonHeaders, daysToKeepMin, numRuns, clusters, pgIndex };
}
