// ===============================
// cohesity_prod_failures_p2
// - GET-only
// - Reads Part 1 output (pgIndex)
// - Policy cache per cluster
// - Filters PGs: Policy daysToKeep >= minDaysToKeep
// - Output: { baseUrl, numRuns, minDaysToKeep, pgIndex35[] }
// ===============================

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";
import { result } from "@dynatrace-sdk/automation-utils";

export default async function () {
  const PART1 = "cohesity_prod_failures_p1";
  const p1 = await result(PART1);

  if (!p1?.baseUrl || !Array.isArray(p1.pgIndex)) {
    throw new Error(`Part 2: missing Part 1 output. Check step name: ${PART1}`);
  }

  const baseUrl = p1.baseUrl;
  const numRuns = Number(p1.numRuns ?? 20);
  const minDaysToKeep = Number(p1.minDaysToKeep ?? 35);
  const pgIndex = p1.pgIndex;

  // ==============================
  // AUTH (vault id) âœ… EXACT style
  // ==============================
  const vaultId = "credentials_vault-312312";
  const d2 = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
  const apiKey = (d2?.token || d2?.password || "").trim();
  if (!apiKey) throw new Error("No Helios API key available (empty token/password).");

  const commonHeaders = { accept: "application/json", apiKey };

  async function getJson(url, headers) {
    const resp = await fetch(url, { method: "GET", headers });
    if (!resp.ok) {
      let txt = "";
      try { txt = await resp.text(); } catch (_) {}
      throw new Error(`GET ${url} -> HTTP ${resp.status} ${txt}`);
    }
    return resp.json();
  }

  // clusterId -> Map(policyId -> {daysToKeep,name})
  const policyCacheByCluster = new Map();

  async function getPolicyCached(clusterId, headers, policyId) {
    if (!policyId) return null;
    if (!policyCacheByCluster.has(clusterId)) policyCacheByCluster.set(clusterId, new Map());
    const cache = policyCacheByCluster.get(clusterId);
    if (cache.has(policyId)) return cache.get(policyId);

    const enc = encodeURIComponent(String(policyId));
    const url = `${baseUrl}/irisservices/api/v1/public/protectionPolicies/${enc}`;
    try {
      const p = await getJson(url, headers);
      const obj = { daysToKeep: p?.daysToKeep ?? null, name: p?.name ?? "" };
      cache.set(policyId, obj);
      return obj;
    } catch (_) {
      const obj = { daysToKeep: null, name: "PolicyLookupFailed" };
      cache.set(policyId, obj);
      return obj;
    }
  }

  const pgIndex35 = [];

  for (const pg of pgIndex) {
    if (!pg.policyId) continue;
    const headers = { ...commonHeaders, Accept: "application/json", accessClusterId: String(pg.clusterId) };
    const pol = await getPolicyCached(String(pg.clusterId), headers, String(pg.policyId));
    const days = pol?.daysToKeep;
    if (days !== null && Number(days) >= minDaysToKeep) pgIndex35.push(pg);
  }

  return {
    baseUrl,
    numRuns,
    minDaysToKeep,
    pgIndex35,
    pgIndex35Count: pgIndex35.length,
    pgIndexCount: pgIndex.length,
  };
}
