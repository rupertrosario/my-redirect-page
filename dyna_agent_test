// Cohesity Helios – Agent Upgradeability + Client Version Summary
// Vault: name -> id -> manual. GET-only, no metrics.

import { credentialVaultClient } from "@dynatrace-sdk/client-classic-environment-v2";

export default async function () {

  const baseUrl = "https://helios.cohesity.com";

  const vaultName = "Cohesity_API_Key";
  const vaultId   = "credentials_vault-312312";

  let apiKey   = null;
  let authMode = "vault-name";

  async function getKeyByName(name) {
    const all = await credentialVaultClient.getCredentials();
    const found = all.credentials.find(c => c.name === name);
    if (!found) return null;
    const detail = await credentialVaultClient.getCredentialsDetails({ id: found.id });
    console.log(`✓ loaded Helios key from vault (name): ${found.name}`);
    return detail?.token || null;
  }

  // 1) vault by name
  try {
    apiKey = await getKeyByName(vaultName);
    if (!apiKey) throw new Error("not-found");
  } catch {
    // 2) vault by id
    try {
      const detail = await credentialVaultClient.getCredentialsDetails({ id: vaultId });
      apiKey = detail?.token || null;
      authMode = "vault-id";
      console.log(`✓ loaded Helios key from vault (id): ${detail?.name || vaultId}`);
    } catch {
      // 3) manual fallback
      authMode = "manual";
      apiKey   = "PASTE_YOUR_API_KEY_HERE";
      console.log("⚠️ using manual Helios API key (fallback)");
    }
  }

  if (!apiKey) {
    throw new Error("No Helios API key available from vault or manual fallback.");
  }

  const baseHeaders = { accept: "application/json", apiKey };

  // ---------------------------
  // small helper: strip leading 'k' from enums (kWindows -> Windows)
  // ---------------------------
  function cleanEnum(value) {
    if (!value || typeof value !== "string") return value;
    return value.replace(/^k(?=[A-Z])/, "");
  }

  // ---------------------------
  // 2) cluster list
  // ---------------------------
  const listResp = await fetch(`${baseUrl}/v2/mcm/cluster-mgmt/info`, {
    method: "GET",
    headers: baseHeaders,
  });

  if (listResp.status !== 200) {
    const txt = await listResp.text().catch(() => "");
    throw new Error(`cluster list failed (${listResp.status}) ${txt}`);
  }

  const listJson = await listResp.json();
  const clusters = listJson?.cohesityClusters || [];

  if (!clusters.length) {
    const emptyUpgrade =
      "**=== Upgradeability Summary (All Selected Clusters) ===**\n\n_No clusters returned._";
    const emptyVersion =
      "**=== Client Version Summary (All Selected Clusters) ===**\n\n_No clusters returned._";

    return {
      agents: [],
      upgradeMarkdown: emptyUpgrade,
      versionMarkdown: emptyVersion,
      authMode,
    };
  }

  console.log(`found ${clusters.length} clusters…`);

  // ---------------------------
  // 3) per-cluster agents fetch
  // ---------------------------
  const allAgents = [];

  await Promise.all(
    clusters.map(async ({
      clusterName,
      clusterId,
    }) => {
      const h = { ...baseHeaders, accessClusterId: String(clusterId) };

      const url = `${baseUrl}/irisservices/api/v1/public/reports/agents`;
      console.log(`→ GET agents for cluster ${clusterName} (${clusterId})`);

      try {
        const resp = await fetch(url, { method: "GET", headers: h });
        if (resp.status !== 200) {
          const t = await resp.text().catch(() => "");
          console.log(`   agents failed (${resp.status}) ${t}`);
          return;
        }

        const agents = await resp.json();
        if (!Array.isArray(agents) || !agents.length) {
          console.log(`   no agents returned for ${clusterName}`);
          return;
        }

        for (const a of agents) {
          allAgents.push({
            clusterName: clusterName || `Cluster-${clusterId}`,
            hostOsType: cleanEnum(a.hostOsType),
            version: a.version || "Unknown",
            healthStatus: cleanEnum(a.healthStatus),
            upgradability: cleanEnum(a.upgradability),
            upgradeStatusMessage: a.upgradeStatusMessage ?? "",
          });
        }

        console.log(`   ✓ ${clusterName}: ${agents.length} agents`);
      } catch (e) {
        console.log(`   ⚠️ error fetching agents for ${clusterName}: ${e.message}`);
      }
    })
  );

  if (!allAgents.length) {
    const emptyUpgrade =
      "**=== Upgradeability Summary (All Selected Clusters) ===**\n\n_No agents returned from any cluster._";
    const emptyVersion =
      "**=== Client Version Summary (All Selected Clusters) ===**\n\n_No agents returned from any cluster._";

    return {
      agents: [],
      upgradeMarkdown: emptyUpgrade,
      versionMarkdown: emptyVersion,
      authMode,
    };
  }

  // ---------------------------
  // 4) Upgradeability Summary (All Selected Clusters)
  // ---------------------------
  function buildUpgradeSummaryMarkdown(agents) {
    const byCluster = new Map();

    for (const a of agents) {
      const cluster = a.clusterName || "Unknown";
      const upg = a.upgradability;

      if (!byCluster.has(cluster)) {
        byCluster.set(cluster, {
          cluster,
          totalAgents: 0,
          upgradable: 0,
          current: 0,
          nonUpgInvalid: 0,
        });
      }

      const s = byCluster.get(cluster);
      s.totalAgents += 1;

      if (upg === "Upgradable") {
        s.upgradable += 1;
      } else if (upg === "Current") {
        s.current += 1;
      } else if (upg === "NonUpgradableInvalidVersion") {
        s.nonUpgInvalid += 1;
      }
    }

    const rows = Array.from(byCluster.values()).sort((a, b) =>
      a.cluster.localeCompare(b.cluster)
    );

    const totals = rows.reduce(
      (acc, r) => {
        acc.totalAgents += r.totalAgents;
        acc.upgradable += r.upgradable;
        acc.current += r.current;
        acc.nonUpgInvalid += r.nonUpgInvalid;
        return acc;
      },
      {
        cluster: "TOTAL",
        totalAgents: 0,
        upgradable: 0,
        current: 0,
        nonUpgInvalid: 0,
      }
    );
    rows.push(totals);

    let md = "**=== Upgradeability Summary (All Selected Clusters) ===**\n\n";
    md += "| **Cluster** | **TotalAgents** | **Upgradable** | **Current** | **NonUpgradableInvalidVersion** |\n";
    md += "|-------------|----------------:|---------------:|------------:|--------------------------------:|\n";

    for (const r of rows) {
      md += `| ${r.cluster} | ${r.totalAgents} | ${r.upgradable} | ${r.current} | ${r.nonUpgInvalid} |\n`;
    }

    return md;
  }

  // ---------------------------
  // 5) Client Version Summary (All Selected Clusters)
  // ---------------------------
  function buildClientVersionSummaryMarkdown(agents) {
    const byVersion = new Map();

    for (const a of agents) {
      const version = a.version || "Unknown";
      const os = a.hostOsType;
      const health = a.healthStatus;

      if (!byVersion.has(version)) {
        byVersion.set(version, {
          version,
          winHealthy: 0,
          winUnhealthy: 0,
          linHealthy: 0,
          linUnhealthy: 0,
          totalHealthy: 0,
          totalUnhealthy: 0,
          totalAgents: 0,
        });
      }

      const s = byVersion.get(version);
      s.totalAgents += 1;

      const isHealthy = health === "Healthy";

      if (os === "Windows") {
        if (isHealthy) s.winHealthy += 1;
        else s.winUnhealthy += 1;
      } else if (os === "Linux") {
        if (isHealthy) s.linHealthy += 1;
        else s.linUnhealthy += 1;
      }

      if (isHealthy) s.totalHealthy += 1;
      else s.totalUnhealthy += 1;
    }

    const rows = Array.from(byVersion.values()).sort((a, b) =>
      a.version.localeCompare(b.version)
    );

    const totals = rows.reduce(
      (acc, r) => {
        acc.winHealthy += r.winHealthy;
        acc.winUnhealthy += r.winUnhealthy;
        acc.linHealthy += r.linHealthy;
        acc.linUnhealthy += r.linUnhealthy;
        acc.totalHealthy += r.totalHealthy;
        acc.totalUnhealthy += r.totalUnhealthy;
        acc.totalAgents += r.totalAgents;
        return acc;
      },
      {
        version: "TOTAL",
        winHealthy: 0,
        winUnhealthy: 0,
        linHealthy: 0,
        linUnhealthy: 0,
        totalHealthy: 0,
        totalUnhealthy: 0,
        totalAgents: 0,
      }
    );
    rows.push(totals);

    let md = "**=== Client Version Summary (All Selected Clusters) ===**\n\n";
    md += "| **Version** | **Win_Healthy** | **Win_Unhealthy** | **Lin_Healthy** | **Lin_Unhealthy** | **Total_Healthy** | **Total_Unhealthy** | **TotalAgents** |\n";
    md += "|-------------|----------------:|------------------:|----------------:|------------------:|------------------:|--------------------:|----------------:|\n";

    for (const r of rows) {
      md += `| ${r.version} | ${r.winHealthy} | ${r.winUnhealthy} | ${r.linHealthy} | ${r.linUnhealthy} | ${r.totalHealthy} | ${r.totalUnhealthy} | ${r.totalAgents} |\n`;
    }

    return md;
  }

  const upgradeMarkdown = buildUpgradeSummaryMarkdown(allAgents);
  const versionMarkdown = buildClientVersionSummaryMarkdown(allAgents);

  // Use in email step:
  // {{ result("cohesity_agents_summary").upgradeMarkdown }}
  // {{ result("cohesity_agents_summary").versionMarkdown }}
  return {
    agents: allAgents,
    upgradeMarkdown,
    versionMarkdown,
    authMode,
    clusterCount: clusters.length,
    totalAgents: allAgents.length,
  };
}
